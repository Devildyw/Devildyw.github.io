<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Devil的个人博客</title>
  
  <subtitle>永远相信美好的事情即将发生</subtitle>
  <link href="https://devildyw.github.io/atom.xml" rel="self"/>
  
  <link href="https://devildyw.github.io/"/>
  <updated>2022-04-25T14:31:31.045Z</updated>
  <id>https://devildyw.github.io/</id>
  
  <author>
    <name>Devil</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTML</title>
    <link href="https://devildyw.github.io/2022/04/24/Html/"/>
    <id>https://devildyw.github.io/2022/04/24/Html/</id>
    <published>2022-04-24T15:48:59.000Z</published>
    <updated>2022-04-25T14:31:31.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a><code>HTML</code></h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    这里主要用于自己学习前端过程中的一些比较难记的知识点或是容易出错的地方，所以内容不是那么完整。一些基础的标签建议之间看文档知道意思就行了。在学习其他的内容的过程中会使用，此时就可以练习加深印象。</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ul><li><p>表格主要用于展示数据</p></li><li><p>表格所有内容都应该包含在<code>&lt;table&gt;</code>标签中</p></li><li><p>表头应该包含在<code>&lt;thead&gt;</code>(语义标签)中</p></li><li><p>表体应该包含在<code>&lt;tbody&gt;</code>(语义标签)中</p></li><li><p>表位应该包含在<code>&lt;tfoot&gt;</code>(语义标签)中</p></li><li><p><code>&lt;tr&gt;</code>表示表中的一行是比<code>&lt;table&gt;</code>低一级的</p></li><li><p><code>&lt;th&gt;</code>表格头，内容居中，加粗显示</p></li><li><p><code>&lt;td&gt;</code>普通表格，内容左对齐</p></li></ul><p><em><strong>【注意】：浏览器一般是通过加载全部表格数据后才显示，但是当数据量很大时，希望能加载一部分，即显示一部分？？</strong></em></p><p>— 使用 <strong>带结构的表格</strong>！！！ 即使用<thead>  <tbody> <tfoot>三个标签</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/20190313151313759.PNG" alt="img"></p><p><strong>【注意】：如果需要单元格合并？？？—使用 跨列属性<code>colspan</code>、<code>rowspan</code></strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Table<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>丁杨维<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!---这里对表进行了列合并和行合并 都为合并2格-&gt;</span></span><br><span class="line"><span class="comment">                &lt;td&gt;20&lt;/td&gt;</span></span><br><span class="line"><span class="comment">                &lt;!-- &lt;td&gt;男&lt;/td&gt; --&gt;</span><span class="comment">&lt;!--合并之后 后写列或是行的元素就是多余的了就可以去掉--&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>丁杨维<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- &lt;td&gt;20&lt;/td&gt; --&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- &lt;td&gt;男&lt;/td&gt; --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425000232732.png" alt="image-20220425000232732"></p><hr><h3 id="table标签的属性"><a href="#table标签的属性" class="headerlink" title="table标签的属性"></a>table标签的属性</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/20190313144717432.jpg" alt="img"></p><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ul><li><p><code>&lt;ol&gt;</code>标签标识里面包含的元素都是有序的可以理解为<code>order list</code></p></li><li><p><code>&lt;li&gt;</code>标签定义列表项目。</p></li><li><p>&#96;&#96;&#96;html</p><!-- 有序列表 --><pre><code>&lt;ol&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;1&lt;/li&gt;&lt;/ol&gt;</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ![image-20220425000813561](https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425000813561.png)</span><br><span class="line"></span><br><span class="line">  有着数字序号标识顺序</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### **无序列表***</span><br><span class="line"></span><br><span class="line">* `&lt;ul&gt;`标签 标识该标签包含的数据是无序的但`&lt;ul&gt;`标签和`&lt;ol&gt;`标签都无法包含除`&lt;li&gt;`之外的内容</span><br><span class="line">* `&lt;li&gt;`标签定义列表项目。 但是`&lt;li&gt;`标签中却可以包含任何标签</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">&lt;!-- 无序列表 --&gt;</span><br><span class="line">    &lt;h4&gt;你喜欢的食物&lt;/h4&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            5</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425001049361.png" alt="image-20220425001049361"></p><p>黑点无法像数字序号那样有着顺序的含义.</p><hr><h3 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a><strong>自定义列表</strong></h3><ul><li><strong><code>&lt;dl&gt;</code></strong> 标签定义了定义列表（definition list）、**<code>&lt;dl&gt;</code>** 标签用于结合 <strong><code>&lt;dt&gt;</code><strong>（定义列表中的项目）和</strong><code>&lt;dd&gt;</code></strong> （描述列表中的项目）。</li><li>**<code>&lt;dt&gt;</code>**标签（定义列表中的项目）</li><li><strong><code>&lt;dd&gt;</code></strong> （描述列表中的项目）</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自定义列表 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dt</span>&gt;</span>关注我们<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>微信<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>qq<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>weibo<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425001428912.png" alt="image-20220425001428912"></p><hr><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>在HTML中，一个完整的表单通常由表单域，表单控件（表单元素）和提示信息3个部分构成。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425205501066.png" alt="image-20220425205501066"></p><hr><h3 id="表单域"><a href="#表单域" class="headerlink" title="表单域"></a>表单域</h3><p><strong>表单域</strong>是一个包含表单元素的区域</p><p>在HTML标签中，<code>&lt;form&gt;</code>标签用于定义表单域，以实现用户信息的收集和传递。</p><p><code>&lt;form&gt;</code>标签会把它范围内的表单信息提交给服务器。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425210050698.png" alt="image-20220425210050698"></p><hr><h3 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a><a href="https://www.runoob.com/tags/tag-input.html">表单元素</a></h3><p><code>&lt;input&gt;</code> 元素有很多形态，根据不同的 <em>type</em> 属性（必选属性）。</p><p><code>type</code>属性有：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425210352522.png" alt="image-20220425210352522"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425212053862.png" alt="image-20220425212053862"></p><p><code>placeholder</code>与<code>value</code>不同 <code>value</code>相当于会是一个默认值的方式显示在文本框中，而<code>placeholder</code>这是以描述的方式显示起到提醒的作用。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 文本框 value就是该input的描述信息会显示出来(默认值)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;请输入用户名&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 密码框 用于用户填写密码 会有非明文显示的功能 placeholder则是真正的描述不会影响内容 只是起提醒的作用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 单按钮 可以实现多选一--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name是表单元素的名字 这里性别单选按钮必须有相同的名字name 才可以实现多选1 --&gt;</span></span><br><span class="line">    男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">checked</span>&gt;</span> 女 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--复选框 可以实现多选--&gt;</span></span><br><span class="line">    吃饭<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;aihao&quot;</span> <span class="attr">checked</span>&gt;</span> 睡觉<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;aihao&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425212312274.png" alt="image-20220425212312274"></p><h4 id="input-type"><a href="#input-type" class="headerlink" title="input:type"></a><code>input:type</code></h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--提交表单中的数据--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 重置表单中元素的默认值 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;重置&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425213025395.png" alt="image-20220425213025395"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 普通按钮 长搭配js一起使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;button&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 上传文件 使用此标签即可选择文件上传 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425214453918.png" alt="image-20220425214453918"></p><h4 id="lt-lable-gt-标签"><a href="#lt-lable-gt-标签" class="headerlink" title="&lt;lable&gt;标签"></a><code>&lt;lable&gt;</code>标签</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425214600618.png" alt="image-20220425214600618"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;nan&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;nan&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;nv&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;nv&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425215214816.png" alt="image-20220425215214816"></p><p>核心：<code>&lt;label&gt;</code>标签的<strong>for属性的值</strong>与相关元素的<strong>id属性相同</strong></p><h4 id="lt-select-gt-表单元素"><a href="#lt-select-gt-表单元素" class="headerlink" title="&lt;select&gt;表单元素"></a><code>&lt;select&gt;</code>表单元素</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425215400451.png" alt="image-20220425215400451"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        籍贯:</span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>山东<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425215653010.png" alt="image-20220425215653010"></p><p>注意：</p><blockquote><ul><li><p><code>&lt;select&gt;</code>中至少包含一对<code>&lt;option&gt;</code></p></li><li><p>在<code>&lt;option&gt;</code>中定义<code>selected = &quot;selected&quot;</code> 时，当前项即为默认选中项</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><h4 id="lt-textarea-gt-表单元素"><a href="#lt-textarea-gt-表单元素" class="headerlink" title="&lt;textarea&gt;表单元素"></a><code>&lt;textarea&gt;</code>表单元素</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425220048166.png" alt="image-20220425220048166"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        今日反馈:</span><br><span class="line">    <span class="comment">&lt;!-- cols:行数 rows:列数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span>留言板:由textarea实现<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425220432726.png" alt="image-20220425220432726"></p><p>该阶段<code>Demo</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>青春不常在,抓紧谈恋爱<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--第一行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;nan&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;nan&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;nv&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;nv&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--第二行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>生日<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>--请选择年份--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>2001<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>2002<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>2003<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>--请选择月份--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>--请选择日--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--第三行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>所在地区<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;北京&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--第四行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>婚姻状况<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hyzk&quot;</span> <span class="attr">id</span>=<span class="string">&quot;jiehun&quot;</span> <span class="attr">checked</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;jiehun&quot;</span>&gt;</span>结婚<span class="tag">&lt;/<span class="name">label</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hyzk&quot;</span> <span class="attr">id</span>=<span class="string">&quot;yihun&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;yihun&quot;</span>&gt;</span>已婚<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hyzk&quot;</span> <span class="attr">id</span>=<span class="string">&quot;lihun&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;lihun&quot;</span>&gt;</span>离婚<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--第五行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>学历<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;博士后&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--第六行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>喜欢类型<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;xhlx&quot;</span> <span class="attr">id</span>=<span class="string">&quot;qingchun&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;qingchun&quot;</span>&gt;</span>清纯<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;xhlx&quot;</span> <span class="attr">id</span>=<span class="string">&quot;keai&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;keai&quot;</span>&gt;</span>可爱<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--第七行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>个人介绍<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;3&quot;</span>&gt;</span>个人简介<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--第八行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;免费注册&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--第九行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">checked</span>&gt;</span>我同意注册条款</span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--第十行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#a&quot;</span>&gt;</span>我是会员,立即登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--第十一行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h5</span>&gt;</span>我承诺<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span> 年满十八、单身<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>抱着严肃的态度<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>真诚寻找另一半<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425222817761.png" alt="image-20220425222817761"></p><hr><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul><li><a href="https://www.w3school.com.cn/">w3school 在线教程</a></li><li><a href="https://developer.mozilla.org/zh-CN/">MDN Web Docs (mozilla.org)</a></li></ul><hr><h1 id="持续更新中。。。。"><a href="#持续更新中。。。。" class="headerlink" title="持续更新中。。。。"></a>持续更新中。。。。</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;&lt;code&gt;HTML&lt;/code&gt;&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="前端" scheme="https://devildyw.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="HTML5" scheme="https://devildyw.github.io/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>Filter</title>
    <link href="https://devildyw.github.io/2022/04/24/Filter/"/>
    <id>https://devildyw.github.io/2022/04/24/Filter/</id>
    <published>2022-04-24T09:24:56.000Z</published>
    <updated>2022-04-24T09:26:13.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Filter是对客户端访问资源的过滤，符合条件的放行，不符合条件的不放行，并且可以对目标资源访问前后进行逻辑处理的一个组件。</p><h2 id="过滤器的作用"><a href="#过滤器的作用" class="headerlink" title="过滤器的作用"></a>过滤器的作用</h2><p>​    Java过滤器是处于客户端与服务器资源文件之间的一道过滤网，在访问资源文件之前，通过一系列的过滤器可以对请求进行修改、判断等，把不符合规则的请求在中途拦截或修改；也可以对响应进行过滤，拦截或修改响应。例如：修改响应体或是请求体的字符集。</p><hr><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ul><li>步骤： <ul><li>使用Maven创建一个Web项目</li><li>导入<code>javax.servlet-api</code>依赖</li><li>编写一个过滤器继承<code>Filter</code>执行过滤操作</li><li>编写一个<code>Servlet</code>继承<code>HttpServlet</code>执行业务处理操作</li><li>在<code>web.xml/</code>注解中进行配置（配置<code>servlet</code> 和 <code>filter</code> ）</li></ul></li></ul><p>​    <code>CharsetFilter.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharsetFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这里做一些初始化操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这里做一些过滤器被销毁前的操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这里执行过滤请求&quot;</span>);</span><br><span class="line">        <span class="comment">//比如将请求的字符集改为utf-8</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        System.out.println(request.getCharacterEncoding());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里也可以设置响应体的相关参数</span></span><br><span class="line">        System.out.println(response.getCharacterEncoding());</span><br><span class="line">        <span class="comment">//改后放行</span></span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;这里过滤响应&quot;</span>);</span><br><span class="line">        System.out.println(response.getCharacterEncoding());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    <code>ServiceServlet.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        out.println(req.getParameter(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>web.xml</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    注册servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>servlet.ServiceServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.CharsetFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>xml</code>配置</p><p><code>url-pattern</code>：代表要过滤的资源的匹配</p><p><code>filter-name</code>：过滤器名称 用于映射 于<code>servlet-name</code>作用相同</p><p><code>filter-class</code>： 过滤器类的全限定名称</p><p><code>servlet-name</code>：代表要过滤的<code>Servlet</code>的资源匹配</p></blockquote><hr><h2 id="Filter的生命周期其与生命周期相关的方法"><a href="#Filter的生命周期其与生命周期相关的方法" class="headerlink" title="Filter的生命周期其与生命周期相关的方法"></a>Filter的生命周期其与生命周期相关的方法</h2><p>Filter接口有三个方法，这三个方法都与Filter的生命后期有关。</p><ul><li><code>init(FilterConfig)</code>： 代表filter对象初始化方法，filter对象由<code>tomcat</code>创建并且会将配置文件（<code>web.xml</code>）生成一个<code>FilterConfig</code>对象注入其中。</li><li><code>doFilter(ServletRequest,ServletResponse,FilterChain)</code>： 代表filter对象执行过滤的核心方法如果某资源在已经被配置到这个filter进行过滤的话，那么每次访问这个资源都会执行<code>doFilter()</code>方法，与<code>Servlet</code>的<code>Service()</code>方法类似。</li><li><code>destory()</code>： 代表filter销毁的方法，这里可以执行一些销毁前的操作， 当filter对象销毁时会执行这个方法。</li></ul><hr><h3 id="Filter对象的生命周期"><a href="#Filter对象的生命周期" class="headerlink" title="Filter对象的生命周期"></a>Filter对象的生命周期</h3><ul><li><strong>Filter何时创建：服务器启动时就创建该filter对象</strong></li><li><strong>Filter合适销毁： 服务器关闭时filter销毁</strong></li></ul><p><strong>注意：<code>Filter</code>与<code>Servlet</code>一样都是默认单例的。</strong></p><hr><h2 id="Filter相关API"><a href="#Filter相关API" class="headerlink" title="Filter相关API"></a>Filter相关<code>API</code></h2><ol><li><p><code>init(FilterConfig)</code></p><ol><li><code>Filter</code>创建时会去执行的<code>init</code>方法</li><li>参数<code>FilterConfig</code>代表该<code>Filter</code>对象配置信息的对象，内部封装的是该Filter的配置信息。由<code>Tomcat</code>创建该Filter对象时从配置文件中读取封装为一个<code>FilterConfig</code>后注入。</li></ol></li><li><p><code>destroy()</code></p><ol><li>filter对象销毁时执行</li><li>这里可以执行一些销毁前需要执行的操作，因为filter对象销毁时该方法会被执行</li></ol></li><li><p><code>doFilter(ServletRequest,ServletResponse,FilterChain)</code></p><ol><li><p>当该filter映射的<code>url-pattern</code>对应的资源被访问了 会执行该方法</p></li><li><p>其中的参数</p><blockquote><ul><li><code>ServletRequest/ServletResponse</code>：每次在执行<code>doFilter</code>方法时 web容器负责创建一个<code>request</code>和一个<code>response</code>对象作为<code>doFilter</code>的参数传递进来。该<code>request</code>和<code>response</code>就是在访问目标资源的<code>service</code>方法时的<code>request</code>和<code>response</code>。</li><li><code>FilterChain</code>: 过滤器链对象， 通过该对象的<code>doFilter</code>方法可以放行该请求，如果该过滤器上还有过滤器没有过滤该请求，那么转交给它，如果没有则直接到达<code>Servlet</code>的<code>service()</code>。</li></ul></blockquote></li></ol></li></ol><hr><h2 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h2><p>​    在一个 Web 应用程序中可以注册多个 Filter 程序，每个 Filter 程序都可以针对某一个 URL 进行拦截。如果多个 Filter 程序都对同一个 URL 进行拦截，那么这些 Filter 就会组成一个Filter 链（也称过滤器链）。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/e7aa5e26bcbc923a1235b5e70b6e938f.png" alt="e7aa5e26bcbc923a1235b5e70b6e938f.png"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/5-1Z6121G30B63.png" alt="Filter链"></p><ul><li>拦截顺序和过滤器<code>web.xml</code>注册顺序（<code>filter-mapping</code>）一致。</li><li>由上图可知过滤器链过滤的顺序准许”先进后出”的原则。</li></ul><h3 id="过滤器链代码演示"><a href="#过滤器链代码演示" class="headerlink" title="过滤器链代码演示"></a>过滤器链代码演示</h3><p><code>Servlet.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;html/text;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        System.out.println(<span class="string">&quot;请求已接受&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;请求已接受&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Filter01.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Filter01</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求经过过滤器01&quot;</span>);</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">        System.out.println(<span class="string">&quot;响应经过过滤器01&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Filter02.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Filter02</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求经过过滤器02&quot;</span>);</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">        System.out.println(<span class="string">&quot;响应经过过滤器02&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>web.xml</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>servlet.Servlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/filterServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    过滤器链注册--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.Filter01<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/filterServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.Filter02<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/filterServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>控制台输出（可以看到 先进后出）</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220424163848783.png" alt="image-20220424163848783"></p><hr><h2 id="Filter的url-pattern配置"><a href="#Filter的url-pattern配置" class="headerlink" title="Filter的url-pattern配置"></a><code>Filter</code>的<code>url-pattern</code>配置</h2><ul><li><p>匹配单个资源</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.Filter02<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/filterServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>统配符匹配（最常使用）</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.Filter02<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>扩展名匹配 （<code>*.abc *.jsp</code>）<strong>注意不能和统配符混用</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.Filter02<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="End"><a href="#End" class="headerlink" title="-End-"></a>-End-</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Filter&quot;&gt;&lt;a href=&quot;#Filter&quot; class=&quot;headerlink&quot; title=&quot;Filter&quot;&gt;&lt;/a&gt;Filter&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="JavaEE" scheme="https://devildyw.github.io/categories/JavaEE/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式----创建型模式之简单工厂设计模式</title>
    <link href="https://devildyw.github.io/2022/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://devildyw.github.io/2022/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-04-17T09:29:10.000Z</published>
    <updated>2022-04-17T09:30:56.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式—-创建型模式之简单工厂设计模式"><a href="#设计模式—-创建型模式之简单工厂设计模式" class="headerlink" title="设计模式—-创建型模式之简单工厂设计模式"></a>设计模式—-创建型模式之简单工厂设计模式</h1><h2 id="1-1-模式动机"><a href="#1-1-模式动机" class="headerlink" title="1.1. 模式动机"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id15">1.1. 模式动机</a></h2><p>考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。</p><hr><h2 id="1-2-模式定义"><a href="#1-2-模式定义" class="headerlink" title="1.2. 模式定义"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id16">1.2. 模式定义</a></h2><p>简单工厂模式(<code>Simple Factory Pattern</code>)：又称为<strong>静态工厂方法</strong>(<code>Static Factory Method</code>)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><hr><h2 id="1-3-模式结构"><a href="#1-3-模式结构" class="headerlink" title="1.3. 模式结构"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id17">1.3. 模式结构</a></h2><p>简单工厂模式包含如下角色：</p><ul><li><p><code>Factory</code>：工厂角色</p><p>工厂角色负责实现创建所有实例的内部逻辑</p></li><li><p><code>Product</code>：抽象产品角色</p><p>抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</p></li><li><p><code>ConcreteProduct</code>：具体产品角色</p><p>具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</p></li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/SimpleFactory.jpg" alt="../_images/SimpleFactory.jpg"></p><hr><h2 id="1-4-时序图"><a href="#1-4-时序图" class="headerlink" title="1.4. 时序图"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id18">1.4. 时序图</a></h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/seq_SimpleFactory.jpg" alt="../_images/seq_SimpleFactory.jpg"></p><hr><h2 id="1-5-代码分析"><a href="#1-5-代码分析" class="headerlink" title="1.5. 代码分析"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id19">1.5. 代码分析</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VehiclesGenerator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CAR</span> <span class="operator">=</span> <span class="string">&quot;Car&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BIKE</span> <span class="operator">=</span> <span class="string">&quot;Bike&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TRAIN</span> <span class="operator">=</span> <span class="string">&quot;Train&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">AIRPLANE</span> <span class="operator">=</span> <span class="string">&quot;Airplane&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方式一 交通工具生成器</span></span><br><span class="line"><span class="comment">     * 使用if 判断字段来生成实例</span></span><br><span class="line"><span class="comment">     * 返回值为抽象类类型 根据继承的知识我们知道 父类只能拥有子类重写的方法</span></span><br><span class="line"><span class="comment">     * 所以如果子类有额外的方法时需要向下转型.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vehiclesType 交通工具的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的交通工具</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Vehicles <span class="title function_">getInstance</span><span class="params">(String vehiclesType)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vehiclesType.equals(CAR))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vehiclesType.equals(TRAIN))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Train</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vehiclesType.equals(BIKE))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bike</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vehiclesType.equals(AIRPLANE))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Airplane</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">VehiclesGenerator</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-6-模式分析"><a href="#1-6-模式分析" class="headerlink" title="1.6. 模式分析"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id20">1.6. 模式分析</a></h2><ul><li>将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。</li><li>在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。</li><li>简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。</li><li>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</li></ul><hr><h2 id="1-7-实例"><a href="#1-7-实例" class="headerlink" title="1.7. 实例"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id21">1.7. 实例</a></h2><p><a href="https://github.com/Devildyw/design-patterns/tree/master/DesignPatterns-Java/SimpleFactoryPattern">简单工厂设计模式实例</a></p><hr><h2 id="1-8-简单工厂模式的优点"><a href="#1-8-简单工厂模式的优点" class="headerlink" title="1.8. 简单工厂模式的优点"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id22">1.8. 简单工厂模式的优点</a></h2><ul><li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。</li><li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li><li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li></ul><hr><h2 id="1-9-简单工厂模式的缺点"><a href="#1-9-简单工厂模式的缺点" class="headerlink" title="1.9. 简单工厂模式的缺点"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id23">1.9. 简单工厂模式的缺点</a></h2><ul><li>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</li><li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</li><li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li><li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li></ul><hr><h2 id="1-10-适用环境"><a href="#1-10-适用环境" class="headerlink" title="1.10. 适用环境"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id24">1.10. 适用环境</a></h2><p><strong>在以下情况下可以使用简单工厂模式：</strong></p><ul><li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li><li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li></ul><hr><h2 id="1-11-模式应用"><a href="#1-11-模式应用" class="headerlink" title="1.11. 模式应用"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id25">1.11. 模式应用</a></h2><ol><li><code>JDK</code>类库中广泛使用了简单工厂模式，如工具类<code>java.text.DateFormat</code>，它用于格式化一个本地日期或者时间。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title function_">getDateInstance</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title function_">getDateInstance</span><span class="params">(<span class="type">int</span> style)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title function_">getDateInstance</span><span class="params">(<span class="type">int</span> style,Locale</span></span><br><span class="line"><span class="params">locale)</span>;</span><br></pre></td></tr></table></figure><ol><li><code>Java</code>加密技术</li></ol><p>获取不同加密算法的密钥生成器:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">KeyGenerator keyGen=KeyGenerator.getInstance(<span class="string">&quot;DESede&quot;</span>);</span><br></pre></td></tr></table></figure><p>创建密码器:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cipher cp=Cipher.getInstance(<span class="string">&quot;DESede&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="1-12-总结"><a href="#1-12-总结" class="headerlink" title="1.12. 总结"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id26">1.12. 总结</a></h2><ul><li>创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。</li><li>简单工厂模式又称为静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</li><li>简单工厂模式包含三个角色：工厂角色负责实现创建所有实例的内部逻辑；抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</li><li>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</li><li>简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。</li><li>简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。</li></ul><hr><p><strong>摘自:</strong><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html"> 简单工厂模式( Simple Factory Pattern ) — Graphic Design Patterns (design-patterns.readthedocs.io)</a></p><h1 id="End"><a href="#End" class="headerlink" title="-End-"></a>-End-</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式—-创建型模式之简单工厂设计模式&quot;&gt;&lt;a href=&quot;#设计模式—-创建型模式之简单工厂设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式—-创建型模式之简单工厂设计模式&quot;&gt;&lt;/a&gt;设计模式—-创建型模式之简单工厂设计模式&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devildyw.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Developer" scheme="https://devildyw.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>restTemplate</title>
    <link href="https://devildyw.github.io/2022/04/16/restTemplate/"/>
    <id>https://devildyw.github.io/2022/04/16/restTemplate/</id>
    <published>2022-04-16T08:50:04.000Z</published>
    <updated>2022-04-16T09:04:44.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h1><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/wallhaven-8oky1j.jpg" alt="General 1920x1080 Gordon Zuchhold (Artstation) digital art science fiction pixel art city cyberpunk animation futuristic city ArtStation artwork futuristic"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><code>RestTemplate</code>是由<code>Spring</code>框架提供的一个可用于应用中调用<code>rest</code>服务的类它简化了与<code>http</code>服务的通信方式，统一了<code>RESTFul</code>的标准，封装了<code>http</code>连接，我们只需要传入<code>url</code>及其返回值类型即可。相较于之前常用的<code>HttpClient</code>，<code>RestTemplate</code>是一种更为优雅的调用<code>RESTFul</code>服务的方式。</li><li>在<code>Spring</code>应用程序中访问第三方<code>REST服务</code>与使用<code>Spring RestTemplate</code>类有关。<code>RestTemplate</code>类的设计原则与许多其他<code>Spring</code>的模板类(例如<code>JdbcTemplate</code>)相同，为执行复杂任务提供了一种具有默认行为的简化方法。</li><li><code>RestTemplate</code>默认依赖JDK提供了<code>http</code>连接的能力（<code>HttpURLConnection</code>），如果有需要的话也可以通过<code>setRequestFactory</code>方法替换为例如<code>Apache HttpCompoent、Netty或OKHttp</code>等其他<code>Http libaray</code>。</li><li>考虑到了<code>RestTemplate</code>类是为了调用REST服务而设计的，因此它的主要方法与<code>REST</code>的基础紧密相连就不足为奇了，后者时<code>HTTP</code>协议的方法：<code>HEAD、GET、POST、PUT、DELETE、OPTIONS</code>例如，<code>RestTemplate</code>类具有<code>headForHeaders()、getForObject()、putForObject()，put()和delete()</code>等方法。</li></ul><h2 id="创建RestTemplate"><a href="#创建RestTemplate" class="headerlink" title="创建RestTemplate"></a>创建<code>RestTemplate</code></h2><p>​    因为<code>RestTemplate</code>是<code>Spirng</code>框架提供的所以只要是一个<code>Springboot</code>项目就不用考虑导包的问题，这些都是提供好的。</p><p>​    但是<code>Spring</code>并没有将其加入<code>SpringBean</code>容器中，需要我们手动加入，因为我们首先创建一个<code>Springboot</code>配置类，再在配置类中将我们的<code>RestTemlate</code>注册到<code>Bean</code>容器中</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​    使用<code>Springboot</code>提供的<code>RestTemplateBuilder</code>构造类来构造一个<code>RestTemplate</code>，可以自定义一些连接参数，如：连接超时时间，读取超时时间，还有认证信息等</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415202710768.png" alt="image-20220415202710768"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">(RestTemplateBuilder builder)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">                <span class="comment">//设置连接超时时间</span></span><br><span class="line">                .setConnectTimeout(Duration.ofSeconds(<span class="number">5000</span>))</span><br><span class="line">                <span class="comment">//设置读取超时时间</span></span><br><span class="line">                .setReadTimeout(Duration.ofSeconds(<span class="number">5000</span>))</span><br><span class="line">                <span class="comment">//设置认证信息</span></span><br><span class="line">                .basicAuthentication(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                <span class="comment">//设置根路径</span></span><br><span class="line">                .rootUri(<span class="string">&quot;https://api.test.com/&quot;</span>)</span><br><span class="line">                <span class="comment">//构建</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加自定义的拦截器"><a href="#添加自定义的拦截器" class="headerlink" title="添加自定义的拦截器"></a>添加自定义的拦截器</h4><p>​    自定义拦截器示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomClientHttpRequestInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ClientHttpRequestInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ClientHttpResponse <span class="title function_">intercept</span><span class="params">(HttpRequest request, <span class="type">byte</span>[] body, ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印请求明细</span></span><br><span class="line">        logRequestDetails(request,body);</span><br><span class="line">        <span class="type">ClientHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> execution.execute(request, body);</span><br><span class="line">        <span class="comment">//打印响应明细</span></span><br><span class="line">        logResponseDetails(response);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logRequestDetails</span><span class="params">(HttpRequest request, <span class="type">byte</span>[] body)</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Headers:&#123;&#125;&quot;</span>,request.getHeaders());</span><br><span class="line">        log.debug(<span class="string">&quot;body:&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>(body, StandardCharsets.UTF_8));</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>,request.getMethod(),request.getMethodValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logResponseDetails</span><span class="params">(ClientHttpResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Status code : &#123;&#125;&quot;</span>,response.getStatusCode());</span><br><span class="line">        log.debug(<span class="string">&quot;Status text : &#123;&#125;&quot;</span>,response.getStatusText());</span><br><span class="line">        log.debug(<span class="string">&quot;Headers : &#123;&#125;&quot;</span>,response.getHeaders());</span><br><span class="line">        log.debug(<span class="string">&quot;Response body: &#123;&#125;&quot;</span>, StreamUtils.copyToString(response.getBody(),StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    使用<code>RestTemplateBuilder</code>构造类，添加自定义拦截器，构造带有自定义拦截器的<code>RestTemplate</code>实例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">(RestTemplateBuilder builder)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">                .additionalInterceptors(<span class="keyword">new</span> <span class="title class_">CustomClientHttpRequestInterceptor</span>())</span><br><span class="line">                <span class="comment">//构建</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    测试请求确实经过了拦截器，注册成功（注意请求和响应的流只会被读取一次，这里我们读取了response后返回的response就读取不到刚刚读过的内容了）</p><p>​    <img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415204816204.png" alt="image-20220415204816204"></p><hr><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​    使用<code>RestTemplate</code>构造方法构造一个<code>RestTemlate</code>，虽然不能像<code>RestTemplate</code>构造类那样更详细、更多样的配置参数，但是<code>RestTemplate</code>构造方法在一般情况是够用的。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415195208601.png" alt="image-20220415195208601"></p><ul><li>无参构造 全部参数默认</li><li>指定<code>ClientHttpRequestFactory</code> 的构造方法可以指定自己实现的<code>ClientHttpRequestFactory</code>（客户端<code>http</code>请求工厂）其他的与无参构造相同。<ul><li><code>ClientHttpRequestFactory</code></li></ul></li><li>指定<code>List&lt;HttpMessageConverter&lt;?&gt;&gt;</code>的构造方法可以指定自己是实现的<code>HttpMessageConverter</code>（<code>Http</code>消息转换器）传入其他与无参构造相同。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>​    两者方法都可使用，前者提供了多样的自定义参数的选择，可以将<code>RestTemplate</code>配置的更为完善，后者则简化了配置虽然配置多样性不如前者，但是日常使用调用些<code>API</code>还是足以使用</p><h2 id="RestTemplate-API使用"><a href="#RestTemplate-API使用" class="headerlink" title="RestTemplate API使用"></a><code>RestTemplate API</code>使用</h2><p>​    在使用<code>RestTemplate</code>前先让我们看看<code>RestTemplate</code>有哪些<code>API</code></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415205801633.png" alt="image-20220415205801633"><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415205831801.png" alt="image-20220415205831801"></p><p>​    相信大家看到这么多方法，一定很头大，但是我们仔细看上述的方法，我们可以提取出主要的几种方法是(这里只讨论Http请求的)：</p><ul><li><strong><code>GET</code></strong></li><li><strong><code>POST</code></strong></li><li><strong><code>PUT</code></strong></li><li><strong><code>DELETE</code></strong></li><li><strong><code>HEAD</code></strong></li><li><strong><code>OPTIONS</code></strong></li><li><strong><code>EXCHANGE</code></strong></li><li><strong><code>EXECUTE</code></strong></li></ul><p>​    <strong>这里我给大家安利一个一个网站，它提供免费的RESTFul api的样例测试。</strong><a href="http://httpbin.org/">httpbin A simple HTTP Request &amp; Response Service.</a></p><hr><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>​    通过上图我们可以发现<code>RestTemlate</code>发送<code>GET</code>请求的方法有两种</p><blockquote><ul><li><code>public &lt;T&gt; T getForObject(...)</code></li><li><code>public &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(...)</code></li></ul></blockquote><h4 id="getForEntity"><a href="#getForEntity" class="headerlink" title="getForEntity()"></a><strong><code>getForEntity()</code></strong></h4><p>​    后缀带有<code>Entity</code>的方法都代表返回一个<code>ResponseEntity&lt;T&gt;</code>，<code>ResponseEntity&lt;T&gt;</code>是Spring对<code>HTTP</code>请求响应的封装，包括了几个重要的元素，如响应码，<code>contentType、contentLength</code>、响应消息体等</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415211830207.png" alt="image-20220415211830207"></p><p>​    通过它继承父类(<code>HttpEntity&lt;T&gt;</code>)的<code>getHeader()</code>方法我们可以获取<code>contentType、contentLength</code>、响应消息体等。比如下面这个例子。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryWeather</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        ResponseEntity&lt;Object&gt; forEntity = restTemplate.getForEntity(<span class="string">&quot;https://restapi.amap.com/v3/weather/weatherInfo?city=510100&amp;key=e7a5fa943f706602033b6b329c49fbc6&quot;</span>, Object.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;状态码:&quot;</span>+forEntity.getStatusCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;状态码内容:&quot;</span>+forEntity.getStatusCodeValue());</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> forEntity.getHeaders();</span><br><span class="line">        System.out.println(<span class="string">&quot;响应头:&quot;</span>+headers);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">body</span> <span class="operator">=</span> forEntity.getBody();</span><br><span class="line">        System.out.println(<span class="string">&quot;响应内容:&quot;</span>+body);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    该例子中<code>getForEntity()</code>方法的第一个参数为我要调用服务的<code>URL</code>，第二个参数则为响应内容的类的类型（Java嘛 万物皆对象）还可以添加第三个参数，第三个参数为一个可变参数 代表着调用服务时的传参。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415212800839.png" alt="image-20220415212800839">    <strong>第三个参数可以使用key-value的map来传入参数</strong></p><p>​    <strong>get请求也可通过向在url上添加查询参数来发送带有请求的参数</strong></p><hr><h4 id="getForObject"><a href="#getForObject" class="headerlink" title="getForObject()"></a><strong><code>getForObject()</code></strong></h4><p>​    相比于前者<code>getForEntity()</code>该方法则是，更偏向于直接获取响应内容的，因为他直接返回响应实体的<code>body</code>（响应内容），。比如下面这个例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryWeather</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Object</span> <span class="variable">body</span> <span class="operator">=</span> restTemplate.getForObject(<span class="string">&quot;https://restapi.amap.com/v3/weather/weatherInfo?city=510100&amp;key=e7a5fa943f706602033b6b329c49fbc6&quot;</span>, Object.class);</span><br><span class="line">        System.out.println(body);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><pre><code> 方法参数签名与`getForEntity()`基本一致。</code></pre><hr><p>​    当你只需要返回的响应内容时，使用<code>getForObject()</code>是一个很好的选择，但当你需要获得更详细的响应信息，如响应头中的信息，你就只能选择<code>getForEntity()</code>了。</p><hr><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>​    <code>POST</code>请求有如下三种方法</p><blockquote><ul><li><code>public URI postForLocation(...)</code></li><li><code>public &lt;T&gt; T postForObject(...)</code></li><li><code>public &lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(...)</code></li></ul></blockquote><p>​    后两种用法与<code>GET</code>基本一致不做详细介绍，这里着重介绍<code>postForLocation()</code></p><hr><h4 id="postForEntity"><a href="#postForEntity" class="headerlink" title="postForEntity()"></a><code>postForEntity()</code></h4><p>​    该方法有三个参数，第一个为调用服务的地址（URL）</p><p>​    第二个参数表示上传的参数(json格式提交)</p><p>​    第三个表示返回响应内容的具体类型</p><p>​    第四个参数也用于指定参数（在URL中添加）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryWeather</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;鲁大师&quot;</span>);</span><br><span class="line">        ResponseEntity&lt;Object&gt; objectResponseEntity = restTemplate.postForEntity(<span class="string">&quot;https://restapi.amap.com/v3/weather/weatherInfo?city=510100&amp;key=e7a5fa943f706602033b6b329c49fbc6&quot;</span>, user, Object.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息响应内容:&quot;</span>+objectResponseEntity.getBody());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h4 id="postForObject"><a href="#postForObject" class="headerlink" title="postForObject()"></a><code>postForObject()</code></h4><p>​    使用方法与<code>getForObject</code>类似只是多了一个传入对象参数（传入方式与<code>postForEntity()</code>相同）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryWeather</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;鲁大师&quot;</span>);</span><br><span class="line">        ResponseEntity&lt;Object&gt; objectResponseEntity = restTemplate.postForEntity(<span class="string">&quot;https://httpbin.org/post&quot;</span>, user, Object.class);</span><br><span class="line">        <span class="type">MediaType</span> <span class="variable">contentType</span> <span class="operator">=</span> objectResponseEntity.getHeaders().getContentType();</span><br><span class="line">        System.out.println(contentType);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息响应内容:&quot;</span>+objectResponseEntity.getBody());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h4 id="postForLocation"><a href="#postForLocation" class="headerlink" title="postForLocation()"></a><code>postForLocation()</code></h4><p>​    <code>postForLocation</code>传参用法与前两者一致，只不过返回从实体变成了一个<code>URL</code>，因此它不需要指定返回响应内容的类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryWeather</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;鲁大师&quot;</span>);</span><br><span class="line">        <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> restTemplate.postForLocation(<span class="string">&quot;https://httpbin.org/post&quot;</span>, user);</span><br><span class="line">        System.out.println(uri);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个只需要服务提供者返回一个 URI 即可，该<code>URI</code>返回值体现的是：用于提交完成数据之后的页面跳转，或数据提交完成之后的下一步数据操作<code>URI</code>。</p><h4 id="使用POST以表单方式提交"><a href="#使用POST以表单方式提交" class="headerlink" title="使用POST以表单方式提交"></a>使用POST以表单方式提交</h4><p>​    这里我们着重说一下，如何自己封装一个请求体。</p><p>​    我们需要用到如下几个类</p><blockquote><ul><li><code>HttpHeaders</code></li><li><code>MultiValueMap&lt;K,V&gt;</code></li><li><code>HttpEntity&lt;T&gt;</code></li></ul></blockquote><h5 id="HttpHeaders"><a href="#HttpHeaders" class="headerlink" title="HttpHeaders"></a><code>HttpHeaders</code></h5><p>​    故名思意，就是用来封装Http请求的请求头的，这里我们要设置他的<code>ContentType</code>为**<code>MediaType.APPLICATION_FORM_URLENCODED</code>**以使得我们提交的参数是以Form(表单)的形式提交。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置请求头, x-www-form-urlencoded格式的数据</span></span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        <span class="comment">//这里指定参数以UTF-8编码格式传输</span></span><br><span class="line">        <span class="type">MediaType</span> <span class="variable">mediaType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaType</span>(MediaType.APPLICATION_FORM_URLENCODED, UTF_8);</span><br><span class="line">        httpHeaders.setContentType(mediaType);</span><br><span class="line">        <span class="comment">//提交参数设置</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">        map.add(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;鲁大师&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h5 id="MultiValueMap-lt-K-V-gt"><a href="#MultiValueMap-lt-K-V-gt" class="headerlink" title="MultiValueMap&lt;K,V&gt;"></a><code>MultiValueMap&lt;K,V&gt;</code></h5><p>​    该类是用来封装请求参数的，是以<code>key-value</code>的形式封装但是以单个key对应多个value的格式传输(也就是是以单个<code>key:[value...]</code>的格式传输的)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提交参数设置</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">        map.add(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;鲁大师&quot;</span>);</span><br></pre></td></tr></table></figure><p>​    <strong>如果像传输单个<code>key</code>对应单个<code>value</code>使用普通的<code>Map</code>传参即可</strong></p><hr><h5 id="HttpEntity-lt-T-gt"><a href="#HttpEntity-lt-T-gt" class="headerlink" title="HttpEntity&lt;T&gt;"></a><code>HttpEntity&lt;T&gt;</code></h5><p>​    该类是用来封装请求的，主要作用就是将请求头和请求体封装在一起成为一个请求实体 T用来指定用来封装参数的容器的类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组装请求体</span></span><br><span class="line">        HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; request = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(map, httpHeaders);</span><br></pre></td></tr></table></figure><hr><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>通过上述介绍后，我们就可以自己封装一个以form形式提交参数的<code>POST</code>请求了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//请求地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://httpbin.org/post&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置请求头, x-www-form-urlencoded格式的数据</span></span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        httpHeaders.setContentType(MediaType.APPLICATION_FORM_URLENCODED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交参数设置</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">        map.add(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;鲁大师&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//组装请求体</span></span><br><span class="line">        HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; request = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(map, httpHeaders);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送post请求并打印结果 以String类型接收响应结果JSON字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> restTemplate.postForObject(url, request, String.class);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416124128856.png" alt="image-20220416124128856"></p><p>​    通过拦截器拦截了请求并对请求头进行拆包，可以发现<code>ContentType</code>已经被修改成了<code>x-www-form-urlencoded</code>格式了。</p><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>​    <code>PUT</code>请求的方法只有一类</p><blockquote><ul><li><code>void put()</code></li></ul></blockquote><h4 id="PUT-1"><a href="#PUT-1" class="headerlink" title="PUT()"></a><code>PUT()</code></h4><p>​    使用方法与<code>postForEntity()</code>参数基本一致，只是<code>put</code>方法没有返回值（也就不必去设置响应内容的类型了）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//请求地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/put&quot;</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;鲁大师&quot;</span>);</span><br><span class="line">        restTemplate.put(url,user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>​    与<code>PUT</code>一样，<code>DELETE</code>方法只有一类</p><blockquote><ul><li><code>void delete()</code></li></ul></blockquote><h4 id="delete"><a href="#delete" class="headerlink" title="delete()"></a><code>delete()</code></h4><p>​    <code>delete()</code>可以指定<code>url</code>中的中的参数，但是<code>RestTemplate</code>的<code>delete()</code>方法是不支持上传<code>requestBody</code>的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/delete&quot;</span>;</span><br><span class="line">    restTemplate.delete(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="HEADER"><a href="#HEADER" class="headerlink" title="HEADER"></a>HEADER</h3><p>​    <code>HEADER</code>也只有一类方法</p><blockquote><ul><li><code>public HttpHeaders headForHeaders()</code></li></ul></blockquote><p>​    主要用来发送请求获取响应头部信息，但是像<code>DELETE</code>、<code>PUT</code>这类没有响应的方法，是不能使用该方法的（因为没有响应也就没有响应头了）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//请求地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/get&quot;</span>;</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> restTemplate.headForHeaders(url);</span><br><span class="line">        System.out.println(httpHeaders);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416151836372.png" alt="image-20220416151836372"></p><hr><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><blockquote><ul><li><code>public Set&lt;HttpMethod&gt; optionsForAllow()</code></li></ul></blockquote><p>​    该方法的主要用来判断该服务地址，能够使用那种方法去执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//请求地址</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/get&quot;</span>;</span><br><span class="line">       Set&lt;HttpMethod&gt; httpMethods = restTemplate.optionsForAllow(url);</span><br><span class="line">       System.out.println(httpMethods);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416152755753.png" alt="image-20220416152755753"></p><hr><h3 id="EXCHANGE"><a href="#EXCHANGE" class="headerlink" title="EXCHANGE"></a>EXCHANGE</h3><blockquote><ul><li><code>&lt;T&gt; ResponseEntity&lt;T&gt; exchange()</code></li></ul></blockquote><p>​    该接口与其他接口不同</p><blockquote><ul><li>该方法允许用户指定请求的方法（<code>get,post,put</code>等）</li><li>可以在请求中增加body以及头信息，其内容通过参数<code>HttpEntity&lt;?&gt; requestEntity</code>描述</li><li><code>exchange</code>支持’含参数的类型(即泛型)’作为返回类型，该特性通过<code>ParameterizedTypeReferenceresponseType</code> 描述</li></ul></blockquote><p>​    该方法支持五个参数</p><blockquote><ul><li>第一个是服务地址</li><li>第二个是请求方法</li><li>第三个是写入的请求实体</li><li>第四个是响应内容的类型</li><li>第五个是扩展模板的变量或包含<code>URI</code>模板变量的映射</li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/post&quot;</span>;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;彭于晏&quot;</span>);</span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    httpHeaders.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">    HttpEntity&lt;User&gt; userHttpEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(user, httpHeaders);</span><br><span class="line">    ResponseEntity&lt;Object&gt; exchange = restTemplate.exchange(url, HttpMethod.POST, userHttpEntity, Object.class);</span><br><span class="line">    System.out.println(exchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    上述代码模拟了一个简单的<code>POST</code>请求 <strong>可以理解为可以动态的指定请求方法和请求实体的一个方法。</strong></p><p> <strong>响应实体</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416154441113.png" alt="image-20220416154441113"></p><hr><h3 id="EXECUTE"><a href="#EXECUTE" class="headerlink" title="EXECUTE"></a>EXECUTE</h3><blockquote><ul><li><code>&lt;T&gt; T execute()</code></li></ul></blockquote><p>​    该方法就是执行请求的方法，我们可以发现上述的所有方法的最后执行都是调用的该方法执行，所以他在<code>RestTemplate</code>中十分重要</p><p>​    该方法有五个参数</p><blockquote><ul><li>服务地址</li><li>请求的方法</li><li>准备请求的对象（<code>requestCallback</code>）</li><li>从响应中提取返回值的对象</li><li>扩展模板的变量或包含<code>URI</code>模板变量的映射</li></ul></blockquote><p><code>execute()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">execute</span><span class="params">(String url, HttpMethod method, <span class="meta">@Nullable</span> RequestCallback requestCallback,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> ResponseExtractor&lt;T&gt; responseExtractor, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">URI</span> <span class="variable">expanded</span> <span class="operator">=</span> getUriTemplateHandler().expand(url, uriVariables);</span><br><span class="line"><span class="keyword">return</span> doExecute(expanded, method, requestCallback, responseExtractor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    通过上述源码我们可以发现<code>execute()</code>方法只是将我们传入的<code>String</code>类型的<code>URL</code>转换为了<code>URL</code>类型，最后执行请求是由<code>doExecute()</code>方法</p><hr><h4 id="doExecute"><a href="#doExecute" class="headerlink" title="doExecute()"></a><code>doExecute()</code></h4><p>​    这里需要了解两个类：<code>RequestCallback</code>和<code>ResPonseExtractor</code></p><p>​    <code>RequestCallback</code>: <strong>用于操作请求头和body，在请求发出前执行。不需要关心关闭请求或处理错误：这都将由RestTemplate处理。</strong></p><p>​    该接口有两个实现类：</p><p>​    <img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/v2-6761e212c99b46b5b24de7784c5f6c44_720w.jpg" alt="img"></p><p>​    <code>ResPonseExtractor</code>: <strong>解析HTTP响应的数据，而且不需要担心异常和资源的关闭。</strong></p><p>​    该接口在<code>RestTemplate</code>中同样有两个实现类：</p><table><thead><tr><th><code>HeadersExtractor</code></th><th>提取响应<code>HttpHeaders</code>的响应提取器。直接提取响应体中的响应头</th><th></th></tr></thead><tbody><tr><td><code>ResponseEntityResponseExtractor&lt;T&gt;</code></td><td><code>HttpEntity</code><strong>的响应提取器。可以获取响应实体里面包括响应头，响应体等。具体请查看</strong><code>HttpEntity</code></td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/post&quot;</span>;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;彭于晏&quot;</span>);</span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    httpHeaders.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">    HttpEntity&lt;User&gt; userHttpEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(user, httpHeaders);</span><br><span class="line">    ResponseEntity&lt;Object&gt; execute = restTemplate.execute(url, HttpMethod.POST, restTemplate.httpEntityCallback(userHttpEntity), restTemplate.responseEntityExtractor(Object.class));</span><br><span class="line">    System.out.println(execute);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416161653708.png" alt="image-20220416161653708"></p><hr><h2 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h2><ul><li>前面我们介绍方法的时候发现有个一个可变参数，那个参数被描述成了<strong>扩展模板的变量或是包含<code>URI</code>模板变量的映射</strong></li></ul><p>我们来简单看一下这个参数，我们知道请求传参可以通过<code>url</code>拼接参数的方式传参，拼接参数也分为两种：</p><blockquote><ul><li>路径中嵌入占位的格式（<code>http://httpbin.org/&#123;1&#125;/post</code>）也叫模板映射</li><li>末尾添加<code>Key-value</code>格式（<code>http://httpbin.org/post?name=&quot;彭于晏&quot;</code>）即扩展模板的变量</li></ul></blockquote><ul><li>当我们最后一参数传入map时会以<code>key-value</code>的格式拼接在<code>URL</code>后（通俗的说就是这样设置的变量会跟着<code>URL</code>路径后面）</li></ul><p>​    <code>http://httpbin.org/post?name=&quot;彭于晏&quot;</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/get&quot;</span>;</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;彭于晏&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">forObject</span> <span class="operator">=</span> restTemplate.getForObject(url, Object.class, map);</span><br><span class="line">    System.out.println(forObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当我们传入简单的对象如String，Integer时且路径中有嵌入的占位符时就会代替调用URL中占位符</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/&#123;2&#125;/get&quot;</span>;</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">forObject</span> <span class="operator">=</span> restTemplate.getForObject(url, Object.class, <span class="number">99</span>);</span><br><span class="line">    System.out.println(forObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416163605771.png" alt="image-20220416163605771"></p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u012843361/article/details/79893638">spring cloud 做微服务时关于RestTemplate中的各种请求方法的使用总结_DWT_CCFK的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/31681913">RestTemplate 详解 - 知乎 (zhihu.com)</a></p><p><a href="https://www.jianshu.com/p/35aca2e31f06">RestTemplate使用教程 - 简书 (jianshu.com)</a></p><hr><h1 id="End"><a href="#End" class="headerlink" title="-End-"></a>-End-</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RestTemplate&quot;&gt;&lt;a href=&quot;#RestTemplate&quot; class=&quot;headerlink&quot; title=&quot;RestTemplate&quot;&gt;&lt;/a&gt;RestTemplate&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://ding-blog.os</summary>
      
    
    
    
    <category term="分布式" scheme="https://devildyw.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HttpClient</title>
    <link href="https://devildyw.github.io/2022/04/11/HttpClient/"/>
    <id>https://devildyw.github.io/2022/04/11/HttpClient/</id>
    <published>2022-04-11T09:53:07.000Z</published>
    <updated>2022-04-16T08:52:08.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Apache-HttpClient"><a href="#Apache-HttpClient" class="headerlink" title="Apache HttpClient"></a>Apache HttpClient</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>HttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。HttpClient 已经应用在很多的项目中，比如 Apache Jakarta 上很著名的另外两个开源项目 Cactus 和 <strong>HTMLUnit</strong> 都使用了 HttpClient。</p></blockquote><p>​    使用HttpClient、可以灵活地发送HTTP请求，并且Apache HttpClient提供了很多自定义的请求内容的API（包括连接超时时间设置等）。方便了开发人员测试接口（基于HTTP协议的），既提高了开发效率，也方便了提高代码的健壮性。（后续的RestTemplate的底层也是HttpClient）因此熟悉掌握HttpClient是很重要的必修内容，掌握了HttpClient后，对于HTTP的协议的了解也会更加深刻。</p><hr><h2 id="Apache-HttpClient特性"><a href="#Apache-HttpClient特性" class="headerlink" title="Apache HttpClient特性"></a>Apache HttpClient特性</h2><ul><li>基于标准，纯净的Java语言。实现了HTTP1.0和HTTP1.1</li><li>以可扩展的面向对象的结构实现了 HTTP 全部的方法（<code>GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE</code>）。</li><li>支持 HTTPS 协议。</li><li>通过 HTTP 代理建立透明的连接。</li><li>利用 CONNECT 方法通过 HTTP 代理建立隧道的 HTTPS 连接。</li><li><code>Basic,Digest,NTLMv1,NTLMv2,NTLM2Session,SNPNEGO/Kerberos </code>认证方案。</li><li>插件式的自定义认证方案。</li><li>便携可靠的套接字工厂使它更容易的使用第三方解决方案。</li><li>连接管理器支持多线程应用。支持设置最大连接数，同时支持设置每个主机的最大连接数，发现并关闭过期的连接。</li><li>自动处理 Set-Cookie 中的 Cookie。</li><li>插件式的自定义 Cookie 策略。</li><li>Request 的输出流可以避免流中内容直接缓冲到 Socket 服务器。</li><li>Response 的输入流可以有效的从 Socket 服务器直接读取相应内容。</li><li>在 HTTP 1.0 和 HTTP 1.1 中利用 KeepAlive 保持持久连接。</li><li>直接获取服务器发送的 response code 和 headers。</li><li>设置连接超时的能力。</li><li>实验性的支持 HTTP 1.1 response caching。</li></ul><h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><ul><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpmime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建<code>HttpClient</code>对象（http客户端对象）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();<span class="comment">//方式一</span></span><br><span class="line"><span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClients.createDefault();<span class="comment">//方式二</span></span><br></pre></td></tr></table></figure><p>两种方式相同，因为方式二的底层就是方式一。</p></li><li><p>创建请求方法的实例，并指定<code>URL</code>。因为<code>HttpClient</code>是实现了所有<code>Http</code>请求方法，我们只需要创建请求方法实例（Httpxxx），在方法实例中指定URL即可，例如我们要发送Get请求，就创建<code>HttpGet</code>对象。</p></li><li><p>如果需要发送带有参数的请求，可调用<code>HttpGet、HttpPost</code>共同的<code>setParam（HttpParams params）</code>来添加参数（该方法已经过时&#x2F;弃用了）；<code>HttpGet</code>推荐使用单独创建uri，构建自己的带参数的get请求的uri。<code>HttpPost</code>请求则是调用<code>setEntity(HttpEntity entity)</code>方法来设置请求参数（可以设置对象）。</p></li><li><p>发送请求则是<code>HttpClient</code>的工作，调用<code>HttpClient</code>的<code>execute(HttpUriRequeset request)</code>发送请求，该方法会返回一个<code>HttpResponse</code>（响应模板）</p></li><li><p>调用<code>HttpResponse</code>的<code>getAllHeader()</code>、<code>getHeaders(Sring name)</code>等方法可以获取服务器的响应头，除此之外还可以获取状态码等。通过<code>HttpResponse</code>的<code>getEntity()</code>方法可以获取响应的响应实体，该对象包装了服务器的响应内容，程序可以通过该对象获取服务器的响应内容。</p></li><li><p>最后需要释放资源，关闭<code>HttpClient</code>和<code>reseponse</code>的资源连接</p></li></ul><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p><code>GET请求</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * GET---无参测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGetTestOne</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获得http客户端</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line">        <span class="comment">//创建get请求</span></span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;https://www.cuit.edu.cn/&quot;</span>);</span><br><span class="line">        <span class="comment">//响应模型</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//有客户端指定get请求</span></span><br><span class="line">            response = client.execute(httpGet);</span><br><span class="line">            <span class="comment">//从响应模型中获取响应体</span></span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">responseEntity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;响应状态为:&quot;</span>+response.getStatusLine());</span><br><span class="line">            <span class="keyword">if</span> (responseEntity!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容长度为:&quot;</span>+responseEntity.getContentLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容为:&quot;</span>+ EntityUtils.toString(responseEntity));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//释放资源</span></span><br><span class="line">                <span class="keyword">if</span>(client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * GET--有参测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGetTestWayOne</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获得http客户端</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//参数</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            params.append(<span class="string">&quot;name=&quot;</span>).append(URLEncoder.encode(<span class="string">&quot;&amp;&quot;</span>,<span class="string">&quot;utf-8&quot;</span>)).append(<span class="string">&quot;&amp;&quot;</span>).append(<span class="string">&quot;age=24&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Get请求</span></span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;https://www.cuit.edu.cn/?&quot;</span> + params);</span><br><span class="line">        <span class="comment">//响应模型</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//配置信息</span></span><br><span class="line">            <span class="type">RequestConfig</span> <span class="variable">config</span> <span class="operator">=</span> RequestConfig.custom()</span><br><span class="line">                    <span class="comment">//设置连接超时时间</span></span><br><span class="line">                    .setConnectTimeout(<span class="number">5000</span>)</span><br><span class="line">                    <span class="comment">//设置请求超时时间</span></span><br><span class="line">                    .setConnectionRequestTimeout(<span class="number">5000</span>)</span><br><span class="line">                    <span class="comment">//socket读写超时时间</span></span><br><span class="line">                    .setSocketTimeout(<span class="number">5000</span>)</span><br><span class="line">                    <span class="comment">//设置是否允许重定向(默认为true)</span></span><br><span class="line">                    .setRedirectsEnabled(<span class="literal">true</span>)</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="comment">//将上面的配置信息配入Get请求中</span></span><br><span class="line">            httpGet.setConfig(config);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//由客户端执行Get请求</span></span><br><span class="line">            response = client.execute(httpGet);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从响应模型中获取响应实体</span></span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">responseEntity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;响应状态为:&quot;</span>+response.getStatusLine());</span><br><span class="line">            <span class="keyword">if</span> (responseEntity!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容长度为:&quot;</span>+responseEntity.getContentLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容为:&quot;</span>+ EntityUtils.toString(responseEntity,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientProtocolException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGetTestWayTwo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line">        <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ArrayList&lt;NameValuePair&gt; params = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            params.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;10&quot;</span>));</span><br><span class="line">            params.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>));</span><br><span class="line">            <span class="comment">//这里设置uri信息,并将参数集合放入uri;</span></span><br><span class="line">            <span class="comment">//注: 这里也支持一个键值对一个键值对地往里面方setParameter(String key, String value)</span></span><br><span class="line">            uri = <span class="keyword">new</span> <span class="title class_">URIBuilder</span>().setScheme(<span class="string">&quot;http&quot;</span>).setHost(<span class="string">&quot;www.cuit.edu.cn&quot;</span>)</span><br><span class="line"><span class="comment">//                    .setPort(12345).setPath(&quot;/xw&quot;)</span></span><br><span class="line">                    .setParameters(params).build();</span><br><span class="line">            System.out.println(uri);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建httpGet请求</span></span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(uri);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建响应模型</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">RequestConfig</span> <span class="variable">config</span> <span class="operator">=</span> RequestConfig.custom()</span><br><span class="line">                    .setConnectTimeout(<span class="number">5000</span>)</span><br><span class="line">                    .setConnectionRequestTimeout(<span class="number">5000</span>)</span><br><span class="line">                    .setSocketTimeout(<span class="number">5000</span>)</span><br><span class="line">                    .setRedirectsEnabled(<span class="literal">true</span>).build();</span><br><span class="line"></span><br><span class="line">            httpGet.setConfig(config);</span><br><span class="line">            response = client.execute(httpGet);</span><br><span class="line"></span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;响应状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容长度:&quot;</span>+entity.getContentLength());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容:&quot;</span>+EntityUtils.toString(entity,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientProtocolException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//new GetClient().doGetTestOne();</span></span><br><span class="line">        <span class="comment">//new GetClient().doGetTestWayOne();</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GetClient</span>().doGetTestWayTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>POST请求</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * POST 无参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPostTestOne</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获得http客户端</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line">        <span class="comment">//创建Post请求</span></span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://www.cuit.edu.cn/index.htm&quot;</span>);</span><br><span class="line">        <span class="comment">//创建响应模型</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            response = client.execute(httpPost);</span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;响应状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容长度:&quot;</span>+entity.getContentLength());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容:&quot;</span>+ EntityUtils.toString(entity,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * POST 有参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPostTestFour</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获的http客户端</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//参数</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//字符数据最好encoding; 这样一来, 某些特殊字符才嗯那个传过去(如:某人的名字就是&quot;&amp;&quot;,不encoding,传不过去)</span></span><br><span class="line">            params.append(<span class="string">&quot;phone=&quot;</span>).append(URLEncoder.encode(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            params.append(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">            params.append(<span class="string">&quot;password=admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建post请求</span></span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://www.cuit.edu.cn/?&quot;</span> + params);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置ContentType(注:如果只是传入普通参数的话,ContentType不一定非要用application/json)</span></span><br><span class="line">        httpPost.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//响应模型</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            response = client.execute(httpPost);</span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容长度: &quot;</span>+entity.getContentLength());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容: &quot;</span>+entity);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * POST---有参测试(对象参数)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPostTestTwo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获取Http客户端</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Post请求</span></span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://www.cuit.edu.cn/index.htm&quot;</span>);</span><br><span class="line">        <span class="comment">//User user = new User();</span></span><br><span class="line">        <span class="comment">//user.setName(&quot;潘晓婷&quot;);</span></span><br><span class="line">        <span class="comment">//user.setAge(18);</span></span><br><span class="line">        <span class="comment">//user.setGender(&quot;女&quot;);</span></span><br><span class="line">        <span class="comment">//user.setMotto(&quot;姿势要优雅~&quot;);</span></span><br><span class="line">        <span class="comment">// 我这里利用阿里的fastjson，将Object转换为json字符串;</span></span><br><span class="line">        <span class="comment">// (需要导入com.alibaba.fastjson.JSON包)</span></span><br><span class="line">        <span class="comment">//String jsonString = JSON.toJSONString(user);</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">StringEntity</span> <span class="variable">stringEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringEntity</span>(jsonString, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        httpPost.setEntity(stringEntity);</span><br><span class="line">        httpPost.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=utf8&quot;</span>);</span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            response = client.execute(httpPost);</span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容长度:&quot;</span>+entity.getContentLength());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容:&quot;</span>+EntityUtils.toString(entity,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//new PostClient().doPostTestOne();</span></span><br><span class="line">        <span class="comment">//new PostClient().doPostTestFour();</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">PostClient</span>().doPostTestTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>上传文件</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送文件</span></span><br><span class="line"><span class="comment">     注:如果想要灵活方便的传输文件的话，</span></span><br><span class="line"><span class="comment">     *    除了引入org.apache.httpcomponents基本的httpclient依赖外</span></span><br><span class="line"><span class="comment">     *    再额外引入org.apache.httpcomponents的httpmime依赖。</span></span><br><span class="line"><span class="comment">     *    追注:即便不引入httpmime依赖，也是能传输文件的，不过功能不够强大。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://www.cuit.edu.cn/file&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">MultipartEntityBuilder</span> <span class="variable">multipartEntityBuilder</span> <span class="operator">=</span> MultipartEntityBuilder.create();</span><br><span class="line">            <span class="comment">//第一个文件</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileKey</span> <span class="operator">=</span> <span class="string">&quot;files&quot;</span>;</span><br><span class="line">            <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\图片\\《Valorant》3440x1440带鱼屏游戏壁纸_彼岸图网.jpg&quot;</span>);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            防止服务端收到的文件名乱码. 我们这里可以先将文件名URLEncode, 然后服务端拿到文件后URLDecode</span></span><br><span class="line"><span class="comment">            文件名其实是放在请求头的Content-Disposition中 如其值form-data; name=&quot;files&quot;; filename=&quot;头像.jpg&quot;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            multipartEntityBuilder.addBinaryBody(fileKey,file1, ContentType.DEFAULT_BINARY, URLEncoder.encode(file1.getName(),<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//其他参数(注:自定义contentType,设置UTF-8是为了防止服务端拿到的参数出现乱码)</span></span><br><span class="line">            <span class="type">ContentType</span> <span class="variable">contentType</span> <span class="operator">=</span> ContentType.create(<span class="string">&quot;text/plain&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">            multipartEntityBuilder.addTextBody(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;等沙利文&quot;</span>,contentType);</span><br><span class="line">            multipartEntityBuilder.addTextBody(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;25&quot;</span>,contentType);</span><br><span class="line"></span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">httpEntity</span> <span class="operator">=</span> multipartEntityBuilder.build();</span><br><span class="line">            httpPost.setEntity(httpEntity);</span><br><span class="line">            response = client.execute(httpPost);</span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            <span class="keyword">if</span> (entity!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容长度:&quot;</span>+entity.getContentLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容:&quot;</span>+ EntityUtils.toString(entity,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            File file1 = new File(&quot;D:\\图片\\XXX.jpg&quot;);</span></span><br><span class="line"><span class="comment">            multipartEntityBuilder.addBinaryBody(fileKey,file1);</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileClient</span>().test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Stream请求</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://www.cuit.edu.cn/index.htm&quot;</span>);</span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(<span class="string">&quot;流啊流~&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            <span class="type">InputStreamEntity</span> <span class="variable">ise</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamEntity</span>(is);</span><br><span class="line">            httpPost.setEntity(ise);</span><br><span class="line"></span><br><span class="line">            response = client.execute(httpPost);</span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;响应状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line">            <span class="keyword">if</span> (entity!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容长度:&quot;</span>+entity.getContentLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容:&quot;</span>+ EntityUtils.toString(entity,StandardCharsets.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StreamClient</span>().test5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="END"><a href="#END" class="headerlink" title="-END-"></a>-END-</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Apache-HttpClient&quot;&gt;&lt;a href=&quot;#Apache-HttpClient&quot; class=&quot;headerlink&quot; title=&quot;Apache HttpClient&quot;&gt;&lt;/a&gt;Apache HttpClient&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="分布式" scheme="https://devildyw.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>事务的嵌套</title>
    <link href="https://devildyw.github.io/2022/04/09/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B5%8C%E5%A5%97/"/>
    <id>https://devildyw.github.io/2022/04/09/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B5%8C%E5%A5%97/</id>
    <published>2022-04-09T09:47:42.000Z</published>
    <updated>2022-04-09T09:50:51.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务的嵌套"><a href="#事务的嵌套" class="headerlink" title="事务的嵌套"></a>事务的嵌套</h1><p><strong>什么是嵌套事务？</strong><br>       嵌套是子事务在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。</p><p><strong>可以通过下述的问答进一步去熟悉嵌套事务？</strong></p><ol><li>如果子事务回滚，会发生什么？<br>      父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。</li><li>如果父事务回滚，会发生什么？<br>      父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。</li><li>事务的提交，是什么情况？<br>      父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。</li></ol><p>原文链接：<a href="https://blog.csdn.net/javashareauthor/article/details/82842177">https://blog.csdn.net/javashareauthor/article/details/82842177</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事务的嵌套&quot;&gt;&lt;a href=&quot;#事务的嵌套&quot; class=&quot;headerlink&quot; title=&quot;事务的嵌套&quot;&gt;&lt;/a&gt;事务的嵌套&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;什么是嵌套事务？&lt;/strong&gt;&lt;br&gt;       嵌套是子事务在父事务中执行，子事务是父事务的</summary>
      
    
    
    
    <category term="数据库" scheme="https://devildyw.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="database" scheme="https://devildyw.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Annotation</title>
    <link href="https://devildyw.github.io/2022/04/07/Annotation/"/>
    <id>https://devildyw.github.io/2022/04/07/Annotation/</id>
    <published>2022-04-07T14:09:56.000Z</published>
    <updated>2022-04-16T08:52:19.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    <code>Annotation</code>（注解）是JDK5开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类，方法或者变量，在框架中大量使用（如 Spring、Mybatis等）</p><blockquote><p>注解是一种能被添加到java代码中的元数据，类、方法、变量、参数和包都可以用注解来修饰。注解对于它所修饰的代码并没有直接的影响。</p></blockquote><p>​    下面是我简单写的一个自定义注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">msg</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;Hi&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    通过对上述文件的字节码（.class）的反编译（javap - p xxx.class）可以得到<code>@interface</code>其实就是一个继承了<code>Annotation</code>的一个接口</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javap -p Test.class</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">com</span>.dyw.annotation.Test <span class="keyword">extends</span> <span class="title class_">java</span>.lang.annotation.Annotation &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> java.lang.String <span class="title function_">msg</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期间直接扫描：</strong>编译器在编译Java代码的时候扫描对于的注解并处理，比如某个方法使用了<code>@Override</code>，编译器在编译的时候就会检测当前的方法是否重写了父类对于的方法。</li><li><strong>运行期间通过反射处理：</strong>这个经常在Spring框架中看到，例如Spring的<code>@Value</code>注解，就是通过反射来进行处理的。</li></ul><h2 id="注解详细介绍"><a href="#注解详细介绍" class="headerlink" title="注解详细介绍"></a>注解详细介绍</h2><p>我们通过上述的例子可以看到我们的注解上面还有着其他的注解例如<code>@Retention</code>、<code>@Target</code>（这些都统称为元注解）.</p><p>所以一个注解是由以下成分组成</p><blockquote><ul><li>元注解</li><li><code>public @interface 注解名称</code></li></ul></blockquote><hr><h3 id="元注解介绍"><a href="#元注解介绍" class="headerlink" title="元注解介绍"></a>元注解介绍</h3><p>​    JDK1.8版本为我们提供了6个标准的用来<strong>对注解类型进行注解的注解类</strong>（1.8之前只有四个），我们称之为<code>meta-annotation</code>（元注解）.</p><p>​    <strong>元注解只能用在注解之上（自定义注解时可用）</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407175816207.png" alt="image-20220407175816207"></p><blockquote><p><code>@Target</code></p><p><code>@Retention</code></p><p><code>@Documented</code></p><p><code>@Inherited</code></p><p><code>@Native</code>（1.8新增）</p><p><code>@Repeatable</code>（1.8新增）</p></blockquote><hr><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a><code>@Target</code></h4><p>官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">指示注解类型适用的上下文。注解类型可能适用的声明上下文和类型上下文在 JLS 9.6.4.1 中指定，并在源代码中由java.lang.annotation.ElementType的枚举常量表示。</span><br><span class="line">如果注解类型T上不存在@Target元注解，则类型T的注解可以写为除类型参数声明之外的任何声明的修饰符。</span><br><span class="line">如果存在@Target元注解，编译器将强制执行ElementType枚举常量指示的使用限制，符合 JLS 9.7.4。</span><br></pre></td></tr></table></figure><ul><li><strong>它指明了它所修饰的注解使用的范围 如果自定义的注解为含有@Target元注解修饰，那么默认可以是在（除类型参数之外的）任何项之上使用，若有@Target元注解修饰那么根据Value（ElementType枚举常量）的指定的目标进行规定。</strong></li></ul><h5 id="ElementType"><a href="#ElementType" class="headerlink" title="ElementType"></a><code>ElementType</code></h5><p><code>ElementType.class</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span> &#123;</span><br><span class="line">    <span class="comment">/** 类、接口（包括注解类型）或枚举声明 */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 字段声明（包括枚举常量） */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 方法声明 */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 参数声明 */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 构造函数声明 */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 局部变量声明 */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 注解类型声明 */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 包装声明 */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型参数声明 类型参数即Map&lt;String,Integer&gt;中的String和Integer这里是作为类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用类型 对应于 JLS 4.11 中的 15 个类型上下文，以及两个声明上下文：类型声明（包括注解类型声明）和类型参数声明。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>ElementType的枚举常量指明了注解可以使用的目标。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span><span class="comment">//可修饰在方法之上</span></span><br></pre></td></tr></table></figure><hr><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a><code>@Retention</code></h4><p>官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">指示要保留带注解类型的注解多长时间。如果注释类型声明中不存在保留注释，则保留策略默认为RetentionPolicy.CLASS 。</span><br><span class="line">仅当元注释类型直接用于注释时，保留元注释才有效。如果将元注释类型用作另一个注释类型中的成员类型，则它没有效果。</span><br></pre></td></tr></table></figure><ul><li>即<code>@Retention</code>用来约束注解的生命周期，分别有三个值，源码级别（source）、类文件级别（class）或者运行时级别（runtime）可以通过指定<code>@Retention</code>中的值来实现（值为<code>RetentionPolicy</code>枚举常量）。</li></ul><h5 id="RetentionPolicy-class"><a href="#RetentionPolicy-class" class="headerlink" title="RetentionPolicy.class"></a><code>RetentionPolicy.class</code></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RetentionPolicy</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解将被编译器丢弃。(该类型的注解信息指挥保留在源码中，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class文件中)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解将由编译器记录在类文件中，但不需要在运行时由 VM 保留。这是默认行为.(该类型的注解信息会保留在源码里和class文件里，在执行的时候，不会加载到虚拟机中) 该类型也是未指定<span class="doctag">@Retention</span>值的缺省值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解将由编译器记录在类文件中，并在运行时由 VM 保留，因此可以反射性地读取它们。(源码，class文件和执行时(VM)都保留注解的信息)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>注意：</strong>生命周期大小排序为<code>SOURCE &lt; CLASS &lt; RUNTIME</code>，范围依次增大，前者能使用的地方后者一定能使用。如果需要在运行时去动态获取注解信息，那只能使用<code>RUNTIME</code>；如果要在编译时进行一些预处理操作，比如生成一些辅助代码，就是用<code>CLASS</code>；如果只是做一些检查性的操作，比如<code>@Override和@SupperssWarning</code>，可选择<code>SOURCE</code></p><hr><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a><code>@Documented</code></h4><p>官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">表示默认情况下，带有类型的注释将由 javadoc 和类似工具记录。这种类型应该用于注解类型的声明，这些类型的注释会影响其客户对注释元素的使用。如果使用 Documented 对类型声明进行注释，则其注释将成为注释元素的公共 API 的一部分。</span><br></pre></td></tr></table></figure><ul><li>带上该注解后的注解表明，在默认情况下这个注解是由JavaDoc和类似工具记录的，即带上了该文档化的注解被使用再生成文档时，会称为API的一部分。（默认情况下JavaDoc是不包含注解的，除非声明注解的时候使用了<code>@Documented</code>）</li></ul><p><code>Person.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Person &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="meta">@Person(name = &quot;ding&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//@Person(name = &quot;ding&quot;)</span></span><br><span class="line">    <span class="meta">@Person(name = &quot;yang&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>生成的文档</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407193958620.png" alt="image-20220407193958620"></p><ul><li>不带<code>@Documented</code>注解生成的文档</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407194037553.png" alt="image-20220407194037553"></p><hr><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a><code>@Inherited</code></h4><p>官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">指示注解类型是自动继承的。如果注解类型声明中存在 Inherited 元注解，并且用户在类声明中查询注解类型，并且类声明没有该类型的注解，则将自动查询该类的超类以获取注解类型。将重复此过程，直到找到此类型的注释，或到达类层次结构（对象）的顶部。如果没有超类具有此类型的注释，则查询将指示所讨论的类没有此类注释。</span><br><span class="line">请注意，如果注释类型用于注释类以外的任何内容，则此元注释类型无效。另请注意，此元注释仅导致注释从超类继承；已实现接口上的注解无效。</span><br></pre></td></tr></table></figure><ul><li>被该元注解修饰的自定义注解再使用后会自动继承，如果使用了该自定义注解去修饰一个class那么这个注解也会作用于该class的子类。就是说如果某个类使用了被<code>@Inherited</code>修饰的注解，则其子类将会自动具有该注释</li></ul><p>​    <strong>注意：</strong> <code>@Inherited annotation</code>类型是被标注过的<code>class</code>的子类所继承。类并不从它所实现的接口继承<code>annotation</code>，方法并不从它所重载的方法继承<code>annotation</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span> <span class="comment">//使用@Inherited修饰的自定义注解</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Person &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>main.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Father.class.getAnnotation(Person.class));</span><br><span class="line">        System.out.println(Son.class.getAnnotation(Person.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">com</span>.dyw.annotation.obj.Father &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407204033473.png" alt="image-20220407204033473"></p><hr><h4 id="Native"><a href="#Native" class="headerlink" title="@Native"></a><code>@Native</code></h4><p>官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">表示可以从本机代码引用定义常量值的字段。注释可以被生成本机头文件的工具用作提示，以确定是否需要头文件，如果需要，它应该包含哪些声明。</span><br></pre></td></tr></table></figure><ul><li>使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可。</li></ul><hr><h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a><code>@Repeatable</code></h4><p>官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">注释类型java.lang.annotation.Repeatable用于指示它（元）注释其声明的注释类型是可重复的。 @Repeatable的值表示可重复注解类型的包含注解类型。</span><br></pre></td></tr></table></figure><blockquote><p><code>@Repeatable</code>允许在相同的程序元素中重复注解（不报错）。在需要对同一种注解多次使用时，往往需要借助 @Repeatable 注解。Java 8 版本以前，同一个程序元素前最多只能有一个相同类型的注解，如果需要在同一个元素前使用多个相同类型的注解，则必须使用注解“容器”。</p></blockquote><p>​    <strong>不使用<code>@Repeatable</code>修饰的自定义注解完成重复注解</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Persons &#123;</span><br><span class="line">    Person[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Person &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Persons(value = &#123;@Person(name = &quot;ding&quot;),@Person(name = &quot;yang&quot;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>使用<code>@Repeatable</code>修饰的自定义注解</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Persons &#123;</span><br><span class="line">    Person[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable(Persons.class)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Person &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Person(name = &quot;ding&quot;)</span></span><br><span class="line"><span class="meta">@Person(name = &quot;yang&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>两种方法不同的地方是，创建重复注解Person时加上了<code>@Repeatable</code>注解，指向存储注解Persons，这样使用时就可以直接重复使用Person注解。从上述例子可以看出使用<code>@Repeatable</code>注解更符合常规思维，可读性强。</p></li><li><p>但两种方法的效果相同，只是使用了<code>@Repeatable</code>注解简化了写法，这种简化的底层依旧是多个重复注解使用了一个被称作“容器”注解的value的成员的数组元素处理。</p></li></ul><hr><h3 id="JDK基本注解介绍"><a href="#JDK基本注解介绍" class="headerlink" title="JDK基本注解介绍"></a>JDK基本注解介绍</h3><p>​    基本注解包括</p><blockquote><ul><li><p><code>@Override</code></p></li><li><p><code>@Deprecated</code></p></li><li><p><code>@SuppressWarnings</code></p></li><li><p><code>@SafeVarargs </code></p></li><li><p><code>@FunctionalInterface</code></p></li></ul></blockquote><h4 id="Override"><a href="#Override" class="headerlink" title="@Override"></a><code>@Override</code></h4><p>​    官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">指示方法声明旨在覆盖超类型中的方法声明。如果使用此注解类型对方法进行注解，则编译器需要生成错误消息，除非至少满足以下条件之一：</span><br><span class="line">该方法确实覆盖或实现了在超类型中声明的方法。</span><br><span class="line">该方法的签名与Object中声明的任何公共方法的签名等效。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">msg</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">msg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果将子类中方法名<code>msg</code>改为<code>mg</code>会发生如下编译错误</li></ul><blockquote><p>java: 方法不会覆盖或实现超类型的方法</p></blockquote><ul><li>所以<code>@Override</code>的作用告诉编译器检查这个方法，保证父类要包含一个被该方法重写的方法，否者就会出错，这样可以帮助程序员避免一些低级错误。</li></ul><hr><h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a><code>@Deprecated</code></h4><p>​    官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">@Deprecated 注释的程序元素是不鼓励程序员使用的程序元素，通常是因为它很危险，或者因为存在更好的替代方案。当在非弃用代码中使用或覆盖弃用的程序元素时，编译器会发出警告。</span><br></pre></td></tr></table></figure><ul><li>通俗的说被该注解修饰的目标项是已经过时的了，不推荐使用的。**</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">msg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>@Deprecated</code>修饰了Son中的<code>msg</code>方法后，调用该方法会出现<strong>删除线</strong>和编译警告。</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407210522333.png" alt="image-20220407210522333"></p><hr><h4 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a><code>@SuppressWarnings</code></h4><p>​    官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">指示应在带注释的元素（以及带注释的元素中包含的所有程序元素）中抑制命名的编译器警告。请注意，给定元素中抑制的警告集是所有包含元素中抑制的警告的超集。例如，如果您注释一个类以抑制一个警告并注释一个方法以抑制另一个警告，则两个警告都将在方法中被抑制。</span><br><span class="line">作为风格问题，程序员应该始终在最有效的嵌套元素上使用此注释。如果您想在特定方法中抑制警告，您应该注释该方法而不是它的类。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *编译器要在带注​​释的元素中抑制的一组警告。允许重复名称。名称的第二次和连续出现将被忽略。存在无法识别的警告名称不是错误：编译器必须忽略它们无法识别的任何警告名称。但是，如果注释包含无法识别的警告名称，它们可以自由发出警告。</span></span><br><span class="line"><span class="comment">字符串&quot;unchecked&quot;用于抑制未经检查的警告。编译器供应商应结合此注释类型记录他们支持的其他警告名称。鼓励他们合作以确保相同的名称在多个编译器中工作。</span></span><br><span class="line"><span class="comment">回报：</span></span><br><span class="line"><span class="comment">要抑制的警告集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Java中的<code>@SuppressWarnings</code> 注解指示被该注解修饰的程序元素（以及该程序元素中的所有子元素）取消显示指定的编译器警告，且会一直作用于该程序元素的所有子元素。</p></li><li><p>如果你对于代码的规范不做要求又对编译器的警告感到烦躁那么你可以使用<code>@SuppressWarnings</code>（仅仅只是取消显示，并没有消除），它可以让你免去这些烦恼，当然编译器报错他是无法帮你取消显示的。</p></li><li><p>添加前：</p></li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407211856114.png" alt="image-20220407211856114"></p><ul><li>添加后：</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407212004111.png" alt="image-20220407212004111"></p><ul><li><p>注解的使用有以下三种：</p><ul><li>抑制单类型的警告：<code>@SuppressWarnings(&quot;unchecked&quot;)</code></li><li>抑制多类型的警告：<code>@SuppressWarnings(&quot;unchecked&quot;,&quot;rawtypes&quot;)</code></li><li>抑制所有类型的警告：<code>@SuppressWarnings(&quot;unchecked&quot;)</code></li></ul></li><li><p>抑制警告的关键字如下表所示：</p><table><thead><tr><th>关键字</th><th>用途</th></tr></thead><tbody><tr><td>all</td><td>抑制所有警告</td></tr><tr><td>boxing</td><td>抑制装箱、拆箱操作时候的警告</td></tr><tr><td>cast</td><td>抑制映射相关的警告</td></tr><tr><td>dep-ann</td><td>抑制启用注释的警告</td></tr><tr><td>deprecation</td><td>抑制过期方法警告</td></tr><tr><td>fallthrough</td><td>抑制在 switch 中缺失 breaks 的警告</td></tr><tr><td>finally</td><td>抑制 finally 模块没有返回的警告</td></tr><tr><td>hiding</td><td>抑制相对于隐藏变量的局部变量的警告</td></tr><tr><td>incomplete-switch</td><td>忽略不完整的 switch 语句</td></tr><tr><td>nls</td><td>忽略非 nls 格式的字符</td></tr><tr><td>null</td><td>忽略对 null 的操作</td></tr><tr><td>rawtypes</td><td>使用 generics 时忽略没有指定相应的类型</td></tr><tr><td>restriction</td><td>抑制禁止使用劝阻或禁止引用的警告</td></tr><tr><td>serial</td><td>忽略在 serializable 类中没有声明 serialVersionUID 变量</td></tr><tr><td>static-access</td><td>抑制不正确的静态访问方式警告</td></tr><tr><td>synthetic-access</td><td>抑制子类没有按最优方法访问内部类的警告</td></tr><tr><td>unchecked</td><td>抑制没有进行类型检查操作的警告</td></tr><tr><td>unqualified-field-access</td><td>抑制没有权限访问的域的警告</td></tr><tr><td>unused</td><td>抑制没被使用过的代码的警告</td></tr></tbody></table></li></ul><hr><h4 id="SafeVarargs"><a href="#SafeVarargs" class="headerlink" title="@SafeVarargs "></a><code>@SafeVarargs </code></h4><p>​    官方解释：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">程序员断言带注释的方法或构造函数的主体不会对其 varargs 参数执行潜在的不安全操作。将此注释应用于方法或构造函数会抑制有关不可具体化的变量 arity (vararg) 类型的未经检查的警告，并抑制有关在调用站点创建参数化数组的未经检查的警告。</span><br><span class="line">除了<span class="meta">@Target</span>元注解施加的使用限制外，编译器还需要对该注解类型实施额外的使用限制；如果使用<span class="meta">@SafeVarargs</span>注释对方法或构造函数声明进行注释，则这是编译时错误，并且：</span><br><span class="line">声明是一个固定的arity方法或构造函数</span><br><span class="line">声明是一个既不是<span class="keyword">static</span>也不是<span class="keyword">final</span>的变量 arity 方法。</span><br><span class="line">鼓励编译器在将此注释类型应用于方法或构造函数声明时发出警告，其中：</span><br><span class="line">变量 arity 参数具有可具体化的元素类型，包括原始类型、 Object和String 。 （对于可具体化的元素类型，此注释类型抑制的未经检查的警告已经不会出现。）</span><br><span class="line">方法或构造函数声明的主体执行潜在的不安全操作，例如对变量 arity 参数数组的元素的赋值会生成未经检查的警告。一些不安全的操作不会触发未经检查的警告。例如，别名在</span><br><span class="line">   <span class="meta">@SafeVarargs</span> <span class="comment">// 实际上并不安全！</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(List&lt;String&gt;... stringLists)</span> &#123;</span><br><span class="line">     Object[] array = stringLists;</span><br><span class="line">     List&lt;Integer&gt; tmpList = Arrays.asList(<span class="number">42</span>);</span><br><span class="line">     array[<span class="number">0</span>] = tmpList; <span class="comment">// 语义上无效，但可以编译</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringLists[<span class="number">0</span>].get(<span class="number">0</span>); <span class="comment">// 哦不，运行时的 ClassCastException！</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">在运行时导致ClassCastException 。</span><br><span class="line">该平台的未来版本可能会要求此类不安全操作出现编译器错误。</span><br></pre></td></tr></table></figure><p>在学习<code>@SafeVarargs</code>之前先来看看下面有一段代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        display(<span class="string">&quot;10&quot;</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(T ...array)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (T arg : array)&#123;</span><br><span class="line">            System.out.println(arg.getClass().getName()+<span class="string">&quot;:&quot;</span>+arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这段代码中我设计了一个接收可变参数的方法<code>public static &lt;T&gt; void display(T ...array)&#123;&#125;</code>可变参数方法中的参数类型相同，为此声明参数是需要指定泛型。</p><p>​    但是调用可变参数方法时，应该提供相同类型的参数，但是代码中传入了不同类型的参数集合，此时可以看到display签名处有如下警告</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407213806123.png" alt="image-20220407213806123"></p><p>​    翻译过来就是<code>参数化可变参数类型可能造成的堆污染</code>并且提示添加<code>@SafeVarargs</code>注解（仅仅起一个取消显示的作用，某种方面上来说是和 <code>@SuppressWarnings</code> 作用相同的）。</p><p>​    这个警告是 unchecked（未检查不安全代码），就是因为将非泛型变量赋值给泛型变量所发生的。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407214116091.png" alt="image-20220407214116091"></p><p>​    可以发现加上了<code>@SafeVarargs</code>注解后编译器警告没有显示了，你肯定会说我使用<code>@SuppressWarnings</code>效果也是一样的，效果虽然一样，但是两者相较来说这里使用<code>@SafeVarargs</code>注解更合适</p><p>​    <strong>注意：</strong><code>@SafeVarargs</code>注解<strong>不适用于非 <code>static</code> 或非 <code>final</code> 声明的方法</strong>，对于未声明为 <code>static</code> 或 <code>final</code> 的方法，如果要抑制 <code>unchecked</code> 警告，<strong>可以使用 <code>@SuppressWarnings</code> 注解。</strong></p><hr><h4 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a><code>@FunctionalInterface</code></h4><p>​    官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">一种信息性注解类型，用于指示接口类型声明旨在成为 Java 语言规范定义的功能接口。从概念上讲，函数式接口只有一个抽象方法。由于默认方法有一个实现，它们不是抽象的。如果接口声明了一个覆盖java.lang.Object的公共方法之一的抽象方法，这也不会计入接口的抽象方法计数，因为接口的任何实现都将具有来自java.lang.Object或其他地方的实现(接口的实现是类,所有类的父类都是Object)。</span><br><span class="line">请注意，函数式接口的实例可以使用 lambda 表达式、方法引用或构造函数引用来创建。</span><br><span class="line">如果使用此注解类型对类型进行注解，则编译器需要生成错误消息，除非：</span><br><span class="line">该类型是接口类型，而不是注解类型、枚举或类。</span><br><span class="line">带注解的类型满足功能接口的要求。</span><br><span class="line">但是，无论接口声明中是否存在FunctionalInterface注释，编译器都会将满足功能接口定义的任何接口视为功能接口。</span><br></pre></td></tr></table></figure><p>​    在学习Lambda表达式时，我们了解过函数式接口（接口中只有个一个抽象方法可以存在多个默认方法或多个static方法）。</p><ul><li><p><code>@FunctionalInterface</code>作用就是用来指定某一个接口必须是函数式接口的，所以<code>@FunctionalInterface</code>只能修饰接口。</p></li><li><p>这里我写了两个抽象方法出现了编译器报错</p></li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407214859347.png" alt="image-20220407214859347"></p><ul><li>这里我只写了一个抽象方法 一个static方法和一个默认方法 符合要求没有报错</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407215038533.png" alt="image-20220407215038533"></p><p>​    <strong>注意：</strong>如果接口声明了一个覆盖<code>java.lang.Object</code>的公共方法之一的抽象方法，这也不会计入接口的抽象方法计数</p><p>得出结论：<code>@FunctionalInterface</code>只是告诉编译器去检查这个接口是不是函数式接口，保证该接口只能包含一个抽象方法，否者就会出现编译错误。</p><hr><h2 id="写一个自己的注解"><a href="#写一个自己的注解" class="headerlink" title="写一个自己的注解"></a>写一个自己的注解</h2><p>注解的格式就是</p><blockquote><ul><li>元注解</li><li><code>public @interface 注解名</code></li><li>注解内容体</li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span> <span class="comment">//这里我希望我的注解能够生成在JavaDoc生成的文档中</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span> <span class="comment">//这里我希望我的注解能够在字节码文件中保留</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span> <span class="comment">//这里我希望我的注解可以修饰于类、接口、抽象类和方法上</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123; <span class="comment">//我声明了一个名为MyAnnotation的注解</span></span><br><span class="line">    <span class="comment">//定义带两个成员变量的注解</span></span><br><span class="line">    <span class="comment">//注解中的成员以方法的形式命名（注解的本质是接口） 并且可以带有默认值</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    想要获取注解中的成员变量需要使用反射的知识、首先需要获取类的Class对象，我们就可以通过的这个Class对象反射得到注解的成员变量了。</p><p>​    反射相关的可以参考这篇博客<a href="https://blog.csdn.net/D1842501760/article/details/120714043?spm=1001.2014.3001.5502">反射</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test</span>().testMyAnnotation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="meta">@MyAnnotation(name = &quot;dyw&quot;,age = 20)</span><span class="comment">//这里我们使用了我们刚才自定义的注解</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMyAnnotation</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">        <span class="comment">//这里获取Test类的Class对象 当类被编译后会当jvm加载时会生成该class文件的Class对象 通过这个Class对象可以完成反射相关的操作</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">testMyAnnotation</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getMethod(<span class="string">&quot;testMyAnnotation&quot;</span>);</span><br><span class="line">        <span class="comment">//通过Class对象的getAnnotation()方法反射得到我们的MyAnnotation对象</span></span><br><span class="line">        <span class="type">MyAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> testMyAnnotation.getAnnotation(MyAnnotation.class);</span><br><span class="line">        <span class="comment">//通过该对象可以获取注解类的成员</span></span><br><span class="line">        System.out.println(<span class="string">&quot;name :&quot;</span>+annotation.name());</span><br><span class="line">        System.out.println(<span class="string">&quot;age :&quot;</span>+annotation.age());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220408151357416.png" alt="image-20220408151357416"></p><p>​    这里只介绍了自定义注解类的简单用法，但是却完美展现了注解搭配反射可以碰撞出的巨大火花。熟悉掌握注解与反射后就有一定能力去学习那些大佬开发的框架的底层代码了。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://c.biancheng.net/java/java/135/">Java注解 (biancheng.net)</a></p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/package-summary.html">java.lang.annotation (Java Platform SE 8 ) (oracle.com)</a></p><p><a href="https://juejin.cn/post/6844903776088752141">理解注解中的@Inherited - 掘金 (juejin.cn)</a></p><p><a href="https://blog.csdn.net/qq_34576220/article/details/105731364">java元注解@Native &amp;&amp; @Repeatable （java8 新增）_似火似水的博客-CSDN博客_native注解</a></p><p><a href="%5D(https://blog.csdn.net/qq_34576220/article/details/105731364">反射</a></p><h1 id="END"><a href="#END" class="headerlink" title="-END-"></a>-END-</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Annotation&quot;&gt;&lt;a href=&quot;#Annotation&quot; class=&quot;headerlink&quot; title=&quot;Annotation&quot;&gt;&lt;/a&gt;Annotation&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="JavaSE" scheme="https://devildyw.github.io/categories/JavaSE/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API</title>
    <link href="https://devildyw.github.io/2022/04/06/RESTful%20API/"/>
    <id>https://devildyw.github.io/2022/04/06/RESTful%20API/</id>
    <published>2022-04-06T12:58:54.000Z</published>
    <updated>2022-04-16T08:52:43.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h1><p>正式学习RESTful API之前,我们需要把什么是API搞懂.</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/v2-1564b88f4461d69b90cd1ab50411f61b_b.jpg" alt="查看源图像"></h2><h2 id="什么是API"><a href="#什么是API" class="headerlink" title="什么是API?"></a>什么是API?</h2><p><strong>API（Application Programming Interface）</strong> 翻译过来是应用程序编程接口的意思。</p><p>相信大家对于API这个此已经不陌生了, 比如”我调用了某某的API”等 又比如我们在进行后端开发的时候，主要的工作就是为前端或者其他后端服务提供 API 比如查询用户数据的 API. </p><ul><li><p>API不仅仅代表了后端系统暴露出的接口, 像框架中提供的方法也属于是API的范畴.</p><p>例如: </p><ul><li>你写的程序需要由支付功能,需要微信支付,就需要去调用微信提供支付的相关API</li><li>使用JDK开发Java程序, 需要获取当前系统时间,需要使用JDK提供的Date相关的API</li><li>….</li></ul></li><li><p>API可以理解为程序与程序之间通信的桥梁, 其本质就是一个函数或者一个方法(函数和方法还是不同的)而已. 另外, API的使用也不是没有章法了, 它的相关规则或是使用协议由API的提供者制订.</p></li></ul><hr><h2 id="什么是RESTful-API"><a href="#什么是RESTful-API" class="headerlink" title="什么是RESTful API?"></a>什么是RESTful API?</h2><p><strong>RESTful API</strong> 经常也被叫做 <strong>REST API</strong>，它是基于 REST 构建的 API.</p><p>举个例子，如果我给你下面两个 API 你是不是立马能知道它们是干什么用的！这就是 RESTful API 的强大之处！</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">GET  /XXXX/classes: 查询列出所有班级</span><br><span class="line">POST  /XXXX/classes: 创建一个新的班级</span><br></pre></td></tr></table></figure><ul><li>由上述例子可以看出 RESTful API可以让人很清楚的知道每个API的目的与作用(前提是它有一定的基础 这个似乎不是什么问题).</li><li><strong>RESTful API</strong>可以让人看到URL+Http Method 就知道这个方法是干什么的, 让你看到HTTP状态码(status code)就知道请求结果如何</li></ul><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">http动作(请求方式) + url [动作+url合起来保证唯一性]</span><br></pre></td></tr></table></figure><p>我们在开发过程中设计API时也应当满足RESTful API的最基本要求(RESTful API 不是协议</p><p>规定, 但是提倡这样设计) <strong>接口中尽量使用名词</strong>, 例如<code>GET /notes/id</code>：获取某个指定 id 的笔记的信息）毕竟是使用Http Method(动词)操作的应当是名词才对.</p><h2 id="解读REST-了解内容"><a href="#解读REST-了解内容" class="headerlink" title="解读REST(了解内容)"></a>解读REST(了解内容)</h2><p><strong>REST</strong> 是 <code>REpresentational State Transfer</code> 的缩写。这个词组的翻译过来就是“<strong>表现层状态转化</strong>”。</p><p>实际上 REST 的全称是 <strong>Resource Representational State Transfer</strong> ，直白地翻译过来就是 <strong>“资源”在网络传输中以某种“表现形式”进行“状态转移”</strong> 。</p><ul><li><strong>资源(Resource):</strong> 任何东西都可以是资源, 图片,甚至是对象, 资源可以是一个集合,也可以是一个个体. 每一种资源都有特定的URL(统一资源标识符)与之对应, 如果我们需要访问这个资源只需要访问这个URI就可以访问.</li><li><strong>表现形式(Representational):</strong>“资源”是一个信息实体,它可以有多种外在表现形式.通常我们把资源具体呈现出来的形式有:<code>json</code>、<code>xml</code>、<code>image</code>、<code>txt</code>等等叫做它的**”表现形式”**。</li><li>**状态转移(State Transfer):**指的就是你的行为对于资源的操作(通过HTTP动词实现)引起资源的状态发生了变化.(ps:互联网通讯协议HTTP协议，是一个无状态协议，所有的资源状态都保存在服务器端.)</li></ul><p>综合总结:</p><blockquote><ul><li>每一个URI代表一种资源；</li><li>客户端与服务器之间,传递这种资源的某种表现形式比如<code>json</code>、<code>xml</code>、 <code>txt</code>、 <code>image</code>等；</li><li>客户端通过特定的HTTP动词，对服务器资源进行操作，实现”表现层状态转化”。</li></ul></blockquote><h2 id="RESTful-API-规范"><a href="#RESTful-API-规范" class="headerlink" title="RESTful API 规范"></a>RESTful API 规范</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6db537c4f5274fc098ed9bf710b41cc4~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.awebp" alt="RESTful API 设计规范"></p><p><strong>动作：</strong></p><blockquote><ul><li><strong><code>GET</code>：</strong>请求从服务器获取特定资源。举个例子：<code>GET /classes</code>（获取所有班级）</li><li><strong><code>POST</code> ：</strong>在服务器上创建一个新的资源。举个例子：<code>POST /classes</code>（创建班级）</li><li><strong><code>PUT</code> ：</strong>更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：<code>PUT /classes/12</code>（更新编号为 12 的班级）</li><li><strong><code>DELETE</code> ：</strong>从服务器删除特定的资源。举个例子：<code>DELETE /classes/12</code>（删除编号为 12 的班级）</li><li><code>PATCH</code> ：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，这里就不举例子了。</li></ul></blockquote><p><strong>路劲(接口命名)：</strong></p><p>路劲又称”终点”(endpoint), 表示API的具体网址。实际开发中的常见规范如下：</p><blockquote><ul><li><strong>网址中不能出现动词，只能都是名词，API中的名词也应该使用复数。</strong> 因为REST中的资源往往和数据库中的表相对应，而数据库中的表都是同种记录的”集合”（collection）。<strong>如果API调用并不涉及资源（如登录、运算等操作）可以使用动词。</strong>比如：**<code>GET /sign-login</code>**</li><li><strong>不用大写，建议用中杠<code>-</code>而不用下划线<code>_</code></strong> 。比如：**<code>GET /signLogin</code>**</li><li><strong>善用版本化API。</strong>当我们的API发生了重大改变而不兼容前期版本的时候，我们可以通过URL来实现版本化，比如**<code>/github.com/kataras/iris/v12</code>**。版本不必非要数字，只是数字使用最多，日期、季节都可以作为版本的标识符，项目团队达成共识即可。</li><li><strong>接口尽量使用名词，避免使用名词。</strong>RESTful API操作(HTTP Method)的是资源（名词）而不是动作（动词）。</li></ul></blockquote><p>现在有这样的一个API提供班级大学班级（class）的信息，还包括学生、老师的信息，则应该设计呈现吗这样。</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">GET    /classes：列出所有班级</span><br><span class="line">POST   /classes：新建一个班级</span><br><span class="line">GET   /classes/&#123;classId&#125;:获取某个指定班级的信息</span><br><span class="line">PUT   /classes/&#123;classId&#125;:更新某个指定班级的信息(一般倾向于整体更新)</span><br><span class="line">PATCH  /classes/&#123;classId&#125;：更新某个指定班级的信息（一般倾向部分更新）</span><br><span class="line">GET    /classes/&#123;classId&#125;/teachers：列出某个指定班级的所有老师的信息</span><br><span class="line">GET    /classes/&#123;classId&#125;/students：列出某个指定班级的所有学生的信息</span><br><span class="line">DELETE /classes/&#123;classId&#125;/teachers/&#123;ID&#125;：删除某个指定班级下的指定的老师的信息</span><br></pre></td></tr></table></figure><p><strong>反例:</strong></p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">/getAllclasses</span><br><span class="line">/createNewclass</span><br><span class="line">/deleteAllActiveclasses</span><br></pre></td></tr></table></figure><p>清理资源的层次结构,比如业务针对的范围是学校,那么学校会是一级资源:<code>/schools</code>、老师：<code>/shcools/teachers</code>、学生：<code>/shcools/students</code>就是二级资源。</p><h3 id="信息过滤"><a href="#信息过滤" class="headerlink" title="信息过滤"></a>信息过滤</h3><p>如果我们在查询的时候需要添加特定的条件的话，建议使用url中添加参数的形式。比如我们要查询state状态位active并且name为guideege的班级：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">GET/classes?state=active<span class="built_in">&amp;</span>name=guigege</span><br></pre></td></tr></table></figure><p>如果要实现分页查询：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">GET/classes?page=1<span class="built_in">&amp;</span>size=10 //指定第几页，每页十条数据</span><br></pre></td></tr></table></figure><h3 id="状态码（Status-Codes）"><a href="#状态码（Status-Codes）" class="headerlink" title="状态码（Status Codes）"></a>状态码（Status Codes）</h3><p><strong>状态码范围：</strong></p><table><thead><tr><th>2xx：成功</th><th>3xx：重定向</th><th>4xx：客户端错误</th><th>5xx：服务器错误</th><th></th><th align="right"></th></tr></thead><tbody><tr><td>200 成功</td><td>301 永久重定向</td><td>400 错误请求</td><td>500 服务器错误</td><td></td><td align="right"></td></tr><tr><td>201 创建</td><td>304 资源未修改</td><td>401 未授权</td><td>502 网关错误</td><td></td><td align="right"></td></tr><tr><td></td><td></td><td>403 禁止访问</td><td>504 网关超时</td><td></td><td align="right"></td></tr><tr><td></td><td></td><td>404 未找到</td><td></td><td></td><td align="right"></td></tr><tr><td></td><td></td><td>405 请求方法不对</td><td></td><td></td><td align="right"></td></tr></tbody></table><h2 id="RESTful-的极致-HATEOAS"><a href="#RESTful-的极致-HATEOAS" class="headerlink" title="RESTful 的极致 HATEOAS"></a>RESTful 的极致 HATEOAS</h2><blockquote><p>RESTful的极致是hateoas，但是这个基本不会在实际项目中用到。</p></blockquote><p>在 Spring 中有一个叫做 HATEOAS 的 API 库，通过它我们可以更轻松的创建出符合 HATEOAS 设计的 API。相关文章(可以参考)：</p><ul><li><a href="https://blog.aisensiy.me/2017/06/04/spring-boot-and-hateoas/">在 Spring Boot 中使用 HATEOASopen in new window</a></li><li><a href="https://spring.io/guides/tutorials/rest/">Building REST services with Springopen in new window</a> (Spring 官网 )</li><li><a href="https://www.baeldung.com/spring-hateoas-tutorial">An Intro to Spring HATEOASopen in new window</a></li><li><a href="https://github.com/spring-projects/spring-hateoas-examples/tree/master/hypermedia">spring-hateoas-examplesopen in new window</a></li><li><a href="https://spring.io/projects/spring-hateoas#learn">Spring HATEOASopen in new window</a> (Spring 官网)</li></ul><p>参考：</p><blockquote><p><a href="https://javaguide.cn/system-design/basis/RESTfulAPI.html#%E4%BD%95%E4%B8%BA-api">RestFul API | JavaGuide</a></p></blockquote><h1 id="END"><a href="#END" class="headerlink" title="-END-"></a>-END-</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RESTful-API&quot;&gt;&lt;a href=&quot;#RESTful-API&quot; class=&quot;headerlink&quot; title=&quot;RESTful API&quot;&gt;&lt;/a&gt;RESTful API&lt;/h1&gt;&lt;p&gt;正式学习RESTful API之前,我们需要把什么是API搞懂.&lt;/</summary>
      
    
    
    
    <category term="开发规范" scheme="https://devildyw.github.io/categories/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="Developer" scheme="https://devildyw.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>雪花算法</title>
    <link href="https://devildyw.github.io/2022/04/04/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/"/>
    <id>https://devildyw.github.io/2022/04/04/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-04T09:34:54.000Z</published>
    <updated>2022-04-06T13:52:37.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h1><p><strong>简介:</strong></p><ul><li>雪花算法是Twitter开源的分布式ID生成算法 <a href="https://github.com/twitter-archive/snowflake.git">Github仓库地址</a></li><li>雪花算法主要用于分布式系统中,数据库的ID生成</li><li>在自然界中并不存在两片完全一样的雪花,每一片雪花都拥有自己漂亮独特的形状,独一无二.雪花算法也表示生成的分布式id如雪花般独一无二.</li></ul><span id="more"></span><h2 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h2><p>随着业务被使用的人越来越多, 单机的数据库已经很难保证业务能够流畅稳定的运行了, 这是我们需要对数据库进行分库分表存储, 使用分布式集群, 但是这样每个表的数据怎么保证ID唯一呢? 如果使用主键递增肯定发生ID不唯一的冲突情况, 所以急需一种可以生成全局唯一ID的算法来解决这个囧境.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/v2-6d694779c7d47e3573939f21993318df_720w.jpg" alt="img"></p><hr><h3 id="分布式ID需要满足的要求"><a href="#分布式ID需要满足的要求" class="headerlink" title="分布式ID需要满足的要求"></a><strong>分布式ID需要满足的要求</strong></h3><h4 id="全局唯一"><a href="#全局唯一" class="headerlink" title="全局唯一:"></a>全局唯一:</h4><ul><li>这是最基本的要求</li></ul><h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能:"></a>高性能:</h4><ul><li>不能为了全局唯一就去生成一大长串,肯定需要考虑性能,既要考虑生成的效率,又要考虑查询的效率(即存储的效率).</li></ul><h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用:"></a>高可用:</h4><ul><li>生成分布式ID的服务要保证可用性高,无限接近100%</li></ul><h4 id="方便易用"><a href="#方便易用" class="headerlink" title="方便易用:"></a>方便易用:</h4><ul><li>拿来即用，使用方便，快速接入！</li></ul><hr><h4 id="安全"><a href="#安全" class="headerlink" title="安全:"></a>安全:</h4><ul><li>分布式ID中不应含有敏感信息,否则了解算法的不怀好意之人解码可能会获取到这些敏感信息.</li></ul><h4 id="有序递增"><a href="#有序递增" class="headerlink" title="有序递增:"></a>有序递增:</h4><ul><li>如果要把 ID 存放在数据库的话，<strong>ID 的有序性可以提升数据库写入速度</strong>。并且，很多时候 ，我们还很有可能会直接通过 ID 来进行排序。</li></ul><h4 id="要求具体的业务含义"><a href="#要求具体的业务含义" class="headerlink" title="要求具体的业务含义:"></a>要求具体的业务含义:</h4><ul><li>生成的ID如果能有具体的业务含义,可以让定位问题以及开发更透明化(例如根据ID就能确定是哪个业务)</li></ul><h4 id="独立部署"><a href="#独立部署" class="headerlink" title="独立部署:"></a>独立部署:</h4><ul><li>也就是分布式系统单独有一个发号器服务，专门用来生成分布式 ID。这样就生成 ID 的服务可以和业务相关的服务解耦。不过，这样同样带来了网络调用消耗增加的问题。总的来说，如果需要用到分布式 ID 的场景比较多的话，独立部署的发号器服务还是很有必要的。(企业级的大型项目中十分有必要)</li></ul><hr><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>雪花算法生成的ID是一个<strong>64bit</strong>的<strong>long</strong>型的数字且<strong>按时间趋势递增</strong>.大致有首位符号位(无效位), 时间戳插值, 机器编码, 序列号四部分组成.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/22531124-e47b04a4e5b26623.png" alt="img"></p><p>如图: </p><ul><li><strong>首位无效符:</strong> 主要用做为符号位,因为一般都是生成正数,所以符号位统一都是0</li><li>**时间戳:**占用41bit,精确到毫秒. 41bit位最好可以表示2^41-1毫秒, 转化成单位年为69年.</li><li><strong>机器编码:</strong> 占用10bit,其中高位5bit是数据中心ID,低位5bit是工作节点ID,最多可以容纳1024个节点.</li><li>**序列号:**占用12bit,每个节点每毫秒0开始不断累加,最多可以累加到2^12-1,一共可以生成4096个ID(包括了0)</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a><strong>Java代码实现</strong></h3><p><code>snowFlake</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dyw.snowFlake;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-04-04 14:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDWorker</span> &#123;</span><br><span class="line">    <span class="comment">//十位的工作机器码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> workerId; <span class="comment">//工作id 五位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> datacenterId; <span class="comment">//数据中心id 五位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//12位序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">sequence</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">twEpoch</span> <span class="operator">=</span> <span class="number">1288834974657L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//长度为5位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">workerIdBits</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">datacenterIdBits</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line">    <span class="comment">//最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">maxWorkerId</span> <span class="operator">=</span> ~(-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">maxDatacenterId</span> <span class="operator">=</span> ~(-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列号id长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">sequenceBits</span> <span class="operator">=</span> <span class="number">12L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">sequenceMask</span> <span class="operator">=</span> ~(-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//工作id需要左移的位数, 12位(序列号的位长)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">workerIdShift</span> <span class="operator">=</span> sequenceBits;</span><br><span class="line">    <span class="comment">//数据中心id需要左移的位数 序列号长+工作id长</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">datacenterIdShift</span> <span class="operator">=</span> sequenceBits + workerIdBits;</span><br><span class="line">    <span class="comment">//时间戳左移位数 = 序列号长+工作id长+工作位长</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">timestampLeftShift</span> <span class="operator">=</span> sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上次时间戳, 初始值位负值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastTimestamp</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workerId 工作节点id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> datacenterId 数据中心id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IDWorker</span><span class="params">(<span class="type">long</span> workerId, <span class="type">long</span> datacenterId)</span> &#123;</span><br><span class="line">        <span class="comment">//检查参数的合法性</span></span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;</span>,</span><br><span class="line">                timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId);</span><br><span class="line">        <span class="built_in">this</span>.workerId = workerId;</span><br><span class="line">        <span class="built_in">this</span>.datacenterId = datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getWorkerId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> workerId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDatacenterId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getSequence</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * //下一个ID生成算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> snowflakeId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//先获取当前系统时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> timeGen();</span><br><span class="line">        <span class="comment">//如果当前系统时间比上次获取id时间戳小就抛出异常 时钟往后移动可能会出现同样id所以这里必须抛异常结束执行</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            System.err.printf(<span class="string">&quot;clock is moving backwards.  Rejecting requests until %d.&quot;</span>,lastTimestamp);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(String.format(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>,</span><br><span class="line">                    lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前时间戳如果等于上次时间戳(同一毫秒内),则在序列号加一,否则序列号赋值为0, 从零开始</span></span><br><span class="line">        <span class="keyword">if</span>(timestamp==lastTimestamp)&#123;</span><br><span class="line">            <span class="comment">//这是使用&amp;sequenceMask是为了防止sequence溢出12位(前面要求了sequence的长度只能是12位)</span></span><br><span class="line">            sequence = (sequence+<span class="number">1</span>)&amp;sequenceMask;</span><br><span class="line">            <span class="comment">//如果防止刚好移除经过&amp;sequenceMask后 会变成0 可能会发生重复的情况</span></span><br><span class="line">            <span class="comment">//所以此时需要再次获取时间戳,并于上次时间戳作比较 直到与上次时间戳不一致返回当前时间戳避免重复</span></span><br><span class="line">            <span class="keyword">if</span>(sequence==<span class="number">0</span>)&#123;</span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//如果不在同一个时间戳中 代表该序列刚开始计数所以初始为0</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sequence = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将上次时间戳值更新</span></span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 返回结果：</span></span><br><span class="line"><span class="comment">         * (timestamp - TwEpoch) &lt;&lt; timestampLeftShift) 表示将时间戳减去初始时间戳，再左移相应位数</span></span><br><span class="line"><span class="comment">         * (datacenterId &lt;&lt; datacenterIdShift) 表示将数据id左移相应位数</span></span><br><span class="line"><span class="comment">         * (workerId &lt;&lt; workerIdShift) 表示将工作id左移相应位数</span></span><br><span class="line"><span class="comment">         * | 是按位或运算符，例如：x | y，只有当x，y都为0的时候结果才为0，其它情况结果都为1。</span></span><br><span class="line"><span class="comment">         * 因为个部分只有相应位上的值有意义，其它位上都是0，所以将各部分的值进行 | 运算就能得到最终拼接好的id</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - twEpoch)&lt;&lt;timestampLeftShift) |</span><br><span class="line">                (datacenterId&lt;&lt;datacenterIdShift) |</span><br><span class="line">                (workerId&lt;&lt;workerIdShift)|</span><br><span class="line">                sequence;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取时间戳,并于上次时间戳作比较</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastTimestamp 上一次获取的时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> timestamp 更新后的系统时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">tilNextMillis</span><span class="params">(<span class="type">long</span> lastTimestamp)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> timeGen();</span><br><span class="line">        <span class="keyword">while</span>(timestamp&lt;=lastTimestamp)&#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取系统时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 系统时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">timeGen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Go语言实现"><a href="#Go语言实现" class="headerlink" title="Go语言实现"></a><strong>Go语言实现</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> al</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutex = sync.Mutex&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">//初始时间戳</span></span><br><span class="line">twEpoch <span class="type">int64</span> = <span class="number">1288834974657</span></span><br><span class="line"><span class="comment">//长度为5位</span></span><br><span class="line">workerIdBits     <span class="type">int64</span> = <span class="number">5</span></span><br><span class="line">datacenterIdBits <span class="type">int64</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最大值</span></span><br><span class="line">maxWorkerId     <span class="type">int64</span> = <span class="number">-1</span> ^ (<span class="number">-1</span> &lt;&lt; workerIdBits)</span><br><span class="line">maxDatacenterId <span class="type">int64</span> = <span class="number">-1</span> ^ (<span class="number">-1</span> &lt;&lt; datacenterIdBits)</span><br><span class="line"></span><br><span class="line"><span class="comment">//序列号id长度</span></span><br><span class="line">sequenceBits <span class="type">int64</span> = <span class="number">12</span></span><br><span class="line">sequenceMask       = <span class="number">-1</span> ^ (<span class="number">-1</span> &lt;&lt; sequenceBits)</span><br><span class="line"></span><br><span class="line"><span class="comment">//工作id需要左移的位数, 12位(序列号的位长)</span></span><br><span class="line">workerIdShift = sequenceBits</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据中心id需要左移的位数 序列号长+工作id长</span></span><br><span class="line">datacenterIdShift = sequenceBits + workerIdBits</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间戳左移位数 = 序列号长+工作id长+工作位长</span></span><br><span class="line">timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//上次时间戳, 初始值位负值</span></span><br><span class="line"><span class="keyword">var</span> lastTimestamp <span class="type">int64</span> = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IDWorker <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//十位的工作机器码</span></span><br><span class="line">workerId     <span class="type">int64</span> <span class="comment">//工作id 五位</span></span><br><span class="line">datacenterId <span class="type">int64</span> <span class="comment">//数据中心id 五位</span></span><br><span class="line"><span class="comment">//12位序列号</span></span><br><span class="line">sequence <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitIDWorker</span><span class="params">(workerId, datacenterId <span class="type">int64</span>)</span></span> (*IDWorker, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">//检查参数合法性</span></span><br><span class="line"><span class="keyword">if</span> workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">var</span> err = errors.New(fmt.Sprintf(<span class="string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">var</span> err = errors.New(fmt.Sprintf(<span class="string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;</span>,</span><br><span class="line">timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId)</span><br><span class="line"><span class="keyword">return</span> &amp;IDWorker&#123;</span><br><span class="line">datacenterId: datacenterId,</span><br><span class="line">workerId:     workerId,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">下一个ID生成算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *IDWorker)</span></span> NextId() (id <span class="type">int64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">//上锁</span></span><br><span class="line">mutex.Lock()</span><br><span class="line"><span class="comment">//程序结束 释放锁</span></span><br><span class="line"><span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line"><span class="comment">//先获取当前系统时间</span></span><br><span class="line"><span class="keyword">var</span> timestamp = timeGen()</span><br><span class="line"><span class="comment">//如果当前系统时间比上次获取id时间戳小就抛出异常 时钟往后移动可能会出现同样id所以这里必须抛异常结束执行</span></span><br><span class="line"><span class="keyword">if</span> timestamp &lt; lastTimestamp &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;clock is moving backwards.  Rejecting requests until %d.&quot;</span>, lastTimestamp)</span><br><span class="line">err = errors.New(fmt.Sprintf(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>,</span><br><span class="line">lastTimestamp-timestamp))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取当前时间戳如果等于上次时间戳(同一毫秒内),则在序列号加一,否则序列号赋值为0, 从零开始</span></span><br><span class="line"><span class="keyword">if</span> timestamp == lastTimestamp &#123;</span><br><span class="line"><span class="comment">//这是使用&amp;sequenceMask是为了防止sequence溢出12位(前面要求了sequence的长度只能是12位)</span></span><br><span class="line">i.sequence = (i.sequence + <span class="number">1</span>) &amp; sequenceMask</span><br><span class="line"><span class="comment">//如果防止刚好移除经过&amp;sequenceMask后 会变成0 可能会发生重复的情况</span></span><br><span class="line"><span class="comment">//所以此时需要再次获取时间戳,并于上次时间戳作比较 直到与上次时间戳不一致返回当前时间戳避免重复</span></span><br><span class="line"><span class="keyword">if</span> i.sequence == <span class="number">0</span> &#123;</span><br><span class="line">timestamp = tilNextMillis(lastTimestamp)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果不在同一个时间戳中 代表该序列刚开始计数所以初始为0</span></span><br><span class="line">i.sequence = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将上次时间戳值更新</span></span><br><span class="line">lastTimestamp = timestamp</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回雪花算法生成的id</span></span><br><span class="line">id = ((timestamp - twEpoch) &lt;&lt; timestampLeftShift) |</span><br><span class="line">(i.datacenterId &lt;&lt; datacenterIdShift) |</span><br><span class="line">(i.workerId &lt;&lt; workerIdShift) |</span><br><span class="line">i.sequence</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i IDWorker)</span></span> WorkerId() <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i.workerId</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i IDWorker)</span></span> DatacenterId() <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i.datacenterId</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i IDWorker)</span></span> Sequence() <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i.sequence</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取系统时间戳</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeGen</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> time.Now().UnixMilli()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取时间戳,并于上次时间戳作比较</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tilNextMillis</span><span class="params">(lastTimestamp <span class="type">int64</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">var</span> timestamp = timeGen()</span><br><span class="line"><span class="keyword">for</span> timestamp &lt;= lastTimestamp &#123;</span><br><span class="line">timestamp = timeGen()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> timestamp</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;雪花算法&quot;&gt;&lt;a href=&quot;#雪花算法&quot; class=&quot;headerlink&quot; title=&quot;雪花算法&quot;&gt;&lt;/a&gt;雪花算法&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;简介:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;雪花算法是Twitter开源的分布式ID生成算法 &lt;a href=&quot;https://github.com/twitter-archive/snowflake.git&quot;&gt;Github仓库地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;雪花算法主要用于分布式系统中,数据库的ID生成&lt;/li&gt;
&lt;li&gt;在自然界中并不存在两片完全一样的雪花,每一片雪花都拥有自己漂亮独特的形状,独一无二.雪花算法也表示生成的分布式id如雪花般独一无二.&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://devildyw.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="算法" scheme="https://devildyw.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://devildyw.github.io/2022/03/28/Redis/"/>
    <id>https://devildyw.github.io/2022/03/28/Redis/</id>
    <published>2022-03-28T12:58:54.000Z</published>
    <updated>2022-04-09T09:49:02.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><a href="https://www.bilibili.com/video/BV1cr4y1671t?p=63&spm_id_from=pageDriver">Redis</a></h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p><strong>Redis是一种NOSQL型数据库,即一种非关系型数据库</strong></p><p>我们常见的Mysql是一种SQL型数据库,是一种关系型数据库</p><span id="more"></span><h3 id="SQL型数据库"><a href="#SQL型数据库" class="headerlink" title="SQL型数据库"></a><strong>SQL型数据库</strong></h3><h4 id="结构化-Structured"><a href="#结构化-Structured" class="headerlink" title="结构化 Structured"></a>结构化 <strong>Structured</strong></h4><ul><li>下面这张图,我们创建这张表之初就对表的字段做了指定与规定,比如下面这张表只有三个字段,每个字段我们都加上了不同的约束,并且规定了字段的类型和长度,就使得这张表具有很强的结构体系,后续插入修改的数据都必须遵守表的结构</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307174510020.png" alt="image-20220307174510020"></p><h4 id="关联的-Relational"><a href="#关联的-Relational" class="headerlink" title="关联的(Relational)"></a>关联的(Relational)</h4><ul><li><p>比如一个表中的某个字段被其他表中的字段所关联(外键) 这样表中的数据就会自动维护,当删除某个字段时,就会提示无法删除的情况,除此之外,关联的优点还有可以节省存储空间,不需要记录数据的全部信息,只需要记录一个数据的主键即可.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307175758165.png" alt="image-20220307175758165"></p><h4 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h4><ul><li><p>优点:语法固定</p></li><li><p>缺点:需要去学习大量的语法 </p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307180551365.png" alt="image-20220307180551365"></p></li></ul><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><ul><li><strong>满足ACID(原子性, 一致性, 隔离性, 持久性) 对关系性要求较高的业务采用SQL</strong></li></ul><h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><ul><li><strong>磁盘</strong></li></ul><h4 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h4><ul><li><strong>垂直</strong>(即一主多从 数据存储的大小没有改变 只是增强了数据的存储效率(读写分离))</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>数据结构稳定</li><li>相关业务对数据安全性,一致性较高.(ACID)</li></ul><hr></li></ul><h3 id="NOSQL"><a href="#NOSQL" class="headerlink" title="NOSQL"></a><strong>NOSQL</strong></h3><h4 id="非结构化"><a href="#非结构化" class="headerlink" title="非结构化"></a>非结构化</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307174959275.png" alt="image-20220307174959275"></p><ul><li>NoSQL有三种数据存储格式 分别为<strong>key-value型, Document型, 还有Graph型</strong> 没有SQL那种有很强的结构性 比如<strong>key-value型的存储格式中</strong> 不需要指定数据的类型, 只要是NoSQL支持的数据格式 都可以填入. 对于<strong>Document型中 数据的字段数量也可以不同可以任意增添数据字段</strong> 不需要上一条数据有四个字段 这次就可以只有三种</li></ul><h4 id="无关系的"><a href="#无关系的" class="headerlink" title="无关系的"></a>无关系的</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307175732140.png" alt="image-20220307175732140"></p><ul><li>一般通过json(Document)的形式存储,缺点就是这种的数据格式不能自己维护,需要程序员自己通过业务逻辑维护 ,并且可能会出现数据的冗余,比如同一个商品多个用户下单,多个用户的信息的存储中都有相同的订单数据,这需要程序员自己根据不同的业务逻辑来维护.</li></ul><h4 id="非SQL"><a href="#非SQL" class="headerlink" title="非SQL"></a>非SQL</h4><ul><li><p>优点: 不需要去学习大量的语法</p></li><li><p>缺点: 不同的NoSQL语句的格式用法可能不同</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307180601578.png" alt="image-20220307180601578"></p><h4 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h4><ul><li><strong>BASE(基本一致或者无事务 无法完全满足ACID) 业务对安全性要求较低的可以采用NoSQL</strong></li></ul><h4 id="存储方式-1"><a href="#存储方式-1" class="headerlink" title="存储方式"></a>存储方式</h4><ul><li><strong>内存</strong></li></ul><h4 id="扩展性-1"><a href="#扩展性-1" class="headerlink" title="扩展性"></a>扩展性</h4><ul><li><strong>水平</strong>(即多主多从 数据存储的大小增加 也增强了数据的存储效率(读写分离))</li></ul><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>数据结构不稳定</li><li>对一致性,安全性要求不高</li><li>对性能要求高</li></ul><hr><h2 id="认识Redis"><a href="#认识Redis" class="headerlink" title="认识Redis"></a><strong>认识Redis</strong></h2><p>Redis诞生与2009年全程时<strong>Remote Dictionary Server(远程词典服务器)</strong>,是一个基于内存的键值型NoSQL数据库.</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a><strong>特征</strong></h3></li><li><p>键值型(key-value)型, value支持多种不同的数据类型,功能丰富</p></li><li><p>单线程,每个命令具有原子性</p></li><li><p>低延迟,速度快(<strong>基于内存</strong>,IO多路复用,良好的编码)</p></li><li><p>支持数据持久化(持久化到磁盘)</p></li><li><p>支持主从集群,分片集群(将数据分部分存储到多个master中 增加数据存储的上限)</p></li><li><p>支持多语言客户端</p></li></ul><hr><h2 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a><strong>Redis常见命令</strong></h2><h3 id="Redis数据结构介绍"><a href="#Redis数据结构介绍" class="headerlink" title="Redis数据结构介绍"></a><strong>Redis数据结构介绍</strong></h3><p>Redis是一个key-value的数据库,key一般是String类型,不过value的类型多种多样</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307191247016.png" alt="image-20220307191247016"></p><p>基本类型: String, Hash, List, Set. SortedSet</p><p>特殊类型: GEO(主要用于存储地理位置信息), BitMap, HyperLog(用来做基数统计的算法), Stream(主要用于消息队列)</p><h3 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a><a href="http://www.redis.cn/commands.html"><strong>Redis通用命令</strong></a></h3><p>通用指令是部分数据类型的,都可以使用的指令,常见的有 用法详情可以官网查看:</p><ul><li><strong>keys</strong>:查看符合模板的所有key,不建议在生产设备上使用(因为Redis是单线程的 使用keys *命令查看会占用很大资源 导致线程堵塞)</li><li>DEL: 删除可以删除一个或多个key (del key1 key2)</li><li>EXISTS: 判断key是否存在</li><li>EXPIRE: 给一个key设置有效期,有效期到时该key会被自动删除</li><li>TTL: 查看一个key剩余有效期</li></ul><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a><strong>String类型</strong></h3><p>String类型,也就是字符串类型,是Redis中最简单的存储类型.</p><p>其value是字符串,不过根据字符串的格式不同,又可以分为3类</p><ul><li>String:普通字符串</li><li>int: 整数类型,可以做自增,自减操作</li><li>float: 浮点类型,可以做自增,自减操作</li></ul><p>不管是哪种格式,底层都是字节数组形式存储,只不过是编码方式不同,字符串类型的最大的空间不能超过512m(可以存储图片 只需要将图片转为字节数组的格式存储 但这样会耗很大空间 一般不这样用)</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220308233257985.png" alt="img">&#x2F;image-20220308233257985.png</p><h4 id="String类型的常见指令"><a href="#String类型的常见指令" class="headerlink" title="String类型的常见指令"></a>String类型的常见指令</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220308233444257.png" alt="image-20220308233444257"></p><p><strong>SETEX</strong>用法比较特殊: <strong><code>set name jack ex 20(存活时间 单位秒)</code></strong></p><h3 id="key的结构"><a href="#key的结构" class="headerlink" title="key的结构"></a><strong>key的结构</strong></h3><p>Redis的key允许有多个单词形成<strong>层级结构</strong>,多个单词之间用**<code>&#39;:&#39;</code>**隔开,格式如下:</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220308235659340.png" alt="image-20220308235659340"></p><p>这个格式并非固定,也可以根据自己的需求来删除或添加词条</p><p>例如 一个项目下有user和product两种不同类型的数据,我们可以这样定义key:</p><ul><li>user相关的key: project:user:1</li><li>product相关的key: project:producet:1</li></ul><p>这样的格式实际上是以层级结构的形式存储的**(主要是为了区分不同项目中相同的数据 用户的id可以为1 商品的id也可以为1)**</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309000908161.png" alt="image-20220309000908161"></p><p>如果value是一个java对象,例如要给User对象,则可以将对象序列化为JSON字符串后存储</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220308235948333.png" alt="image-20220308235948333"></p><p>​                    <strong><code>set project:user:1 &#39;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;ding&quot;&#125;&#39;</code></strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309000302102.png" alt="image-20220309000302102"></p><hr><h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a><strong>Hash类型</strong></h3><p>Hash类型,也叫散列,其value是一个无序字典,类似于java中的HashMap结构.</p><p>String结构是将对象序列化为JSON字符串后存储,当需要修改对象某个字段时很不方便:</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309191057489.png" alt="image-20220309191057489"></p><p>Hash结构可以将对象中的每个字段独立存储,可以针对单个字段做CRUD: 相对于String类型较为灵活</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309191148786.png" alt="image-20220309191148786"></p><h4 id="Hash类型的常见命令"><a href="#Hash类型的常见命令" class="headerlink" title="Hash类型的常见命令:"></a>Hash类型的常见命令:</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309191557981.png" alt="image-20220309191557981"></p><hr><h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a><strong>List类型</strong></h3><p>Redis中的List类型于Java中的LinkedList类似,可以看作是一个双向链表结构.既可以支持正向检索也可以支持反向检索.</p><p>特征也与LinkedList类似</p><ul><li><strong>有序</strong></li><li><strong>元素可以重复</strong></li><li><strong>插入和删除块</strong></li><li><strong>查询速度一般</strong></li></ul><p>常用来存储一个有序数据,例如:朋友圈点赞列表,批量列表等.</p><h4 id="List的常见命令"><a href="#List的常见命令" class="headerlink" title="List的常见命令"></a>List的常见命令</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309194126739.png" alt="image-20220309194126739"></p><hr><h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a><strong>Set类型</strong></h3><p>Redis的Set结构与Java的中HashSet类似,可以看做是一个value为null的HashMap.因为也是一个Hash表,因此具备与HashSet类似的特征</p><ul><li><strong>无序</strong></li><li><strong>元素不可重复</strong></li><li><strong>查找块</strong></li><li><strong>支持交集 并集 差集等功能</strong></li></ul><h4 id="Set类型的常见命令"><a href="#Set类型的常见命令" class="headerlink" title="Set类型的常见命令"></a><strong>Set类型的常见命令</strong></h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309195325392.png" alt="image-20220309195325392"></p><hr><h3 id="SortedSet类型-有序集合"><a href="#SortedSet类型-有序集合" class="headerlink" title="SortedSet类型(有序集合)"></a><strong>SortedSet类型(有序集合)</strong></h3><p>Redis的SortedSet是一个可排序的set集合,与Java中的TreeSet有些类似,但底层数据结构却差别很大.SortedSet中的每一个元素都带有一个score属性,可以基于score属性对元素排序,底层的实现是一个跳表(SkipList)加hash表.SortedSet具备下列特性:</p><ul><li><strong>可排序</strong></li><li><strong>元素不重复</strong></li><li><strong>查询速度快</strong></li></ul><p>因为SortedSet的可排序特性,经常被用来实现排行榜这样的功能</p><h4 id="SortedSet类型的常见命令"><a href="#SortedSet类型的常见命令" class="headerlink" title="SortedSet类型的常见命令"></a>SortedSet类型的常见命令</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309201610780.png" alt="image-20220309201610780"></p><h2 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a><strong>Redis的Java客户端</strong></h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309203536114.png" alt="image-20220309203536114"></p><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a><strong>Jedis</strong></h3><ul><li><p><strong>创建Maven工程</strong></p></li><li><p><strong>引入Jedis依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>建立连接</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@BeforeEach</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//建立连接</span></span><br><span class="line">       jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;81.68.186.20&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">       <span class="comment">//设置密码</span></span><br><span class="line">       jedis.auth(<span class="string">&quot;ffdd2021@&quot;</span>);</span><br><span class="line">       <span class="comment">//选择库</span></span><br><span class="line">       jedis.select(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>存取数据</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//存入数据</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;12&quot;</span>);</span><br><span class="line">       System.out.println(name);</span><br><span class="line">       <span class="comment">//获取数据</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">       System.out.println(name1);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//插入hash数据</span></span><br><span class="line">       <span class="type">long</span> <span class="variable">name</span> <span class="operator">=</span> jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">       System.out.println(name);</span><br><span class="line">       <span class="comment">//取出</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> jedis.hget(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">       System.out.println(name1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>关闭连接</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//关闭连接</span></span><br><span class="line">       <span class="keyword">if</span>(jedis!=<span class="literal">null</span>)&#123;</span><br><span class="line">           jedis.close();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>Jedis中数据的存储命令是与命令行一致的</strong></p><hr></li></ul></li></ul><h4 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h4><p>Jedis本身是线程不安全的,并且频繁的创建和销毁连接会有性能损耗,因此我们推荐大家使用Jedis连接池代替Jedis直连的方式.</p><p>类似SQL型的数据库连接池 不会直接关闭连接而是归还到连接池</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        <span class="comment">//连接总数</span></span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//最大连接数量</span></span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//最小连接数量</span></span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//最大等待时间</span></span><br><span class="line">        jedisPoolConfig.setMaxWait(Duration.ofMillis(<span class="number">10000</span>));</span><br><span class="line">        <span class="comment">//创建连接池对象</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jedisPoolConfig,<span class="string">&quot;81.68.186.20&quot;</span>,<span class="number">6379</span>,<span class="number">1000</span>,<span class="string">&quot;ffdd2021@&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个获取连接的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a><a href="https://spring.io/projects/spring-data-redis"><strong>SpringDataRedis</strong></a></h3><p>SpringData是Spring中数据操作的模板,包含对各种数据库的集成,其中对Redis的集成模板就叫做SpringDataRedis </p><ul><li><strong>提供了对不同Redis客户端的整合(Lettuce和Jedis)</strong></li><li><strong>提供了RedisTemplate统一API来操作Redis</strong></li><li><strong>支持Redis的发布订阅模型</strong></li><li><strong>支持Redis哨兵和Redis集群</strong></li><li><strong>支持基于Lettuce的响应式编程</strong></li><li><strong>支持JDK,JSON,字符串,Spring对象的数据序列化及反序列化</strong>(方便地将上述数据格式 转化为字节数组 更方便地去存储在Redis中)</li><li><strong>支持基于Redis的JDKCollection实现</strong></li></ul><p>SpringDataRedis中提供了RedisTemplate工具类,其中封装了各种对Redis的操作.并且将不同数据类型的操作API封装到了不同的类型中:</p><h4 id="RedisTemplate工具类"><a href="#RedisTemplate工具类" class="headerlink" title="RedisTemplate工具类"></a>RedisTemplate工具类</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309234553190.png" alt="image-20220309234553190"></p><h4 id="RedisTemplate使用"><a href="#RedisTemplate使用" class="headerlink" title="RedisTemplate使用"></a>RedisTemplate使用</h4><ul><li><p>导入依赖</p><ul><li><p>SpringDataRedis依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>连接池依赖(Jedis和Lettuce都是依赖于commons-pool2实现)</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置文件</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">81.68</span><span class="number">.186</span><span class="number">.20</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">ffdd2021@</span></span><br><span class="line">    <span class="comment"># 选择数据库 database: 1</span></span><br><span class="line">    <span class="comment"># pool SpringDataRedis默认使用的客户端是Lettuce 可以导入其他依赖来使用其他连接池</span></span><br><span class="line">    <span class="comment"># 必须要配置了连接池 连接池才能生效</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br></pre></td></tr></table></figure></li><li><p>注入RedisTemplate工具类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Redis01RedisTemplateApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;丁杨维&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310000959983.png" alt="image-20220310000959983"></p></li></ul><h4 id="SpringDataRedis的序列化方式"><a href="#SpringDataRedis的序列化方式" class="headerlink" title="SpringDataRedis的序列化方式"></a>SpringDataRedis的序列化方式</h4><p>RedisTemplate可以接收任意Object作为值写入Redis,只不过吸入人前会把Object序列化为字节形式,默认是采用的JDK序列化,得到的结果是这样的:(及使用RedisTemplate时没有指定泛型)</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220310185259667.png" alt="image-20220310185259667"></p><p><strong>缺点:</strong></p><ul><li><strong>可读性差</strong></li><li><strong>内存占用较大</strong></li></ul><hr><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h4><ul><li><p>如果key-value都是String类型 直接指定泛型为String即可 但如果value或者key为Object时就需要自己配置了.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310190944166.png" alt="image-20220310190944166"></p><p>Redis提供了设置key-value序列化方式的接口</p></li><li><p>首先导入Jackson的依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>最新版<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置类 <code>RedisConfig</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">//创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String,Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//创建JSON序列化工具  注意这里使用的时Jackson需要导入Jackson的相关依赖才行</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">genericJackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">//设置key的序列化</span></span><br><span class="line">        template.setKeySerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashKeySerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//设置value的序列化</span></span><br><span class="line">        template.setValueSerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实体类 <code>User</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Redis01RedisTemplateApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,Object&gt; redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;丁杨维&quot;</span>, <span class="number">19</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;user1&quot;</span>,user);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1=&quot;</span>+user1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310191828636.png" alt="image-20220310191828636"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310191838617.png" alt="image-20220310191838617"></p><p>通过配置使用了Jackson序列化对象对JSON字符串格式存储,在取出时也可以将JSON字符串反系列化为对象.</p><hr><h4 id="JSON序列化的问题"><a href="#JSON序列化的问题" class="headerlink" title="JSON序列化的问题"></a>JSON序列化的问题</h4><p>如上图 我们会发现使用JSON序列化存储value时,会默认带上全类名名称 这样会造成额外的内存开销. (<strong>为了在反序列化时知道对象的类型,JSON序列化器会将类的class类型写入json结果中,存入Redis.</strong> )而如果想使用JSON序列化器序列化对象,这一步又是必不可少的.</p><p><strong>解决方案:</strong></p><ul><li>为了节省内存空间, 我们并不会使用JSON序列化器来处理value, <strong>而是统一使用String序列化器</strong>, 要求只能存储String类型的Key和value. <strong>当需要存储Java对象时, 手动完成对象的序列化和反序列化</strong>.</li><li>Spring默认提供了一个StringRedisTemplate类,他的key和value的序列化方式默认就是String方式.省去了我们自定义RedisTemplate的过程.</li></ul><hr><h4 id="StringRedisTemplate类"><a href="#StringRedisTemplate类" class="headerlink" title="StringRedisTemplate类"></a>StringRedisTemplate类</h4><ul><li><p>Jackson的ObjectMapper提供了将Java对象序列化为Json字符串和反序列化为Java对象的API</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Redis01RedisTemplateApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTest</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;彭芳姐&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ObjectMapper提供了将对象转化为Json串的API</span></span><br><span class="line">        <span class="comment">//手动序列化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userString</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user2&quot;</span>,userString);</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动反序列化</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> mapper.readValue(userJson, User.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310194423995.png" alt="image-20220310194423995"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310194441788.png" alt="image-20220310194441788"></p><h3 id="RedisTemplate对Hash的操作"><a href="#RedisTemplate对Hash的操作" class="headerlink" title="RedisTemplate对Hash的操作"></a><strong>RedisTemplate对Hash的操作</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void doTest2()&#123;</span><br><span class="line">    stringRedisTemplate.opsForHash().put(&quot;key&quot;,&quot;hashKey&quot;,&quot;value&quot;);</span><br><span class="line">    stringRedisTemplate.opsForHash().put(&quot;key&quot;,&quot;hashKey1&quot;,&quot;value1&quot;);</span><br><span class="line"></span><br><span class="line">    Map&lt;Object, Object&gt; key = stringRedisTemplate.opsForHash().entries(&quot;key&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作习惯上更偏向于java的HashMap之类的.</p><p>stringRedisTemplate.opsForHash().entries(String key)会获得hash类型中的某个key的全部key-value信息.</p><p>剩余操作或其他类型操作可以参考官方文档.<a href="https://docs.spring.io/spring-data/redis/docs/current/api/">RedisAPI文档</a></p><hr><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a><strong>项目实战</strong></h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310200358089.png" alt="image-20220310200358089"></p><hr><h3 id="Session共享问题"><a href="#Session共享问题" class="headerlink" title="Session共享问题:"></a><strong>Session共享问题:</strong></h3><p>多台TomCat并不共享session存储空间,当请求切换到不同的tomcat服务时,导致数据丢失的问题</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310213458462.png" alt="image-20220310213458462"></p><p>session的代替方案应该满足:</p><ul><li><strong>数据共享</strong></li><li><strong>内存存储</strong></li><li><strong>key-value结构</strong></li></ul><p><strong>以上的要求Redis都满足, 可以使用Redis来代替Session存储,但也不是简单的存储.</strong></p><h3 id="基于Redis实现共享Session登陆"><a href="#基于Redis实现共享Session登陆" class="headerlink" title="基于Redis实现共享Session登陆"></a><strong>基于Redis实现共享Session登陆</strong></h3><p><strong>Redis要实现共享Session登陆, 需要满足key唯一性.</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310214224767.png" alt="image-20220310214224767"></p><ul><li>如果使用用户登陆存储一定的用户信息在Redis中时,一般使用token作为key,而value使用Hash类型.</li><li>学习Hash类型的时候我们学过 Hash类型的存储可以将对象的字段分别存储,可以针对单个字段进行crud,不需要每次改的是否传全部信息进行更改.</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309191148786.png" alt="image-20220309191148786"></p><p>使用token存储用户的非敏感信息,传到前端,前端利用浏览器的缓存存储</p><p><strong>注意</strong>:</p><ul><li>使用token存储到Redis时一定要设置过期时间,因为会耗费内存空间(如果存储的token太多 有没有及时清楚 可能会造成堆栈溢出)</li><li>使用 RedisTemplate.expire可以指定指定key-value的存活时间</li><li>在登陆拦截器中,验证了token后需要刷新token存活时间,及再执行一遍第二步.</li><li>常量等可以专门编写一个类来记录 <code>static final constant</code>防止自己写出错.</li><li>对于一些不需要登陆拦截的Controller当用户访问时,也是需要刷新token的,设置一个全局刷新的token的拦截器,将其优先级设置为最高,所有请求都由他拦截,后续的登录拦截只需要从,全局拦截器中的存储到ThreadLocal的用户信息取到验证即可.</li></ul></li></ul></li></ul><h3 id="全局请求拦截器"><a href="#全局请求拦截器" class="headerlink" title="全局请求拦截器"></a><strong>全局请求拦截器</strong></h3><p>作用:</p><ul><li>用于拦截所有请求,获取如果有token就获取token中的数据,并且刷新token,并且将数据存入ThreadLocal中,如果没有就直接放行.(后续可能会被登陆拦截器拦截 检查是否有用户信息, 如果没有就返回false)</li><li>全局请求拦截器的主要作用就是为了防止用户登陆后,访问一些不需要登陆拦截器的接口token无法刷新的情况.</li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><strong>缓存</strong></h2><p><strong>缓存</strong>就是数据交换的缓存区(称作Cache), 是存储数据的临时地方,一般读写性能较高</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311151533133.png" alt="image-20220311151533133"></p><h3 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h3><ul><li>降低后端负载</li><li>提高读写效率,降低响应时间.</li></ul><h3 id="缓存的成本"><a href="#缓存的成本" class="headerlink" title="缓存的成本"></a>缓存的成本</h3><ul><li>数据一致性成本</li><li>代码维护成本</li><li>运维成本</li></ul><h3 id="添加Redis缓存"><a href="#添加Redis缓存" class="headerlink" title="添加Redis缓存"></a>添加Redis缓存</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311152211102.png" alt="image-20220311152211102"></p><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311153346059.png" alt="image-20220311153346059"></p><p>对于经常修改的数据,可以采用主动更新策略,在修改数据库的同时,更新缓存,这样的数据一致性较好,相应的维护成本较高. 对于不经常修改的数据,采用默认策略即可.</p><h4 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h4><h5 id="Cache-Aside-Pattern-常用"><a href="#Cache-Aside-Pattern-常用" class="headerlink" title="Cache Aside Pattern*(常用)"></a>Cache Aside Pattern*(常用)</h5><ul><li>由缓存的调用者,在更新数据库同时更新缓存.</li></ul><h5 id="Read-x2F-Write-Through-Pattern"><a href="#Read-x2F-Write-Through-Pattern" class="headerlink" title="Read&#x2F;Write Through Pattern"></a>Read&#x2F;Write Through Pattern</h5><ul><li>缓存与数据库整合为一个服务, 有服务来维护一致性. 调用者调用该服务, 无需关心缓存的一致性.</li></ul><h5 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h5><ul><li>调用者只是操作缓存,有其他线程异步地将缓存数据持久化到数据库,保证最终一致性</li></ul><h3 id="操作缓存和数据库时的三个问题考虑-For-Cache-Aside-Pattern"><a href="#操作缓存和数据库时的三个问题考虑-For-Cache-Aside-Pattern" class="headerlink" title="操作缓存和数据库时的三个问题考虑(For Cache Aside Pattern)"></a>操作缓存和数据库时的三个问题考虑(For Cache Aside Pattern)</h3><ol><li><p>删除缓存还是更新缓存 ?</p><ul><li>更新缓存: 每次更新数据库都更新缓存, 无效写操作较多(<strong>×</strong>)</li><li>删除缓存: 更新数据库时让缓存失效, 查询时在更新缓存(<strong>√</strong>)</li></ul></li><li><p>如何保证数据与数据库的同时成功或失败 ?</p><ul><li>单体系统, 将缓存与数据库操作防止一个事务</li><li>分布式系统,利用TTC等分布式事务方案</li></ul></li><li><p>先操作缓存还是先操作数据库 ?</p><ul><li>对于先操作缓存,可能会出现在删除缓存后将要操作数据库时, 另一个线程在查询缓存, 此时缓存中已无数据, 缓存未命中查询数据库写入缓存的情况,然后才去更新我们的数据库 造成读到脏数据的线程安全问题.</li><li>对于先操作数据库,也可能出现(刚好一个缓存过期)一个线程想要来查询缓存,缓存未命中,查询数据库的情况,此时数据库还没有更新,在要进行吸入缓存之前数据库才更新,这就造成读取到脏数据的情况.</li><li>但是对于先操作数据库的情况,实际上写入缓存的时间是非常快的,是远远快于操作数据库的情况,所以基本上不会出现在写入缓存之前,还能操作数据库的情况,所以一般采用先操作数据库的情况. 相比于第一种安全性更高.</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311160417480.png" alt="image-20220311160417480"></p></li></ol><h3 id="缓存更新的最佳实践方案"><a href="#缓存更新的最佳实践方案" class="headerlink" title="缓存更新的最佳实践方案:"></a><strong>缓存更新的最佳实践方案:</strong></h3><ol><li>低一致性需求: 使用Redis自带的淘汰机制</li><li>高一致性需求: 主动更新,并以超时作为兜底<ul><li>读操作:<ul><li>缓存命中则直接返回</li><li>缓存 未命中则查询数据库,并写入缓存,设定超时时间</li></ul></li><li>写操作:<ul><li>先写入数据库,再删除缓存</li><li>要确保数据的于缓存操作的原子性</li></ul></li></ul></li></ol><hr><h2 id="缓存未命中"><a href="#缓存未命中" class="headerlink" title="缓存未命中"></a><strong>缓存未命中</strong></h2><p>当CPU在缓存中找到有用的数据时，称为命中。当缓存中没有CPU需要的数据时（这称为未命中）</p><hr><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><strong>缓存穿透</strong></h2><p><strong>缓存穿透</strong>是指客户端请求的数据在缓存中和数据库中都不存在,这样的缓存永远都不会生效,这些请求都会打到数据库.</p><p>一些不坏好意的人可能会利用这里点来多线程发送多次请求导致数据库崩坏. 不存在的数据在数据库中查询对于数据库来说是会遍历全部数据然后返回NULL这对数据库的压力很大.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311161920235.png" alt="image-20220311161920235"></p><p><strong>常见的解决方案</strong>:</p><ul><li><p><strong>缓存空对象</strong>*</p><ul><li>优点: 实现简单,维护方便</li><li>缺点:<ul><li>额外的内存消耗(一般设置过期时间,且过期时间较短)</li><li>可能造成短期的不一致(此时新增一条该key对应的数据,但是在TTL结束前,查询到的都是NULL 造成短期不一致)</li></ul></li></ul></li><li><p><strong>布隆过滤</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311162648729.png" alt="image-20220311162648729"></p><ul><li>优点: 内存占用较少, 没有多余key</li><li>缺点:<ul><li>实现复杂</li><li>存在误判</li></ul></li></ul></li></ul><p><strong>除此之外缓存穿透的解决方案还有:</strong></p><ul><li>增强id的复杂度,避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流(也可以减小数据库压力)</li></ul><hr><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h2><p><strong>缓存雪崩</strong>是指在同一时间段大量的缓存key同时失效或者Redis服务宕机,导致大量请求到达数据库,带来巨大压力.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311163954070.png" alt="image-20220311163954070"></p><p><strong>解决方案</strong>:</p><ul><li>给不同的key的TTL添加随机值(防止大量的缓存Key同时失效)</li><li>利用Redis集群提高服务的可用性(防止单机宕机的情况)</li><li>给缓存业务添加降级限流策略(待学)</li><li>给业务添加多级缓存</li></ul><hr><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><strong>缓存击穿</strong></h2><p><strong>缓存击穿问题</strong>也叫热点Key问题,就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务比较复杂</strong>的key突然失效了,无数的请求访问会在瞬间给数据库带来巨大的冲击.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311165255394.png" alt="image-20220311165255394"></p><p><strong>常见解决方案</strong>:</p><ul><li><p><strong>互斥锁</strong></p><ul><li><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311165723072.png" alt="image-20220311165723072"></li><li>加锁,性能低.</li></ul></li><li><p><strong>逻辑过期</strong></p><ul><li>设置逻辑过期时间 而非TTL</li><li>获取互斥锁 开启新线程,去查询数据库重建缓存数据.</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311170401649.png" alt="image-20220311170401649"></p></li></ul><p><strong>两种方案的比较</strong>:</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311170545184.png" alt="image-20220311170545184"></p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁实现原理是通过Redis中的String类型的SETNX(插入一个不存在的数据)方法.这样别人就无法修改了.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311172926169.png" alt="image-20220311172926169"></p><p>RedisTemplate中的api是 opsForValue.setIfAbsent()</p><h3 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h3><p>使用逻辑过期 需要给数据设置一个逻辑过期时间, 一般会创建一个RedisData类 将逻辑过期时间和业务数据封装在一起,避免了在原有的业务基础上修改代码(指在实体类上新增逻辑过期字段).</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="comment">//业务数据</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LocalDateTime.After(LocalDateTime time),如果时间过期那么返回</p><h2 id="封装Redis工具"><a href="#封装Redis工具" class="headerlink" title="封装Redis工具"></a><strong>封装Redis工具</strong></h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311180308032.png" alt="image-20220311180308032"></p><h2 id="全局ID生成器"><a href="#全局ID生成器" class="headerlink" title="全局ID生成器"></a><strong>全局ID生成器</strong></h2><p>当用户抢购时,就会生成订单数据保存到订单表中,而订单表如果使用数据库自增ID就存在一些问题:</p><ul><li><strong>id的规律性太明显</strong></li><li><strong>受单表数据量的限制</strong></li></ul><p>全局ID生成器,是一种在分布式系统下用来生成全局唯一ID的工具,一般满足下列特性:</p><ul><li><strong>唯一性</strong></li><li><strong>高可用</strong></li><li><strong>递增性</strong></li><li><strong>安全性</strong></li><li><strong>高性能</strong></li></ul><p>为了增加ID的安全性,我们可以不直接使用Redis自增的数值,而是拼接一些其他的信息.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311210845236.png" alt="image-20220311210845236">ID的组成部分:</p><blockquote><ul><li>符号位: 1bit, 永远为0</li><li>时间戳: 31bit,以秒为单位</li><li>序列号: 32bit,秒内的计数器, 支持每秒产生2^32个不同的ID</li></ul></blockquote><p>全局唯一ID生成策略:</p><blockquote><ul><li>UUID</li><li><strong>Redis自增</strong>*</li><li><strong>snowflake算法(雪花算法)</strong>*</li><li>数据库自增</li></ul></blockquote><p><strong>Redis自增策略</strong>:</p><ul><li>每天一个key, 方便统计订单量</li><li>ID构造是 时间戳 + 计数器</li></ul><h2 id="优惠券秒杀下单功能"><a href="#优惠券秒杀下单功能" class="headerlink" title="优惠券秒杀下单功能"></a>优惠券秒杀下单功能</h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312123558073.png" alt="image-20220312123558073"></p><h3 id="超卖问题-线程安全问题"><a href="#超卖问题-线程安全问题" class="headerlink" title="超卖问题(线程安全问题)"></a>超卖问题(线程安全问题)</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312131903889.png" alt="image-20220312131903889"></p><p><strong>解决方案: 加锁</strong></p><ul><li><strong>悲观锁</strong></li><li><strong>乐观锁</strong></li></ul><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>认为线程安全问题一定会发生,因此在操作数据之前先获取锁,确保线程串行执行.</p><blockquote><ul><li>例如Synchronized, Lock都属于悲观锁</li><li>优点: 简单粗暴</li><li>缺点: 性能一般</li></ul></blockquote><hr><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>认为线程安全问题不一定会发生,因此不加锁,只是在更新数据时去判断有没有其他线程对数据进行了修改</p><blockquote><ul><li>如果没有修改则认为是安全的, 自己才更新数据</li><li>如果已经被其他线程修改说明发生了线程安全问题,此时可以重试或异常.</li><li>优点: 性能好</li><li>缺点存在成功率低的问题</li></ul></blockquote><p>乐观锁的关键是判断之前查询到的数据是否被修改过,常见的方式有两种:</p><ul><li><p>版本号法</p><p>设置一个用于悲观锁修改是判断的字段(版本号),每次修改后都会被修改</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312132808463.png" alt="image-20220312132808463"></p></li><li><p>CAS法</p><p>利用本身的数据作为判断依据(不新增任何字段 用自身数据代替版本)</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312133142933.png" alt="image-20220312133142933"></p></li></ul><h3 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h3><p>同一张优惠券一个用户只能下一单</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312135825445.png" alt="image-20220312135825445"></p><h4 id="集群下的一人一单问题"><a href="#集群下的一人一单问题" class="headerlink" title="集群下的一人一单问题"></a>集群下的一人一单问题</h4><p>JVM中有一个锁监视器 单机情况下可以实现锁的监视,但是在集群模式下 多个的JVM有不同的锁监视器, 即集群模式下的悲观锁失效了(它只能保证单个JVM下的线程安全问题)</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312142218951.png" alt="image-20220312142218951"></p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><strong>分布式锁</strong></h3><p>**分布式锁:**满足分布式系统或集群模式下多进程可见并且互斥的锁.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312142754987.png" alt="image-20220312142754987"></p><blockquote><ul><li><strong>多线程可见</strong>*</li><li><strong>互斥</strong>*</li><li><strong>高可用</strong>*</li><li><strong>高性能(指获得锁的性能)</strong>*</li><li><strong>安全性</strong>*</li><li>…</li></ul></blockquote><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312143720266.png" alt="image-20220312143720266"></p><h3 id="实现分布式锁-此处的是实现都是基于一人一单的情况下"><a href="#实现分布式锁-此处的是实现都是基于一人一单的情况下" class="headerlink" title="实现分布式锁(此处的是实现都是基于一人一单的情况下)"></a><strong>实现分布式锁</strong>(此处的是实现都是基于一人一单的情况下)</h3><p>实现分布式锁需要实现两个基本方法</p><ul><li>获取锁</li><li>释放锁</li></ul><h3 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a><strong>基于Redis的分布式锁</strong></h3><p>利用SETNX的互斥机制 和DEL的删除机制</p><p>为了防止Redis异常宕机的情况下锁的安全性问题(需要设置锁的过期时间)</p><ul><li><p>获取锁:</p><ul><li><p>互斥: 确保只能有一个线程获取锁</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">添加锁, NX是互斥 EX是设置超时时间</span></span><br><span class="line">set lock thread1 NX EX 10</span><br></pre></td></tr></table></figure></li></ul></li><li><p>释放锁:</p><ul><li><p>手动释放</p></li><li><p>超时释放: 获取锁时添加一个超时时间</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">释放锁, 删除即可</span></span><br><span class="line">DEL key</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312145523204.png" alt="image-20220312145523204"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">//获取线程表示</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">//获取锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的分布式锁的线程安全问题</p><p>业务堵塞导致锁的时间到期释放, 第二个线程此时获取到锁,在执行业务中,一号线程业务堵塞完毕此时释放锁 就导致线程二的锁被释放了.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312152342991.png" alt="image-20220312152342991"></p><p>改进后</p><p>通过新增UUID+ThreadID作为锁标识 在释放锁之前判断锁标识是否一致(同一个线程的锁标识一致,这样就不会出现业务堵塞导致释放了其他线程的锁的情况)</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312152522311.png" alt="image-20220312152522311"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312152710464.png" alt="image-20220312152710464"></p><h4 id="改进Redis的分布式锁"><a href="#改进Redis的分布式锁" class="headerlink" title="改进Redis的分布式锁"></a>改进Redis的分布式锁</h4><p>修改之前的分布式锁实现,满足</p><ol><li><p>在获取锁时存入线程表示(可用UUID表示)</p></li><li><p>在释放锁时先获取锁中的线程标识,判断是否与当前线程标识一致</p><blockquote><ul><li><p>如果不一致则不释放锁</p></li><li><p>如果一致则释放锁</p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取线程标识</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX+Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">//获取锁中的标识</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="comment">//判断是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(threadId.equals(id))&#123;</span><br><span class="line">        <span class="comment">//一致就释放锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX+name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则就不释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>改良后的Redis分布式锁 依旧存在如下问题就是在 删除锁的时候发生了堵塞 导致超时释放锁 此时二号线程进入获得锁执行业务,但是刚好一号线程堵塞完毕就将二号线程的锁释放了.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312173903547.png" alt="image-20220312173903547"></p><h3 id="Redis的Lua脚本"><a href="#Redis的Lua脚本" class="headerlink" title="Redis的Lua脚本"></a>Redis的Lua脚本</h3><p>释放锁业务的Lua脚本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- 比较线程标示与锁中的标示是否一致</span><br><span class="line">if(redis.call(&#x27;get&#x27;, KEYS[1]) ==  ARGV[1]) then</span><br><span class="line">    -- 释放锁 del key</span><br><span class="line">    return redis.call(&#x27;del&#x27;, KEYS[1])</span><br><span class="line">end</span><br><span class="line">return 0</span><br></pre></td></tr></table></figure><h3 id="Java中调用Lua脚本"><a href="#Java中调用Lua脚本" class="headerlink" title="Java中调用Lua脚本"></a>Java中调用Lua脚本</h3><p>RedisTemplate可以直接调用Lua脚本</p><p>使用静态代码块初始化lua脚本</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">    UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将原来java中的两行代码,变为了一行代码, 就不会出现上述的情况</p><p>改良后的unlock方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX+name),</span><br><span class="line">            ID_PREFIX+Thread.currentThread().getId());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于Redis的分布式锁优化"><a href="#基于Redis的分布式锁优化" class="headerlink" title="基于Redis的分布式锁优化"></a>基于Redis的分布式锁优化</h3><p>基于SETNX实现的分布式锁存在下面的问题:</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312184555611.png" alt="image-20220312184555611"></p><p><a href="https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95"><strong>Redission官方文档</strong></a></p><p>Redission是一个在Redis的基础上实现的java驻内存数据网络(In-Memory Data Grid). 它不仅提供了一系列的分布式java常用对象,还提供了许多分布式服务,其中就包含了各种分布式锁的实现</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312200824948.png" alt="image-20220312200824948"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1cr4y1671t?p=63&amp;spm_id_from=pageDriver&quot;&gt;Redis&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Redis是一种NOSQL型数据库,即一种非关系型数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们常见的Mysql是一种SQL型数据库,是一种关系型数据库&lt;/p&gt;</summary>
    
    
    
    <category term="NoSQL" scheme="https://devildyw.github.io/categories/NoSQL/"/>
    
    
    <category term="database" scheme="https://devildyw.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Git分布式版本控制工具</title>
    <link href="https://devildyw.github.io/2022/02/28/Git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"/>
    <id>https://devildyw.github.io/2022/02/28/Git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-04-16T08:53:06.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git分布式版本控制工具"><a href="#Git分布式版本控制工具" class="headerlink" title="Git分布式版本控制工具"></a><a href="D:\BaiduNetdiskDownload\Git讲义.pdf">Git分布式版本控制工具</a></h1><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220127230403996.png" alt="image-20220127230403996"></p><p><strong>命令如下：</strong></p><ol><li><strong>clone（克隆）</strong>: 从远程仓库中克隆代码到本地仓库</li><li><strong>checkout （检出）</strong>:从本地仓库中检出一个仓库分支然后进行修订</li><li><strong>add（添加）</strong>: 在提交前先将代码提交到暂存区</li><li><strong>commit（提交）</strong>: 提交到本地仓库。本地仓库中保存修改的各个历史版本</li><li><strong>fetch (抓取)</strong> ： 从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。</li><li><strong>pull (拉取)</strong> ： 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于fetch+merge</li><li><strong>push（推送）</strong> : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库</li></ol><span id="more"></span><hr><p><strong>备注：</strong></p><p><strong>Git GUI</strong>：Git提供的图形界面工具</p><p><strong>Git Bash</strong>：Git提供的命令行工具</p><p>当安装Git后首先要做的事情是<strong>设置用户名称</strong>和<strong>email</strong>地址。这是非常重要的，因为每次Git提交都会使用该用户信息</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;itcast&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;hello@qq.com&quot;</span></span><br></pre></td></tr></table></figure><p>查看配置信息</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git confifig --global user.name</span><br><span class="line">git confifig --global user.email</span><br></pre></td></tr></table></figure><hr><h2 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a><strong>本地仓库</strong></h2><p>要使用Git对我们的代码进行版本控制，首先需要获得本地仓库</p><ol><li><p>在电脑的任意位置创建一个空目录（例如test）作为我们的本地Git仓库</p></li><li><p>进入这个目录中，点击右键打开Git bash窗口</p></li><li><p>执行命令<strong>git init</strong> (初始化本文件为本地仓库)</p></li><li><p>如果创建成功后可在文件夹下看到隐藏的.git目录。</p></li></ol><hr><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a><strong>命令</strong></h2><ul><li><strong>git touch</strong> 文件名 可以创建文件</li></ul><hr><p>Git工作目录下对于文件的<strong>修改</strong>(增加、删除、更新)会存在几个状态，这些<strong>修改</strong>的状态会随着我们执行Git的命令而发生变化。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220127231451204.png" alt="image-20220127231451204"></p><ul><li><p><strong>git add</strong> (工作区 –&gt; 暂存区) (<strong>git add . 将所有修改加入暂存区</strong>)</p></li><li><p><strong>git commit</strong> (暂存区 –&gt; 本地仓库) (<strong>git commit -m ‘注释内容’</strong> 将暂存区中的内容提交到本地仓库)</p></li><li><p><strong>git status</strong>:<strong>查看修改的状态</strong></p></li></ul><hr><p><strong>查看提交日志</strong></p><ul><li><p><strong>git log</strong> [option]</p></li><li><p>options</p><ul><li><p><strong>all</strong> 显示所有分支</p></li><li><p><strong>pretty&#x3D;oneline</strong> 将提交信息显示为一行</p></li><li><p><strong>abbrev-commit</strong> 使得输出的commitId更简短</p></li><li><p><strong>graph</strong> 以图的形式显示</p></li></ul></li></ul><p><strong>对log的格式进行自定义 并且对该操作使用alias起了一个别名</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global alias.lg <span class="string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span></span><br></pre></td></tr></table></figure><hr><p><strong>版本回退</strong></p><ul><li>作用: 版本切换</li><li>命令: <strong>git reset –hard commitID</strong><ul><li><strong>commitID</strong> 可以使用 <strong>git lg</strong> 或 <strong>git log</strong> 指令查看</li></ul></li></ul><p><strong>如何查看已经删除的记录？</strong></p><ul><li><p><strong>git reflflog</strong></p></li><li><p>这个指令可以看到已经删除的提交记录</p></li></ul><hr><p><strong>添加文件至忽略列表</strong></p><p>一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以在工作目录中创建一个名为 <strong>.gitignore 的文件（文件名称固定）</strong>，列出要忽略的文件模式。</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">HELP.md</span><br><span class="line">target/</span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar</span><br><span class="line">!**/src/main/**/target/</span><br><span class="line">!**/src/test/**/target/</span><br><span class="line"></span><br><span class="line"><span class="params">###</span> STS <span class="params">###</span></span><br><span class="line">.apt<span class="built_in">_</span>generated</span><br><span class="line">.classpath</span><br><span class="line">.factorypath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.springBeans</span><br><span class="line">.sts4-cache</span><br><span class="line"></span><br><span class="line"><span class="params">###</span> IntelliJ IDEA <span class="params">###</span></span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line"></span><br><span class="line"><span class="params">###</span> NetBeans <span class="params">###</span></span><br><span class="line">/nbproject/private/</span><br><span class="line">/nbbuild/</span><br><span class="line">/dist/</span><br><span class="line">/nbdist/</span><br><span class="line">/.nb-gradle/</span><br><span class="line">build/</span><br><span class="line">!**/src/main/**/build/</span><br><span class="line">!**/src/test/**/build/</span><br><span class="line"></span><br><span class="line"><span class="params">###</span> VS Code <span class="params">###</span></span><br><span class="line">.vscode/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a><strong>分支</strong></h2><p><strong>查看本地分支</strong></p><ul><li><strong>git branch</strong></li></ul><hr><p><strong>创建本地分支</strong></p><ul><li><strong>git branch 分支名</strong></li></ul><hr><p><strong>切换分支</strong></p><ul><li><strong>git checkout 分支名</strong></li><li><strong>git checkout -b 分支名 (创建并切换)</strong></li></ul><hr><p><strong>合并分支</strong></p><ul><li><strong>git merge 分支名称</strong></li></ul><hr><p><strong>删除分支</strong></p><ul><li><strong>git branch -d 分支名 (删除分支时，需要做各种检查)</strong></li><li><strong>git branch -D 分支名 (不做任何检查，强制删除)</strong></li></ul><hr><p><strong>解决冲突</strong></p><p>当两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解决冲突，解决冲突步骤如下：</p><ol><li><p>处理文件中冲突的地方</p></li><li><p>将解决完冲突的文件加入暂存区(add)</p></li><li><p>提交到仓库(commit)</p></li></ol><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220127233455735.png" alt="image-20220127233455735"></p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a><strong>远程仓库</strong></h2><ul><li><p><strong>注册gitee(码云)</strong></p></li><li><p><strong>创建仓库</strong></p></li></ul><p><strong>配置SSH公钥</strong></p><ul><li><p><strong>生成SSH公钥</strong></p><ul><li><strong>ssh-keygen -t rsa</strong></li></ul></li><li><p><strong>Gitee设置账户共公钥</strong></p><ul><li><p>上面我们以及生成了SSH公钥 这里我们要获取</p></li><li><p><strong>cat ~&#x2F;.ssh&#x2F;id_rsa.pub</strong> </p></li><li><p>复制这个SSH公钥</p></li><li><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220128220100844.png" alt="image-20220128220100844"></p></li><li><p>验证是否配置成功 <strong>ssh -T <a href="mailto:&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#101;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#101;&#101;&#x2e;&#99;&#x6f;&#x6d;</a></strong></p></li></ul><h4 id="操作远程仓库"><a href="#操作远程仓库" class="headerlink" title="操作远程仓库"></a>操作远程仓库</h4><ul><li><p><strong>添加远程仓库</strong> (此操作是先初始化本地仓库,然后与一创建的远程仓库进行对接)</p><ul><li><p><strong>命令: git remote add &lt;远端名称(别名)&gt; &lt;仓库路径(url)&gt;</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote add origin git@gitee.com:Devildyw/spring-mvc.git</span><br></pre></td></tr></table></figure></li><li><p><strong>命令: git remote</strong>(查看已添加的远程仓库)</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220128221118298.png" alt="image-20220128221118298"></p></li></ul></li></ul></li></ul><hr><ul><li><p><strong>推送到远程仓库</strong></p><ul><li><p><strong>命令: git push [-f] [–set-upstream] [远端名称[本地分支名 [:远端分支名]]</strong></p><ul><li><pre><code class="sh">git push origin master<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* **-f** 表示强制覆盖</span><br><span class="line"></span><br><span class="line">* **--set-upstream**: 推送到远端的同时并且建立起和远端分支的关联关系</span><br><span class="line"></span><br><span class="line">* ```sh</span><br><span class="line">  git push --set-upstream origin master</span><br></pre></td></tr></table></figure></code></pre></li><li><p>如果当前分支已经和远端分支建立关联,则可以省略分支名和远端名 <strong>(git push)</strong></p></li></ul></li><li><p><strong>查看本地分支与远程分支的关联关系</strong></p><ul><li><strong>命令: git brach -vv</strong></li></ul></li></ul></li></ul><hr><ul><li><strong>从远程仓库克隆(一般只有一开始会做一次 后续都会使用pull拉取)</strong><ul><li><strong>命令: git clone &lt;仓库路径&gt; [本地目录]</strong><ul><li>本地目录可以省略,会自动生成一个目录</li></ul></li></ul></li><li><strong>从远程仓库中抓取和拉取</strong><ul><li>远程分支和本地的分支一样，我们可以进行merge操作，只是需要先把远端仓库里的更新都下载到本地，再进行操作。<ul><li><strong>抓取 命令: git fetch [remote name] [branch name]</strong><ul><li><strong>抓取指令就是将仓库里的更新都抓取到本地，不会进行合并</strong></li><li>如果不指定远端名称和分支名，则抓取所有分支。</li></ul></li><li><strong>拉取 命令: git pull [remote name] [branch name]</strong><ul><li>**拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于 ** <strong>fetch+merge</strong></li><li>如果不指定远端名称和分支名，则抓取所有并更新当前分支。</li></ul></li></ul></li></ul></li></ul><hr><ul><li><p><strong>解决合并冲突</strong></p><ul><li><p>在一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突。A用户在本地修改代码后优先推送到远程仓库，此时B用户在本地修订代码，提交到本地仓库后，也需要推送到远程仓库，此时B用户晚于A用户，<strong>故需要先拉取远程仓库的提交，经过合并后才能推送到远端分支</strong></p></li><li><p>在B用户拉取代码时，因为A、B用户同一段时间修改了同一个文件的相同位置代码，故会发生合并冲突。<strong>远程分支也是分支，所以合并时冲突的解决方式也和解决本地分支冲突相同相同</strong></p></li><li><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220128223521930.png" alt="image-20220128223521930"></p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Git分布式版本控制工具&quot;&gt;&lt;a href=&quot;#Git分布式版本控制工具&quot; class=&quot;headerlink&quot; title=&quot;Git分布式版本控制工具&quot;&gt;&lt;/a&gt;&lt;a href=&quot;D:\BaiduNetdiskDownload\Git讲义.pdf&quot;&gt;Git分布式版本控制工具&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220127230403996.png&quot; alt=&quot;image-20220127230403996&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;clone（克隆）&lt;/strong&gt;: 从远程仓库中克隆代码到本地仓库&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;checkout （检出）&lt;/strong&gt;:从本地仓库中检出一个仓库分支然后进行修订&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;add（添加）&lt;/strong&gt;: 在提交前先将代码提交到暂存区&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;commit（提交）&lt;/strong&gt;: 提交到本地仓库。本地仓库中保存修改的各个历史版本&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fetch (抓取)&lt;/strong&gt; ： 从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pull (拉取)&lt;/strong&gt; ： 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于fetch+merge&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;push（推送）&lt;/strong&gt; : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="开发工具" scheme="https://devildyw.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Developer" scheme="https://devildyw.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="https://devildyw.github.io/2022/02/28/ThreadLocal/"/>
    <id>https://devildyw.github.io/2022/02/28/ThreadLocal/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-04-16T08:53:20.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal-ThreadLocal-简书-jianshu-com"><a href="#ThreadLocal-ThreadLocal-简书-jianshu-com" class="headerlink" title="[ThreadLocal](ThreadLocal - 简书 (jianshu.com))"></a>[ThreadLocal](<a href="https://www.jianshu.com/p/3c5d7f09dfbd">ThreadLocal - 简书 (jianshu.com)</a>)</h1><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>threadlocal使用方法很简单</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;T&gt; sThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;T&gt;();</span><br><span class="line">sThreadLocal.set()</span><br><span class="line">sThreadLocal.get()</span><br></pre></td></tr></table></figure><p>threadlocal而是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据，官方解释如下。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220211183419286.png" alt="image-20220211183419286"></p><p>大致意思就是ThreadLocal提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。通过get和set方法就可以得到当前线程对应的值。</p><p>做个不恰当的比喻，从表面上看ThreadLocal相当于维护了一个map，key就是当前的线程，value就是需要存储的对象。</p><p><strong>这里的这个比喻是不恰当的，实际上是ThreadLocal的静态内部类ThreadLocalMap为每个Thread都维护了一个数组table，ThreadLocal确定了一个数组下标，而这个下标就是value存储的对应位置。</strong></p><span id="more"></span><p>作为一个存储数据的类，关键点就在get和set方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**源码**/</span></span><br><span class="line"><span class="comment">//set 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">      <span class="comment">//获取当前线程</span></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">      <span class="comment">//实际存储的数据结构类型</span></span><br><span class="line">      <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">      <span class="comment">//如果存在map就直接set，没有则创建map并set</span></span><br><span class="line">      <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">          map.set(<span class="built_in">this</span>, value);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          createMap(t, value);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//getMap方法</span></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">      <span class="comment">//thred中维护了一个ThreadLocalMap</span></span><br><span class="line">      <span class="keyword">return</span> t.threadLocals;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//createMap</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">      <span class="comment">//实例化一个新的ThreadLocalMap，并赋值给线程的成员变量threadLocals</span></span><br><span class="line">      t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出<strong>每个线程持有一个ThreadLocalMap对象</strong>。每一个新的线程Thread都会实例化一个ThreadLocalMap并赋值给成员变量threadLocals，使用时若已经存在threadLocals则直接使用已经存在的对象。</p><hr><h2 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/9e256d87362c4d9295589e3d72e69211.png" alt="在这里插入图片描述"></p><p><strong>实线代表强引用,虚线代表弱引用</strong></p><ul><li><p>每一个Thread维护一个ThreadLocalMap, key为使用弱引用的ThreadLocal实例，value为线程变量的副本。</p></li><li><p>强引用，使用最普遍的引用，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。</p></li><li><p>如果想取消强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样可以使JVM在合适的时间就会回收该对象。</p></li><li><p>弱引用，JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>简单来说就是 ThreadLocal为每个线程提供了一个ThreadLocalMap对象 这样就避免了线程安全问题 实际开发中可以用于存储用户信息代替session</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ThreadLocal-ThreadLocal-简书-jianshu-com&quot;&gt;&lt;a href=&quot;#ThreadLocal-ThreadLocal-简书-jianshu-com&quot; class=&quot;headerlink&quot; title=&quot;[ThreadLocal](ThreadLocal - 简书 (jianshu.com))&quot;&gt;&lt;/a&gt;[ThreadLocal](&lt;a href=&quot;https://www.jianshu.com/p/3c5d7f09dfbd&quot;&gt;ThreadLocal - 简书 (jianshu.com)&lt;/a&gt;)&lt;/h1&gt;&lt;h4 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h4&gt;&lt;p&gt;threadlocal使用方法很简单&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; ThreadLocal&amp;lt;T&amp;gt; sThreadLocal = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ThreadLocal&lt;/span&gt;&amp;lt;T&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sThreadLocal.set()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sThreadLocal.get()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;threadlocal而是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据，官方解释如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220211183419286.png&quot; alt=&quot;image-20220211183419286&quot;&gt;&lt;/p&gt;
&lt;p&gt;大致意思就是ThreadLocal提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。通过get和set方法就可以得到当前线程对应的值。&lt;/p&gt;
&lt;p&gt;做个不恰当的比喻，从表面上看ThreadLocal相当于维护了一个map，key就是当前的线程，value就是需要存储的对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里的这个比喻是不恰当的，实际上是ThreadLocal的静态内部类ThreadLocalMap为每个Thread都维护了一个数组table，ThreadLocal确定了一个数组下标，而这个下标就是value存储的对应位置。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="开发规范" scheme="https://devildyw.github.io/categories/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？</title>
    <link href="https://devildyw.github.io/2022/02/28/%E5%8E%9F%E5%AD%90%E2%80%BB%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7/"/>
    <id>https://devildyw.github.io/2022/02/28/%E5%8E%9F%E5%AD%90%E2%80%BB%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-04-16T08:55:20.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java原子性是什么-中级Java应该清楚的概念：原子性、可见性、有序性是什么？"><a href="#java原子性是什么-中级Java应该清楚的概念：原子性、可见性、有序性是什么？" class="headerlink" title="java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？"></a>java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？</h1><p>原子性、可见性、有序性是多线程编程中最重要的几个知识点，由于多线程情况复杂，如何让每个线程能看到正确的结果，这是非常重要的，下面和千锋广州小编一起来看看吧！</p><p><a href="%5B(4%E6%9D%A1%E6%B6%88%E6%81%AF">原网站</a> java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？…_我才是Guido的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_42460182/article/details/114101352">https://blog.csdn.net/weixin_42460182/article/details/114101352</a>))</p><span id="more"></span><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性是指一个线程的操作是不能被其他线程打断，同一时间只有一个线程对一个变量进行操作。在多线程情况下，每个线程的执行结果不受其他线程的干扰，比如说多个线程同时对同一个共享成员变量n++100次，如果n初始值为0，n最后的值应该是100，所以说它们是互不干扰的，这就是传说的中的原子性。但n++并不是原子性的操作，要使用AtomicInteger保证原子性。</p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性是指某个线程修改了某一个共享变量的值，而其他线程是否可以看见该共享变量修改后的值。在单线程中肯定不会有这种问题，单线程读到的肯定都是最新的值，而在多线程编程中就不一定了。</p><p>每个线程都有自己的工作内存，线程先把共享变量的值从主内存读到工作内存，形成一个副本，当计算完后再把副本的值刷回主内存，从读取到最后刷回主内存这是一个过程，当还没刷回主内存的时候这时候对其他线程是不可见的，所以其他线程从主内存读到的值是修改之前的旧值。</p><p>像CPU的缓存优化、硬件优化、指令重排及对JVM编译器的优化，都会出现可见性的问题。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>我们都知道程序是按代码顺序执行的，对于单线程来说确实是如此，但在多线程情况下就不是如此了。为了优化程序执行和提高CPU的处理性能，JVM和操作系统都会对指令进行重排，也就说前面的代码并不一定都会在后面的代码前面执行，即后面的代码可能会插到前面的代码之前执行，只要不影响当前线程的执行结果。所以，指令重排只会保证当前线程执行结果一致，但指令重排后势必会影响多线程的执行结果。</p><p>虽然重排序优化了性能，但也是会遵守一些规则的，并不能随便乱排序，只是重排序会影响多线程执行的结果。</p><p>以上就是原子性、可见性、有序性的概念解释，希望对大家有帮助哦！</p><p><strong>相关资源：</strong><a href="https://download.csdn.net/download/weixin_38575456/12793647?spm=1001.2101.3001.5697"><em>Java</em>高并发三:<em>Java</em>内存模型和线程安全详解_<em>java</em>高并发模型-其它*.<strong>.</strong>.*</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;java原子性是什么-中级Java应该清楚的概念：原子性、可见性、有序性是什么？&quot;&gt;&lt;a href=&quot;#java原子性是什么-中级Java应该清楚的概念：原子性、可见性、有序性是什么？&quot; class=&quot;headerlink&quot; title=&quot;java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？&quot;&gt;&lt;/a&gt;java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？&lt;/h1&gt;&lt;p&gt;原子性、可见性、有序性是多线程编程中最重要的几个知识点，由于多线程情况复杂，如何让每个线程能看到正确的结果，这是非常重要的，下面和千锋广州小编一起来看看吧！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;%5B(4%E6%9D%A1%E6%B6%88%E6%81%AF&quot;&gt;原网站&lt;/a&gt; java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？…_我才是Guido的博客-CSDN博客](&lt;a href=&quot;https://blog.csdn.net/weixin_42460182/article/details/114101352&quot;&gt;https://blog.csdn.net/weixin_42460182/article/details/114101352&lt;/a&gt;))&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE" scheme="https://devildyw.github.io/categories/JavaSE/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据库(mysql)</title>
    <link href="https://devildyw.github.io/2022/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://devildyw.github.io/2022/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-03-06T16:00:04.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 展示所有数据库</span><br><span class="line">show databases;</span><br><span class="line"># 展示创建数据库的一些详细操作 以及数据库的字符集 等其他信息 可以用来查看已经创建的数据库的一些详细信息</span><br><span class="line">show create database mysql;</span><br><span class="line"># 创建数据库时指定字符集</span><br><span class="line">create database db2 character set gbk;</span><br><span class="line"></span><br><span class="line">show create database db2;</span><br><span class="line"># 删除数据库 如果数据库存在</span><br><span class="line">drop database if exists db2;</span><br><span class="line"># 创建数据库 如果数据库不存在</span><br><span class="line">create database if not exists db2;</span><br><span class="line"># 修改数据库的字符集</span><br><span class="line">alter database db2 character set gb2312;</span><br><span class="line"># 查询正在使用的数据库</span><br><span class="line">select database();</span><br><span class="line"># 查看数据库中的所有表</span><br><span class="line">show tables;</span><br><span class="line"># 使用数据库（选择） </span><br><span class="line">use world;</span><br><span class="line"># 查看表的结构</span><br><span class="line">desc city;</span><br><span class="line"></span><br><span class="line">use my_db;</span><br><span class="line"># 创建表</span><br><span class="line">create table student(</span><br><span class="line">id int,</span><br><span class="line">    name varchar(32),</span><br><span class="line">    age int,</span><br><span class="line">    score double(4,1),</span><br><span class="line">    birthday date,</span><br><span class="line">    insert_time timestamp default current_timestamp);</span><br><span class="line">    </span><br><span class="line">desc student;</span><br><span class="line"># 删除表</span><br><span class="line">drop table student;</span><br><span class="line"></span><br><span class="line">show tables;</span><br><span class="line"># 删除表如果表存在</span><br><span class="line">drop table if exists student;</span><br><span class="line"># 修改表的名字</span><br><span class="line">alter table student rename to stu;</span><br><span class="line"># 修改表的字符集</span><br><span class="line">alter table stu character set gbk;</span><br><span class="line"></span><br><span class="line">drop table if exists stu;</span><br><span class="line">#查看创建表的操作 与一些详细信息</span><br><span class="line">show create table stu;</span><br><span class="line"># 增加新的一列并指定类型</span><br><span class="line">alter table stu add gender varchar(10);</span><br><span class="line"></span><br><span class="line">desc stu;</span><br><span class="line"></span><br><span class="line">alter table stu change gender sex varchar(20);</span><br><span class="line"># 修改执行列的类型</span><br><span class="line">alter table stu modify sex varchar(10);</span><br><span class="line"># 插入一行 如果没有指定插入那些元素 则你默认全部修改</span><br><span class="line">insert into stu (id,name,age) values(1,&quot;肖明桓&quot;,19);</span><br><span class="line"># 查询表中的全部信息</span><br><span class="line">select* from stu;</span><br><span class="line"># where条件语句 查询指定条件的行</span><br><span class="line">delete from stu where id = 2;</span><br><span class="line"></span><br><span class="line">create table stu(</span><br><span class="line">id int,</span><br><span class="line">name varchar(32),</span><br><span class="line">age int,</span><br><span class="line">score double(4,1),</span><br><span class="line">birthday date,</span><br><span class="line">insert_time timestamp default CURRENT_TIMESTAMP);</span><br><span class="line"></span><br><span class="line">drop table stu;</span><br><span class="line"></span><br><span class="line">insert into stu (id,name,age) values(2,&quot;张敏&quot;,19);</span><br><span class="line"></span><br><span class="line">insert into stu (id,name,age) values(3,&quot;丁杨维&quot;,19);</span><br><span class="line"></span><br><span class="line"># truncate  在创建一个空表</span><br><span class="line">truncate stu;</span><br><span class="line"></span><br><span class="line">#delete from 表名 9[where语句] 删除指定的多少条记录</span><br><span class="line">delete from stu where id = 2;</span><br><span class="line"></span><br><span class="line"># updata from 表名 set 列名 = 值 [where条件] 修改指定元组中的列的值 如不加条件则会将列的所有值都修改</span><br><span class="line">update stu set age = 20 where id = 1;</span><br><span class="line"></span><br><span class="line">update stu set age = 20; </span><br><span class="line"></span><br><span class="line">update stu set score = 70 where id = 2;</span><br><span class="line"></span><br><span class="line">update stu set score = 88 where id = 3;</span><br><span class="line"></span><br><span class="line">update stu set age = 19 where id = 3;</span><br><span class="line">update stu set age = 21 where id = 2;</span><br><span class="line"></span><br><span class="line">update stu set score = 99;</span><br><span class="line"></span><br><span class="line"># 排序 asc 升序 desc 降序 </span><br><span class="line">select* from stu order by score asc; </span><br><span class="line"></span><br><span class="line"># 排序 如果数学成绩一样 则按年龄排序</span><br><span class="line">select* from stu order by score asc, age asc;</span><br></pre></td></tr></table></figure><blockquote><p><strong>聚合函数</strong> 计算会排除null值</p><ol><li>count：计算个数</li></ol><p>  一般以主键作为计数标记 一般不用count(*)(只要一列中有一个不为null那么count就加一);</p><ol start="2"><li><p>max</p></li><li><p>min</p></li><li><p>sum</p></li><li><p>avg</p></li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(ifnull(english,0)) from student;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<strong>聚合函数</strong> 计算会排除null值 </p><p>解决方案：</p><ol><li><p>选择不为空的列进行计算</p></li><li><p>使用ifnull 函数 </p><blockquote><p>select count(ifnull(english,0)) from student; 将english为null的值按0计数</p></blockquote></li></ol><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>操作数据库database 的关键字： create 创建 drop删除 alter 修改 show展示</p><p>table表的关键字 create创建 drop删除 alter修改 desc展示表的结构 </p><p>table中的行的插入 insert into 修改 update 删除 delete 查询 select。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM my_db.stu;</span><br><span class="line"># 主键就是 既非空又唯一的特殊约束 primary key </span><br><span class="line"></span><br><span class="line">#添加主键 方式一</span><br><span class="line">alter table stu modify id int primary key;</span><br><span class="line"># 添加主键 方式二 建表的时候定义</span><br><span class="line"></span><br><span class="line"># 删除主键 alter table 表名 drop primary key 一张表只有一个主键;</span><br><span class="line">alter table stu drop primary key;</span><br><span class="line"></span><br><span class="line"># 非空约束 NOT NULL;</span><br><span class="line"># 创建方式一</span><br><span class="line">alter table stu modify name varchar(32) not null;</span><br><span class="line">#创建方式二 创建表时定义</span><br><span class="line"></span><br><span class="line"># 删除非空约束</span><br><span class="line">alter table stu modify name varchar(32);</span><br><span class="line"></span><br><span class="line"># 唯一约束 unique</span><br><span class="line">#创建方式一 创建表时定义</span><br><span class="line">#创建方式二  </span><br><span class="line">alter table stu modify name varchar(32) unique;</span><br><span class="line">#删除 唯一约束</span><br><span class="line"># 错误方式 alter table stu modify name varchar(32);</span><br><span class="line">alter table stu drop index name ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除外键</span><br><span class="line">alter table stu1 drop foreign key c_key;</span><br><span class="line"># 添加外键方式一:</span><br><span class="line">alter table stu1 add constraint c_key foreign key(cid) references course(id);</span><br><span class="line"># 添加外键方式二: 创建时就定义 一般格式 constraint 外键名 foreign key(列名) references 表名 (列名);</span><br><span class="line"></span><br><span class="line"># 复制表的结构方式一用 like 模板 create table 新表 like 旧表 会将约束关系一同复制;</span><br><span class="line">create table stu2 like stu1;</span><br><span class="line"></span><br><span class="line"># 复制表的结构方式二用 create table 新表 select* from 旧表 where 1 = 2 但不会将约束关系一同复制;</span><br><span class="line">create table stu3 select * from stu1 where 1 = 2;</span><br><span class="line"># 复制表的结构与数据 create table 新表 select* from 旧表 但不会将约束关系一同复制;</span><br><span class="line">create table stu4 select* from stu1;</span><br><span class="line"></span><br><span class="line"># 主键约束自动增长 不给主键定值的情况下主键会按照主键的上一个值加一</span><br><span class="line"># 添加方式一: alter table 表名 modify 列名 类型 主键约束 auto_increment;</span><br><span class="line"># 添加方式二: 创建表的时候定义;</span><br><span class="line">alter table stu2 modify id int primary key auto_increment;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h1&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://devildyw.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="database" scheme="https://devildyw.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务</title>
    <link href="https://devildyw.github.io/2022/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <id>https://devildyw.github.io/2022/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-03-06T16:00:15.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><h3 id="事务的基本要素-4大性质"><a href="#事务的基本要素-4大性质" class="headerlink" title="事务的基本要素 4大性质"></a><strong>事务的基本要素 4大性质</strong></h3><blockquote><ol><li>原子性:事务开始后的所有操作,要么全部成功,要么全部失败回滚,不可能停滞在中间环节.事务执行过程中出错,会回滚到事务开始之前的状态,所有操作就像没有发生一样.也就是说事务是一个不可分割的整体,就像化学中学过的原子,是事务构成的基本单位.</li><li>一致性:事务开始前和结束后,数据库的完整性约束没有被破坏,如A向B转张,不可能出现A扣了钱而B却没有加的情况</li><li>隔离性:同一时间,只允许一个事务请求同一数据,不同事务之间彼此没有任何干扰,如A正在从一张银行卡中取钱,在A取钱的过程结束前,B不能向这张卡转账.</li><li>持久性:事务完成之后,事务对数据库更新将会被保存写在数据库上,不能回滚.</li></ol></blockquote><span id="more"></span><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p> <strong>隔离级别定义了一个事务可能受其他并发事务影响的程度。</strong></p><blockquote><p><strong>脏读（Dirty reads）</strong>—— 事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。</p><p><strong>不可重复读（Nonrepeatable read）</strong>—— 事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</p><p><strong>幻读（Phantom read）</strong>—— 系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p></blockquote><p>不可重复读是指在原本有个数据上进行修改导致一个事务一致都是读到不同的数据, 而幻读则是在原来的数据中的插入,删除等操作导致的.<strong>解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</strong></p><hr><p><strong>串行化</strong>隔离规则类型在开发中很少用到。举个很简单的例子。咱们使用了ISOLATION_SERIALIZABLE规则。A,B两个事务操作同一个数据表并发过来了。A先执行。A事务这个时候会把表给锁住，B事务执行的时候直接报错。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据库事务&quot;&gt;&lt;a href=&quot;#数据库事务&quot; class=&quot;headerlink&quot; title=&quot;数据库事务&quot;&gt;&lt;/a&gt;数据库事务&lt;/h1&gt;&lt;h3 id=&quot;事务的基本要素-4大性质&quot;&gt;&lt;a href=&quot;#事务的基本要素-4大性质&quot; class=&quot;headerlink&quot; title=&quot;事务的基本要素 4大性质&quot;&gt;&lt;/a&gt;&lt;strong&gt;事务的基本要素 4大性质&lt;/strong&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;原子性:事务开始后的所有操作,要么全部成功,要么全部失败回滚,不可能停滞在中间环节.事务执行过程中出错,会回滚到事务开始之前的状态,所有操作就像没有发生一样.也就是说事务是一个不可分割的整体,就像化学中学过的原子,是事务构成的基本单位.&lt;/li&gt;
&lt;li&gt;一致性:事务开始前和结束后,数据库的完整性约束没有被破坏,如A向B转张,不可能出现A扣了钱而B却没有加的情况&lt;/li&gt;
&lt;li&gt;隔离性:同一时间,只允许一个事务请求同一数据,不同事务之间彼此没有任何干扰,如A正在从一张银行卡中取钱,在A取钱的过程结束前,B不能向这张卡转账.&lt;/li&gt;
&lt;li&gt;持久性:事务完成之后,事务对数据库更新将会被保存写在数据库上,不能回滚.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://devildyw.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="database" scheme="https://devildyw.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>每日一记--synchronized关键字</title>
    <link href="https://devildyw.github.io/2022/02/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0--synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://devildyw.github.io/2022/02/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0--synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-04-16T08:53:36.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每日一记–synchronized关键字"><a href="#每日一记–synchronized关键字" class="headerlink" title="每日一记–synchronized关键字"></a>每日一记–synchronized关键字</h1><h2 id="synchronized关键字（隐式的获取和释放锁）"><a href="#synchronized关键字（隐式的获取和释放锁）" class="headerlink" title="synchronized关键字（隐式的获取和释放锁）"></a>synchronized关键字（隐式的获取和释放锁）</h2><p>作用于静态方法：</p><p><strong>对象锁</strong>给对象加锁（可以理解为这个对象的内存上锁，<strong>注意：只是这块内存，其他同类对象都会有各自的内存锁</strong>）这时候在其他一个以上线程中执行该对象的这个同步方法（<strong>注意：是该对象</strong>）就会产生互斥）</p><p>作用于静态方法：</p><p><strong>类锁</strong>：相当于在类上枷锁（*.class位于代码区，静态方法位于静态区域，这个类产生的对象公用这个静态方法，所以这块内存，N个对象来竞争），这时候，只要是这个类产生的对象，在调用这个静态方法时都会产生互斥</p><p><strong>对象锁与类锁区别</strong>：主要就在于内存区域不同 <strong>对象锁</strong>只作用与同类的单个对象的内存区域 <strong>类锁</strong>则作用于同类的所有对象的内存区域 </p><span id="more"></span><p>Java线程内存模型：每个线程都用拥有自己的栈、堆内存共享、如下图所示。锁是线程间内存和信息沟通的载体。<img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/491378-20160720152209982-808156316.png" alt="img"></p><p>Java中为了保证每个线程中的原子操作，引入了内置锁或者称监视器锁，其中，每个Java对象都可以作为实现锁的对象。</p><p>synchronized关键字修饰的代码块被称为同步代码块 ，线程进入同步代码块自动获取内置锁，退出同步代码块则释放锁，不需要调用者考虑它的创建以及消除而别的线程此时无法获得这把锁，就无法调用这个方法。一个线程想要获得这个锁只能等上一个线程执行结束这个方法将锁释放，下一个线程才能有机会调用这个方法获得该对象的锁（即synchronized关键字可以获得内置锁，同一时间只允许一个线程获得某个锁）。</p><blockquote><p>java的每个对象都有一个锁，不需要显示地去创建。</p><p><strong>java的内置锁</strong>：每个java对象都可以用做一个实现同步的锁，这些锁称为<strong>内置锁</strong>。<strong>线程</strong>进入同步代码块或方法的时候会<strong>自动获得该锁</strong>，在<strong>退出</strong>同步代码块或方法时会<strong>释放</strong>该锁。获得内置锁的<strong>唯一途径就是进入这个锁的保护的同步代码块或方法</strong>。</p><p><strong>java内置锁</strong>是一个<strong>互斥锁</strong>，这就意味着同一时间最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，线程A必须<strong>等待或者阻塞</strong>，直到线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。</p></blockquote><p><strong>1.同步方法（粗粒度锁）</strong>：</p><p>即有<strong>synchronized</strong>关键字修饰的方法。</p><p><strong>由于java中每个对象都有一个内置锁，当使用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.<strong>同步代码块（细粒度锁）</strong>：</p><p>即有<strong>synchronized</strong>关键字修饰的语句块。</p><p>被该关键字修饰的语句块会被自动加上内置锁，从而实现同步。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object)&#123; </span><br><span class="line">代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：同步是一种高开销的操作，因此应该尽量减少同步的内容。 通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。</strong> 同步会影响一定的多线程性能</p><p><strong>synchronized的缺陷</strong>：当某个线程进入同步方法获得对象锁，那么其他线程访问这里对象的同步方法时，必须等待或者阻塞，这对高并发的系统是致命的，这很容易导致系统的崩溃。如果某个线程在同步方法里面发生了死循环，那么它就永远不会释放这个对象锁，那么其他线程就要永远的等待。这是一个致命的问题。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;每日一记–synchronized关键字&quot;&gt;&lt;a href=&quot;#每日一记–synchronized关键字&quot; class=&quot;headerlink&quot; title=&quot;每日一记–synchronized关键字&quot;&gt;&lt;/a&gt;每日一记–synchronized关键字&lt;/h1&gt;&lt;h2 id=&quot;synchronized关键字（隐式的获取和释放锁）&quot;&gt;&lt;a href=&quot;#synchronized关键字（隐式的获取和释放锁）&quot; class=&quot;headerlink&quot; title=&quot;synchronized关键字（隐式的获取和释放锁）&quot;&gt;&lt;/a&gt;synchronized关键字（隐式的获取和释放锁）&lt;/h2&gt;&lt;p&gt;作用于静态方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象锁&lt;/strong&gt;给对象加锁（可以理解为这个对象的内存上锁，&lt;strong&gt;注意：只是这块内存，其他同类对象都会有各自的内存锁&lt;/strong&gt;）这时候在其他一个以上线程中执行该对象的这个同步方法（&lt;strong&gt;注意：是该对象&lt;/strong&gt;）就会产生互斥）&lt;/p&gt;
&lt;p&gt;作用于静态方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类锁&lt;/strong&gt;：相当于在类上枷锁（*.class位于代码区，静态方法位于静态区域，这个类产生的对象公用这个静态方法，所以这块内存，N个对象来竞争），这时候，只要是这个类产生的对象，在调用这个静态方法时都会产生互斥&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象锁与类锁区别&lt;/strong&gt;：主要就在于内存区域不同 &lt;strong&gt;对象锁&lt;/strong&gt;只作用与同类的单个对象的内存区域 &lt;strong&gt;类锁&lt;/strong&gt;则作用于同类的所有对象的内存区域 &lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE" scheme="https://devildyw.github.io/categories/JavaSE/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>每日一记--多线程（续）</title>
    <link href="https://devildyw.github.io/2022/02/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0--%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%BB%AD%EF%BC%89/"/>
    <id>https://devildyw.github.io/2022/02/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0--%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%BB%AD%EF%BC%89/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-04-16T08:53:43.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每日一记–多线程（续）"><a href="#每日一记–多线程（续）" class="headerlink" title="每日一记–多线程（续）"></a>每日一记–多线程（续）</h1><hr><p>今天看了看书 更了解了多线程。</p><h2 id="Java中的线程"><a href="#Java中的线程" class="headerlink" title="Java中的线程"></a>Java中的线程</h2><p><strong>程序</strong>：程序是一段静态的代码，他是应用软件执行的蓝本。</p><p><strong>进程</strong>：进程是程序的一次动态执行过程，它对应了从代码加载、执行至完毕的一个完整过程，这个过程也是进程本身从产生、发展至消亡的过程。</p><p><strong>线程</strong>：线程是比进程更小的执行单位。线程之间可以共享相同的内存单元（即内存中的堆区 包括代码和数据）并利用这些共享单元来实现数据交换、实时通信与必要的同步操作。</p><p><strong>进程与线程的关系</strong>：一个进程在其执行的过程中可以产生多个线程，形成多条执行线索，每条线索，即没有线程都有它自身的产生、存在与消亡的过程，也是一个动态的概念。</p><p><strong>多线程原理</strong>：我们知道，操作系统分时管理各个进程，按时间片轮流执行每个进程。Java的多线程就是在操作系统每次分时给Java程序一个时间片的cpu时间内，在若干个独立的可控制的线程之间进行切换。如果机器能有多个cpu处理器，那么JVM就能充分利用这些cpu，使得Java程序在同一时刻能获得多个时间片，Java程序就可以获得真实的线程并发执行效果。</p><p><strong>主线程</strong>：每个Java程序都有一个默认的主线程，这个线程就是当执行主类main方法开始执行时，当JVM加载代码发现main方法之后，就会启动一个线程，这个线程就被称为<strong>“主线程”</strong>，该线程负责执行main方法，如果在main方法的执行过程中再创建的线程 就称为<strong>其他线程</strong>。如果main方法中没有创建其他线程，那么当main方法执行完最后一个语句，JVM就会结束Java应用程序。如果main方法中有创建了其他线程，那么JVM就要在主线程和其他线程之间轮流切换，以保证每个线程都能有机会使用cpu资源。</p><p><strong>注</strong>：main方法即使执行完最后的语句（主线程结束），JVM也不会结束程序，JVM会等待程序中其他线程都结束才会结束Java应用程序。</p><span id="more"></span><hr><h3 id="线程的状态与生命周期"><a href="#线程的状态与生命周期" class="headerlink" title="线程的状态与生命周期"></a>线程的状态与生命周期</h3><p><strong>新建状态</strong>：当一个Thread类或其子类的对象被声明并创建时，新生的线程处于NEW状态。此时它已经有了相应的内存空间和其他资源，即此时线程已准备但尚未启动（未调用**start()**方法），此时JVM管理的线程中还没有这个线程。</p><p><strong>可运行状态</strong>：当处于NEW状态的线程调用了Thread类提供的**start()**方法，此时线程就会进入RUNNABLE状态，称为可运行状态，此时JVM就会知道有一个新的线程在等待切换了。</p><p><strong>中断状态</strong>：<strong>BOLOCKED、WAITING、TIMED_WAITING</strong>状态都属于中断状态，当中断的线程重新进入RUNNABLE状态后，一旦JVM将cpu使用权切换给该线程，<strong>run()<strong>方法将</strong>从中断出继续执行</strong>。</p><ul><li>JVM将从cpu资源从当前RUNNABLE线程切换给其他线程，是本线程让出cpu的使用权进入BLOCKED状态，进入BOLOCKED状态的线程必须等待JVM解除它的BLOCKED状态，再次进入RUNNABLE状态，并从中断处继续执行。</li><li>线程使用cpu资源期间，执行了<strong>sleep(int millsecond)</strong>,使得当前线程进入休眠状态。<strong>sleep(int millsecond)<strong>方法是Thread类的类方法，一个线程一旦执行了这个方法，就立刻让出cpu使用权，使当前线程处于</strong>TIMED_WAITING</strong>状态。经过至多参数<strong>millsecond</strong>指定的毫秒数之后，该线程再次进入RUNNABLE状态。</li><li>线程使用cpu资源期间，执行了wait()方法，使得当前线程进入<strong>WAITING</strong>状态。该状态的线程不会主动进入RUNNABLE状态，必须由其他线程调用**notify()**方法通知它，使得它进入RUNNABLE状态。</li></ul><p><strong>死亡状态</strong>：当一个线程执行完<strong>run()<strong>方法，该线程就完成了它的全部工作进入</strong>TERMINATED状态</strong>。</p><p><strong>注</strong>：只有处于NEW状态的线程才可以调用<strong>start()<strong>方法，处于其他状态的线程都不可以调用该方法，否则将会触发</strong>IllegalThreadStateException</strong>异常</p><hr><p>例：用继承Thread的子类创建两个线程，这两个线程在控制台分别输出五句“老虎”和“小猫”；主线程控制台输出6句主人。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DEVIL.多线程;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil(丁杨维)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-14-22:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E_06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;<span class="comment">//主线程</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">//通过Thread类子类创建一个线程 此时出NEW状态</span></span><br><span class="line">        <span class="type">Tiger</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tiger</span>();<span class="comment">//创建另一个线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Tiger线程的状态&quot;</span>+ t1.getState());<span class="comment">//获取线程的状态</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Cat线程的状态&quot;</span>+ t2.getState());</span><br><span class="line">        t1.start();<span class="comment">//启动线程 是现成进入RUNNABLE状态</span></span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;\n%s&quot;</span>,<span class="string">&quot;Tiger线程的状态&quot;</span>+ t1.getState());<span class="comment">//获取线程执行时状态</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;\n%s&quot;</span>,<span class="string">&quot;Cat线程的状态&quot;</span>+t2.getState());</span><br><span class="line">            System.out.printf(<span class="string">&quot;\n%s&quot;</span>,<span class="string">&quot;主人&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;\nTiger线程的状态&quot;</span>+ t1.getState());<span class="comment">//获取线程执行结束时状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Cat线程的状态&quot;</span>+ t2.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;|小猫&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;|老虎&quot;</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//延时1秒 使其进入TIMED_WAITING状态</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tiger线程的状态NEW</span><br><span class="line">Cat线程的状态NEW</span><br><span class="line">Tiger线程的状态RUNNABLE|老虎1|小猫1|小猫2|小猫3|小猫4|小猫5</span><br><span class="line"></span><br><span class="line">Cat线程的状态BLOCKED</span><br><span class="line">主人1</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">主人2</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">主人3</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">主人4</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">主人5</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">主人6</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">|老虎2|老虎3|老虎4|老虎5</span><br></pre></td></tr></table></figure><p><strong>注</strong>：程序在不同的计算机运行或在同一台计算机上反复运行的结果不尽相同，输出结果依赖于当前cpu使用情况。当其他线程的<strong>run()<strong>方法都结束了，线程进入</strong>死亡状态</strong>，只留下一个线程时，<strong>JVM</strong>不再将cpu资源切给主线程，等到最后一个线程也结束了，<strong>JVM</strong>就将java程序退出虚拟机，即java程序的结束。</p><hr><h3 id="线程的调度与优先级"><a href="#线程的调度与优先级" class="headerlink" title="线程的调度与优先级"></a>线程的调度与优先级</h3><blockquote><p>处于就绪状态的线程首先进入就绪队列排队等候cpu资源，同一时刻再就绪队列中的线程可能由多个。Java虚拟机（JVM）中的<strong>线程调度器</strong>负责管理线程，调度器把线程的的优先级分为了10个级别，分别用<strong>Thread类</strong>中的类常量表示。每个Java线程的优先级都为常数1~10，即<strong>Thread.MIN_PRIORITY和Thread.MAX_PRIORITY</strong>之间。<em><strong>如果没有明确第设置线程的优先级别，每个线程的优先级都默认为常数5</strong></em>，即<strong>Thread.NORM_PRIORITY</strong>。</p><p>线程的优先级可以通过<strong>setPriority(int grade)<strong>方法调整，该方法需要一个int参数代表设置线程的等级，如果该参数不在1~10的范围内，那么</strong>setPriority</strong>便会产生一个<strong>IllegalArgumentException</strong>异常。如果参数正常该方法会返回所设置的线程的优先级。（ <strong>注</strong>：有些操作系统只能识别3个级别，即1、5和10。）</p><p><strong>java线程调度器</strong>的任务就是使高优先级的线程能始终运行，一旦时间片有空闲，则使具有同等优先级的线程以轮流D这四个线程，且A和B的级别高于C和D，那么，Java调度器首先以轮流的方式执行A和B，一直等到A、B都执行完毕进入死亡状态，才会再C、D之间轮流切换。）</p><p><strong>注</strong>：在实际编程时，不提倡使用线程的优先级来保证算法的正确执行。如果要编写正确、跨平台的多线程代码，必须假设线程在任何时刻都有可能被剥夺cpu资源的使用权</p></blockquote><hr><h2 id="Java程序内存的简单分析"><a href="#Java程序内存的简单分析" class="headerlink" title="Java程序内存的简单分析"></a>Java程序内存的简单分析</h2><ul><li><strong>栈：</strong>一般来说，<strong>基本数据类型</strong>直接在栈中分配空间，<strong>局部变量</strong>（在方法代码段中定义的变量）也在栈中直接分配空间，<strong>当局部变量所在方法执行完成之后该空间便立刻被JVM回收</strong>，还有一种是<strong>引用数据类型</strong>，即我们通常所说的需要用<strong>关键字new创建出来的对象所对应的引用</strong>也是在栈空间中，此时，JVM在栈空间中给对象引用分配了一个地址空间（相当于一个门牌号，通过这个门牌号就可以找到你家），在堆空间中给该引用的对象分配一个空间，栈空间中的地址引用指向了堆空间中的对象区（通过门牌号找住址）；</li><li><strong>堆：</strong>一般用来存放用<strong>关键字new出来的数据</strong>。</li></ul><hr><h1 id="end"><a href="#end" class="headerlink" title="-end-"></a>-end-</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;每日一记–多线程（续）&quot;&gt;&lt;a href=&quot;#每日一记–多线程（续）&quot; class=&quot;headerlink&quot; title=&quot;每日一记–多线程（续）&quot;&gt;&lt;/a&gt;每日一记–多线程（续）&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;今天看了看书 更了解了多线程。&lt;/p&gt;
&lt;h2 id=&quot;Java中的线程&quot;&gt;&lt;a href=&quot;#Java中的线程&quot; class=&quot;headerlink&quot; title=&quot;Java中的线程&quot;&gt;&lt;/a&gt;Java中的线程&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;程序&lt;/strong&gt;：程序是一段静态的代码，他是应用软件执行的蓝本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;：进程是程序的一次动态执行过程，它对应了从代码加载、执行至完毕的一个完整过程，这个过程也是进程本身从产生、发展至消亡的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;：线程是比进程更小的执行单位。线程之间可以共享相同的内存单元（即内存中的堆区 包括代码和数据）并利用这些共享单元来实现数据交换、实时通信与必要的同步操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程与线程的关系&lt;/strong&gt;：一个进程在其执行的过程中可以产生多个线程，形成多条执行线索，每条线索，即没有线程都有它自身的产生、存在与消亡的过程，也是一个动态的概念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多线程原理&lt;/strong&gt;：我们知道，操作系统分时管理各个进程，按时间片轮流执行每个进程。Java的多线程就是在操作系统每次分时给Java程序一个时间片的cpu时间内，在若干个独立的可控制的线程之间进行切换。如果机器能有多个cpu处理器，那么JVM就能充分利用这些cpu，使得Java程序在同一时刻能获得多个时间片，Java程序就可以获得真实的线程并发执行效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主线程&lt;/strong&gt;：每个Java程序都有一个默认的主线程，这个线程就是当执行主类main方法开始执行时，当JVM加载代码发现main方法之后，就会启动一个线程，这个线程就被称为&lt;strong&gt;“主线程”&lt;/strong&gt;，该线程负责执行main方法，如果在main方法的执行过程中再创建的线程 就称为&lt;strong&gt;其他线程&lt;/strong&gt;。如果main方法中没有创建其他线程，那么当main方法执行完最后一个语句，JVM就会结束Java应用程序。如果main方法中有创建了其他线程，那么JVM就要在主线程和其他线程之间轮流切换，以保证每个线程都能有机会使用cpu资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：main方法即使执行完最后的语句（主线程结束），JVM也不会结束程序，JVM会等待程序中其他线程都结束才会结束Java应用程序。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE" scheme="https://devildyw.github.io/categories/JavaSE/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>每日一记</title>
    <link href="https://devildyw.github.io/2022/02/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    <id>https://devildyw.github.io/2022/02/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-04-16T08:53:30.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h1><hr><h2 id="栈简单应用之符号匹配"><a href="#栈简单应用之符号匹配" class="headerlink" title="栈简单应用之符号匹配"></a>栈简单应用之符号匹配</h2><p><strong>关键：</strong>读括号时，如果时括号的左半部分（正常情况下，括号的左半部分总是先读到）,如果遇到括号的右半部分，获取栈顶元素，如果匹配则弹出栈，如果不匹配依旧弹栈且哨兵flag记为FALSE,最后如果flag为TRUE且栈不为空或是flag为FALSE且栈为空则符号不匹配，如果栈为空且flag为TRUE则符号匹配。</p><span id="more"></span><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DEVIL.泛型与集合框架.堆栈;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil(丁杨维)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-12-18:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">栈应用之符号匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E_04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//先创建一个栈的对象</span></span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//设置哨兵 将他初始化为true</span></span><br><span class="line">        String str;</span><br><span class="line">        <span class="comment">//输入一行字符串其中包含符号(如&#x27;(&#x27; &#x27;)&#x27; &#x27;[&#x27; &#x27;]&#x27; &#x27;&#123;&#x27; &#x27;&#125;&#x27;);</span></span><br><span class="line">        str = sc.nextLine();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;str.length();i++)&#123;<span class="comment">//筛选已输入字符串中符合条件的符号</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&#x27;(&#x27;</span>||ch==<span class="string">&#x27;&#123;&#x27;</span>||ch==<span class="string">&#x27;[&#x27;</span>)&#123;<span class="comment">//如果字符为符合条件且为符号的左半部分则压入栈中</span></span><br><span class="line">                stack.push(ch);<span class="comment">//压栈操作</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果字符为符号的右半部分则获取栈顶元素进行匹配</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;)&#x27;</span>&amp;&amp; !stack.empty())&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.peek() == <span class="string">&#x27;(&#x27;</span>)&#123;<span class="comment">//栈不为空获取栈顶元素进行匹配 匹配成功 弹栈;</span></span><br><span class="line">                    stack.pop();<span class="comment">//弹栈</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;<span class="comment">//除此之外则匹配失败</span></span><br><span class="line">                    stack.pop();<span class="comment">//弹栈</span></span><br><span class="line">                    flag = <span class="literal">false</span>;<span class="comment">//哨兵赋值为false</span></span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//跳出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;&#125;&#x27;</span>&amp;&amp; !stack.empty())&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.peek() == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;]&#x27;</span>&amp;&amp; !stack.empty())&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.peek() == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后如果栈为空且哨兵值为true 则字符串中的符号完全匹配</span></span><br><span class="line">        <span class="keyword">if</span>(flag&amp;&amp;stack.empty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果栈不为空或是哨兵值为false抑或是两者都不满足 则字符串中符号匹配失败</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sc.close();<span class="comment">//最后关闭io流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输入样例1：</p><blockquote><p>{(1+2)*3+4&#x2F;(3-1)</p></blockquote><p>控制台输出：</p><blockquote><p>NO</p></blockquote><p>输入样例2：</p><blockquote><p>(1+2)*3+4&#x2F;(3-1)</p></blockquote><p>控制台输出：</p><blockquote><p>YES</p></blockquote><h2 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h2><hr><p><em><em>对称矩阵可以将一个n * n存储空间的数组压缩成一个n</em>(n+1)&#x2F;2大小的数组</em>* 一般拿一维数组存储。</p><p>接下来代码将展示一般对称矩阵压缩以及还原输出</p><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习题;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil(丁杨维)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-12-20:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对称矩阵</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E_21</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n;<span class="comment">//矩阵的行列数(对称矩阵的前提是行列数都相等)</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;=======================输入数据==============================&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入一个n*n的矩阵的n:&quot;</span>);</span><br><span class="line">        n = sc.nextInt();<span class="comment">//从键盘输入n</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入n*n矩阵的元素:&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[][] Array = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;Array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;Array[i].length; j++)&#123;</span><br><span class="line">                Array[i][j]=sc.nextInt();<span class="comment">//读入矩阵数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSymmetricMatrix(Array))&#123;<span class="comment">//判断是否是对称矩阵</span></span><br><span class="line">            System.out.println(<span class="string">&quot;输入的矩阵是对称矩阵&quot;</span>);</span><br><span class="line">            <span class="type">int</span>[] SymmetricMatrix = <span class="keyword">new</span> <span class="title class_">int</span>[n*(n+<span class="number">1</span>)/<span class="number">2</span>];<span class="comment">//初始化压缩矩阵</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//压缩矩阵下标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;Array.length; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i+<span class="number">1</span>; j++)&#123;</span><br><span class="line">                    SymmetricMatrix[index++] = Array[i][j];<span class="comment">//装载数据</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;=======================输出压缩后的矩阵==============================&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> symmetricMatrix : SymmetricMatrix) &#123;</span><br><span class="line">                System.out.print(symmetricMatrix+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">&quot;=========================还原对阵矩阵============================&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">                        <span class="comment">//上三角元素下标与压缩矩阵元素下标满足关系k = (j*(j+1)/2+i) k为压缩矩阵元素下标</span></span><br><span class="line">                        System.out.print(SymmetricMatrix[j*(j+<span class="number">1</span>)/<span class="number">2</span>+i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//下三角以及对角线元素下标与压缩矩阵元素下标满足关系k = (j*(j+1)/2+i)</span></span><br><span class="line">                        System.out.print(SymmetricMatrix[i*(i+<span class="number">1</span>)/<span class="number">2</span>+j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是对称矩阵的函数;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSymmetricMatrix</span><span class="params">(<span class="type">int</span>[][] Array)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;Array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt;Array[i].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Array[i][j]!=Array[j][i])&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还原对称矩阵时上三角部分：<em><em>上三角部分的元素下标与压缩矩阵元素下标满足关系k &#x3D; (j</em>(j+1)&#x2F;2+i) k为压缩矩阵元素下标</em>*</p><p>还原对称矩阵时上三角部分：<em><em>下三角以及对角线元素下标与压缩矩阵元素下标满足关系k &#x3D; (j</em>(j+1)&#x2F;2+i)</em>*</p><p>输入样例；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=======================输入数据==============================</span><br><span class="line">请输入一个n*n的矩阵的n:2</span><br><span class="line">请输入n*n矩阵的元素:</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">输入的矩阵是对称矩阵</span><br><span class="line">=======================输出压缩后的矩阵==============================</span><br><span class="line">121</span><br><span class="line">=========================还原对阵矩阵============================</span><br><span class="line">12</span><br><span class="line">21</span><br></pre></td></tr></table></figure><hr><p>接下来将展示输入一个已经压缩的对称矩阵将其还原输出</p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习题;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil(丁杨维)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-12-20:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E_22</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n, row;<span class="comment">//用于储存压缩矩阵的大小 和还原矩阵的大小</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;=======================输入数据==============================&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入压缩的对称矩阵的大小n:&quot;</span>);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请给出矩阵元素:&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[] SymmetricMatrix = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">//录入数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            SymmetricMatrix[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出压缩的对称矩阵</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n======================输出压缩的对称矩阵======================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            System.out.print(SymmetricMatrix[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取还原矩阵的行列数</span></span><br><span class="line">        <span class="keyword">for</span>(row = <span class="number">0</span>; row&lt;n; row++)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((row*(row+<span class="number">1</span>)/<span class="number">2</span>)==n)&#123;<span class="comment">//还原矩阵的行列数与压缩矩阵的长度 关系为n*(n+1)/2</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n======================还原输出对称矩阵======================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;row; j++)&#123;<span class="comment">//还原</span></span><br><span class="line">                <span class="keyword">if</span>(i&lt;j)&#123;<span class="comment">//上三角</span></span><br><span class="line">                    <span class="comment">//上三角元素下标与压缩矩阵元素下标满足关系k = (j*(j+1)/2+i) k为压缩矩阵元素下标</span></span><br><span class="line">                    System.out.print(SymmetricMatrix[j*(j+<span class="number">1</span>)/<span class="number">2</span>+i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;<span class="comment">//下三角以及对角线</span></span><br><span class="line">                    <span class="comment">//下三角以及对角线元素下标与压缩矩阵元素下标满足关系k = (j*(j+1)/2+i)</span></span><br><span class="line">                    System.out.print(SymmetricMatrix[i*(i+<span class="number">1</span>)/<span class="number">2</span>+j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输入样例：</p><blockquote><p>10</p><p>1 2 3 4 5 6 7 8 9 10</p></blockquote><p>控制台输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=======================输入数据==============================</span><br><span class="line">请输入压缩的对称矩阵的大小n:10</span><br><span class="line">请给出矩阵元素:</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line"></span><br><span class="line">======================输出压缩的对称矩阵======================</span><br><span class="line">12345678910</span><br><span class="line">======================还原输出对称矩阵======================</span><br><span class="line">1247</span><br><span class="line">2358</span><br><span class="line">4569</span><br><span class="line">78910</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="end"><a href="#end" class="headerlink" title="-end-"></a>-end-</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;栈简单应用之符号匹配&quot;&gt;&lt;a href=&quot;#栈简单应用之符号匹配&quot; class=&quot;headerlink&quot; title=&quot;栈简单应用之符号匹配&quot;&gt;&lt;/a&gt;栈简单应用之符号匹配&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;关键：&lt;/strong&gt;读括号时，如果时括号的左半部分（正常情况下，括号的左半部分总是先读到）,如果遇到括号的右半部分，获取栈顶元素，如果匹配则弹出栈，如果不匹配依旧弹栈且哨兵flag记为FALSE,最后如果flag为TRUE且栈不为空或是flag为FALSE且栈为空则符号不匹配，如果栈为空且flag为TRUE则符号匹配。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://devildyw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo</title>
    <link href="https://devildyw.github.io/2022/02/28/DUBBO/"/>
    <id>https://devildyw.github.io/2022/02/28/DUBBO/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-04-16T08:55:10.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DUBBO"><a href="#DUBBO" class="headerlink" title="DUBBO"></a>DUBBO</h1><h2 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a><a href="https://github.com/guangxush/SpringBoot_GRPC">RPC框架</a></h2><h3 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h3><p>RPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。</p><span id="more"></span><p>比较正式的描述是：一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p><p>那么我们至少从这样的描述中挖掘出几个要点：</p><ul><li>RPC是协议：既然是协议就只是一套规范，那么就需要有人遵循这套规范来进行实现。目前典型的RPC实现包括：Dubbo、Thrift、GRPC、Hetty等。</li><li>网络协议和网络IO模型对其透明：既然RPC的客户端认为自己是在调用本地对象。那么传输层使用的是TCP&#x2F;UDP还是HTTP协议，又或者是一些其他的网络协议它就不需要关心了。</li><li>信息格式对其透明：我们知道在本地应用程序中，对于某个对象的调用需要传递一些参数，并且会返回一个调用结果。至于被调用的对象内部是如何使用这些参数，并计算出处理结果的，调用方是不需要关心的。那么对于远程调用来说，这些参数会以某种信息格式传递给网络上的另外一台计算机，这个信息格式是怎样构成的，调用方是不需要关心的。</li><li>应该有跨语言能力：为什么这样说呢？因为调用方实际上也不清楚远程服务器的应用程序是使用什么语言运行的。那么对于调用方来说，无论服务器方使用的是什么语言，本次调用都应该成功，并且返回值也应该按照调用方程序语言所能理解的形式进行描述。</li></ul><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/640.png" alt="640"></p><hr><h3 id="为什么要用RPC"><a href="#为什么要用RPC" class="headerlink" title="为什么要用RPC"></a>为什么要用RPC</h3><p>其实这是应用开发到一定的阶段的强烈需求驱动的。如果我们开发简单的单一应用，逻辑简单、用户不多、流量不大，那我们用不着。当我们的系统访问量增大、业务增多时，我们会发现一台单机运行此系统已经无法承受。此时，我们可以将业务拆分成几个互不关联的应用，分别部署在各自机器上，以划清逻辑并减小压力。此时，我们也可以不需要RPC，因为应用之间是互不关联的。</p><p>当我们的业务越来越多、应用也越来越多时，自然的，我们会发现有些功能已经不能简单划分开来或者划分不出来。此时，可以将公共业务逻辑抽离出来，将之组成独立的服务Service应用 。而原有的、新增的应用都可以与那些独立的Service应用 交互，以此来完成完整的业务功能。</p><p>所以此时，我们急需一种高效的应用程序之间的通讯手段来完成这种需求，所以你看，RPC大显身手的时候来了！</p><p>其实描述的场景也是服务化 、微服务和分布式系统架构的基础场景。即RPC框架就是实现以上结构的有力方式。</p><h3 id="常用的RPC框架"><a href="#常用的RPC框架" class="headerlink" title="常用的RPC框架"></a>常用的RPC框架</h3><ul><li>Thrift：thrift是一个软件框架，用来进行可扩展且跨语言的服务的开发。它结合了功能强大的软件堆栈和代码生成引擎，以构建在 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml 这些编程语言间无缝结合的、高效的服务。</li><li>gRPC：一开始由 google 开发，是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。</li><li><strong>Dubbo</strong>：Dubbo是一个分布式服务框架，以及SOA治理方案。其功能主要包括：高性能NIO通讯及多协议集成，服务动态寻址与路由，软负载均衡与容错，依赖分析与降级等。Dubbo是阿里巴巴内部的SOA服务化治理方案的核心框架，Dubbo自2011年开源后，已被许多非阿里系公司使用。</li><li><strong>Spring Cloud</strong>：Spring Cloud由众多子项目组成，如Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Consul 等，提供了搭建分布式系统及微服务常用的工具，如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性token、全局锁、选主、分布式会话和集群状态等，满足了构建微服务所需的所有解决方案。Spring Cloud基于Spring Boot, 使得开发部署极其简单。</li></ul><h2 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h2><h3 id="RPC调用流程"><a href="#RPC调用流程" class="headerlink" title="RPC调用流程"></a>RPC调用流程</h3><p>要让网络通信细节对使用者透明，我们需要对通信细节进行封装，我们先看下一个RPC调用的流程涉及到哪些通信细节：</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220306235426986.png" alt="image-20220306235426986"></p><ol><li>服务消费方（client）调用以本地调用方式调用服务；</li><li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li><li>client stub找到服务地址，并将消息发送到服务端；</li><li>server stub收到消息后进行解码；</li><li>server stub根据解码结果调用本地的服务；</li><li>本地服务执行并将结果返回给server stub；</li><li>server stub将返回结果打包成消息并发送至消费方；</li><li>client stub接收到消息，并进行解码；</li><li>服务消费方得到最终结果。</li></ol><p>RPC的目标就是要2~8这些步骤都封装起来，让用户对这些细节透明。</p><p>下面是网上的另外一幅图，感觉一目了然：</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220306235500320.png" alt="image-20220306235500320"></p><h3 id="如何做到透明化远程服务调用"><a href="#如何做到透明化远程服务调用" class="headerlink" title="如何做到透明化远程服务调用"></a>如何做到透明化远程服务调用</h3><p>怎么封装通信细节才能让用户像以本地调用方式调用远程服务呢？对java来说就是使用代理！java代理有两种方式：1） jdk 动态代理；2）字节码生成。尽管字节码生成方式实现的代理更为强大和高效，但代码维护不易，大部分公司实现RPC框架时还是选择动态代理方式。</p><blockquote><p>其实就是通过动态代理模式，在执行该方法的前后对数据进行封装和解码等，让用于感觉就像是直接调用该方法一样，殊不知，我们对方法前后都经过了复杂的处理。(通过代理实现在调用方法前后进行编码和译码)</p></blockquote><h3 id="如何对消息进行编码和解码"><a href="#如何对消息进行编码和解码" class="headerlink" title="如何对消息进行编码和解码"></a>如何对消息进行编码和解码</h3><h4 id="确定消息数据结构"><a href="#确定消息数据结构" class="headerlink" title="确定消息数据结构"></a>确定消息数据结构</h4><p>客户端的请求消息结构一般需要包括以下内容：</p><ul><li>接口名称：在我们的例子里接口名是“HelloWorldService”，如果不传，服务端就不知道调用哪个接口了；</li><li>方法名：一个接口内可能有很多方法，如果不传方法名服务端也就不知道调用哪个方法；</li><li>参数类型&amp;参数值：参数类型有很多，比如有bool、int、long、double、string、map、list，甚至如struct等，以及相应的参数值；</li><li>超时时间 + requestID（标识唯一请求id）</li></ul><p>服务端返回的消息结构一般包括以下内容：</p><ul><li>状态code + 返回值</li><li>requestID(<strong>可以根据requestID去查验调用结果</strong>)</li></ul><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>一旦确定了消息的数据结构后，下一步就是要考虑序列化与反序列化了。</p><p>什么是序列化？序列化就是将数据结构或对象转换成二进制串的过程，也就是编码的过程。</p><p>什么是反序列化？将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。</p><p>为什么需要序列化？转换为二进制串后才好进行网络传输嘛！</p><p>为什么需要反序列化？将二进制转换为对象才好进行后续处理！</p><p>现如今序列化的方案越来越多，每种序列化方案都有优点和缺点，它们在设计之初有自己独特的应用场景，那到底选择哪种呢？从RPC的角度上看，主要看三点：</p><ul><li>通用性：比如是否能支持Map等复杂的数据结构；</li><li>性能：包括时间复杂度和空间复杂度，由于RPC框架将会被公司几乎所有服务使用，如果序列化上能节约一点时间，对整个公司的收益都将非常可观，同理如果序列化上能节约一点内存，网络带宽也能省下不少；</li><li>可扩展性：对互联网公司而言，业务变化飞快，如果序列化协议具有良好的可扩展性，支持自动增加新的业务字段，而不影响老的服务，这将大大提供系统的灵活度。</li></ul><p>目前互联网公司广泛使用Protobuf、Thrift、Avro等成熟的序列化解决方案来搭建RPC框架，这些都是久经考验的解决方案。</p><h3 id="如何发布自己的服务"><a href="#如何发布自己的服务" class="headerlink" title="如何发布自己的服务"></a>如何发布自己的服务</h3><p>通过注册中心将生产者和消费者联系起来,将生产者(消息的提供者)注册到注册中心,消费者通过与注册中心的长连接获得生产者的ip去获得服务. <strong>java常用的是zookeeper</strong></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220306235517192.png" alt="image-20220306235517192"></p><hr><h2 id="Dubbo-Architecture"><a href="#Dubbo-Architecture" class="headerlink" title="Dubbo Architecture"></a><a href="https://dubbo.apache.org/zh/docs/">Dubbo Architecture</a></h2><p>Dubbo 提供了构建云原生微服务业务的一站式解决方案，可以使用 Dubbo 快速定义并发布微服务组件，同时基于 Dubbo 开箱即用的丰富特性及超强的扩展能力，构建运维整个微服务体系所需的各项服务治理能力，如 Tracing、Transaction 等，Dubbo 提供的基础能力包括：</p><ul><li>服务发现</li><li>流式通信</li><li>负载均衡</li><li>流量治理</li><li>…..</li></ul><p>Dubbo 计划提供丰富的多语言客户端实现，其中 Java、Golang 版本是当前稳定性、活跃度最好的版本，其他多语言客户端[]正在持续建设中。</p><p><strong>Dubbo的优点</strong>:</p><blockquote><ul><li>开箱即用<ul><li>易用性高，如 Java 版本的面向接口代理特性能实现本地透明调用</li><li>功能丰富，基于原生库或轻量扩展即可实现绝大多数的微服务治理能力</li></ul></li><li>超大规模微服务集群实践<ul><li>高性能的跨进程通信协议</li><li>地址发现、流量治理层面，轻松支持百万规模集群实例</li></ul></li><li>企业级微服务治理能力<ul><li>服务测试</li><li>服务Mock</li></ul></li></ul></blockquote><p>Dubbo3 是在云原生背景下诞生的，使用 Dubbo 构建的微服务遵循云原生思想，能更好的复用底层云原生基础设施、贴合云原生微服务架构。这体现在：</p><ul><li>服务支持部署在容器、Kubernetes平台，服务生命周期可实现与平台调度周期对齐；</li><li>支持经典 Service Mesh 微服务架构，引入了 Proxyless Mesh 架构，进一步简化 Mesh 的落地与迁移成本，提供更灵活的选择；</li><li>作为桥接层，支持与 SpringCloud、gRPC 等异构微服务体系的互调互通</li></ul><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>服务发现，即消费端自动发现服务地址列表的能力，是微服务框架需要具备的关键能力，借助于自动化的服务发现，微服务之间可以在无需感知对端部署位置与 IP 地址的情况下实现通信。</p><p>Dubbo提供的是一种Client-Based的服务发现机制,通常还需要部署第三方的注册中心来实现,例如Nacos,Consul,Zookeeper等,Dubbo自身也提供了对多种注册中心组件的对接,用户可以灵活选择.</p><p>Dubbo 基于消费端的自动服务发现能力，其基本工作原理如下图：</p><p><img src="https://dubbo.apache.org/imgs/architecture.png" alt="//imgs/architecture.png"></p><p><img src="https://dubbo.apache.org/imgs/v3/concepts/threecenters.png" alt="//imgs/v3/concepts/threecenters.png"></p><p>服务发现的一个核心组件是注册中心,Provider注册ip地址到注册中心,Consumer从注册中心读取和订阅Provider地址列表,因此要启用服务发现需要为Dubbo增加注册中心的配置</p><p><code>dubbo-spring-boot-starter</code>使用方式 增加registry配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"><span class="string">dubbo</span></span><br><span class="line"> <span class="string">registry</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">zookeeper://127.0.0.1:2181</span></span><br></pre></td></tr></table></figure><h3 id="Dubbo的协议-RPC-通信协议-Apache-Dubbo"><a href="#Dubbo的协议-RPC-通信协议-Apache-Dubbo" class="headerlink" title="]Dubbo的协议](RPC 通信协议 | Apache Dubbo)"></a>]Dubbo的协议](<a href="https://dubbo.apache.org/zh/docs/concepts/rpc-protocol/">RPC 通信协议 | Apache Dubbo</a>)</h3><ul><li><p><strong>Triple</strong></p><blockquote><p><strong>Triple</strong>是一种兼容 gRPC ，以 HTTP2 作为传输层构建新的协议.</p></blockquote></li></ul><h3 id="Dubbo-服务流量管理-服务流量管理-Apache-Dubbo"><a href="#Dubbo-服务流量管理-服务流量管理-Apache-Dubbo" class="headerlink" title="[Dubbo 服务流量管理](服务流量管理 | Apache Dubbo)"></a>[Dubbo 服务流量管理](<a href="https://dubbo.apache.org/zh/docs/concepts/traffic-management/">服务流量管理 | Apache Dubbo</a>)</h3><h4 id="流量管理"><a href="#流量管理" class="headerlink" title="流量管理"></a>流量管理</h4><p>流量管理的本质是将请求根据制定好的路由规则分发到应用服务上，如下图所示：</p><p><img src="https://dubbo.apache.org/imgs/v3/concepts/what-is-traffic-control.png" alt="What is traffic control"></p><ul><li>路由规则可以有多个，不同的路由规则之间存在优先级。如：<strong>Router(1) -&gt; Router(2) -&gt; …… -&gt; Router(n)</strong></li><li>一个路由规则可以路由到多个不同的应用服务。如：Router(2)既可以路由到Service(1)也可以路由到Service(2)</li><li>多个不同的路由规则可以路由到同一个应用服务。如：Router(1)和Router(2)都可以路由到Service(2)</li><li>路由规则也可以不路由到任何应用服务。如：Router(m)没有路由到任何一个Service上，所有命中Router(m)的请求都会因为没有对应的应用服务处理而导致报错</li><li>应用服务可以是单个的实例，也可以是一个应用集群。</li></ul><h3 id="Dubbo的配置"><a href="#Dubbo的配置" class="headerlink" title="Dubbo的配置"></a>Dubbo的配置</h3><h4 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h4><p>即采用xml格式的配置文件 配置Dubbo 详情参数和配置参考官方文档</p><p><a href="https://dubbo.apache.org/zh/docs/references/xml/">Schema 配置参考手册 | Apache Dubbo</a></p><h4 id="注解配置-注解配置-Apache-Dubbo"><a href="#注解配置-注解配置-Apache-Dubbo" class="headerlink" title="[注解配置](注解配置 | Apache Dubbo)"></a>[注解配置](<a href="https://dubbo.apache.org/zh/docs/references/configuration/annotation/#%E5%A2%9E%E5%8A%A0%E5%BA%94%E7%94%A8%E5%85%B1%E4%BA%AB%E9%85%8D%E7%BD%AE">注解配置 | Apache Dubbo</a>)</h4><h5 id="服务提供方"><a href="#服务提供方" class="headerlink" title="服务提供方"></a>服务提供方</h5><p>**<code>@DubboService</code>**注解暴露服务</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DubboService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AnnotationService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;annotation: hello, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="增加应用共享配置"><a href="#增加应用共享配置" class="headerlink" title="增加应用共享配置"></a>增加应用共享配置</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dubbo-provider.properties</span></span><br><span class="line"><span class="attr">dubbo.application.name</span>=<span class="string">annotation-provider</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="attr">dubbo.protocol.name</span>=<span class="string">dubbo</span></span><br><span class="line"><span class="attr">dubbo.protocol.port</span>=<span class="string">20880</span></span><br></pre></td></tr></table></figure><h5 id="增加spring扫描路径"><a href="#增加spring扫描路径" class="headerlink" title="增加spring扫描路径"></a>增加spring扫描路径</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableDubbo(scanBasePackages = &quot;org.apache.dubbo.samples.simple.annotation.impl&quot;)</span><span class="comment">//也可以在启动类上配置 启动类本身也就是一个配置类</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/spring/dubbo-provider.properties&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderConfiguration</span> &#123;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="服务消费方"><a href="#服务消费方" class="headerlink" title="服务消费方"></a>服务消费方</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;annotationAction&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationAction</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DubboReference</span></span><br><span class="line">    <span class="keyword">private</span> AnnotationService annotationService;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doSayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> annotationService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="增加应用共享配置-1"><a href="#增加应用共享配置-1" class="headerlink" title="增加应用共享配置"></a>增加应用共享配置</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dubbo-consumer.properties</span></span><br><span class="line"><span class="attr">dubbo.application.name</span>=<span class="string">annotation-consumer</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="attr">dubbo.consumer.timeout</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure><h5 id="指定Spring扫描路径"><a href="#指定Spring扫描路径" class="headerlink" title="指定Spring扫描路径"></a>指定Spring扫描路径</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableDubbo(scanBasePackages = &quot;org.apache.dubbo.samples.simple.annotation.action&quot;)</span><span class="comment">//同样可以在启动类中配置 也可在配置文件中配置</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/spring/dubbo-consumer.properties&quot;)</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &#123;&quot;org.apache.dubbo.samples.simple.annotation.action&quot;&#125;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用服务"><a href="#调用服务" class="headerlink" title="调用服务"></a>调用服务</h4><p>配置完一切就可以(先启动生产者 在启动消费者)像调用本地方法一样去调用远程服务了(不用去考虑底层的传输协议 编码解码之类的繁琐的东西)</p><hr><h3 id="Dubbo的使用"><a href="#Dubbo的使用" class="headerlink" title="Dubbo的使用"></a>Dubbo的使用</h3><p>对于Dubbo而言一个完整的简单的Dubbo项目应该有如下三个模块 生产者(服务的提供者) 消费者(服务的消费者) API(暴露的接口名称和公共可用的信息)</p><ul><li><p>创建一个简单的Demo Maven工程</p></li><li><p>创建三个子工程分别是**<code>consumer provider dubbo-api</code>**</p></li><li><p>首先编写dubbo-api编写其中的service接口和需要用的其他信息(consumer和provider都能用到的信息 比如实体类 访问的param对象等)注意: 类应当实现序列化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MailUserService</span> &#123;</span><br><span class="line">    Result <span class="title function_">save</span><span class="params">(MailUser mailUser)</span>;</span><br><span class="line"></span><br><span class="line">    Result&lt;MailUser&gt; <span class="title function_">selectUserById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    Result&lt;MailUser&gt; <span class="title function_">selectUserByInfo</span><span class="params">(MailUser mailUser)</span>;</span><br><span class="line"></span><br><span class="line">    Result&lt;List&lt;MailUser&gt;&gt; <span class="title function_">selectUserList</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Result&lt;String&gt; <span class="title function_">sendMail</span><span class="params">(MailDTO mailDTO)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220306214920772.png" alt="image-20220306214920772"></p><p><strong>然后将其打包上传到本地仓库或是远程仓库供生产者和消费者使用</strong></p></li><li><p>在provider 和 consumer中都加入 </p><blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--这个是dubbo的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这个是注册中心的依赖 这里使用的是zookeeper--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-dependencies-zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这个是公用的api依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dyw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Demo-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.2-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>在provider中实现dubbo-api中的编写的接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@DubboService</span> <span class="comment">//使用该注解可以将该服务注册到注册中心 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailUserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MailUserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(MailUser mailUser)</span> &#123;</span><br><span class="line">        userMapper.insert(mailUser);</span><br><span class="line">        <span class="keyword">return</span> R.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;MailUser&gt; <span class="title function_">selectUserById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;MailUser&gt; mailUserLambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        mailUserLambdaQueryWrapper.eq(MailUser::getId, id).last(<span class="string">&quot;last 1&quot;</span>);</span><br><span class="line">        <span class="type">MailUser</span> <span class="variable">mailUser</span> <span class="operator">=</span> userMapper.selectOne(mailUserLambdaQueryWrapper);</span><br><span class="line">        <span class="keyword">return</span> R.success(mailUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;MailUser&gt; <span class="title function_">selectUserByInfo</span><span class="params">(MailUser mailUser)</span> &#123;</span><br><span class="line">        <span class="type">MailUser</span> <span class="variable">mailUser1</span> <span class="operator">=</span> userMapper.selectById(mailUser);</span><br><span class="line">        <span class="keyword">return</span> R.success(mailUser1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;MailUser&gt;&gt; <span class="title function_">selectUserList</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;MailUser&gt; mailUsers = userMapper.selectList(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> R.success(mailUsers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">sendMail</span><span class="params">(MailDTO mailDTO)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; idList = mailDTO.getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sendTime</span> <span class="operator">=</span> mailDTO.getSendTime();</span><br><span class="line">        <span class="type">String</span> <span class="variable">subject</span> <span class="operator">=</span> mailDTO.getSubject();</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> mailDTO.getContent();</span><br><span class="line">        List&lt;MailUser&gt; userList = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(subject) || StringUtils.isBlank(content)) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.fail(<span class="string">&quot;参数有误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idList.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            userList = userMapper.selectList(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            userList = userMapper.selectBatchIds(idList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(sendTime)) &#123;</span><br><span class="line">            sendTime = <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        mailDTO.setUserList(userList);</span><br><span class="line">        mailDTO.setSendTime(sendTime);</span><br><span class="line"></span><br><span class="line">        rocketMQTemplate.asyncSend(<span class="string">&quot;notice:mail&quot;</span>, mailDTO, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;发送信息成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;发送失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> R.success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>编写实现完所有的接口后 记得将服务注册到注册中心 这里需要配置dubbo 和 服务中心的信息</p><blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">&gt;dubbo:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Demo-provider</span> <span class="comment">#应用名称</span></span><br><span class="line"><span class="attr">registry:</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">zookeeper://localhost:2181</span> <span class="comment">#注册中心地址</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">6000</span> <span class="comment">#获取配置的超时时间</span></span><br><span class="line"><span class="attr">protocol:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">20880</span> <span class="comment">#服务端口</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dubbo</span> <span class="comment">#协议名称</span></span><br><span class="line"><span class="attr">scan:</span></span><br><span class="line">  <span class="attr">base-packages:</span> <span class="string">com.dyw.demoprovider.service.Impl</span> <span class="comment"># 扫描服务实现的包的位置 使用注解时才使用</span></span><br></pre></td></tr></table></figure><p>紧接着就是配置需要注册到注册中心的服务的信息(可以使用注解)如果使用spring-config配置服务的信息</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">     http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;demo-provider&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20890&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.dubbo.samples.basic.impl.DemoServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;org.apache.dubbo.samples.basic.api.DemoService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;demoService&quot;</span>/&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>在consumer中也需要配置注册中心的信息 来获取远端信息</p><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;dubbo:</span><br><span class="line">registry:</span><br><span class="line">  address: zookeeper:<span class="comment">//localhost:2181</span></span><br><span class="line">application:</span><br><span class="line">  name: Demo-Consumer</span><br></pre></td></tr></table></figure><p>完成上述配置后 就可以进行接口的调用了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">@RestController</span></span><br><span class="line">&gt;<span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="meta">@DubboReference</span></span><br><span class="line">  MailUserService mailUserService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span></span><br><span class="line">  <span class="keyword">public</span> Result&lt;List&lt;MailUser&gt;&gt; <span class="title function_">selectUserList</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mailUserService.selectUserList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span></span><br><span class="line">  <span class="keyword">public</span> Result&lt;MailUser&gt; <span class="title function_">addUser</span><span class="params">(<span class="meta">@RequestBody</span> MailUser mailUser)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mailUserService.save(mailUser);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Result&lt;MailUser&gt; <span class="title function_">selectUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mailUserService.selectUserById(id);</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">@RestController</span></span><br><span class="line">&gt;<span class="meta">@RequestMapping(&quot;mail&quot;)</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailController</span> &#123;</span><br><span class="line">  <span class="meta">@DubboReference</span></span><br><span class="line">  MailUserService mailUserService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span></span><br><span class="line">  <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">sendMail</span><span class="params">(<span class="meta">@RequestBody</span> MailDTO mailDTO)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mailUserService.sendMail(mailDTO);</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><p>你会发现一个有意思的事情 比如 我的mybatis log配置在生产者端 但是确实我的消费端看到了日志信息. 这也说明了服务是在消费者端实现的 证明了上述RPC框架的图</p></li></ul><h2 id="Dubbo高级用法"><a href="#Dubbo高级用法" class="headerlink" title="Dubbo高级用法"></a>Dubbo高级用法</h2><p>参考官方文档 用法很多</p><p><a href="https://dubbo.apache.org/zh/docs/advanced/">高级用法 | Apache Dubbo</a></p><h1 id="—-END—"><a href="#—-END—" class="headerlink" title="—-END—-"></a>—-END—-</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;DUBBO&quot;&gt;&lt;a href=&quot;#DUBBO&quot; class=&quot;headerlink&quot; title=&quot;DUBBO&quot;&gt;&lt;/a&gt;DUBBO&lt;/h1&gt;&lt;h2 id=&quot;RPC框架&quot;&gt;&lt;a href=&quot;#RPC框架&quot; class=&quot;headerlink&quot; title=&quot;RPC框架&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/guangxush/SpringBoot_GRPC&quot;&gt;RPC框架&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;什么是RPC&quot;&gt;&lt;a href=&quot;#什么是RPC&quot; class=&quot;headerlink&quot; title=&quot;什么是RPC&quot;&gt;&lt;/a&gt;什么是RPC&lt;/h3&gt;&lt;p&gt;RPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。&lt;/p&gt;</summary>
    
    
    
    <category term="中间件" scheme="https://devildyw.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ</title>
    <link href="https://devildyw.github.io/2022/02/28/RocketMQ/"/>
    <id>https://devildyw.github.io/2022/02/28/RocketMQ/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-04-16T08:55:31.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/concept.md">RocketMQ</a></h1><p><strong>MQ(Message Queue)</strong>:消息队列</p><span id="more"></span><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="消息模型（Message-Model）"><a href="#消息模型（Message-Model）" class="headerlink" title="消息模型（Message Model）:"></a>消息模型（Message Model）:</h3><p>RocketMQ主要由 <strong>Producer、Broker、Consumer 三部分组成</strong>，其中Producer 负责生产消息，Consumer 负责消费消息，<strong>Broker 负责存储消息</strong>。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。</p><h3 id="消息生产者（Producer）"><a href="#消息生产者（Producer）" class="headerlink" title="消息生产者（Producer）:"></a>消息生产者（Producer）:</h3><p>负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，<strong>同步发送、异步发送、顺序发送、单向发送</strong>。<strong>同步和异步方式均需要Broker返回确认信息，单向发送不需要。</strong></p><h3 id="消息消费者（Consumer）"><a href="#消息消费者（Consumer）" class="headerlink" title="消息消费者（Consumer）:"></a>消息消费者（Consumer）:</h3><p>负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。</p><h3 id="主题（Topic）"><a href="#主题（Topic）" class="headerlink" title="主题（Topic）:"></a>主题（Topic）:</h3><p>表示一类消息的集合，<strong>每个主题包含若干条消息，每条消息只能属于一个主题</strong>，(topic)<strong>是RocketMQ进行消息订阅的基本单位。</strong></p><h3 id="代理服务器（Broker-Server）"><a href="#代理服务器（Broker-Server）" class="headerlink" title="代理服务器（Broker Server）:"></a>代理服务器（Broker Server）:</h3><p><strong>消息中转角色，负责存储消息、转发消息。</strong>代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p><h3 id="名字服务（Name-Server）"><a href="#名字服务（Name-Server）" class="headerlink" title="名字服务（Name Server）:"></a>名字服务（Name Server）:</h3><p>名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/2ms3i8hm3a.jpg" alt="2ms3i8hm3a"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220222203606812.png" alt="image-20220222203606812"></p><p>由上图可知 Broker集群,producer集群,consumer集群都要与NameServer集群进行通信.</p><h3 id="拉取式消费（Pull-Consumer）"><a href="#拉取式消费（Pull-Consumer）" class="headerlink" title="拉取式消费（Pull Consumer）:"></a>拉取式消费（Pull Consumer）:</h3><p>Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、<strong>主动权由应用控制</strong>。一旦获取了批量消息，应用就会启动消费过程。</p><h3 id="推动式消费（Push-Consumer）"><a href="#推动式消费（Push-Consumer）" class="headerlink" title="推动式消费（Push Consumer）:"></a>推动式消费（Push Consumer）:</h3><p>Consumer消费的一种类型，<strong>该模式下Broker收到数据后会主动推送给消费端</strong>，该消费模式一般实时性较高。</p><h3 id="生产者组（Producer-Group）"><a href="#生产者组（Producer-Group）" class="headerlink" title="生产者组（Producer Group）:"></a>生产者组（Producer Group）:</h3><p><strong>同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。</strong>如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p><h3 id="消费者组（Consumer-Group）"><a href="#消费者组（Consumer-Group）" class="headerlink" title="消费者组（Consumer Group）:"></a>消费者组（Consumer Group）:</h3><p><strong>同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。</strong>消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，<strong>消费者组的消费者实例必须订阅完全相同的Topic。</strong>RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p><h3 id="集群消费（Clustering）"><a href="#集群消费（Clustering）" class="headerlink" title="集群消费（Clustering）:"></a>集群消费（Clustering）:</h3><p>集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</p><h3 id="广播消费（Broadcasting）"><a href="#广播消费（Broadcasting）" class="headerlink" title="广播消费（Broadcasting）:"></a>广播消费（Broadcasting）:</h3><p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。</p><h3 id="普通顺序消息（Normal-Ordered-Message）"><a href="#普通顺序消息（Normal-Ordered-Message）" class="headerlink" title="普通顺序消息（Normal Ordered Message）:"></a>普通顺序消息（Normal Ordered Message）:</h3><p>普通顺序消费模式下，消费者通过同一个消息队列（ Topic 分区，称作 Message Queue） 收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。</p><h3 id="严格顺序消息（Strictly-Ordered-Message）"><a href="#严格顺序消息（Strictly-Ordered-Message）" class="headerlink" title="严格顺序消息（Strictly Ordered Message）:"></a>严格顺序消息（Strictly Ordered Message）:</h3><p>严格顺序消息模式下，消费者收到的所有消息均是有顺序的。</p><h3 id="消息（Message）"><a href="#消息（Message）" class="headerlink" title="消息（Message）:"></a>消息（Message）:</h3><p><strong>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。</strong>RocketMQ中<strong>每个消息拥有唯一的Message ID</strong>，且<strong>可以携带具有业务标识的Key</strong>。系统提供了<strong>通过Message ID和Key查询消息</strong>的功能。</p><h3 id="标签（Tag）"><a href="#标签（Tag）" class="headerlink" title="标签（Tag）:"></a>标签（Tag）:</h3><p><strong>为消息设置的标志，用于同一主题下区分不同类型的消息。</strong>来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。<strong>标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统</strong>。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p><h3 id="MQ-Messages-Queue-三大优点"><a href="#MQ-Messages-Queue-三大优点" class="headerlink" title="MQ(Messages Queue)三大优点:"></a>MQ(Messages Queue)三大优点:</h3><ul><li>应用解耦: <strong>提高系统的容错性和可维护性</strong></li><li>削峰填谷: <strong>提升用户体验和系统的吞吐量</strong></li><li>异步提速:<strong>提高系统的稳定性</strong></li></ul><h3 id="通常的MQ-三大缺点"><a href="#通常的MQ-三大缺点" class="headerlink" title="通常的MQ 三大缺点:"></a>通常的MQ 三大缺点:</h3><ul><li><p>应用可用性降低</p><blockquote><p>系统引入的外部依赖越多, 系统的稳定性越差,一旦MQ宕机,就会对业造成影响.</p></blockquote></li><li><p>系统的复杂度提高</p><blockquote><p>MQ的加入大大增加了系统的复杂度,以前系统间是同步的远程调用,现在是通过MQ进行异步调用.</p></blockquote></li><li><p>一致性的问题(A B系统正常 但是C系统处理失败 会发生事务问题)</p><blockquote><p>A系统处理完业务,通过MQ给BCD三个系统发送消息数据,如果B系统,C系统处理成功,D系统处理失败.</p></blockquote></li></ul><hr><h2 id="单对单模式-初始RocketMQ"><a href="#单对单模式-初始RocketMQ" class="headerlink" title="单对单模式(初始RocketMQ)"></a>单对单模式(初始RocketMQ)</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><blockquote><ul><li>谁来发</li><li>发给谁</li><li>启动连接</li><li>发什么</li><li>怎么发</li><li>发的结果是?</li><li>关闭连接</li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQBrokerException, RemotingException, InterruptedException, MQClientException &#123;</span><br><span class="line">        <span class="comment">//1. 谁来发?</span></span><br><span class="line">        <span class="comment">//创建一个生产者</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="comment">/*可以在这里设置名称*/</span><span class="string">&quot;group1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.发给谁</span></span><br><span class="line">        <span class="comment">//发送给命名服务器 通过Name Server分配Brokerip 再由生产者发送给broker</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动连接</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.怎么发</span></span><br><span class="line">        <span class="comment">//发送Message apache包下的 网络传输都是字节流传输</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic1&quot;</span>,<span class="string">&quot;Tag1&quot;</span>,(<span class="string">&quot;Hello World&quot;</span>).getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.发什么</span></span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.发的结果是什么</span></span><br><span class="line">        <span class="comment">//SendResult 就是发送后的结果</span></span><br><span class="line">        System.out.println(sendResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.打扫战场</span></span><br><span class="line">        <span class="comment">//生产者是与name Server建立了一个长连接进行发送消息 所以发送完毕后 关闭连接</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><blockquote><ul><li>谁来收</li><li>从哪里收</li><li>监听那个消息队列</li><li>处理业务流程</li><li>启动连接</li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.谁来收</span></span><br><span class="line">        <span class="comment">//消费者有两种模式 一种是拉去(需要消费者自己去拉去) 一种是推送(消息主动推送给消费者)</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">pushConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.从哪里收</span></span><br><span class="line">        <span class="comment">//与生产者一样 消费者 也许要去name Server中获得对应broker的地址去获得消息</span></span><br><span class="line">        pushConsumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.监听那个消息队列</span></span><br><span class="line">        <span class="comment">//设置监听队列 subscribe:订阅 指定主题 和订阅表达式 &quot;*&quot;表示订阅主题中的所有</span></span><br><span class="line">        pushConsumer.subscribe(<span class="string">&quot;Topic1&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.处理业务流程</span></span><br><span class="line">        <span class="comment">//注册一个监听器 去监听是否有消息被生产 一有就立刻接收</span></span><br><span class="line">        pushConsumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                <span class="comment">//接收到的消息就是 List&lt;MessageExt&gt; msgs 这时我们就能写我们的业务逻辑</span></span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//启动连接</span></span><br><span class="line">        pushConsumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消费者启动起来了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意不要关闭消费者(如果还有对应主题的生产者的情况下 关闭就无法监听消息 就无法收到消息了)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一对多-单生产者-多消费者模式"><a href="#一对多-单生产者-多消费者模式" class="headerlink" title="一对多(单生产者 多消费者模式)"></a>一对多(单生产者 多消费者模式)</h2><h3 id="多消费者都在同一组中时"><a href="#多消费者都在同一组中时" class="headerlink" title="多消费者都在同一组中时"></a>多消费者都在同一组中时</h3><p><strong>消息会被分配到该组的不同消费者手中(当一个组中的消费者为偶数时平分)</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220223173114990.png" alt="image-20220223173114990"></p><h3 id="多消费者在不同组时"><a href="#多消费者在不同组时" class="headerlink" title="多消费者在不同组时"></a>多消费者在不同组时</h3><p><strong>每个组都会有完整的消息数目和消息信息(广播式 消息先被复制到不同的消费者组)</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220223173349238.png" alt="image-20220223173349238"></p><p>**特别的:**如果想在同一组中实现广播模式 可以在接收消息前设置消息的模式</p><blockquote><p><code>Consumer.setMessageModel(消息模式);</code></p><p>默认是CLUSTERING 负载均衡模式</p><p>可以设置为BROADCASTING 就是广播模式</p></blockquote><h2 id="多对多-多生产者-多消费者模式"><a href="#多对多-多生产者-多消费者模式" class="headerlink" title="多对多(多生产者 多消费者模式)"></a>多对多(多生产者 多消费者模式)</h2><p>对于生产者生产的消息而言</p><hr><h2 id="消息类别"><a href="#消息类别" class="headerlink" title="消息类别"></a>消息类别</h2><h3 id="同步消息"><a href="#同步消息" class="headerlink" title="同步消息"></a>同步消息</h3><p><strong>特征:</strong> 即时性较强,重要的消息,且必须有回执的消息,例如短息,通知(转账成功)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;Devilsproducer&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicTest&quot;</span>,<span class="string">&quot;TagA&quot;</span>,(<span class="string">&quot;Hello RocketMq &quot;</span>+ i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s%n&quot;</span>,sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步消息"><a href="#异步消息" class="headerlink" title="异步消息"></a>异步消息</h3><p><strong>特征:</strong> 即时性较弱,但需要有回执的消息,例如订单中的某些信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group3&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic3&quot;</span>, <span class="string">&quot;tag1&quot;</span>, msg.getBytes());</span><br><span class="line">            <span class="comment">//异步消息 Callback也是一个多线的接口</span></span><br><span class="line">            producer.send(message, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">                <span class="comment">//发送成功的回调方法a</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">                    System.out.println(sendResult);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//发送失败的回调方法</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                    System.out.println(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;异步发送完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单向消息"><a href="#单向消息" class="headerlink" title="单向消息"></a>单向消息</h3><p><strong>特征:</strong> 不需要有回执的信息,例如日志类消息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneWayProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group3&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//单项消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>+i;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic1&quot;</span>, <span class="string">&quot;tag1&quot;</span>, msg.getBytes());</span><br><span class="line">            <span class="comment">//发送单项消息 没有回执消息</span></span><br><span class="line">            producer.sendOneway(message);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送完成了&quot;</span>);</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h3><p><strong>特征:</strong> 消息发送时并不直接发送到消息服务器,而是根据设定等待的时间到达,起到延时到达的缓冲作用</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220223203009432.png" alt="image-20220223203009432"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//延时消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>+i;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic1&quot;</span>, <span class="string">&quot;tag1&quot;</span>, msg.getBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置延时 能分别设置每一条消息的延时等级 数字对应等级 而不是真正的时间</span></span><br><span class="line">            message.setDelayTimeLevel(<span class="number">4</span>);</span><br><span class="line">            <span class="comment">//发送延时消息</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line">            System.out.println(sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送成功了&quot;</span>);</span><br><span class="line">        <span class="comment">//断开连接</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h3><p><strong>特征:</strong> 一次发送多条消息,节约网络开销</p><p>原理就是通过producer可以通过send方法发送Collection(集合)的缘故 这样我们就可以将Message对象封装到一个集合中 通过send方法完成批量消息的发送</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过producer的send方法可以传输Collection的机制 我们只需要将消息封装到一个集合中 我们就能发送批量消息了</span></span><br><span class="line">        ArrayList&lt;Message&gt; messages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>+i;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic1&quot;</span>, <span class="string">&quot;tag1&quot;</span>, msg.getBytes());</span><br><span class="line">            messages.add(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//批量发送</span></span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">send</span> <span class="operator">=</span> producer.send(messages);</span><br><span class="line">        System.out.println(send);</span><br><span class="line">        System.out.println(<span class="string">&quot;批量消息发送成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><blockquote><ul><li><p>这些批量消息应该有相同的topic</p></li><li><p>相同的waitStoreMsgOK</p></li><li><p>不能是延时消息</p></li><li><p>消息内容的总长度不能超过4M</p></li><li><p>消息内容总长度包含如下:</p><blockquote><ol><li>topic(字符串字节数)</li><li>body(字节数组长度)</li><li>消息追加的属性(key与value对应的字符串字节数)</li><li>日志(固定20字节)</li></ol></blockquote></li></ul></blockquote><h2 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h2><p>语法过滤(属性过滤&#x2F;语法过滤&#x2F;SQL过滤):按照消息的某些属性过滤;</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220223210153476.png" alt="image-20220223210153476"></p><p>针对消费者而言在设置订阅消息的模式时, 可以设置主题(Topic) 还可以设置订阅表达式 该订阅表示就是用来过滤你要接收的消息的</p><hr><h3 id="Tag过滤"><a href="#Tag过滤" class="headerlink" title="Tag过滤"></a>Tag过滤</h3><p><strong><code>pushConsumer.subscribe(&quot;Topic1&quot;,MessageSelector.byTag(&quot;Tag1 || vip&quot;));</code></strong></p><p>表示只接收标签为Tag1 或者 vip的消息(默认不指定也是以Tag执行)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.谁来收</span></span><br><span class="line">        <span class="comment">//消费者有两种模式 一种是拉去(需要消费者自己去拉去) 一种是推送(消息主动推送给消费者)</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">pushConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.从哪里收</span></span><br><span class="line">        <span class="comment">//与生产者一样 消费者 也许要去name Server中获得对应broker的地址去获得消息</span></span><br><span class="line">        pushConsumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.监听那个消息队列</span></span><br><span class="line">        <span class="comment">//设置监听队列 subscribe:订阅 指定主题 和订阅表达式 &quot;*&quot;表示订阅主题中的所有</span></span><br><span class="line">        pushConsumer.subscribe(<span class="string">&quot;Topic1&quot;</span>,<span class="string">&quot;Tag1 || vip&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.处理业务流程</span></span><br><span class="line">        <span class="comment">//注册一个监听器 去监听是否有消息被生产 一有就立刻接收</span></span><br><span class="line">        pushConsumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                <span class="comment">//接收到的消息就是 List&lt;MessageExt&gt; msgs 这时我们就能写我们的业务逻辑</span></span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//启动连接</span></span><br><span class="line">        pushConsumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消费者启动起来了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意不要关闭消费者(如果还有对应主题的生产者的情况下 关闭就无法监听消息 就无法收到消息了)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SQL过滤"><a href="#SQL过滤" class="headerlink" title="SQL过滤"></a>SQL过滤</h3><p>要是使用sql过滤首先生产者方在发送消息时需要给消息添加参数 <strong><code>message.putUserProperty(&quot;key&quot;,&quot;value&quot;);</code></strong>(因为这不是Tag过滤 并且tag也无法搭载过多的信息)</p><p>使用SQL过滤之前需要在broker.conf添加</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开启对 propertyfilter的支持</span><br><span class="line">enablePropertyFilter = true</span><br><span class="line">filterSupportRetry = true</span><br></pre></td></tr></table></figure><p>然后再调用**<code>pushConsumer.subscribe(&quot;Topic1&quot;,MessageSelector.bySql(&quot;age&gt;18&quot;));</code>**</p><p><code>producer</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic1&quot;</span>,<span class="string">&quot;vip&quot;</span>,(<span class="string">&quot;Hello World&quot;</span>).getBytes());</span><br><span class="line"></span><br><span class="line">message.putUserProperty(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">message.putUserProperty(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.发什么</span></span><br><span class="line"><span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br></pre></td></tr></table></figure><p><code>consumer</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.谁来收</span></span><br><span class="line">        <span class="comment">//消费者有两种模式 一种是拉去(需要消费者自己去拉去) 一种是推送(消息主动推送给消费者)</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">pushConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.从哪里收</span></span><br><span class="line">        <span class="comment">//与生产者一样 消费者 也许要去name Server中获得对应broker的地址去获得消息</span></span><br><span class="line">        pushConsumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.监听那个消息队列</span></span><br><span class="line">        <span class="comment">//设置监听队列 subscribe:订阅 指定主题 和订阅表达式 &quot;*&quot;表示订阅主题中的所有</span></span><br><span class="line">        pushConsumer.subscribe(<span class="string">&quot;Topic1&quot;</span>, MessageSelector.bySql(<span class="string">&quot;age &gt; 16&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.处理业务流程</span></span><br><span class="line">        <span class="comment">//注册一个监听器 去监听是否有消息被生产 一有就立刻接收</span></span><br><span class="line">        pushConsumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                <span class="comment">//接收到的消息就是 List&lt;MessageExt&gt; msgs 这时我们就能写我们的业务逻辑</span></span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                    Map&lt;String, String&gt; properties = msg.getProperties();</span><br><span class="line">                    Iterator&lt;Map.Entry&lt;String,String&gt;&gt; iter = properties.entrySet().iterator();</span><br><span class="line">                    <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">                        Map.Entry&lt;String, String&gt; next = iter.next();</span><br><span class="line">                        System.out.println(next.getKey()+<span class="string">&quot; = &quot;</span>+next.getValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//启动连接</span></span><br><span class="line">        pushConsumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消费者启动起来了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意不要关闭消费者(如果还有对应主题的生产者的情况下 关闭就无法监听消息 就无法收到消息了)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Springboot整合RocketMQ"><a href="#Springboot整合RocketMQ" class="headerlink" title="Springboot整合RocketMQ"></a>Springboot整合RocketMQ</h2><ul><li>导入Springboot与RocketMQ整合starter</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>可以在application中配置rocketmq name-server的ip地址 和生产者的信息 或是消费者的信息</li></ul><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="attr">name-server:</span> <span class="string">localhost:9876</span></span><br><span class="line">  <span class="attr">consumer:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">group1</span></span><br><span class="line">  <span class="attr">producer:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">group1</span></span><br></pre></td></tr></table></figure><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><ul><li><p>在使用时 我们需要将springboot容器中的RocketMQTemplate(使用@Autowired)注册到我们的类中</p></li><li><p><strong>RocketMQTemplate:RocketMQ模板类 : 建立连接 断开连接</strong></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;<span class="comment">//RocketMQ模板类: 建连接 短链接</span></span><br></pre></td></tr></table></figure><ul><li><p>Springboot中传输的消息是Springboot框架提供的 <strong><code>org.springframework.messaging.Message&lt;T&gt;</code></strong></p></li><li><p>可以使用 <strong><code>org.springframework.messaging.support.MessageBuilder</code><strong>的</strong>静态方法withPayload(T payload)新建一个消息构建器 再调用build()方法</strong> 就可以将<strong>payload转换为一个Message对象</strong></p></li><li><p>上述都是使用send方法发送信息的需要做的 我们可以使用rocketMQTemplate的其他方法 例如 **<code>converAndSend()</code><strong>该方法由名字就知道它可以转化并且发送 它可以将java对象转化为</strong><code>org.springframework.messaging.Message&lt;T&gt;</code>**发送</p></li><li><p>除了上述两种方法 还有**<code>syncSend(), asyncSend(), sendOneWay() </code><strong>分别对应着同步,异步,单向消息 还可以在方法的参数上添加</strong><code>timeout delayLevel</code>**等参数以达到延时效果</p></li></ul><p><strong>注意:</strong> 这里不再是单纯的填入Topic了而是<strong>destination</strong> 并且格式是 <strong><code>topicName:tags</code></strong> </p><p>RocketMQ获取destination的源码</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220224202331947.png" alt="image-20220224202331947"></p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><ul><li><p>Consumer方面我们使用了监听器的方式来接收消息 实现RocketMQ自带的**<code>RocketMQListener&lt;T&gt;</code>** T指的**<code>withpayload</code>**中的消息类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span> <span class="comment">//注册到容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConsumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收成功的回调方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(User message)</span> &#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>设置了接收的监听器 我们还要设置监听的消息的主题 消息过滤 还有消费者组的名称 才能满足RocketMQ的规范</p><ul><li>这里我们使用**<code>rocketmq-spring-boot-starter</code><strong>的注解</strong><code>@RocketMQMessageListener</code>**设置参数 因为name-server在application.yml中我们已经设置了 springboot会自动识别并且设置.</li></ul></li><li><p>@RocketMQMessageListener</p><blockquote><ul><li>topic:主题</li><li>selectorExpression:过滤表达式</li><li>selectorType:设置过滤类型(Tag or Sql)</li><li>consumerGroup: 消费者组的名称</li><li>messageModel:消息的模式(广播或是集群)</li></ul></blockquote></li></ul></li></ul><p><strong><code>Producer</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;<span class="comment">//RocketMQ模板类: 建连接 短链接</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/send&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Devil&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        rocketMQTemplate.convertAndSend(<span class="string">&quot;Topic2&quot;</span>,user);<span class="comment">//convert: 消息转换为字节数组 甚至可以自动将对象转化为字节数组 但必须实现序列化</span></span><br><span class="line"></span><br><span class="line">        rocketMQTemplate.syncSend(<span class="string">&quot;Topic2&quot;</span>,user);<span class="comment">//发送同步消息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送异步消息</span></span><br><span class="line">        rocketMQTemplate.asyncSend(<span class="string">&quot;Topic2&quot;</span>, user, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">            <span class="comment">//发送成功的回调方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//发送失败的回调方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送单项消息</span></span><br><span class="line">        rocketMQTemplate.sendOneWay(<span class="string">&quot;Topic2&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送延时消息</span></span><br><span class="line">        rocketMQTemplate.syncSend(<span class="string">&quot;Topic2:tag1&quot;</span>, MessageBuilder.withPayload(user).build(),<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>Consumer</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(topic = &quot;Topic2&quot;,selectorExpression = &quot;tag1 || tag2&quot;,consumerGroup = &quot;$&#123;rocketmq.producer.group&#125;&quot;,</span></span><br><span class="line"><span class="meta">        selectorType = SelectorType.TAG,messageModel = MessageModel.BROADCASTING)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConsumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收成功的回调方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(User message)</span> &#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="消息顺序"><a href="#消息顺序" class="headerlink" title="消息顺序"></a>消息顺序</h2><p> <strong>消息错乱的原因:</strong></p><blockquote><p>默认消息的发送是每条消息按照 依次按照queue的顺序进入queue 即:<strong>队列内无序,队列外有序</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220224214903923.png" alt="image-20220224214903923"></p><p><strong><code>Producer</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这样发送会导致消息错乱</span></span><br><span class="line"><span class="keyword">for</span> (OrderStep orderStep : orderSteps) &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;topic3&quot;</span>, <span class="string">&quot;tag1&quot;</span>, orderStep.toString().getBytes());</span><br><span class="line">    <span class="type">SendResult</span> <span class="variable">send</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line"></span><br><span class="line">    System.out.println(send);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Consumer</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这样接收会导致消息错乱</span></span><br><span class="line">pushConsumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">        <span class="comment">//接收到的消息就是 List&lt;MessageExt&gt; msgs 这时我们就能写我们的业务逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><p><strong>纠正消息错乱:</strong></p><blockquote><p>修改消息的顺序,即指定消息进入的队列, 完整的顺序(订单的完整流程 创建 支付 完成)应当进入同一个消息队列. 即:<strong>队列内有序,队列外无序</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220224214826242.png" alt="image-20220224214826242"></p><p>为了使得生产的消息有序可以在producer中发送消息时指定消息进入的消息队列</p><p><strong><code>producer.send(message, new MessageQueueSelector() &#123;...&#125;,null);</code></strong> 其中的**<code>MessageQueueSelector()</code>**接口的select方法就可以指定消息填充的队列的队列id 更具这个id就可以获得这个队列 再通过send方法 发送到这个队列中</p><p><strong><code>Producer</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正确的发送</span></span><br><span class="line"><span class="keyword">for</span> (OrderStep orderStep : orderSteps) &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;topic3&quot;</span>, <span class="string">&quot;tag1&quot;</span>, orderStep.toString().getBytes());</span><br><span class="line">    <span class="type">SendResult</span> <span class="variable">send</span> <span class="operator">=</span> producer.send(message, <span class="keyword">new</span> <span class="title class_">MessageQueueSelector</span>() &#123;</span><br><span class="line">        <span class="comment">//这个方法就是队列悬着的方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> MessageQueue <span class="title function_">select</span><span class="params">(List&lt;MessageQueue&gt; mqs<span class="comment">/*消息队里额*/</span>, Message msg, Object arg)</span> &#123;</span><br><span class="line">            <span class="comment">//队列数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> mqs.size();</span><br><span class="line">            <span class="comment">//确定的orderId对应确定的队列 取模运算</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">orderId</span> <span class="operator">=</span> (<span class="type">int</span>) (orderStep.getOrderId());</span><br><span class="line">            <span class="type">int</span> <span class="variable">queueId</span> <span class="operator">=</span> orderId % size;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//根据 计算出的queueId 从List&lt;MessageQueue&gt; mqs中获取消息队列</span></span><br><span class="line">            <span class="keyword">return</span> mqs.get(queueId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(send);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于Consumer需要注册<strong>顺序的监听器</strong> 作用就是一个线程只监听一个MessageQueue 这样就可以接收一个queue中的消息了</p><p>而一个queue中都是producer生产的顺序的消息.</p><blockquote><p> <strong><code>new MessageListenerOrderly()&#123;...&#125;</code></strong></p></blockquote><p><strong><code>Consumer</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消费者注册一个顺序的监听器 作用就是一个线程只监听一个MessageQueue</span></span><br><span class="line">pushConsumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerOrderly</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeOrderlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(context.getMessageQueue().getQueueId());</span><br><span class="line">        <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><h3 id="RocketMQ事务流程概要"><a href="#RocketMQ事务流程概要" class="headerlink" title="RocketMQ事务流程概要"></a>RocketMQ事务流程概要</h3><p>RocketMQ实现事务主要分为两个阶段: 正常事务的发送及提交、事务信息的补偿流程(都是针对生产者 因为事务只出现在DataBase中 有些情况需要将消息存储在数据库中 如果发生事务问题….)</p><p><strong>整体流程为:</strong></p><blockquote><ul><li>正常事务发送与提交阶段<ol><li>生产者发送一个半消息给broker(半消息是指的暂时不能消费的消息)</li><li>服务端响应消息写入结果,半消息发送成功</li><li>开始执行本地事务</li><li>根据本地事务的执行情况执行Commit或者Rollback</li></ol></li><li>事务信息的补偿流程<ol><li>如果broker长时间没有收到本地事务的执行状态,会向生产者发起一个确认会查的操作请求</li><li>生产者收到确认会查请求后,检查本地事务的执行状态</li><li>根据检查后的结果执行Commit或者Rollback操作 补偿阶段主要是用于解决生产者在发送Commit或者Rollbacke操作时发生超时或失败的情况</li></ol></li></ul><p><img src="https://pic3.zhimg.com/80/v2-325e5949a667b144f2684caac49dd41a_720w.png" alt="img"></p></blockquote><h3 id="RocketMQ事务流程关键"><a href="#RocketMQ事务流程关键" class="headerlink" title="RocketMQ事务流程关键"></a>RocketMQ事务流程关键</h3><ul><li><p><strong>事务消息在一阶段对用户不可见</strong> </p><p>事务消息相对普通消息最大的特点就是一阶段发送的消息对用户是不可见的,也就是说消费者不能直接消费.这里RocketMQ实现方法是原消息的主题与消息消费队列,然后把主题改成**<code>RMQ_SYS_TRANS_HALF_TOPIC</code>**.这样由于消费者没有订阅这个主题,所以不会消费.</p></li><li><p><strong>如何处理第二阶段的发送消息?</strong></p><p>在本地事务执行完成后回向Broker发送Commit或者Rollback操作,此时如果在发送消息的时候生产者出故障了,要保证这条消息最终被消费,broker就会向服务端发送回查请求,确认本地事务的执行状态.当然RocketMQ并不会无休止的发送事务状态回查请求,<strong>默认是15次</strong>,如果15次回查还是无法得知事务的状态,RocketMQ默认回滚消息(broker就会将这条半消息删除)</p></li><li><p>事务的三种状态:</p><blockquote><ul><li><strong>TransactionStatus.CommitTransaction</strong>：提交事务消息，消费者可以消费此消息</li><li><strong>TransactionStatus.RollbackTransaction</strong>：回滚事务，它代表该消息将被删除，不允许被消费。</li><li><strong>TransactionStatus.Unknown</strong> ：中间状态，它代表需要检查消息队列来确定状态。</li></ul></blockquote></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>创建生产者时我们不在简单地创建**<code>DefaultMQProducer</code>** 而是RocketMQ事务专属的 <strong><code>TransactionMQProducer</code></strong> 并且不再简单地发送消息了 而是设置一个事务监听器 <strong><code>setTransactionListener(new TransactionListener()&#123;...&#125;);</code></strong> 实现接口方法 并且由于监听器需要等待本地事务的执行情况我们不能再生产者发送完消息后关闭</p><p><strong><code>Producer</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TransactionMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionMQProducer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置事务监听</span></span><br><span class="line">        producer.setTransactionListener(<span class="keyword">new</span> <span class="title class_">TransactionListener</span>() &#123;</span><br><span class="line">            <span class="comment">//执行本地事务 这就是正常事务过程</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> &#123;</span><br><span class="line">                <span class="comment">//消息保存到数据库中</span></span><br><span class="line">                <span class="comment">//sql代码</span></span><br><span class="line">                <span class="comment">//根据数据库事务状态 返回事务状态</span></span><br><span class="line">                System.out.println(<span class="string">&quot;正常执行的过程&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//LocalTransactionState.ROLLBACK_MESSAGE 表示事务回滚 这时broker就会删除掉half消息 消费者接收不到</span></span><br><span class="line">                <span class="comment">//如果是LocalTransactionState.COMMIT_MESSAGE 表示提交消息 这时broker就会提交half消息 消费能接收</span></span><br><span class="line">                <span class="comment">//LocalTransactionState.UNKNOW 事务结果未知 执行事务补偿过程 即broker主动询问生产者事务结果</span></span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//检查本地事务 这就是事务补偿过程</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> LocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行事务补偿过程&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello Transaction&quot;</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;topic4&quot;</span>, <span class="string">&quot;tag1&quot;</span>, msg.getBytes());</span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">send</span> <span class="operator">=</span> producer.sendMessageInTransaction(message,<span class="literal">null</span>);</span><br><span class="line">        System.out.println(send);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消息生产完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能关闭 涉及事务的提交和回滚 以及事务与broker的交互过程 不能一发出消息就关闭</span></span><br><span class="line">        <span class="comment">//producer.shutdown();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Consumer</code></strong> 整个事务消息环节与Consumer相关不大,所以不用对原来的Consumer进行修改 正常接收消息即可.</p><h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><h3 id="集群分类"><a href="#集群分类" class="headerlink" title="集群分类"></a>集群分类</h3><ul><li><strong>单机</strong><ul><li>一个broker提供服务(宕机后服务瘫痪)</li></ul></li><li><strong>集群</strong><ul><li>多个broker提供服务(单机宕机后消息无法及时被消费)</li><li>多个master和多个slave<ul><li>master到slave消息同步方式为同步(较异步方式性能略低,消息无延迟)</li><li>master到slave消息同步方式为异步(较同步方式性能略高,数据略有延迟)</li></ul></li></ul></li><li><strong>根据配置文件中的信息来设置主从集群</strong></li></ul><h3 id="RocketMQ集群工作流程"><a href="#RocketMQ集群工作流程" class="headerlink" title="RocketMQ集群工作流程"></a>RocketMQ集群工作流程</h3><ul><li>NameServer启动,开启监听,等待broker,producer与consumer连接</li><li>broker启动,根据配置信息,连接所有的NameServer,并保持长连接 <ul><li>如果broker中现存数据,NameServer将保存topic与broker关系</li></ul></li><li>producer发送信息,连接某个NameServer,并建立长连接</li><li>producer发送消息<ul><li>如果topic存在,由NameServer直接分配</li><li>如果topic不存在,由NameServer创建topic与broker关系,并分配</li></ul></li><li>producer与broker的topic选择一个消息队列(从列表中选择)</li><li>producer与broker建立长连接,用于发送消息</li><li>producer发送消息</li></ul><p><strong><code>Consumer</code><strong>工作流程同</strong><code>Producer</code></strong></p><hr><h2 id="RocketMQ高级特性"><a href="#RocketMQ高级特性" class="headerlink" title="RocketMQ高级特性"></a>RocketMQ高级特性</h2><p><strong>RocketMQ消息发送底层</strong></p><ol><li><p>消息的生产者发送消息到MQ</p></li><li><p>MQ返回ACK给生产者</p></li><li><p>MQ push消息给对于的消费者</p></li><li><p>消息消费者返回ACK给MQ</p></li></ol><p>说明: ACK(Acknowledge character)</p><p>注意: <strong>如果broker出现问题不能发送和接收ACK  生产者就会接收不到broker发送的ACK 就会导致生产者一直发送同一条消息 也会导致消费者一直消费同一条消息</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225203843889.png" alt="image-20220225203843889"></p><h3 id="消息的存储"><a href="#消息的存储" class="headerlink" title="消息的存储"></a>消息的存储</h3><ol><li><p>消息生产者发送消息到MQ</p></li><li><p>MQ接收到消息,将消息持久化,存储该消息</p></li><li><p>MQ返回ACK给生产者</p></li><li><p>MQpush消息给对应的消费者</p></li><li><p>消息消费者返回ACK给MQ</p></li><li><p>MQ删除消息</p></li></ol><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225204155340.png" alt="image-20220225204155340"></p><p><strong>注意:</strong></p><blockquote><ul><li>第5步 MQ在指定时间接收到消息消费者返回ACK, MQ认定消息消费成功,执行6</li><li>第5步 MQ在指定时间未接收到消息消费者返回ACK,MQ认定消费失败,重新执行456</li></ul></blockquote><h3 id="消息的存储介质"><a href="#消息的存储介质" class="headerlink" title="消息的存储介质"></a>消息的存储介质</h3><p>为了防止数据库出现故障和数据库I&#x2F;O降低性能(数据库最后也是将数据存储再磁盘上(文件系统))</p><p><strong>所以我们直接绕过数据库 直接将消息存在本地的文件系统上</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225204909019.png" alt="image-20220225204909019"></p><p><strong>数据库:</strong></p><ul><li>ActiveMQ使用</li><li>缺点: 数据库瓶颈将成为MQ瓶颈</li></ul><p><strong>文件系统:</strong></p><ul><li>RocketMQ&#x2F;Kafka&#x2F;RabbitMQ</li><li>解决方案: 采用消息刷盘的机制进行数据的存储</li><li>缺点:硬盘损坏的问题无法避免</li></ul><h3 id="高效的消息存储与读写方式"><a href="#高效的消息存储与读写方式" class="headerlink" title="高效的消息存储与读写方式"></a>高效的消息存储与读写方式</h3><ul><li><strong>SSD(Solid State Disk): 固态硬盘</strong><ul><li>随机写 100kb&#x2F;s</li><li>顺序写 600-3000m&#x2F;s</li></ul></li><li>由上可知 顺序写的速度是远远快于随机写的</li></ul><hr><ul><li><p><strong>RocketMQ中向文件系统预先申请了一定大小的磁盘空间 用于顺序读写</strong>(这就是RocketMQ高速读写的第一个原因)</p></li><li><p>Linux系统发送数据的方式</p><blockquote><p>“零拷贝”技术</p><ul><li>数据传输由传统的4次复制简化成3次复制,减少1次复制过程</li><li>java语言中使用MappedByteBuffer类实现了该技术</li><li>要求:预留存储空间,用于保存数据(1G存储空间起步)</li></ul></blockquote><p>传统模式</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225211130484.png" alt="image-20220225211130484"></p></li></ul><p>“零拷贝模式”</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225211155810.png" alt="image-20220225211155810"></p><p><strong>总结(RocketMQ高速读写的原因):</strong></p><blockquote><ul><li>磁盘读写方式</li><li>“零拷贝”技术</li></ul></blockquote><h3 id="消息存储的结构"><a href="#消息存储的结构" class="headerlink" title="消息存储的结构"></a>消息存储的结构</h3><p>MQ数据存储区域包括如下内容</p><ul><li><p>消息数据存储区域</p><ul><li>topic</li><li>queueId</li><li>message</li></ul></li><li><p>消费逻辑队列(会记录每一个队列被每一个消费者消费到了什么(多少偏移量))</p><ul><li>minOffset</li><li>maxOffset</li><li>consumerOffset</li></ul></li><li><p>索引</p><ul><li>key索引</li><li>创建时间索引</li><li>……</li></ul></li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225212158831.png" alt="image-20220225212158831"></p><h3 id="刷盘机制"><a href="#刷盘机制" class="headerlink" title="刷盘机制"></a>刷盘机制</h3><h4 id="同步刷盘"><a href="#同步刷盘" class="headerlink" title="同步刷盘:"></a>同步刷盘:</h4><ol><li>生产者发送消息到MQ,MQ接到消息数据</li><li>MQ挂起生产者发送消息的线程</li><li>MQ将消息数据写入内存</li><li>内存数据写入硬盘</li><li>磁盘存储后返回SUCCESS</li><li>MQ回复挂起的生产者线程</li><li>发送ACK到生产者</li></ol><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225212521664.png" alt="image-20220225212521664"></p><h4 id="异步刷盘"><a href="#异步刷盘" class="headerlink" title="异步刷盘"></a>异步刷盘</h4><ol><li><p>生产者发送消息到MQ,MQ接收到消息数据</p></li><li><p>MQ将消息写入内存</p></li><li><p>发送ACK到生产者</p></li><li><p>待到内存中的消息数据积累到一定量 就将消息数据写入硬盘</p></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><blockquote><ul><li>同步刷盘: 安全性高,效率低,速度慢(适用于对数据安全性要求较高的业务)</li><li>异步刷盘:安全性低,效率高,速度块(使用与对数据处理速度要求较高的业务)</li></ul></blockquote><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225213018812.png" alt="image-20220225213018812"></p><hr><h3 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h3><ul><li>NameServer<ul><li>无状态(相互之间无联系)+全服务器注册</li></ul></li><li>消息服务器<ul><li>主从框架(2M-2S)</li></ul></li><li>消息生产<ul><li>生产者将相同的topic绑定到多个group组,保障master挂掉后,其他master仍可以正常进行消息接收</li></ul></li><li>消息消费<ul><li>RocketMQ自身会根据master的压力确认是否由master承担消息读取的功能,当master繁忙的时候,自动切换slave成单数据读取的工作(主从分离 当压力过大时 master只写入 因为slave中的数据与master实时更新 所以这时slave可以承担读的功能)</li></ul></li></ul><p><strong>主从数据复制</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225213710132.png" alt="image-20220225213710132"></p><hr><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul><li>**<code>Producer</code>**负载均衡</li></ul><blockquote><ul><li>内部实现了不同broker集群中对同一个topic对应消息队列的负载均衡</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225214232482.png" alt="image-20220225214232482"></p></blockquote><ul><li>**<code>Consumer</code>**负载均衡(针对相同的消费者组间)</li></ul><blockquote><ul><li>平均分配</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225214249237.png" alt="image-20220225214249237"></p><ul><li>循环平均分配(解决宕机问题)</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225214305341.png" alt="image-20220225214305341"></p></blockquote><hr><h3 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h3><p>当消息消费后未正常返回消费成功的消息将启动消息重试机制</p><p><strong>消息重试机制</strong></p><blockquote><ul><li><p><strong>顺序消息重试</strong></p><blockquote><p>当消费者消费失败后,RocketMQ会自动进行消息重试(每次间隔为1s)</p><p><strong>注意:</strong> 应用会出现消息消费被堵塞的情况,因此要对顺序消息的消费情况进行监控,避免阻塞的现象发生</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225214842367.png" alt="image-20220225214842367"></p></blockquote></li><li><p><strong>无序消息重试</strong></p><blockquote><ul><li>无序消息包括普通消息、定时消息、延时消息、事务消息</li><li>无序消息重试仅适用于负载均衡（集群）模型下的消息消费，不适用于广播模式下的消息</li><li>消费为保障无序消息的消费，MQ设定了合理的消息重试间隔时长</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225215028265.png" alt="image-20220225215028265"></p></blockquote></li></ul></blockquote><hr><h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p><strong>死信队列就是那些重试无果的消息存在的队列</strong></p><ul><li><p><strong>死信队列特征</strong></p><blockquote><ul><li>归属某一个组（Gourp Id)，而不归属Topic，也不归属消费者。</li><li>一个死信队列中可以包含同一个组下的多个Topic中的死信消息</li><li>死信队列不会进行默认初始化，当第一个死信出现后，此队列首次初始化</li></ul></blockquote></li><li><p><strong>死信队列中消息特征</strong></p><blockquote><ul><li><p>不会被再次重复消费</p></li><li><p>死信队列中的消息有效期为3天，达到时限后将被清除</p></li></ul></blockquote></li><li><p><strong>死信处理</strong></p><blockquote><p>在监控平台中,通过查找死信,获取死信的messageId,然后通过id对死信进行精准消费</p></blockquote></li></ul><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h4><ul><li><p>死信</p><blockquote><ul><li><p>死信队列与死信</p></li><li><p>死信处理方式</p></li></ul></blockquote></li></ul><hr><h3 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h3><h4 id="消息重复发送的原因"><a href="#消息重复发送的原因" class="headerlink" title="消息重复发送的原因"></a>消息重复发送的原因</h4><ul><li>生产者发送了重复的消息<ul><li>网络闪断(例如: 消息服务器没有发送ACK给生产者)</li><li>生产者宕机</li></ul></li><li>消息服务器投递了重复的消息<ul><li>网络闪断(例如: 消费者没有发送ACK给消息服务器)</li></ul></li><li>动态的负载均衡过程<ul><li>网络闪断&#x2F;抖动</li><li>broker重启</li><li>订阅方应用重启(消费者)</li><li>客户端扩容</li><li>客户端缩容</li></ul></li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225220215976.png" alt="image-20220225220215976"></p><h4 id="消息幂等"><a href="#消息幂等" class="headerlink" title="消息幂等"></a>消息幂等</h4><ul><li><p>对于同一条消息,无论消费了多少次,结果保持一致,称为<strong>消息幂等性</strong></p></li><li><p>解决方案</p><ul><li>使用业务id作为消息的key</li><li>在消费消息时,客户端对key做判定,未使用过放行,使用过抛弃</li></ul></li><li><p>注意: <strong>messageId由RocketMQ产生,MessageId并不具有唯一性,不能作用幂等判定条件</strong></p></li><li><p><strong>常见的幂等方法示例</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225220811978.png" alt="image-20220225220811978"></p></li></ul><h1 id="——End——"><a href="#——End——" class="headerlink" title="——End——"></a>——End——</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RocketMQ&quot;&gt;&lt;a href=&quot;#RocketMQ&quot; class=&quot;headerlink&quot; title=&quot;RocketMQ&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/apache/rocketmq/blob/master/docs/cn/concept.md&quot;&gt;RocketMQ&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;MQ(Message Queue)&lt;/strong&gt;:消息队列&lt;/p&gt;</summary>
    
    
    
    <category term="中间件" scheme="https://devildyw.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
