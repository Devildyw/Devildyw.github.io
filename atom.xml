<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Devil的个人博客</title>
  
  <subtitle>永远相信美好的事情即将发生</subtitle>
  <link href="https://devildyw.github.io/atom.xml" rel="self"/>
  
  <link href="https://devildyw.github.io/"/>
  <updated>2022-03-12T13:00:09.958Z</updated>
  <id>https://devildyw.github.io/</id>
  
  <author>
    <name>Devil</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis</title>
    <link href="https://devildyw.github.io/2022/03/28/Redis/"/>
    <id>https://devildyw.github.io/2022/03/28/Redis/</id>
    <published>2022-03-28T12:58:54.000Z</published>
    <updated>2022-03-12T13:00:09.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><a href="https://www.bilibili.com/video/BV1cr4y1671t?p=63&spm_id_from=pageDriver">Redis</a></h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p><strong>Redis是一种NOSQL型数据库,即一种非关系型数据库</strong></p><p>我们常见的Mysql是一种SQL型数据库,是一种关系型数据库</p><span id="more"></span><h3 id="SQL型数据库"><a href="#SQL型数据库" class="headerlink" title="SQL型数据库"></a><strong>SQL型数据库</strong></h3><h4 id="结构化-Structured"><a href="#结构化-Structured" class="headerlink" title="结构化 Structured"></a>结构化 <strong>Structured</strong></h4><ul><li>下面这张图,我们创建这张表之初就对表的字段做了指定与规定,比如下面这张表只有三个字段,每个字段我们都加上了不同的约束,并且规定了字段的类型和长度,就使得这张表具有很强的结构体系,后续插入修改的数据都必须遵守表的结构</li></ul><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220307174510020.png" alt="image-20220307174510020"></p><h4 id="关联的-Relational"><a href="#关联的-Relational" class="headerlink" title="关联的(Relational)"></a>关联的(Relational)</h4><ul><li><p>比如一个表中的某个字段被其他表中的字段所关联(外键) 这样表中的数据就会自动维护,当删除某个字段时,就会提示无法删除的情况,除此之外,关联的优点还有可以节省存储空间,不需要记录数据的全部信息,只需要记录一个数据的主键即可.</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220307175758165.png" alt="image-20220307175758165"></p><h4 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h4><ul><li><p>优点:语法固定</p></li><li><p>缺点:需要去学习大量的语法 </p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220307180551365.png" alt="image-20220307180551365"></p></li></ul><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><ul><li><strong>满足ACID(原子性, 一致性, 隔离性, 持久性) 对关系性要求较高的业务采用SQL</strong></li></ul><h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><ul><li><strong>磁盘</strong></li></ul><h4 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h4><ul><li><strong>垂直</strong>(即一主多从 数据存储的大小没有改变 只是增强了数据的存储效率(读写分离))</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>数据结构稳定</li><li>相关业务对数据安全性,一致性较高.(ACID)</li></ul><hr></li></ul><h3 id="NOSQL"><a href="#NOSQL" class="headerlink" title="NOSQL"></a><strong>NOSQL</strong></h3><h4 id="非结构化"><a href="#非结构化" class="headerlink" title="非结构化"></a>非结构化</h4><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220307174959275.png" alt="image-20220307174959275"></p><ul><li>NoSQL有三种数据存储格式 分别为<strong>key-value型, Document型, 还有Graph型</strong> 没有SQL那种有很强的结构性 比如<strong>key-value型的存储格式中</strong> 不需要指定数据的类型, 只要是NoSQL支持的数据格式 都可以填入. 对于<strong>Document型中 数据的字段数量也可以不同可以任意增添数据字段</strong> 不需要上一条数据有四个字段 这次就可以只有三种</li></ul><h4 id="无关系的"><a href="#无关系的" class="headerlink" title="无关系的"></a>无关系的</h4><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220307175732140.png" alt="image-20220307175732140"></p><ul><li>一般通过json(Document)的形式存储,缺点就是这种的数据格式不能自己维护,需要程序员自己通过业务逻辑维护 ,并且可能会出现数据的冗余,比如同一个商品多个用户下单,多个用户的信息的存储中都有相同的订单数据,这需要程序员自己根据不同的业务逻辑来维护.</li></ul><h4 id="非SQL"><a href="#非SQL" class="headerlink" title="非SQL"></a>非SQL</h4><ul><li><p>优点: 不需要去学习大量的语法</p></li><li><p>缺点: 不同的NoSQL语句的格式用法可能不同</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220307180601578.png" alt="image-20220307180601578"></p><h4 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h4><ul><li><strong>BASE(基本一致或者无事务 无法完全满足ACID) 业务对安全性要求较低的可以采用NoSQL</strong></li></ul><h4 id="存储方式-1"><a href="#存储方式-1" class="headerlink" title="存储方式"></a>存储方式</h4><ul><li><strong>内存</strong></li></ul><h4 id="扩展性-1"><a href="#扩展性-1" class="headerlink" title="扩展性"></a>扩展性</h4><ul><li><strong>水平</strong>(即多主多从 数据存储的大小增加 也增强了数据的存储效率(读写分离))</li></ul><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>数据结构不稳定</li><li>对一致性,安全性要求不高</li><li>对性能要求高</li></ul><hr><h2 id="认识Redis"><a href="#认识Redis" class="headerlink" title="认识Redis"></a><strong>认识Redis</strong></h2><p>Redis诞生与2009年全程时<strong>Remote Dictionary Server(远程词典服务器)</strong>,是一个基于内存的键值型NoSQL数据库.</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a><strong>特征</strong></h3></li><li><p>键值型(key-value)型, value支持多种不同的数据类型,功能丰富</p></li><li><p>单线程,每个命令具有原子性</p></li><li><p>低延迟,速度快(<strong>基于内存</strong>,IO多路复用,良好的编码)</p></li><li><p>支持数据持久化(持久化到磁盘)</p></li><li><p>支持主从集群,分片集群(将数据分部分存储到多个master中 增加数据存储的上限)</p></li><li><p>支持多语言客户端</p></li></ul><hr><h2 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a><strong>Redis常见命令</strong></h2><h3 id="Redis数据结构介绍"><a href="#Redis数据结构介绍" class="headerlink" title="Redis数据结构介绍"></a><strong>Redis数据结构介绍</strong></h3><p>Redis是一个key-value的数据库,key一般是String类型,不过value的类型多种多样</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220307191247016.png" alt="image-20220307191247016"></p><p>基本类型: String, Hash, List, Set. SortedSet</p><p>特殊类型: GEO(主要用于存储地理位置信息), BitMap, HyperLog(用来做基数统计的算法), Stream(主要用于消息队列)</p><h3 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a><a href="http://www.redis.cn/commands.html"><strong>Redis通用命令</strong></a></h3><p>通用指令是部分数据类型的,都可以使用的指令,常见的有 用法详情可以官网查看:</p><ul><li><strong>keys</strong>:查看符合模板的所有key,不建议在生产设备上使用(因为Redis是单线程的 使用keys *命令查看会占用很大资源 导致线程堵塞)</li><li>DEL: 删除可以删除一个或多个key (del key1 key2)</li><li>EXISTS: 判断key是否存在</li><li>EXPIRE: 给一个key设置有效期,有效期到时该key会被自动删除</li><li>TTL: 查看一个key剩余有效期</li></ul><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a><strong>String类型</strong></h3><p>String类型,也就是字符串类型,是Redis中最简单的存储类型.</p><p>其value是字符串,不过根据字符串的格式不同,又可以分为3类</p><ul><li>String:普通字符串</li><li>int: 整数类型,可以做自增,自减操作</li><li>float: 浮点类型,可以做自增,自减操作</li></ul><p>不管是哪种格式,底层都是字节数组形式存储,只不过是编码方式不同,字符串类型的最大的空间不能超过512m(可以存储图片 只需要将图片转为字节数组的格式存储 但这样会耗很大空间 一般不这样用)</p><p>![image-20220308233257985](<a href="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220308233257985.png">https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220308233257985.png</a></p><h4 id="String类型的常见指令"><a href="#String类型的常见指令" class="headerlink" title="String类型的常见指令"></a>String类型的常见指令</h4><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220308233444257.png" alt="image-20220308233444257"></p><p><strong>SETEX</strong>用法比较特殊: <strong><code>set name jack ex 20(存活时间 单位秒)</code></strong></p><h3 id="key的结构"><a href="#key的结构" class="headerlink" title="key的结构"></a><strong>key的结构</strong></h3><p>Redis的key允许有多个单词形成<strong>层级结构</strong>,多个单词之间用**<code>&#39;:&#39;</code>**隔开,格式如下:</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220308235659340.png" alt="image-20220308235659340"></p><p>这个格式并非固定,也可以根据自己的需求来删除或添加词条</p><p>例如 一个项目下有user和product两种不同类型的数据,我们可以这样定义key:</p><ul><li>user相关的key: project:user:1</li><li>product相关的key: project:producet:1</li></ul><p>这样的格式实际上是以层级结构的形式存储的**(主要是为了区分不同项目中相同的数据 用户的id可以为1 商品的id也可以为1)**</p><p><img src="C:\Users\Devil\AppData\Roaming\Typora\typora-user-images\image-20220309000908161.png" alt="image-20220309000908161"></p><p>如果value是一个java对象,例如要给User对象,则可以将对象序列化为JSON字符串后存储</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220308235948333.png" alt="image-20220308235948333"></p><p>​                    <strong><code>set project:user:1 &#39;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;ding&quot;&#125;&#39;</code></strong></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220309000302102.png" alt="image-20220309000302102"></p><hr><h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a><strong>Hash类型</strong></h3><p>Hash类型,也叫散列,其value是一个无序字典,类似于java中的HashMap结构.</p><p>String结构是将对象序列化为JSON字符串后存储,当需要修改对象某个字段时很不方便:</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220309191057489.png" alt="image-20220309191057489"></p><p>Hash结构可以将对象中的每个字段独立存储,可以针对单个字段做CRUD: 相对于String类型较为灵活</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220309191148786.png" alt="image-20220309191148786"></p><h4 id="Hash类型的常见命令"><a href="#Hash类型的常见命令" class="headerlink" title="Hash类型的常见命令:"></a>Hash类型的常见命令:</h4><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220309191557981.png" alt="image-20220309191557981"></p><hr><h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a><strong>List类型</strong></h3><p>Redis中的List类型于Java中的LinkedList类似,可以看作是一个双向链表结构.既可以支持正向检索也可以支持反向检索.</p><p>特征也与LinkedList类似</p><ul><li><strong>有序</strong></li><li><strong>元素可以重复</strong></li><li><strong>插入和删除块</strong></li><li><strong>查询速度一般</strong></li></ul><p>常用来存储一个有序数据,例如:朋友圈点赞列表,批量列表等.</p><h4 id="List的常见命令"><a href="#List的常见命令" class="headerlink" title="List的常见命令"></a>List的常见命令</h4><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220309194126739.png" alt="image-20220309194126739"></p><hr><h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a><strong>Set类型</strong></h3><p>Redis的Set结构与Java的中HashSet类似,可以看做是一个value为null的HashMap.因为也是一个Hash表,因此具备与HashSet类似的特征</p><ul><li><strong>无序</strong></li><li><strong>元素不可重复</strong></li><li><strong>查找块</strong></li><li><strong>支持交集 并集 差集等功能</strong></li></ul><h4 id="Set类型的常见命令"><a href="#Set类型的常见命令" class="headerlink" title="Set类型的常见命令"></a><strong>Set类型的常见命令</strong></h4><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220309195325392.png" alt="image-20220309195325392"></p><hr><h3 id="SortedSet类型-有序集合"><a href="#SortedSet类型-有序集合" class="headerlink" title="SortedSet类型(有序集合)"></a><strong>SortedSet类型(有序集合)</strong></h3><p>Redis的SortedSet是一个可排序的set集合,与Java中的TreeSet有些类似,但底层数据结构却差别很大.SortedSet中的每一个元素都带有一个score属性,可以基于score属性对元素排序,底层的实现是一个跳表(SkipList)加hash表.SortedSet具备下列特性:</p><ul><li><strong>可排序</strong></li><li><strong>元素不重复</strong></li><li><strong>查询速度快</strong></li></ul><p>因为SortedSet的可排序特性,经常被用来实现排行榜这样的功能</p><h4 id="SortedSet类型的常见命令"><a href="#SortedSet类型的常见命令" class="headerlink" title="SortedSet类型的常见命令"></a>SortedSet类型的常见命令</h4><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220309201610780.png" alt="image-20220309201610780"></p><h2 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a><strong>Redis的Java客户端</strong></h2><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220309203536114.png" alt="image-20220309203536114"></p><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a><strong>Jedis</strong></h3><ul><li><p><strong>创建Maven工程</strong></p></li><li><p><strong>引入Jedis依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>建立连接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@BeforeEach</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//建立连接</span></span><br><span class="line">       jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;81.68.186.20&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">       <span class="comment">//设置密码</span></span><br><span class="line">       jedis.auth(<span class="string">&quot;ffdd2021@&quot;</span>);</span><br><span class="line">       <span class="comment">//选择库</span></span><br><span class="line">       jedis.select(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>存取数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//存入数据</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;12&quot;</span>);</span><br><span class="line">       System.out.println(name);</span><br><span class="line">       <span class="comment">//获取数据</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">       System.out.println(name1);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//插入hash数据</span></span><br><span class="line">       <span class="type">long</span> <span class="variable">name</span> <span class="operator">=</span> jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">       System.out.println(name);</span><br><span class="line">       <span class="comment">//取出</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> jedis.hget(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">       System.out.println(name1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>关闭连接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//关闭连接</span></span><br><span class="line">       <span class="keyword">if</span>(jedis!=<span class="literal">null</span>)&#123;</span><br><span class="line">           jedis.close();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>Jedis中数据的存储命令是与命令行一致的</strong></p><hr></li></ul></li></ul><h4 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h4><p>Jedis本身是线程不安全的,并且频繁的创建和销毁连接会有性能损耗,因此我们推荐大家使用Jedis连接池代替Jedis直连的方式.</p><p>类似SQL型的数据库连接池 不会直接关闭连接而是归还到连接池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        <span class="comment">//连接总数</span></span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//最大连接数量</span></span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//最小连接数量</span></span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//最大等待时间</span></span><br><span class="line">        jedisPoolConfig.setMaxWait(Duration.ofMillis(<span class="number">10000</span>));</span><br><span class="line">        <span class="comment">//创建连接池对象</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jedisPoolConfig,<span class="string">&quot;81.68.186.20&quot;</span>,<span class="number">6379</span>,<span class="number">1000</span>,<span class="string">&quot;ffdd2021@&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个获取连接的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a><a href="https://spring.io/projects/spring-data-redis"><strong>SpringDataRedis</strong></a></h3><p>SpringData是Spring中数据操作的模板,包含对各种数据库的集成,其中对Redis的集成模板就叫做SpringDataRedis </p><ul><li><strong>提供了对不同Redis客户端的整合(Lettuce和Jedis)</strong></li><li><strong>提供了RedisTemplate统一API来操作Redis</strong></li><li><strong>支持Redis的发布订阅模型</strong></li><li><strong>支持Redis哨兵和Redis集群</strong></li><li><strong>支持基于Lettuce的响应式编程</strong></li><li><strong>支持JDK,JSON,字符串,Spring对象的数据序列化及反序列化</strong>(方便地将上述数据格式 转化为字节数组 更方便地去存储在Redis中)</li><li><strong>支持基于Redis的JDKCollection实现</strong></li></ul><p>SpringDataRedis中提供了RedisTemplate工具类,其中封装了各种对Redis的操作.并且将不同数据类型的操作API封装到了不同的类型中:</p><h4 id="RedisTemplate工具类"><a href="#RedisTemplate工具类" class="headerlink" title="RedisTemplate工具类"></a>RedisTemplate工具类</h4><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220309234553190.png" alt="image-20220309234553190"></p><h4 id="RedisTemplate使用"><a href="#RedisTemplate使用" class="headerlink" title="RedisTemplate使用"></a>RedisTemplate使用</h4><ul><li><p>导入依赖</p><ul><li><p>SpringDataRedis依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>连接池依赖(Jedis和Lettuce都是依赖于commons-pool2实现)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">81.68</span><span class="number">.186</span><span class="number">.20</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">ffdd2021@</span></span><br><span class="line">    <span class="comment"># 选择数据库 database: 1</span></span><br><span class="line">    <span class="comment"># pool SpringDataRedis默认使用的客户端是Lettuce 可以导入其他依赖来使用其他连接池</span></span><br><span class="line">    <span class="comment"># 必须要配置了连接池 连接池才能生效</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br></pre></td></tr></table></figure></li><li><p>注入RedisTemplate工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Redis01RedisTemplateApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;丁杨维&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220310000959983.png" alt="image-20220310000959983"></p></li></ul><h4 id="SpringDataRedis的序列化方式"><a href="#SpringDataRedis的序列化方式" class="headerlink" title="SpringDataRedis的序列化方式"></a>SpringDataRedis的序列化方式</h4><p>RedisTemplate可以接收任意Object作为值写入Redis,只不过吸入人前会把Object序列化为字节形式,默认是采用的JDK序列化,得到的结果是这样的:(及使用RedisTemplate时没有指定泛型)</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220310185259667.png" alt="image-20220310185259667"></p><p><strong>缺点:</strong></p><ul><li><strong>可读性差</strong></li><li><strong>内存占用较大</strong></li></ul><hr><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h4><ul><li><p>如果key-value都是String类型 直接指定泛型为String即可 但如果value或者key为Object时就需要自己配置了.</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220310190944166.png" alt="image-20220310190944166"></p><p>Redis提供了设置key-value序列化方式的接口</p></li><li><p>首先导入Jackson的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>最新版<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置类 <code>RedisConfig</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">//创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String,Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//创建JSON序列化工具  注意这里使用的时Jackson需要导入Jackson的相关依赖才行</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">genericJackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">//设置key的序列化</span></span><br><span class="line">        template.setKeySerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashKeySerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//设置value的序列化</span></span><br><span class="line">        template.setValueSerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实体类 <code>User</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Redis01RedisTemplateApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,Object&gt; redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;丁杨维&quot;</span>, <span class="number">19</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;user1&quot;</span>,user);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1=&quot;</span>+user1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220310191828636.png" alt="image-20220310191828636"></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220310191838617.png" alt="image-20220310191838617"></p><p>通过配置使用了Jackson序列化对象对JSON字符串格式存储,在取出时也可以将JSON字符串反系列化为对象.</p><hr><h4 id="JSON序列化的问题"><a href="#JSON序列化的问题" class="headerlink" title="JSON序列化的问题"></a>JSON序列化的问题</h4><p>如上图 我们会发现使用JSON序列化存储value时,会默认带上全类名名称 这样会造成额外的内存开销. (<strong>为了在反序列化时知道对象的类型,JSON序列化器会将类的class类型写入json结果中,存入Redis.</strong> )而如果想使用JSON序列化器序列化对象,这一步又是必不可少的.</p><p><strong>解决方案:</strong></p><ul><li>为了节省内存空间, 我们并不会使用JSON序列化器来处理value, <strong>而是统一使用String序列化器</strong>, 要求只能存储String类型的Key和value. <strong>当需要存储Java对象时, 手动完成对象的序列化和反序列化</strong>.</li><li>Spring默认提供了一个StringRedisTemplate类,他的key和value的序列化方式默认就是String方式.省去了我们自定义RedisTemplate的过程.</li></ul><hr><h4 id="StringRedisTemplate类"><a href="#StringRedisTemplate类" class="headerlink" title="StringRedisTemplate类"></a>StringRedisTemplate类</h4><ul><li><p>Jackson的ObjectMapper提供了将Java对象序列化为Json字符串和反序列化为Java对象的API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Redis01RedisTemplateApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTest</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;彭芳姐&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ObjectMapper提供了将对象转化为Json串的API</span></span><br><span class="line">        <span class="comment">//手动序列化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userString</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user2&quot;</span>,userString);</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动反序列化</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> mapper.readValue(userJson, User.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220310194423995.png" alt="image-20220310194423995"></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220310194441788.png" alt="image-20220310194441788"></p><h3 id="RedisTemplate对Hash的操作"><a href="#RedisTemplate对Hash的操作" class="headerlink" title="RedisTemplate对Hash的操作"></a><strong>RedisTemplate对Hash的操作</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void doTest2()&#123;</span><br><span class="line">    stringRedisTemplate.opsForHash().put(&quot;key&quot;,&quot;hashKey&quot;,&quot;value&quot;);</span><br><span class="line">    stringRedisTemplate.opsForHash().put(&quot;key&quot;,&quot;hashKey1&quot;,&quot;value1&quot;);</span><br><span class="line"></span><br><span class="line">    Map&lt;Object, Object&gt; key = stringRedisTemplate.opsForHash().entries(&quot;key&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作习惯上更偏向于java的HashMap之类的.</p><p>stringRedisTemplate.opsForHash().entries(String key)会获得hash类型中的某个key的全部key-value信息.</p><p>剩余操作或其他类型操作可以参考官方文档.<a href="https://docs.spring.io/spring-data/redis/docs/current/api/">RedisAPI文档</a></p><hr><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a><strong>项目实战</strong></h2><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220310200358089.png" alt="image-20220310200358089"></p><hr><h3 id="Session共享问题"><a href="#Session共享问题" class="headerlink" title="Session共享问题:"></a><strong>Session共享问题:</strong></h3><p>多台TomCat并不共享session存储空间,当请求切换到不同的tomcat服务时,导致数据丢失的问题</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220310213458462.png" alt="image-20220310213458462"></p><p>session的代替方案应该满足:</p><ul><li><strong>数据共享</strong></li><li><strong>内存存储</strong></li><li><strong>key-value结构</strong></li></ul><p><strong>以上的要求Redis都满足, 可以使用Redis来代替Session存储,但也不是简单的存储.</strong></p><h3 id="基于Redis实现共享Session登陆"><a href="#基于Redis实现共享Session登陆" class="headerlink" title="基于Redis实现共享Session登陆"></a><strong>基于Redis实现共享Session登陆</strong></h3><p><strong>Redis要实现共享Session登陆, 需要满足key唯一性.</strong></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220310214224767.png" alt="image-20220310214224767"></p><ul><li>如果使用用户登陆存储一定的用户信息在Redis中时,一般使用token作为key,而value使用Hash类型.</li><li>学习Hash类型的时候我们学过 Hash类型的存储可以将对象的字段分别存储,可以针对单个字段进行crud,不需要每次改的是否传全部信息进行更改.</li></ul><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220309191148786.png" alt="image-20220309191148786"></p><p>使用token存储用户的非敏感信息,传到前端,前端利用浏览器的缓存存储</p><p><strong>注意</strong>:</p><ul><li>使用token存储到Redis时一定要设置过期时间,因为会耗费内存空间(如果存储的token太多 有没有及时清楚 可能会造成堆栈溢出)</li><li>使用 RedisTemplate.expire可以指定指定key-value的存活时间</li><li>在登陆拦截器中,验证了token后需要刷新token存活时间,及再执行一遍第二步.</li><li>常量等可以专门编写一个类来记录 <code>static final constant</code>防止自己写出错.</li><li>对于一些不需要登陆拦截的Controller当用户访问时,也是需要刷新token的,设置一个全局刷新的token的拦截器,将其优先级设置为最高,所有请求都由他拦截,后续的登录拦截只需要从,全局拦截器中的存储到ThreadLocal的用户信息取到验证即可.</li></ul></li></ul></li></ul><h3 id="全局请求拦截器"><a href="#全局请求拦截器" class="headerlink" title="全局请求拦截器"></a><strong>全局请求拦截器</strong></h3><p>作用:</p><ul><li>用于拦截所有请求,获取如果有token就获取token中的数据,并且刷新token,并且将数据存入ThreadLocal中,如果没有就直接放行.(后续可能会被登陆拦截器拦截 检查是否有用户信息, 如果没有就返回false)</li><li>全局请求拦截器的主要作用就是为了防止用户登陆后,访问一些不需要登陆拦截器的接口token无法刷新的情况.</li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><strong>缓存</strong></h2><p><strong>缓存</strong>就是数据交换的缓存区(称作Cache), 是存储数据的临时地方,一般读写性能较高</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220311151533133.png" alt="image-20220311151533133"></p><h3 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h3><ul><li>降低后端负载</li><li>提高读写效率,降低响应时间.</li></ul><h3 id="缓存的成本"><a href="#缓存的成本" class="headerlink" title="缓存的成本"></a>缓存的成本</h3><ul><li>数据一致性成本</li><li>代码维护成本</li><li>运维成本</li></ul><h3 id="添加Redis缓存"><a href="#添加Redis缓存" class="headerlink" title="添加Redis缓存"></a>添加Redis缓存</h3><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220311152211102.png" alt="image-20220311152211102"></p><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220311153346059.png" alt="image-20220311153346059"></p><p>对于经常修改的数据,可以采用主动更新策略,在修改数据库的同时,更新缓存,这样的数据一致性较好,相应的维护成本较高. 对于不经常修改的数据,采用默认策略即可.</p><h4 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h4><h5 id="Cache-Aside-Pattern-常用"><a href="#Cache-Aside-Pattern-常用" class="headerlink" title="Cache Aside Pattern*(常用)"></a>Cache Aside Pattern*(常用)</h5><ul><li>由缓存的调用者,在更新数据库同时更新缓存.</li></ul><h5 id="Read-x2F-Write-Through-Pattern"><a href="#Read-x2F-Write-Through-Pattern" class="headerlink" title="Read&#x2F;Write Through Pattern"></a>Read&#x2F;Write Through Pattern</h5><ul><li>缓存与数据库整合为一个服务, 有服务来维护一致性. 调用者调用该服务, 无需关心缓存的一致性.</li></ul><h5 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h5><ul><li>调用者只是操作缓存,有其他线程异步地将缓存数据持久化到数据库,保证最终一致性</li></ul><h3 id="操作缓存和数据库时的三个问题考虑-For-Cache-Aside-Pattern"><a href="#操作缓存和数据库时的三个问题考虑-For-Cache-Aside-Pattern" class="headerlink" title="操作缓存和数据库时的三个问题考虑(For Cache Aside Pattern)"></a>操作缓存和数据库时的三个问题考虑(For Cache Aside Pattern)</h3><ol><li><p>删除缓存还是更新缓存 ?</p><ul><li>更新缓存: 每次更新数据库都更新缓存, 无效写操作较多(<strong>×</strong>)</li><li>删除缓存: 更新数据库时让缓存失效, 查询时在更新缓存(<strong>√</strong>)</li></ul></li><li><p>如何保证数据与数据库的同时成功或失败 ?</p><ul><li>单体系统, 将缓存与数据库操作防止一个事务</li><li>分布式系统,利用TTC等分布式事务方案</li></ul></li><li><p>先操作缓存还是先操作数据库 ?</p><ul><li>对于先操作缓存,可能会出现在删除缓存后将要操作数据库时, 另一个线程在查询缓存, 此时缓存中已无数据, 缓存未命中查询数据库写入缓存的情况,然后才去更新我们的数据库 造成读到脏数据的线程安全问题.</li><li>对于先操作数据库,也可能出现(刚好一个缓存过期)一个线程想要来查询缓存,缓存未命中,查询数据库的情况,此时数据库还没有更新,在要进行吸入缓存之前数据库才更新,这就造成读取到脏数据的情况.</li><li>但是对于先操作数据库的情况,实际上写入缓存的时间是非常快的,是远远快于操作数据库的情况,所以基本上不会出现在写入缓存之前,还能操作数据库的情况,所以一般采用先操作数据库的情况. 相比于第一种安全性更高.</li></ul><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220311160417480.png" alt="image-20220311160417480"></p></li></ol><h3 id="缓存更新的最佳实践方案"><a href="#缓存更新的最佳实践方案" class="headerlink" title="缓存更新的最佳实践方案:"></a><strong>缓存更新的最佳实践方案:</strong></h3><ol><li>低一致性需求: 使用Redis自带的淘汰机制</li><li>高一致性需求: 主动更新,并以超时作为兜底<ul><li>读操作:<ul><li>缓存命中则直接返回</li><li>缓存 未命中则查询数据库,并写入缓存,设定超时时间</li></ul></li><li>写操作:<ul><li>先写入数据库,再删除缓存</li><li>要确保数据的于缓存操作的原子性</li></ul></li></ul></li></ol><hr><h2 id="缓存未命中"><a href="#缓存未命中" class="headerlink" title="缓存未命中"></a><strong>缓存未命中</strong></h2><p>当CPU在缓存中找到有用的数据时，称为命中。当缓存中没有CPU需要的数据时（这称为未命中）</p><hr><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><strong>缓存穿透</strong></h2><p><strong>缓存穿透</strong>是指客户端请求的数据在缓存中和数据库中都不存在,这样的缓存永远都不会生效,这些请求都会打到数据库.</p><p>一些不坏好意的人可能会利用这里点来多线程发送多次请求导致数据库崩坏. 不存在的数据在数据库中查询对于数据库来说是会遍历全部数据然后返回NULL这对数据库的压力很大.</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220311161920235.png" alt="image-20220311161920235"></p><p><strong>常见的解决方案</strong>:</p><ul><li><p><strong>缓存空对象</strong>*</p><ul><li>优点: 实现简单,维护方便</li><li>缺点:<ul><li>额外的内存消耗(一般设置过期时间,且过期时间较短)</li><li>可能造成短期的不一致(此时新增一条该key对应的数据,但是在TTL结束前,查询到的都是NULL 造成短期不一致)</li></ul></li></ul></li><li><p><strong>布隆过滤</strong></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220311162648729.png" alt="image-20220311162648729"></p><ul><li>优点: 内存占用较少, 没有多余key</li><li>缺点:<ul><li>实现复杂</li><li>存在误判</li></ul></li></ul></li></ul><p><strong>除此之外缓存穿透的解决方案还有:</strong></p><ul><li>增强id的复杂度,避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流(也可以减小数据库压力)</li></ul><hr><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h2><p><strong>缓存雪崩</strong>是指在同一时间段大量的缓存key同时失效或者Redis服务宕机,导致大量请求到达数据库,带来巨大压力.</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220311163954070.png" alt="image-20220311163954070"></p><p><strong>解决方案</strong>:</p><ul><li>给不同的key的TTL添加随机值(防止大量的缓存Key同时失效)</li><li>利用Redis集群提高服务的可用性(防止单机宕机的情况)</li><li>给缓存业务添加降级限流策略(待学)</li><li>给业务添加多级缓存</li></ul><hr><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><strong>缓存击穿</strong></h2><p><strong>缓存击穿问题</strong>也叫热点Key问题,就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务比较复杂</strong>的key突然失效了,无数的请求访问会在瞬间给数据库带来巨大的冲击.</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220311165255394.png" alt="image-20220311165255394"></p><p><strong>常见解决方案</strong>:</p><ul><li><p><strong>互斥锁</strong></p><ul><li><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220311165723072.png" alt="image-20220311165723072"></li><li>加锁,性能低.</li></ul></li><li><p><strong>逻辑过期</strong></p><ul><li>设置逻辑过期时间 而非TTL</li><li>获取互斥锁 开启新线程,去查询数据库重建缓存数据.</li></ul><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220311170401649.png" alt="image-20220311170401649"></p></li></ul><p><strong>两种方案的比较</strong>:</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220311170545184.png" alt="image-20220311170545184"></p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁实现原理是通过Redis中的String类型的SETNX(插入一个不存在的数据)方法.这样别人就无法修改了.</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220311172926169.png" alt="image-20220311172926169"></p><p>RedisTemplate中的api是 opsForValue.setIfAbsent()</p><h3 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h3><p>使用逻辑过期 需要给数据设置一个逻辑过期时间, 一般会创建一个RedisData类 将逻辑过期时间和业务数据封装在一起,避免了在原有的业务基础上修改代码(指在实体类上新增逻辑过期字段).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="comment">//业务数据</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LocalDateTime.After(LocalDateTime time),如果时间过期那么返回</p><h2 id="封装Redis工具"><a href="#封装Redis工具" class="headerlink" title="封装Redis工具"></a><strong>封装Redis工具</strong></h2><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220311180308032.png" alt="image-20220311180308032"></p><h2 id="全局ID生成器"><a href="#全局ID生成器" class="headerlink" title="全局ID生成器"></a><strong>全局ID生成器</strong></h2><p>当用户抢购时,就会生成订单数据保存到订单表中,而订单表如果使用数据库自增ID就存在一些问题:</p><ul><li><strong>id的规律性太明显</strong></li><li><strong>受单表数据量的限制</strong></li></ul><p>全局ID生成器,是一种在分布式系统下用来生成全局唯一ID的工具,一般满足下列特性:</p><ul><li><strong>唯一性</strong></li><li><strong>高可用</strong></li><li><strong>递增性</strong></li><li><strong>安全性</strong></li><li><strong>高性能</strong></li></ul><p>为了增加ID的安全性,我们可以不直接使用Redis自增的数值,而是拼接一些其他的信息.</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220311210845236.png" alt="image-20220311210845236">ID的组成部分:</p><blockquote><ul><li>符号位: 1bit, 永远为0</li><li>时间戳: 31bit,以秒为单位</li><li>序列号: 32bit,秒内的计数器, 支持每秒产生2^32个不同的ID</li></ul></blockquote><p>全局唯一ID生成策略:</p><blockquote><ul><li>UUID</li><li><strong>Redis自增</strong>*</li><li><strong>snowflake算法(雪花算法)</strong>*</li><li>数据库自增</li></ul></blockquote><p><strong>Redis自增策略</strong>:</p><ul><li>每天一个key, 方便统计订单量</li><li>ID构造是 时间戳 + 计数器</li></ul><h2 id="优惠券秒杀下单功能"><a href="#优惠券秒杀下单功能" class="headerlink" title="优惠券秒杀下单功能"></a>优惠券秒杀下单功能</h2><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220312123558073.png" alt="image-20220312123558073"></p><h3 id="超卖问题-线程安全问题"><a href="#超卖问题-线程安全问题" class="headerlink" title="超卖问题(线程安全问题)"></a>超卖问题(线程安全问题)</h3><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220312131903889.png" alt="image-20220312131903889"></p><p><strong>解决方案: 加锁</strong></p><ul><li><strong>悲观锁</strong></li><li><strong>乐观锁</strong></li></ul><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>认为线程安全问题一定会发生,因此在操作数据之前先获取锁,确保线程串行执行.</p><blockquote><ul><li>例如Synchronized, Lock都属于悲观锁</li><li>优点: 简单粗暴</li><li>缺点: 性能一般</li></ul></blockquote><hr><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>认为线程安全问题不一定会发生,因此不加锁,只是在更新数据时去判断有没有其他线程对数据进行了修改</p><blockquote><ul><li>如果没有修改则认为是安全的, 自己才更新数据</li><li>如果已经被其他线程修改说明发生了线程安全问题,此时可以重试或异常.</li><li>优点: 性能好</li><li>缺点存在成功率低的问题</li></ul></blockquote><p>乐观锁的关键是判断之前查询到的数据是否被修改过,常见的方式有两种:</p><ul><li><p>版本号法</p><p>设置一个用于悲观锁修改是判断的字段(版本号),每次修改后都会被修改</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220312132808463.png" alt="image-20220312132808463"></p></li><li><p>CAS法</p><p>利用本身的数据作为判断依据(不新增任何字段 用自身数据代替版本)</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220312133142933.png" alt="image-20220312133142933"></p></li></ul><h3 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h3><p>同一张优惠券一个用户只能下一单</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220312135825445.png" alt="image-20220312135825445"></p><h4 id="集群下的一人一单问题"><a href="#集群下的一人一单问题" class="headerlink" title="集群下的一人一单问题"></a>集群下的一人一单问题</h4><p>JVM中有一个锁监视器 单机情况下可以实现锁的监视,但是在集群模式下 多个的JVM有不同的锁监视器, 即集群模式下的悲观锁失效了(它只能保证单个JVM下的线程安全问题)</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220312142218951.png" alt="image-20220312142218951"></p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><strong>分布式锁</strong></h3><p>**分布式锁:**满足分布式系统或集群模式下多进程可见并且互斥的锁.</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220312142754987.png" alt="image-20220312142754987"></p><blockquote><ul><li><strong>多线程可见</strong>*</li><li><strong>互斥</strong>*</li><li><strong>高可用</strong>*</li><li><strong>高性能(指获得锁的性能)</strong>*</li><li><strong>安全性</strong>*</li><li>…</li></ul></blockquote><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220312143720266.png" alt="image-20220312143720266"></p><h3 id="实现分布式锁-此处的是实现都是基于一人一单的情况下"><a href="#实现分布式锁-此处的是实现都是基于一人一单的情况下" class="headerlink" title="实现分布式锁(此处的是实现都是基于一人一单的情况下)"></a><strong>实现分布式锁</strong>(此处的是实现都是基于一人一单的情况下)</h3><p>实现分布式锁需要实现两个基本方法</p><ul><li>获取锁</li><li>释放锁</li></ul><h3 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a><strong>基于Redis的分布式锁</strong></h3><p>利用SETNX的互斥机制 和DEL的删除机制</p><p>为了防止Redis异常宕机的情况下锁的安全性问题(需要设置锁的过期时间)</p><ul><li><p>获取锁:</p><ul><li><p>互斥: 确保只能有一个线程获取锁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">添加锁, NX是互斥 EX是设置超时时间</span></span><br><span class="line">set lock thread1 NX EX 10</span><br></pre></td></tr></table></figure></li></ul></li><li><p>释放锁:</p><ul><li><p>手动释放</p></li><li><p>超时释放: 获取锁时添加一个超时时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">释放锁, 删除即可</span></span><br><span class="line">DEL key</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220312145523204.png" alt="image-20220312145523204"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">//获取线程表示</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">//获取锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的分布式锁的线程安全问题</p><p>业务堵塞导致锁的时间到期释放, 第二个线程此时获取到锁,在执行业务中,一号线程业务堵塞完毕此时释放锁 就导致线程二的锁被释放了.</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220312152342991.png" alt="image-20220312152342991"></p><p>改进后</p><p>通过新增UUID+ThreadID作为锁标识 在释放锁之前判断锁标识是否一致(同一个线程的锁标识一致,这样就不会出现业务堵塞导致释放了其他线程的锁的情况)</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220312152522311.png" alt="image-20220312152522311"></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220312152710464.png" alt="image-20220312152710464"></p><h4 id="改进Redis的分布式锁"><a href="#改进Redis的分布式锁" class="headerlink" title="改进Redis的分布式锁"></a>改进Redis的分布式锁</h4><p>修改之前的分布式锁实现,满足</p><ol><li><p>在获取锁时存入线程表示(可用UUID表示)</p></li><li><p>在释放锁时先获取锁中的线程标识,判断是否与当前线程标识一致</p><blockquote><ul><li><p>如果不一致则不释放锁</p></li><li><p>如果一致则释放锁</p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取线程标识</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX+Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">//获取锁中的标识</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="comment">//判断是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(threadId.equals(id))&#123;</span><br><span class="line">        <span class="comment">//一致就释放锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX+name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则就不释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>改良后的Redis分布式锁 依旧存在如下问题就是在 删除锁的时候发生了堵塞 导致超时释放锁 此时二号线程进入获得锁执行业务,但是刚好一号线程堵塞完毕就将二号线程的锁释放了.</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220312173903547.png" alt="image-20220312173903547"></p><h3 id="Redis的Lua脚本"><a href="#Redis的Lua脚本" class="headerlink" title="Redis的Lua脚本"></a>Redis的Lua脚本</h3><p>释放锁业务的Lua脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 比较线程标示与锁中的标示是否一致</span><br><span class="line">if(redis.call(&#x27;get&#x27;, KEYS[1]) ==  ARGV[1]) then</span><br><span class="line">    -- 释放锁 del key</span><br><span class="line">    return redis.call(&#x27;del&#x27;, KEYS[1])</span><br><span class="line">end</span><br><span class="line">return 0</span><br></pre></td></tr></table></figure><h3 id="Java中调用Lua脚本"><a href="#Java中调用Lua脚本" class="headerlink" title="Java中调用Lua脚本"></a>Java中调用Lua脚本</h3><p>RedisTemplate可以直接调用Lua脚本</p><p>使用静态代码块初始化lua脚本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">    UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将原来java中的两行代码,变为了一行代码, 就不会出现上述的情况</p><p>改良后的unlock方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX+name),</span><br><span class="line">            ID_PREFIX+Thread.currentThread().getId());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于Redis的分布式锁优化"><a href="#基于Redis的分布式锁优化" class="headerlink" title="基于Redis的分布式锁优化"></a>基于Redis的分布式锁优化</h3><p>基于SETNX实现的分布式锁存在下面的问题:</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220312184555611.png" alt="image-20220312184555611"></p><p><a href="https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95"><strong>Redission官方文档</strong></a></p><p>Redission是一个在Redis的基础上实现的java驻内存数据网络(In-Memory Data Grid). 它不仅提供了一系列的分布式java常用对象,还提供了许多分布式服务,其中就包含了各种分布式锁的实现</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220312200824948.png" alt="image-20220312200824948"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1cr4y1671t?p=63&amp;spm_id_from=pageDriver&quot;&gt;Redis&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Redis是一种NOSQL型数据库,即一种非关系型数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们常见的Mysql是一种SQL型数据库,是一种关系型数据库&lt;/p&gt;</summary>
    
    
    
    <category term="NoSQL" scheme="https://devildyw.github.io/categories/NoSQL/"/>
    
    
    <category term="databese" scheme="https://devildyw.github.io/tags/databese/"/>
    
  </entry>
  
  <entry>
    <title>Git分布式版本控制工具</title>
    <link href="https://devildyw.github.io/2022/02/28/Git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"/>
    <id>https://devildyw.github.io/2022/02/28/Git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-03-06T15:57:12.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git分布式版本控制工具"><a href="#Git分布式版本控制工具" class="headerlink" title="Git分布式版本控制工具"></a><a href="D:\BaiduNetdiskDownload\Git讲义.pdf">Git分布式版本控制工具</a></h1><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220127230403996.png" alt="image-20220127230403996"></p><p><strong>命令如下：</strong></p><ol><li><strong>clone（克隆）</strong>: 从远程仓库中克隆代码到本地仓库</li><li><strong>checkout （检出）</strong>:从本地仓库中检出一个仓库分支然后进行修订</li><li><strong>add（添加）</strong>: 在提交前先将代码提交到暂存区</li><li><strong>commit（提交）</strong>: 提交到本地仓库。本地仓库中保存修改的各个历史版本</li><li><strong>fetch (抓取)</strong> ： 从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。</li><li><strong>pull (拉取)</strong> ： 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于fetch+merge</li><li><strong>push（推送）</strong> : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库</li></ol><span id="more"></span><hr><p><strong>备注：</strong></p><p><strong>Git GUI</strong>：Git提供的图形界面工具</p><p><strong>Git Bash</strong>：Git提供的命令行工具</p><p>当安装Git后首先要做的事情是<strong>设置用户名称</strong>和<strong>email</strong>地址。这是非常重要的，因为每次Git提交都会使用该用户信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;itcast&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;hello@qq.com&quot;</span></span><br></pre></td></tr></table></figure><p>查看配置信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git confifig --global user.name</span><br><span class="line">git confifig --global user.email</span><br></pre></td></tr></table></figure><hr><h2 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a><strong>本地仓库</strong></h2><p>要使用Git对我们的代码进行版本控制，首先需要获得本地仓库</p><ol><li><p>在电脑的任意位置创建一个空目录（例如test）作为我们的本地Git仓库</p></li><li><p>进入这个目录中，点击右键打开Git bash窗口</p></li><li><p>执行命令<strong>git init</strong> (初始化本文件为本地仓库)</p></li><li><p>如果创建成功后可在文件夹下看到隐藏的.git目录。</p></li></ol><hr><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a><strong>命令</strong></h2><ul><li><strong>git touch</strong> 文件名 可以创建文件</li></ul><hr><p>Git工作目录下对于文件的<strong>修改</strong>(增加、删除、更新)会存在几个状态，这些<strong>修改</strong>的状态会随着我们执行Git的命令而发生变化。</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220127231451204.png" alt="image-20220127231451204"></p><ul><li><p><strong>git add</strong> (工作区 –&gt; 暂存区) (<strong>git add . 将所有修改加入暂存区</strong>)</p></li><li><p><strong>git commit</strong> (暂存区 –&gt; 本地仓库) (<strong>git commit -m ‘注释内容’</strong> 将暂存区中的内容提交到本地仓库)</p></li><li><p><strong>git status</strong>:<strong>查看修改的状态</strong></p></li></ul><hr><p><strong>查看提交日志</strong></p><ul><li><p><strong>git log</strong> [option]</p></li><li><p>options</p><ul><li><p><strong>all</strong> 显示所有分支</p></li><li><p><strong>pretty&#x3D;oneline</strong> 将提交信息显示为一行</p></li><li><p><strong>abbrev-commit</strong> 使得输出的commitId更简短</p></li><li><p><strong>graph</strong> 以图的形式显示</p></li></ul></li></ul><p><strong>对log的格式进行自定义 并且对该操作使用alias起了一个别名</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg <span class="string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span></span><br></pre></td></tr></table></figure><hr><p><strong>版本回退</strong></p><ul><li>作用: 版本切换</li><li>命令: <strong>git reset –hard commitID</strong><ul><li><strong>commitID</strong> 可以使用 <strong>git lg</strong> 或 <strong>git log</strong> 指令查看</li></ul></li></ul><p><strong>如何查看已经删除的记录？</strong></p><ul><li><p><strong>git reflflog</strong></p></li><li><p>这个指令可以看到已经删除的提交记录</p></li></ul><hr><p><strong>添加文件至忽略列表</strong></p><p>一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以在工作目录中创建一个名为 <strong>.gitignore 的文件（文件名称固定）</strong>，列出要忽略的文件模式。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">HELP.md</span><br><span class="line">target/</span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar</span><br><span class="line">!**/src/main/**/target/</span><br><span class="line">!**/src/test/**/target/</span><br><span class="line"></span><br><span class="line"><span class="params">###</span> STS <span class="params">###</span></span><br><span class="line">.apt<span class="built_in">_</span>generated</span><br><span class="line">.classpath</span><br><span class="line">.factorypath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.springBeans</span><br><span class="line">.sts4-cache</span><br><span class="line"></span><br><span class="line"><span class="params">###</span> IntelliJ IDEA <span class="params">###</span></span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line"></span><br><span class="line"><span class="params">###</span> NetBeans <span class="params">###</span></span><br><span class="line">/nbproject/private/</span><br><span class="line">/nbbuild/</span><br><span class="line">/dist/</span><br><span class="line">/nbdist/</span><br><span class="line">/.nb-gradle/</span><br><span class="line">build/</span><br><span class="line">!**/src/main/**/build/</span><br><span class="line">!**/src/test/**/build/</span><br><span class="line"></span><br><span class="line"><span class="params">###</span> VS Code <span class="params">###</span></span><br><span class="line">.vscode/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a><strong>分支</strong></h2><p><strong>查看本地分支</strong></p><ul><li><strong>git branch</strong></li></ul><hr><p><strong>创建本地分支</strong></p><ul><li><strong>git branch 分支名</strong></li></ul><hr><p><strong>切换分支</strong></p><ul><li><strong>git checkout 分支名</strong></li><li><strong>git checkout -b 分支名 (创建并切换)</strong></li></ul><hr><p><strong>合并分支</strong></p><ul><li><strong>git merge 分支名称</strong></li></ul><hr><p><strong>删除分支</strong></p><ul><li><strong>git branch -d 分支名 (删除分支时，需要做各种检查)</strong></li><li><strong>git branch -D 分支名 (不做任何检查，强制删除)</strong></li></ul><hr><p><strong>解决冲突</strong></p><p>当两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解决冲突，解决冲突步骤如下：</p><ol><li><p>处理文件中冲突的地方</p></li><li><p>将解决完冲突的文件加入暂存区(add)</p></li><li><p>提交到仓库(commit)</p></li></ol><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220127233455735.png" alt="image-20220127233455735"></p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a><strong>远程仓库</strong></h2><ul><li><p><strong>注册gitee(码云)</strong></p></li><li><p><strong>创建仓库</strong></p></li></ul><p><strong>配置SSH公钥</strong></p><ul><li><p><strong>生成SSH公钥</strong></p><ul><li><strong>ssh-keygen -t rsa</strong></li></ul></li><li><p><strong>Gitee设置账户共公钥</strong></p><ul><li><p>上面我们以及生成了SSH公钥 这里我们要获取</p></li><li><p><strong>cat ~&#x2F;.ssh&#x2F;id_rsa.pub</strong> </p></li><li><p>复制这个SSH公钥</p></li><li><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220128220100844.png" alt="image-20220128220100844"></p></li><li><p>验证是否配置成功 <strong>ssh -T <a href="mailto:&#103;&#x69;&#x74;&#64;&#103;&#105;&#x74;&#x65;&#x65;&#x2e;&#99;&#x6f;&#x6d;">&#103;&#x69;&#x74;&#64;&#103;&#105;&#x74;&#x65;&#x65;&#x2e;&#99;&#x6f;&#x6d;</a></strong></p></li></ul><h4 id="操作远程仓库"><a href="#操作远程仓库" class="headerlink" title="操作远程仓库"></a>操作远程仓库</h4><ul><li><p><strong>添加远程仓库</strong> (此操作是先初始化本地仓库,然后与一创建的远程仓库进行对接)</p><ul><li><p><strong>命令: git remote add &lt;远端名称(别名)&gt; &lt;仓库路径(url)&gt;</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee.com:Devildyw/spring-mvc.git</span><br></pre></td></tr></table></figure></li><li><p><strong>命令: git remote</strong>(查看已添加的远程仓库)</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220128221118298.png" alt="image-20220128221118298"></p></li></ul></li></ul></li></ul><hr><ul><li><p><strong>推送到远程仓库</strong></p><ul><li><p><strong>命令: git push [-f] [–set-upstream] [远端名称[本地分支名 [:远端分支名]]</strong></p><ul><li><pre><code class="sh">git push origin master<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* **-f** 表示强制覆盖</span><br><span class="line"></span><br><span class="line">* **--set-upstream**: 推送到远端的同时并且建立起和远端分支的关联关系</span><br><span class="line"></span><br><span class="line">* ```sh</span><br><span class="line">  git push --set-upstream origin master</span><br></pre></td></tr></table></figure></code></pre></li><li><p>如果当前分支已经和远端分支建立关联,则可以省略分支名和远端名 <strong>(git push)</strong></p></li></ul></li><li><p><strong>查看本地分支与远程分支的关联关系</strong></p><ul><li><strong>命令: git brach -vv</strong></li></ul></li></ul></li></ul><hr><ul><li><strong>从远程仓库克隆(一般只有一开始会做一次 后续都会使用pull拉取)</strong><ul><li><strong>命令: git clone &lt;仓库路径&gt; [本地目录]</strong><ul><li>本地目录可以省略,会自动生成一个目录</li></ul></li></ul></li><li><strong>从远程仓库中抓取和拉取</strong><ul><li>远程分支和本地的分支一样，我们可以进行merge操作，只是需要先把远端仓库里的更新都下载到本地，再进行操作。<ul><li><strong>抓取 命令: git fetch [remote name] [branch name]</strong><ul><li><strong>抓取指令就是将仓库里的更新都抓取到本地，不会进行合并</strong></li><li>如果不指定远端名称和分支名，则抓取所有分支。</li></ul></li><li><strong>拉取 命令: git pull [remote name] [branch name]</strong><ul><li>**拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于 ** <strong>fetch+merge</strong></li><li>如果不指定远端名称和分支名，则抓取所有并更新当前分支。</li></ul></li></ul></li></ul></li></ul><hr><ul><li><p><strong>解决合并冲突</strong></p><ul><li><p>在一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突。A用户在本地修改代码后优先推送到远程仓库，此时B用户在本地修订代码，提交到本地仓库后，也需要推送到远程仓库，此时B用户晚于A用户，<strong>故需要先拉取远程仓库的提交，经过合并后才能推送到远端分支</strong></p></li><li><p>在B用户拉取代码时，因为A、B用户同一段时间修改了同一个文件的相同位置代码，故会发生合并冲突。<strong>远程分支也是分支，所以合并时冲突的解决方式也和解决本地分支冲突相同相同</strong></p></li><li><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220128223521930.png" alt="image-20220128223521930"></p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Git分布式版本控制工具&quot;&gt;&lt;a href=&quot;#Git分布式版本控制工具&quot; class=&quot;headerlink&quot; title=&quot;Git分布式版本控制工具&quot;&gt;&lt;/a&gt;&lt;a href=&quot;D:\BaiduNetdiskDownload\Git讲义.pdf&quot;&gt;Git分布式版本控制工具&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220127230403996.png&quot; alt=&quot;image-20220127230403996&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;clone（克隆）&lt;/strong&gt;: 从远程仓库中克隆代码到本地仓库&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;checkout （检出）&lt;/strong&gt;:从本地仓库中检出一个仓库分支然后进行修订&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;add（添加）&lt;/strong&gt;: 在提交前先将代码提交到暂存区&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;commit（提交）&lt;/strong&gt;: 提交到本地仓库。本地仓库中保存修改的各个历史版本&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fetch (抓取)&lt;/strong&gt; ： 从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pull (拉取)&lt;/strong&gt; ： 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于fetch+merge&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;push（推送）&lt;/strong&gt; : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="开发工具" scheme="https://devildyw.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="java" scheme="https://devildyw.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="https://devildyw.github.io/2022/02/28/ThreadLocal/"/>
    <id>https://devildyw.github.io/2022/02/28/ThreadLocal/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-03-06T15:59:02.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal-ThreadLocal-简书-jianshu-com"><a href="#ThreadLocal-ThreadLocal-简书-jianshu-com" class="headerlink" title="[ThreadLocal](ThreadLocal - 简书 (jianshu.com))"></a>[ThreadLocal](<a href="https://www.jianshu.com/p/3c5d7f09dfbd">ThreadLocal - 简书 (jianshu.com)</a>)</h1><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>threadlocal使用方法很简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;T&gt; sThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;T&gt;();</span><br><span class="line">sThreadLocal.set()</span><br><span class="line">sThreadLocal.get()</span><br></pre></td></tr></table></figure><p>threadlocal而是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据，官方解释如下。</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220211183419286.png" alt="image-20220211183419286"></p><p>大致意思就是ThreadLocal提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。通过get和set方法就可以得到当前线程对应的值。</p><p>做个不恰当的比喻，从表面上看ThreadLocal相当于维护了一个map，key就是当前的线程，value就是需要存储的对象。</p><p><strong>这里的这个比喻是不恰当的，实际上是ThreadLocal的静态内部类ThreadLocalMap为每个Thread都维护了一个数组table，ThreadLocal确定了一个数组下标，而这个下标就是value存储的对应位置。</strong></p><span id="more"></span><p>作为一个存储数据的类，关键点就在get和set方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**源码**/</span></span><br><span class="line"><span class="comment">//set 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">      <span class="comment">//获取当前线程</span></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">      <span class="comment">//实际存储的数据结构类型</span></span><br><span class="line">      <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">      <span class="comment">//如果存在map就直接set，没有则创建map并set</span></span><br><span class="line">      <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">          map.set(<span class="built_in">this</span>, value);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          createMap(t, value);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//getMap方法</span></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">      <span class="comment">//thred中维护了一个ThreadLocalMap</span></span><br><span class="line">      <span class="keyword">return</span> t.threadLocals;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//createMap</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">      <span class="comment">//实例化一个新的ThreadLocalMap，并赋值给线程的成员变量threadLocals</span></span><br><span class="line">      t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出<strong>每个线程持有一个ThreadLocalMap对象</strong>。每一个新的线程Thread都会实例化一个ThreadLocalMap并赋值给成员变量threadLocals，使用时若已经存在threadLocals则直接使用已经存在的对象。</p><hr><h2 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h2><p><img src="https://img-blog.csdnimg.cn/9e256d87362c4d9295589e3d72e69211.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGptXzk5,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>实线代表强引用,虚线代表弱引用</strong></p><ul><li><p>每一个Thread维护一个ThreadLocalMap, key为使用弱引用的ThreadLocal实例，value为线程变量的副本。</p></li><li><p>强引用，使用最普遍的引用，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。</p></li><li><p>如果想取消强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样可以使JVM在合适的时间就会回收该对象。</p></li><li><p>弱引用，JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>简单来说就是 ThreadLocal为每个线程提供了一个ThreadLocalMap对象 这样就避免了线程安全问题 实际开发中可以用于存储用户信息代替session</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ThreadLocal-ThreadLocal-简书-jianshu-com&quot;&gt;&lt;a href=&quot;#ThreadLocal-ThreadLocal-简书-jianshu-com&quot; class=&quot;headerlink&quot; title=&quot;[ThreadLocal](ThreadLocal - 简书 (jianshu.com))&quot;&gt;&lt;/a&gt;[ThreadLocal](&lt;a href=&quot;https://www.jianshu.com/p/3c5d7f09dfbd&quot;&gt;ThreadLocal - 简书 (jianshu.com)&lt;/a&gt;)&lt;/h1&gt;&lt;h4 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h4&gt;&lt;p&gt;threadlocal使用方法很简单&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; ThreadLocal&amp;lt;T&amp;gt; sThreadLocal = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ThreadLocal&lt;/span&gt;&amp;lt;T&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sThreadLocal.set()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sThreadLocal.get()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;threadlocal而是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据，官方解释如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220211183419286.png&quot; alt=&quot;image-20220211183419286&quot;&gt;&lt;/p&gt;
&lt;p&gt;大致意思就是ThreadLocal提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。通过get和set方法就可以得到当前线程对应的值。&lt;/p&gt;
&lt;p&gt;做个不恰当的比喻，从表面上看ThreadLocal相当于维护了一个map，key就是当前的线程，value就是需要存储的对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里的这个比喻是不恰当的，实际上是ThreadLocal的静态内部类ThreadLocalMap为每个Thread都维护了一个数组table，ThreadLocal确定了一个数组下标，而这个下标就是value存储的对应位置。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="开发工具" scheme="https://devildyw.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="java" scheme="https://devildyw.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？</title>
    <link href="https://devildyw.github.io/2022/02/28/%E5%8E%9F%E5%AD%90%E2%80%BB%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7/"/>
    <id>https://devildyw.github.io/2022/02/28/%E5%8E%9F%E5%AD%90%E2%80%BB%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-03-06T16:00:25.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java原子性是什么-中级Java应该清楚的概念：原子性、可见性、有序性是什么？"><a href="#java原子性是什么-中级Java应该清楚的概念：原子性、可见性、有序性是什么？" class="headerlink" title="java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？"></a>java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？</h1><p>原子性、可见性、有序性是多线程编程中最重要的几个知识点，由于多线程情况复杂，如何让每个线程能看到正确的结果，这是非常重要的，下面和千锋广州小编一起来看看吧！</p><p><a href="%5B(4%E6%9D%A1%E6%B6%88%E6%81%AF">原网站</a> java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？…_我才是Guido的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_42460182/article/details/114101352">https://blog.csdn.net/weixin_42460182/article/details/114101352</a>))</p><span id="more"></span><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性是指一个线程的操作是不能被其他线程打断，同一时间只有一个线程对一个变量进行操作。在多线程情况下，每个线程的执行结果不受其他线程的干扰，比如说多个线程同时对同一个共享成员变量n++100次，如果n初始值为0，n最后的值应该是100，所以说它们是互不干扰的，这就是传说的中的原子性。但n++并不是原子性的操作，要使用AtomicInteger保证原子性。</p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性是指某个线程修改了某一个共享变量的值，而其他线程是否可以看见该共享变量修改后的值。在单线程中肯定不会有这种问题，单线程读到的肯定都是最新的值，而在多线程编程中就不一定了。</p><p>每个线程都有自己的工作内存，线程先把共享变量的值从主内存读到工作内存，形成一个副本，当计算完后再把副本的值刷回主内存，从读取到最后刷回主内存这是一个过程，当还没刷回主内存的时候这时候对其他线程是不可见的，所以其他线程从主内存读到的值是修改之前的旧值。</p><p>像CPU的缓存优化、硬件优化、指令重排及对JVM编译器的优化，都会出现可见性的问题。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>我们都知道程序是按代码顺序执行的，对于单线程来说确实是如此，但在多线程情况下就不是如此了。为了优化程序执行和提高CPU的处理性能，JVM和操作系统都会对指令进行重排，也就说前面的代码并不一定都会在后面的代码前面执行，即后面的代码可能会插到前面的代码之前执行，只要不影响当前线程的执行结果。所以，指令重排只会保证当前线程执行结果一致，但指令重排后势必会影响多线程的执行结果。</p><p>虽然重排序优化了性能，但也是会遵守一些规则的，并不能随便乱排序，只是重排序会影响多线程执行的结果。</p><p>以上就是原子性、可见性、有序性的概念解释，希望对大家有帮助哦！</p><p><strong>相关资源：</strong><a href="https://download.csdn.net/download/weixin_38575456/12793647?spm=1001.2101.3001.5697"><em>Java</em>高并发三:<em>Java</em>内存模型和线程安全详解_<em>java</em>高并发模型-其它*.<strong>.</strong>.*</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;java原子性是什么-中级Java应该清楚的概念：原子性、可见性、有序性是什么？&quot;&gt;&lt;a href=&quot;#java原子性是什么-中级Java应该清楚的概念：原子性、可见性、有序性是什么？&quot; class=&quot;headerlink&quot; title=&quot;java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？&quot;&gt;&lt;/a&gt;java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？&lt;/h1&gt;&lt;p&gt;原子性、可见性、有序性是多线程编程中最重要的几个知识点，由于多线程情况复杂，如何让每个线程能看到正确的结果，这是非常重要的，下面和千锋广州小编一起来看看吧！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;%5B(4%E6%9D%A1%E6%B6%88%E6%81%AF&quot;&gt;原网站&lt;/a&gt; java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？…_我才是Guido的博客-CSDN博客](&lt;a href=&quot;https://blog.csdn.net/weixin_42460182/article/details/114101352&quot;&gt;https://blog.csdn.net/weixin_42460182/article/details/114101352&lt;/a&gt;))&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE" scheme="https://devildyw.github.io/categories/JavaSE/"/>
    
    
    <category term="java" scheme="https://devildyw.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务</title>
    <link href="https://devildyw.github.io/2022/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <id>https://devildyw.github.io/2022/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-03-06T16:00:15.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><h3 id="事务的基本要素-4大性质"><a href="#事务的基本要素-4大性质" class="headerlink" title="事务的基本要素 4大性质"></a><strong>事务的基本要素 4大性质</strong></h3><blockquote><ol><li>原子性:事务开始后的所有操作,要么全部成功,要么全部失败回滚,不可能停滞在中间环节.事务执行过程中出错,会回滚到事务开始之前的状态,所有操作就像没有发生一样.也就是说事务是一个不可分割的整体,就像化学中学过的原子,是事务构成的基本单位.</li><li>一致性:事务开始前和结束后,数据库的完整性约束没有被破坏,如A向B转张,不可能出现A扣了钱而B却没有加的情况</li><li>隔离性:同一时间,只允许一个事务请求同一数据,不同事务之间彼此没有任何干扰,如A正在从一张银行卡中取钱,在A取钱的过程结束前,B不能向这张卡转账.</li><li>持久性:事务完成之后,事务对数据库更新将会被保存写在数据库上,不能回滚.</li></ol></blockquote><span id="more"></span><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p> <strong>隔离级别定义了一个事务可能受其他并发事务影响的程度。</strong></p><blockquote><p><strong>脏读（Dirty reads）</strong>—— 事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。</p><p><strong>不可重复读（Nonrepeatable read）</strong>—— 事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</p><p><strong>幻读（Phantom read）</strong>—— 系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p></blockquote><p>不可重复读是指在原本有个数据上进行修改导致一个事务一致都是读到不同的数据, 而幻读则是在原来的数据中的插入,删除等操作导致的.<strong>解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</strong></p><hr><p><strong>串行化</strong>隔离规则类型在开发中很少用到。举个很简单的例子。咱们使用了ISOLATION_SERIALIZABLE规则。A,B两个事务操作同一个数据表并发过来了。A先执行。A事务这个时候会把表给锁住，B事务执行的时候直接报错。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据库事务&quot;&gt;&lt;a href=&quot;#数据库事务&quot; class=&quot;headerlink&quot; title=&quot;数据库事务&quot;&gt;&lt;/a&gt;数据库事务&lt;/h1&gt;&lt;h3 id=&quot;事务的基本要素-4大性质&quot;&gt;&lt;a href=&quot;#事务的基本要素-4大性质&quot; class=&quot;headerlink&quot; title=&quot;事务的基本要素 4大性质&quot;&gt;&lt;/a&gt;&lt;strong&gt;事务的基本要素 4大性质&lt;/strong&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;原子性:事务开始后的所有操作,要么全部成功,要么全部失败回滚,不可能停滞在中间环节.事务执行过程中出错,会回滚到事务开始之前的状态,所有操作就像没有发生一样.也就是说事务是一个不可分割的整体,就像化学中学过的原子,是事务构成的基本单位.&lt;/li&gt;
&lt;li&gt;一致性:事务开始前和结束后,数据库的完整性约束没有被破坏,如A向B转张,不可能出现A扣了钱而B却没有加的情况&lt;/li&gt;
&lt;li&gt;隔离性:同一时间,只允许一个事务请求同一数据,不同事务之间彼此没有任何干扰,如A正在从一张银行卡中取钱,在A取钱的过程结束前,B不能向这张卡转账.&lt;/li&gt;
&lt;li&gt;持久性:事务完成之后,事务对数据库更新将会被保存写在数据库上,不能回滚.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://devildyw.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="database" scheme="https://devildyw.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>数据库(mysql)</title>
    <link href="https://devildyw.github.io/2022/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://devildyw.github.io/2022/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-03-06T16:00:04.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"># 展示所有数据库</span><br><span class="line">show databases;</span><br><span class="line"># 展示创建数据库的一些详细操作 以及数据库的字符集 等其他信息 可以用来查看已经创建的数据库的一些详细信息</span><br><span class="line">show create database mysql;</span><br><span class="line"># 创建数据库时指定字符集</span><br><span class="line">create database db2 character set gbk;</span><br><span class="line"></span><br><span class="line">show create database db2;</span><br><span class="line"># 删除数据库 如果数据库存在</span><br><span class="line">drop database if exists db2;</span><br><span class="line"># 创建数据库 如果数据库不存在</span><br><span class="line">create database if not exists db2;</span><br><span class="line"># 修改数据库的字符集</span><br><span class="line">alter database db2 character set gb2312;</span><br><span class="line"># 查询正在使用的数据库</span><br><span class="line">select database();</span><br><span class="line"># 查看数据库中的所有表</span><br><span class="line">show tables;</span><br><span class="line"># 使用数据库（选择） </span><br><span class="line">use world;</span><br><span class="line"># 查看表的结构</span><br><span class="line">desc city;</span><br><span class="line"></span><br><span class="line">use my_db;</span><br><span class="line"># 创建表</span><br><span class="line">create table student(</span><br><span class="line">id int,</span><br><span class="line">    name varchar(32),</span><br><span class="line">    age int,</span><br><span class="line">    score double(4,1),</span><br><span class="line">    birthday date,</span><br><span class="line">    insert_time timestamp default current_timestamp);</span><br><span class="line">    </span><br><span class="line">desc student;</span><br><span class="line"># 删除表</span><br><span class="line">drop table student;</span><br><span class="line"></span><br><span class="line">show tables;</span><br><span class="line"># 删除表如果表存在</span><br><span class="line">drop table if exists student;</span><br><span class="line"># 修改表的名字</span><br><span class="line">alter table student rename to stu;</span><br><span class="line"># 修改表的字符集</span><br><span class="line">alter table stu character set gbk;</span><br><span class="line"></span><br><span class="line">drop table if exists stu;</span><br><span class="line">#查看创建表的操作 与一些详细信息</span><br><span class="line">show create table stu;</span><br><span class="line"># 增加新的一列并指定类型</span><br><span class="line">alter table stu add gender varchar(10);</span><br><span class="line"></span><br><span class="line">desc stu;</span><br><span class="line"></span><br><span class="line">alter table stu change gender sex varchar(20);</span><br><span class="line"># 修改执行列的类型</span><br><span class="line">alter table stu modify sex varchar(10);</span><br><span class="line"># 插入一行 如果没有指定插入那些元素 则你默认全部修改</span><br><span class="line">insert into stu (id,name,age) values(1,&quot;肖明桓&quot;,19);</span><br><span class="line"># 查询表中的全部信息</span><br><span class="line">select* from stu;</span><br><span class="line"># where条件语句 查询指定条件的行</span><br><span class="line">delete from stu where id = 2;</span><br><span class="line"></span><br><span class="line">create table stu(</span><br><span class="line">id int,</span><br><span class="line">name varchar(32),</span><br><span class="line">age int,</span><br><span class="line">score double(4,1),</span><br><span class="line">birthday date,</span><br><span class="line">insert_time timestamp default CURRENT_TIMESTAMP);</span><br><span class="line"></span><br><span class="line">drop table stu;</span><br><span class="line"></span><br><span class="line">insert into stu (id,name,age) values(2,&quot;张敏&quot;,19);</span><br><span class="line"></span><br><span class="line">insert into stu (id,name,age) values(3,&quot;丁杨维&quot;,19);</span><br><span class="line"></span><br><span class="line"># truncate  在创建一个空表</span><br><span class="line">truncate stu;</span><br><span class="line"></span><br><span class="line">#delete from 表名 9[where语句] 删除指定的多少条记录</span><br><span class="line">delete from stu where id = 2;</span><br><span class="line"></span><br><span class="line"># updata from 表名 set 列名 = 值 [where条件] 修改指定元组中的列的值 如不加条件则会将列的所有值都修改</span><br><span class="line">update stu set age = 20 where id = 1;</span><br><span class="line"></span><br><span class="line">update stu set age = 20; </span><br><span class="line"></span><br><span class="line">update stu set score = 70 where id = 2;</span><br><span class="line"></span><br><span class="line">update stu set score = 88 where id = 3;</span><br><span class="line"></span><br><span class="line">update stu set age = 19 where id = 3;</span><br><span class="line">update stu set age = 21 where id = 2;</span><br><span class="line"></span><br><span class="line">update stu set score = 99;</span><br><span class="line"></span><br><span class="line"># 排序 asc 升序 desc 降序 </span><br><span class="line">select* from stu order by score asc; </span><br><span class="line"></span><br><span class="line"># 排序 如果数学成绩一样 则按年龄排序</span><br><span class="line">select* from stu order by score asc, age asc;</span><br></pre></td></tr></table></figure><blockquote><p><strong>聚合函数</strong> 计算会排除null值</p><ol><li>count：计算个数</li></ol><p>  一般以主键作为计数标记 一般不用count(*)(只要一列中有一个不为null那么count就加一);</p><ol start="2"><li><p>max</p></li><li><p>min</p></li><li><p>sum</p></li><li><p>avg</p></li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(ifnull(english,0)) from student;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<strong>聚合函数</strong> 计算会排除null值 </p><p>解决方案：</p><ol><li><p>选择不为空的列进行计算</p></li><li><p>使用ifnull 函数 </p><blockquote><p>select count(ifnull(english,0)) from student; 将english为null的值按0计数</p></blockquote></li></ol><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>操作数据库database 的关键字： create 创建 drop删除 alter 修改 show展示</p><p>table表的关键字 create创建 drop删除 alter修改 desc展示表的结构 </p><p>table中的行的插入 insert into 修改 update 删除 delete 查询 select。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM my_db.stu;</span><br><span class="line"># 主键就是 既非空又唯一的特殊约束 primary key </span><br><span class="line"></span><br><span class="line">#添加主键 方式一</span><br><span class="line">alter table stu modify id int primary key;</span><br><span class="line"># 添加主键 方式二 建表的时候定义</span><br><span class="line"></span><br><span class="line"># 删除主键 alter table 表名 drop primary key 一张表只有一个主键;</span><br><span class="line">alter table stu drop primary key;</span><br><span class="line"></span><br><span class="line"># 非空约束 NOT NULL;</span><br><span class="line"># 创建方式一</span><br><span class="line">alter table stu modify name varchar(32) not null;</span><br><span class="line">#创建方式二 创建表时定义</span><br><span class="line"></span><br><span class="line"># 删除非空约束</span><br><span class="line">alter table stu modify name varchar(32);</span><br><span class="line"></span><br><span class="line"># 唯一约束 unique</span><br><span class="line">#创建方式一 创建表时定义</span><br><span class="line">#创建方式二  </span><br><span class="line">alter table stu modify name varchar(32) unique;</span><br><span class="line">#删除 唯一约束</span><br><span class="line"># 错误方式 alter table stu modify name varchar(32);</span><br><span class="line">alter table stu drop index name ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 删除外键</span><br><span class="line">alter table stu1 drop foreign key c_key;</span><br><span class="line"># 添加外键方式一:</span><br><span class="line">alter table stu1 add constraint c_key foreign key(cid) references course(id);</span><br><span class="line"># 添加外键方式二: 创建时就定义 一般格式 constraint 外键名 foreign key(列名) references 表名 (列名);</span><br><span class="line"></span><br><span class="line"># 复制表的结构方式一用 like 模板 create table 新表 like 旧表 会将约束关系一同复制;</span><br><span class="line">create table stu2 like stu1;</span><br><span class="line"></span><br><span class="line"># 复制表的结构方式二用 create table 新表 select* from 旧表 where 1 = 2 但不会将约束关系一同复制;</span><br><span class="line">create table stu3 select * from stu1 where 1 = 2;</span><br><span class="line"># 复制表的结构与数据 create table 新表 select* from 旧表 但不会将约束关系一同复制;</span><br><span class="line">create table stu4 select* from stu1;</span><br><span class="line"></span><br><span class="line"># 主键约束自动增长 不给主键定值的情况下主键会按照主键的上一个值加一</span><br><span class="line"># 添加方式一: alter table 表名 modify 列名 类型 主键约束 auto_increment;</span><br><span class="line"># 添加方式二: 创建表的时候定义;</span><br><span class="line">alter table stu2 modify id int primary key auto_increment;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h1&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://devildyw.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="database" scheme="https://devildyw.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>每日一记--多线程（续）</title>
    <link href="https://devildyw.github.io/2022/02/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0--%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%BB%AD%EF%BC%89/"/>
    <id>https://devildyw.github.io/2022/02/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0--%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%BB%AD%EF%BC%89/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-03-06T15:59:43.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每日一记–多线程（续）"><a href="#每日一记–多线程（续）" class="headerlink" title="每日一记–多线程（续）"></a>每日一记–多线程（续）</h1><hr><p>今天看了看书 更了解了多线程。</p><h2 id="Java中的线程"><a href="#Java中的线程" class="headerlink" title="Java中的线程"></a>Java中的线程</h2><p><strong>程序</strong>：程序是一段静态的代码，他是应用软件执行的蓝本。</p><p><strong>进程</strong>：进程是程序的一次动态执行过程，它对应了从代码加载、执行至完毕的一个完整过程，这个过程也是进程本身从产生、发展至消亡的过程。</p><p><strong>线程</strong>：线程是比进程更小的执行单位。线程之间可以共享相同的内存单元（即内存中的堆区 包括代码和数据）并利用这些共享单元来实现数据交换、实时通信与必要的同步操作。</p><p><strong>进程与线程的关系</strong>：一个进程在其执行的过程中可以产生多个线程，形成多条执行线索，每条线索，即没有线程都有它自身的产生、存在与消亡的过程，也是一个动态的概念。</p><p><strong>多线程原理</strong>：我们知道，操作系统分时管理各个进程，按时间片轮流执行每个进程。Java的多线程就是在操作系统每次分时给Java程序一个时间片的cpu时间内，在若干个独立的可控制的线程之间进行切换。如果机器能有多个cpu处理器，那么JVM就能充分利用这些cpu，使得Java程序在同一时刻能获得多个时间片，Java程序就可以获得真实的线程并发执行效果。</p><p><strong>主线程</strong>：每个Java程序都有一个默认的主线程，这个线程就是当执行主类main方法开始执行时，当JVM加载代码发现main方法之后，就会启动一个线程，这个线程就被称为<strong>“主线程”</strong>，该线程负责执行main方法，如果在main方法的执行过程中再创建的线程 就称为<strong>其他线程</strong>。如果main方法中没有创建其他线程，那么当main方法执行完最后一个语句，JVM就会结束Java应用程序。如果main方法中有创建了其他线程，那么JVM就要在主线程和其他线程之间轮流切换，以保证每个线程都能有机会使用cpu资源。</p><p><strong>注</strong>：main方法即使执行完最后的语句（主线程结束），JVM也不会结束程序，JVM会等待程序中其他线程都结束才会结束Java应用程序。</p><span id="more"></span><hr><h3 id="线程的状态与生命周期"><a href="#线程的状态与生命周期" class="headerlink" title="线程的状态与生命周期"></a>线程的状态与生命周期</h3><p><strong>新建状态</strong>：当一个Thread类或其子类的对象被声明并创建时，新生的线程处于NEW状态。此时它已经有了相应的内存空间和其他资源，即此时线程已准备但尚未启动（未调用**start()**方法），此时JVM管理的线程中还没有这个线程。</p><p><strong>可运行状态</strong>：当处于NEW状态的线程调用了Thread类提供的**start()**方法，此时线程就会进入RUNNABLE状态，称为可运行状态，此时JVM就会知道有一个新的线程在等待切换了。</p><p><strong>中断状态</strong>：<strong>BOLOCKED、WAITING、TIMED_WAITING</strong>状态都属于中断状态，当中断的线程重新进入RUNNABLE状态后，一旦JVM将cpu使用权切换给该线程，<strong>run()<strong>方法将</strong>从中断出继续执行</strong>。</p><ul><li>JVM将从cpu资源从当前RUNNABLE线程切换给其他线程，是本线程让出cpu的使用权进入BLOCKED状态，进入BOLOCKED状态的线程必须等待JVM解除它的BLOCKED状态，再次进入RUNNABLE状态，并从中断处继续执行。</li><li>线程使用cpu资源期间，执行了<strong>sleep(int millsecond)</strong>,使得当前线程进入休眠状态。<strong>sleep(int millsecond)<strong>方法是Thread类的类方法，一个线程一旦执行了这个方法，就立刻让出cpu使用权，使当前线程处于</strong>TIMED_WAITING</strong>状态。经过至多参数<strong>millsecond</strong>指定的毫秒数之后，该线程再次进入RUNNABLE状态。</li><li>线程使用cpu资源期间，执行了wait()方法，使得当前线程进入<strong>WAITING</strong>状态。该状态的线程不会主动进入RUNNABLE状态，必须由其他线程调用**notify()**方法通知它，使得它进入RUNNABLE状态。</li></ul><p><strong>死亡状态</strong>：当一个线程执行完<strong>run()<strong>方法，该线程就完成了它的全部工作进入</strong>TERMINATED状态</strong>。</p><p><strong>注</strong>：只有处于NEW状态的线程才可以调用<strong>start()<strong>方法，处于其他状态的线程都不可以调用该方法，否则将会触发</strong>IllegalThreadStateException</strong>异常</p><hr><p>例：用继承Thread的子类创建两个线程，这两个线程在控制台分别输出五句“老虎”和“小猫”；主线程控制台输出6句主人。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DEVIL.多线程;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil(丁杨维)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-14-22:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E_06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;<span class="comment">//主线程</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">//通过Thread类子类创建一个线程 此时出NEW状态</span></span><br><span class="line">        <span class="type">Tiger</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tiger</span>();<span class="comment">//创建另一个线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Tiger线程的状态&quot;</span>+ t1.getState());<span class="comment">//获取线程的状态</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Cat线程的状态&quot;</span>+ t2.getState());</span><br><span class="line">        t1.start();<span class="comment">//启动线程 是现成进入RUNNABLE状态</span></span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;\n%s&quot;</span>,<span class="string">&quot;Tiger线程的状态&quot;</span>+ t1.getState());<span class="comment">//获取线程执行时状态</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;\n%s&quot;</span>,<span class="string">&quot;Cat线程的状态&quot;</span>+t2.getState());</span><br><span class="line">            System.out.printf(<span class="string">&quot;\n%s&quot;</span>,<span class="string">&quot;主人&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;\nTiger线程的状态&quot;</span>+ t1.getState());<span class="comment">//获取线程执行结束时状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Cat线程的状态&quot;</span>+ t2.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;|小猫&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;|老虎&quot;</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//延时1秒 使其进入TIMED_WAITING状态</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Tiger线程的状态NEW</span><br><span class="line">Cat线程的状态NEW</span><br><span class="line">Tiger线程的状态RUNNABLE|老虎1|小猫1|小猫2|小猫3|小猫4|小猫5</span><br><span class="line"></span><br><span class="line">Cat线程的状态BLOCKED</span><br><span class="line">主人1</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">主人2</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">主人3</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">主人4</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">主人5</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">主人6</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">|老虎2|老虎3|老虎4|老虎5</span><br></pre></td></tr></table></figure><p><strong>注</strong>：程序在不同的计算机运行或在同一台计算机上反复运行的结果不尽相同，输出结果依赖于当前cpu使用情况。当其他线程的<strong>run()<strong>方法都结束了，线程进入</strong>死亡状态</strong>，只留下一个线程时，<strong>JVM</strong>不再将cpu资源切给主线程，等到最后一个线程也结束了，<strong>JVM</strong>就将java程序退出虚拟机，即java程序的结束。</p><hr><h3 id="线程的调度与优先级"><a href="#线程的调度与优先级" class="headerlink" title="线程的调度与优先级"></a>线程的调度与优先级</h3><blockquote><p>处于就绪状态的线程首先进入就绪队列排队等候cpu资源，同一时刻再就绪队列中的线程可能由多个。Java虚拟机（JVM）中的<strong>线程调度器</strong>负责管理线程，调度器把线程的的优先级分为了10个级别，分别用<strong>Thread类</strong>中的类常量表示。每个Java线程的优先级都为常数1~10，即<strong>Thread.MIN_PRIORITY和Thread.MAX_PRIORITY</strong>之间。<em><strong>如果没有明确第设置线程的优先级别，每个线程的优先级都默认为常数5</strong></em>，即<strong>Thread.NORM_PRIORITY</strong>。</p><p>线程的优先级可以通过<strong>setPriority(int grade)<strong>方法调整，该方法需要一个int参数代表设置线程的等级，如果该参数不在1~10的范围内，那么</strong>setPriority</strong>便会产生一个<strong>IllegalArgumentException</strong>异常。如果参数正常该方法会返回所设置的线程的优先级。（ <strong>注</strong>：有些操作系统只能识别3个级别，即1、5和10。）</p><p><strong>java线程调度器</strong>的任务就是使高优先级的线程能始终运行，一旦时间片有空闲，则使具有同等优先级的线程以轮流D这四个线程，且A和B的级别高于C和D，那么，Java调度器首先以轮流的方式执行A和B，一直等到A、B都执行完毕进入死亡状态，才会再C、D之间轮流切换。）</p><p><strong>注</strong>：在实际编程时，不提倡使用线程的优先级来保证算法的正确执行。如果要编写正确、跨平台的多线程代码，必须假设线程在任何时刻都有可能被剥夺cpu资源的使用权</p></blockquote><hr><h2 id="Java程序内存的简单分析"><a href="#Java程序内存的简单分析" class="headerlink" title="Java程序内存的简单分析"></a>Java程序内存的简单分析</h2><ul><li><strong>栈：</strong>一般来说，<strong>基本数据类型</strong>直接在栈中分配空间，<strong>局部变量</strong>（在方法代码段中定义的变量）也在栈中直接分配空间，<strong>当局部变量所在方法执行完成之后该空间便立刻被JVM回收</strong>，还有一种是<strong>引用数据类型</strong>，即我们通常所说的需要用<strong>关键字new创建出来的对象所对应的引用</strong>也是在栈空间中，此时，JVM在栈空间中给对象引用分配了一个地址空间（相当于一个门牌号，通过这个门牌号就可以找到你家），在堆空间中给该引用的对象分配一个空间，栈空间中的地址引用指向了堆空间中的对象区（通过门牌号找住址）；</li><li><strong>堆：</strong>一般用来存放用<strong>关键字new出来的数据</strong>。</li></ul><hr><p>–end–</p><p>今天还是摸索学习方法的一天呢。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;每日一记–多线程（续）&quot;&gt;&lt;a href=&quot;#每日一记–多线程（续）&quot; class=&quot;headerlink&quot; title=&quot;每日一记–多线程（续）&quot;&gt;&lt;/a&gt;每日一记–多线程（续）&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;今天看了看书 更了解了多线程。&lt;/p&gt;
&lt;h2 id=&quot;Java中的线程&quot;&gt;&lt;a href=&quot;#Java中的线程&quot; class=&quot;headerlink&quot; title=&quot;Java中的线程&quot;&gt;&lt;/a&gt;Java中的线程&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;程序&lt;/strong&gt;：程序是一段静态的代码，他是应用软件执行的蓝本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;：进程是程序的一次动态执行过程，它对应了从代码加载、执行至完毕的一个完整过程，这个过程也是进程本身从产生、发展至消亡的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;：线程是比进程更小的执行单位。线程之间可以共享相同的内存单元（即内存中的堆区 包括代码和数据）并利用这些共享单元来实现数据交换、实时通信与必要的同步操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程与线程的关系&lt;/strong&gt;：一个进程在其执行的过程中可以产生多个线程，形成多条执行线索，每条线索，即没有线程都有它自身的产生、存在与消亡的过程，也是一个动态的概念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多线程原理&lt;/strong&gt;：我们知道，操作系统分时管理各个进程，按时间片轮流执行每个进程。Java的多线程就是在操作系统每次分时给Java程序一个时间片的cpu时间内，在若干个独立的可控制的线程之间进行切换。如果机器能有多个cpu处理器，那么JVM就能充分利用这些cpu，使得Java程序在同一时刻能获得多个时间片，Java程序就可以获得真实的线程并发执行效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主线程&lt;/strong&gt;：每个Java程序都有一个默认的主线程，这个线程就是当执行主类main方法开始执行时，当JVM加载代码发现main方法之后，就会启动一个线程，这个线程就被称为&lt;strong&gt;“主线程”&lt;/strong&gt;，该线程负责执行main方法，如果在main方法的执行过程中再创建的线程 就称为&lt;strong&gt;其他线程&lt;/strong&gt;。如果main方法中没有创建其他线程，那么当main方法执行完最后一个语句，JVM就会结束Java应用程序。如果main方法中有创建了其他线程，那么JVM就要在主线程和其他线程之间轮流切换，以保证每个线程都能有机会使用cpu资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：main方法即使执行完最后的语句（主线程结束），JVM也不会结束程序，JVM会等待程序中其他线程都结束才会结束Java应用程序。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE" scheme="https://devildyw.github.io/categories/JavaSE/"/>
    
    
    <category term="java" scheme="https://devildyw.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>每日一记--synchronized关键字</title>
    <link href="https://devildyw.github.io/2022/02/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0--synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://devildyw.github.io/2022/02/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0--synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-03-06T15:59:33.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每日一记–synchronized关键字"><a href="#每日一记–synchronized关键字" class="headerlink" title="每日一记–synchronized关键字"></a>每日一记–synchronized关键字</h1><h2 id="synchronized关键字（隐式的获取和释放锁）"><a href="#synchronized关键字（隐式的获取和释放锁）" class="headerlink" title="synchronized关键字（隐式的获取和释放锁）"></a>synchronized关键字（隐式的获取和释放锁）</h2><p>作用于静态方法：</p><p><strong>对象锁</strong>给对象加锁（可以理解为这个对象的内存上锁，<strong>注意：只是这块内存，其他同类对象都会有各自的内存锁</strong>）这时候在其他一个以上线程中执行该对象的这个同步方法（<strong>注意：是该对象</strong>）就会产生互斥）</p><p>作用于静态方法：</p><p><strong>类锁</strong>：相当于在类上枷锁（*.class位于代码区，静态方法位于静态区域，这个类产生的对象公用这个静态方法，所以这块内存，N个对象来竞争），这时候，只要是这个类产生的对象，在调用这个静态方法时都会产生互斥</p><p><strong>对象锁与类锁区别</strong>：主要就在于内存区域不同 <strong>对象锁</strong>只作用与同类的单个对象的内存区域 <strong>类锁</strong>则作用于同类的所有对象的内存区域 </p><span id="more"></span><p>Java线程内存模型：每个线程都用拥有自己的栈、堆内存共享、如下图所示。锁是线程间内存和信息沟通的载体。<img src="https://images2015.cnblogs.com/blog/491378/201607/491378-20160720152209982-808156316.png" alt="img"></p><p>Java中为了保证每个线程中的原子操作，引入了内置锁或者称监视器锁，其中，每个Java对象都可以作为实现锁的对象。</p><p>synchronized关键字修饰的代码块被称为同步代码块 ，线程进入同步代码块自动获取内置锁，退出同步代码块则释放锁，不需要调用者考虑它的创建以及消除而别的线程此时无法获得这把锁，就无法调用这个方法。一个线程想要获得这个锁只能等上一个线程执行结束这个方法将锁释放，下一个线程才能有机会调用这个方法获得该对象的锁（即synchronized关键字可以获得内置锁，同一时间只允许一个线程获得某个锁）。</p><blockquote><p>java的每个对象都有一个锁，不需要显示地去创建。</p><p><strong>java的内置锁</strong>：每个java对象都可以用做一个实现同步的锁，这些锁称为<strong>内置锁</strong>。<strong>线程</strong>进入同步代码块或方法的时候会<strong>自动获得该锁</strong>，在<strong>退出</strong>同步代码块或方法时会<strong>释放</strong>该锁。获得内置锁的<strong>唯一途径就是进入这个锁的保护的同步代码块或方法</strong>。</p><p><strong>java内置锁</strong>是一个<strong>互斥锁</strong>，这就意味着同一时间最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，线程A必须<strong>等待或者阻塞</strong>，直到线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。</p></blockquote><p><strong>1.同步方法（粗粒度锁）</strong>：</p><p>即有<strong>synchronized</strong>关键字修饰的方法。</p><p><strong>由于java中每个对象都有一个内置锁，当使用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.<strong>同步代码块（细粒度锁）</strong>：</p><p>即有<strong>synchronized</strong>关键字修饰的语句块。</p><p>被该关键字修饰的语句块会被自动加上内置锁，从而实现同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object)&#123; </span><br><span class="line">代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：同步是一种高开销的操作，因此应该尽量减少同步的内容。 通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。</strong> 同步会影响一定的多线程性能</p><p><strong>synchronized的缺陷</strong>：当某个线程进入同步方法获得对象锁，那么其他线程访问这里对象的同步方法时，必须等待或者阻塞，这对高并发的系统是致命的，这很容易导致系统的崩溃。如果某个线程在同步方法里面发生了死循环，那么它就永远不会释放这个对象锁，那么其他线程就要永远的等待。这是一个致命的问题。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;每日一记–synchronized关键字&quot;&gt;&lt;a href=&quot;#每日一记–synchronized关键字&quot; class=&quot;headerlink&quot; title=&quot;每日一记–synchronized关键字&quot;&gt;&lt;/a&gt;每日一记–synchronized关键字&lt;/h1&gt;&lt;h2 id=&quot;synchronized关键字（隐式的获取和释放锁）&quot;&gt;&lt;a href=&quot;#synchronized关键字（隐式的获取和释放锁）&quot; class=&quot;headerlink&quot; title=&quot;synchronized关键字（隐式的获取和释放锁）&quot;&gt;&lt;/a&gt;synchronized关键字（隐式的获取和释放锁）&lt;/h2&gt;&lt;p&gt;作用于静态方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象锁&lt;/strong&gt;给对象加锁（可以理解为这个对象的内存上锁，&lt;strong&gt;注意：只是这块内存，其他同类对象都会有各自的内存锁&lt;/strong&gt;）这时候在其他一个以上线程中执行该对象的这个同步方法（&lt;strong&gt;注意：是该对象&lt;/strong&gt;）就会产生互斥）&lt;/p&gt;
&lt;p&gt;作用于静态方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类锁&lt;/strong&gt;：相当于在类上枷锁（*.class位于代码区，静态方法位于静态区域，这个类产生的对象公用这个静态方法，所以这块内存，N个对象来竞争），这时候，只要是这个类产生的对象，在调用这个静态方法时都会产生互斥&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象锁与类锁区别&lt;/strong&gt;：主要就在于内存区域不同 &lt;strong&gt;对象锁&lt;/strong&gt;只作用与同类的单个对象的内存区域 &lt;strong&gt;类锁&lt;/strong&gt;则作用于同类的所有对象的内存区域 &lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE" scheme="https://devildyw.github.io/categories/JavaSE/"/>
    
    
    <category term="java" scheme="https://devildyw.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>每日一记</title>
    <link href="https://devildyw.github.io/2022/02/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    <id>https://devildyw.github.io/2022/02/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-03-06T15:59:20.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h1><hr><h2 id="栈简单应用之符号匹配"><a href="#栈简单应用之符号匹配" class="headerlink" title="栈简单应用之符号匹配"></a>栈简单应用之符号匹配</h2><p><strong>关键：</strong>读括号时，如果时括号的左半部分（正常情况下，括号的左半部分总是先读到）,如果遇到括号的右半部分，获取栈顶元素，如果匹配则弹出栈，如果不匹配依旧弹栈且哨兵flag记为FALSE,最后如果flag为TRUE且栈不为空或是flag为FALSE且栈为空则符号不匹配，如果栈为空且flag为TRUE则符号匹配。</p><span id="more"></span><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DEVIL.泛型与集合框架.堆栈;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil(丁杨维)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-12-18:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">栈应用之符号匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E_04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//先创建一个栈的对象</span></span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//设置哨兵 将他初始化为true</span></span><br><span class="line">        String str;</span><br><span class="line">        <span class="comment">//输入一行字符串其中包含符号(如&#x27;(&#x27; &#x27;)&#x27; &#x27;[&#x27; &#x27;]&#x27; &#x27;&#123;&#x27; &#x27;&#125;&#x27;);</span></span><br><span class="line">        str = sc.nextLine();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;str.length();i++)&#123;<span class="comment">//筛选已输入字符串中符合条件的符号</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&#x27;(&#x27;</span>||ch==<span class="string">&#x27;&#123;&#x27;</span>||ch==<span class="string">&#x27;[&#x27;</span>)&#123;<span class="comment">//如果字符为符合条件且为符号的左半部分则压入栈中</span></span><br><span class="line">                stack.push(ch);<span class="comment">//压栈操作</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果字符为符号的右半部分则获取栈顶元素进行匹配</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;)&#x27;</span>&amp;&amp; !stack.empty())&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.peek() == <span class="string">&#x27;(&#x27;</span>)&#123;<span class="comment">//栈不为空获取栈顶元素进行匹配 匹配成功 弹栈;</span></span><br><span class="line">                    stack.pop();<span class="comment">//弹栈</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;<span class="comment">//除此之外则匹配失败</span></span><br><span class="line">                    stack.pop();<span class="comment">//弹栈</span></span><br><span class="line">                    flag = <span class="literal">false</span>;<span class="comment">//哨兵赋值为false</span></span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//跳出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;&#125;&#x27;</span>&amp;&amp; !stack.empty())&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.peek() == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;]&#x27;</span>&amp;&amp; !stack.empty())&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.peek() == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后如果栈为空且哨兵值为true 则字符串中的符号完全匹配</span></span><br><span class="line">        <span class="keyword">if</span>(flag&amp;&amp;stack.empty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果栈不为空或是哨兵值为false抑或是两者都不满足 则字符串中符号匹配失败</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sc.close();<span class="comment">//最后关闭io流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输入样例1：</p><blockquote><p>{(1+2)*3+4&#x2F;(3-1)</p></blockquote><p>控制台输出：</p><blockquote><p>NO</p></blockquote><p>输入样例2：</p><blockquote><p>(1+2)*3+4&#x2F;(3-1)</p></blockquote><p>控制台输出：</p><blockquote><p>YES</p></blockquote><h2 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h2><hr><p><em><em>对称矩阵可以将一个n * n存储空间的数组压缩成一个n</em>(n+1)&#x2F;2大小的数组</em>* 一般拿一维数组存储。</p><p>接下来代码将展示一般对称矩阵压缩以及还原输出</p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习题;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil(丁杨维)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-12-20:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对称矩阵</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E_21</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n;<span class="comment">//矩阵的行列数(对称矩阵的前提是行列数都相等)</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;=======================输入数据==============================&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入一个n*n的矩阵的n:&quot;</span>);</span><br><span class="line">        n = sc.nextInt();<span class="comment">//从键盘输入n</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入n*n矩阵的元素:&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[][] Array = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;Array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;Array[i].length; j++)&#123;</span><br><span class="line">                Array[i][j]=sc.nextInt();<span class="comment">//读入矩阵数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSymmetricMatrix(Array))&#123;<span class="comment">//判断是否是对称矩阵</span></span><br><span class="line">            System.out.println(<span class="string">&quot;输入的矩阵是对称矩阵&quot;</span>);</span><br><span class="line">            <span class="type">int</span>[] SymmetricMatrix = <span class="keyword">new</span> <span class="title class_">int</span>[n*(n+<span class="number">1</span>)/<span class="number">2</span>];<span class="comment">//初始化压缩矩阵</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//压缩矩阵下标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;Array.length; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i+<span class="number">1</span>; j++)&#123;</span><br><span class="line">                    SymmetricMatrix[index++] = Array[i][j];<span class="comment">//装载数据</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;=======================输出压缩后的矩阵==============================&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> symmetricMatrix : SymmetricMatrix) &#123;</span><br><span class="line">                System.out.print(symmetricMatrix+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">&quot;=========================还原对阵矩阵============================&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">                        <span class="comment">//上三角元素下标与压缩矩阵元素下标满足关系k = (j*(j+1)/2+i) k为压缩矩阵元素下标</span></span><br><span class="line">                        System.out.print(SymmetricMatrix[j*(j+<span class="number">1</span>)/<span class="number">2</span>+i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//下三角以及对角线元素下标与压缩矩阵元素下标满足关系k = (j*(j+1)/2+i)</span></span><br><span class="line">                        System.out.print(SymmetricMatrix[i*(i+<span class="number">1</span>)/<span class="number">2</span>+j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是对称矩阵的函数;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSymmetricMatrix</span><span class="params">(<span class="type">int</span>[][] Array)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;Array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt;Array[i].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Array[i][j]!=Array[j][i])&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还原对称矩阵时上三角部分：<em><em>上三角部分的元素下标与压缩矩阵元素下标满足关系k &#x3D; (j</em>(j+1)&#x2F;2+i) k为压缩矩阵元素下标</em>*</p><p>还原对称矩阵时上三角部分：<em><em>下三角以及对角线元素下标与压缩矩阵元素下标满足关系k &#x3D; (j</em>(j+1)&#x2F;2+i)</em>*</p><p>输入样例；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">=======================输入数据==============================</span><br><span class="line">请输入一个n*n的矩阵的n:2</span><br><span class="line">请输入n*n矩阵的元素:</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">输入的矩阵是对称矩阵</span><br><span class="line">=======================输出压缩后的矩阵==============================</span><br><span class="line">121</span><br><span class="line">=========================还原对阵矩阵============================</span><br><span class="line">12</span><br><span class="line">21</span><br></pre></td></tr></table></figure><hr><p>接下来将展示输入一个已经压缩的对称矩阵将其还原输出</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习题;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil(丁杨维)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-12-20:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E_22</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n, row;<span class="comment">//用于储存压缩矩阵的大小 和还原矩阵的大小</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;=======================输入数据==============================&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入压缩的对称矩阵的大小n:&quot;</span>);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请给出矩阵元素:&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[] SymmetricMatrix = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">//录入数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            SymmetricMatrix[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出压缩的对称矩阵</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n======================输出压缩的对称矩阵======================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            System.out.print(SymmetricMatrix[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取还原矩阵的行列数</span></span><br><span class="line">        <span class="keyword">for</span>(row = <span class="number">0</span>; row&lt;n; row++)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((row*(row+<span class="number">1</span>)/<span class="number">2</span>)==n)&#123;<span class="comment">//还原矩阵的行列数与压缩矩阵的长度 关系为n*(n+1)/2</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n======================还原输出对称矩阵======================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;row; j++)&#123;<span class="comment">//还原</span></span><br><span class="line">                <span class="keyword">if</span>(i&lt;j)&#123;<span class="comment">//上三角</span></span><br><span class="line">                    <span class="comment">//上三角元素下标与压缩矩阵元素下标满足关系k = (j*(j+1)/2+i) k为压缩矩阵元素下标</span></span><br><span class="line">                    System.out.print(SymmetricMatrix[j*(j+<span class="number">1</span>)/<span class="number">2</span>+i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;<span class="comment">//下三角以及对角线</span></span><br><span class="line">                    <span class="comment">//下三角以及对角线元素下标与压缩矩阵元素下标满足关系k = (j*(j+1)/2+i)</span></span><br><span class="line">                    System.out.print(SymmetricMatrix[i*(i+<span class="number">1</span>)/<span class="number">2</span>+j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输入样例：</p><blockquote><p>10</p><p>1 2 3 4 5 6 7 8 9 10</p></blockquote><p>控制台输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">=======================输入数据==============================</span><br><span class="line">请输入压缩的对称矩阵的大小n:10</span><br><span class="line">请给出矩阵元素:</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line"></span><br><span class="line">======================输出压缩的对称矩阵======================</span><br><span class="line">12345678910</span><br><span class="line">======================还原输出对称矩阵======================</span><br><span class="line">1247</span><br><span class="line">2358</span><br><span class="line">4569</span><br><span class="line">78910</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>今天停电了学的挺少的 呜呜呜~~</p><p>–end–</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;栈简单应用之符号匹配&quot;&gt;&lt;a href=&quot;#栈简单应用之符号匹配&quot; class=&quot;headerlink&quot; title=&quot;栈简单应用之符号匹配&quot;&gt;&lt;/a&gt;栈简单应用之符号匹配&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;关键：&lt;/strong&gt;读括号时，如果时括号的左半部分（正常情况下，括号的左半部分总是先读到）,如果遇到括号的右半部分，获取栈顶元素，如果匹配则弹出栈，如果不匹配依旧弹栈且哨兵flag记为FALSE,最后如果flag为TRUE且栈不为空或是flag为FALSE且栈为空则符号不匹配，如果栈为空且flag为TRUE则符号匹配。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://devildyw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="java" scheme="https://devildyw.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ</title>
    <link href="https://devildyw.github.io/2022/02/28/RocketMQ/"/>
    <id>https://devildyw.github.io/2022/02/28/RocketMQ/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-03-06T15:57:44.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/concept.md">RocketMQ</a></h1><p><strong>MQ(Message Queue)</strong>:消息队列</p><span id="more"></span><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="消息模型（Message-Model）"><a href="#消息模型（Message-Model）" class="headerlink" title="消息模型（Message Model）:"></a>消息模型（Message Model）:</h3><p>RocketMQ主要由 <strong>Producer、Broker、Consumer 三部分组成</strong>，其中Producer 负责生产消息，Consumer 负责消费消息，<strong>Broker 负责存储消息</strong>。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。</p><h3 id="消息生产者（Producer）"><a href="#消息生产者（Producer）" class="headerlink" title="消息生产者（Producer）:"></a>消息生产者（Producer）:</h3><p>负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，<strong>同步发送、异步发送、顺序发送、单向发送</strong>。<strong>同步和异步方式均需要Broker返回确认信息，单向发送不需要。</strong></p><h3 id="消息消费者（Consumer）"><a href="#消息消费者（Consumer）" class="headerlink" title="消息消费者（Consumer）:"></a>消息消费者（Consumer）:</h3><p>负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。</p><h3 id="主题（Topic）"><a href="#主题（Topic）" class="headerlink" title="主题（Topic）:"></a>主题（Topic）:</h3><p>表示一类消息的集合，<strong>每个主题包含若干条消息，每条消息只能属于一个主题</strong>，(topic)<strong>是RocketMQ进行消息订阅的基本单位。</strong></p><h3 id="代理服务器（Broker-Server）"><a href="#代理服务器（Broker-Server）" class="headerlink" title="代理服务器（Broker Server）:"></a>代理服务器（Broker Server）:</h3><p><strong>消息中转角色，负责存储消息、转发消息。</strong>代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p><h3 id="名字服务（Name-Server）"><a href="#名字服务（Name-Server）" class="headerlink" title="名字服务（Name Server）:"></a>名字服务（Name Server）:</h3><p>名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/2ms3i8hm3a.jpg" alt="2ms3i8hm3a"></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220222203606812.png" alt="image-20220222203606812"></p><p>由上图可知 Broker集群,producer集群,consumer集群都要与NameServer集群进行通信.</p><h3 id="拉取式消费（Pull-Consumer）"><a href="#拉取式消费（Pull-Consumer）" class="headerlink" title="拉取式消费（Pull Consumer）:"></a>拉取式消费（Pull Consumer）:</h3><p>Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、<strong>主动权由应用控制</strong>。一旦获取了批量消息，应用就会启动消费过程。</p><h3 id="推动式消费（Push-Consumer）"><a href="#推动式消费（Push-Consumer）" class="headerlink" title="推动式消费（Push Consumer）:"></a>推动式消费（Push Consumer）:</h3><p>Consumer消费的一种类型，<strong>该模式下Broker收到数据后会主动推送给消费端</strong>，该消费模式一般实时性较高。</p><h3 id="生产者组（Producer-Group）"><a href="#生产者组（Producer-Group）" class="headerlink" title="生产者组（Producer Group）:"></a>生产者组（Producer Group）:</h3><p><strong>同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。</strong>如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p><h3 id="消费者组（Consumer-Group）"><a href="#消费者组（Consumer-Group）" class="headerlink" title="消费者组（Consumer Group）:"></a>消费者组（Consumer Group）:</h3><p><strong>同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。</strong>消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，<strong>消费者组的消费者实例必须订阅完全相同的Topic。</strong>RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p><h3 id="集群消费（Clustering）"><a href="#集群消费（Clustering）" class="headerlink" title="集群消费（Clustering）:"></a>集群消费（Clustering）:</h3><p>集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</p><h3 id="广播消费（Broadcasting）"><a href="#广播消费（Broadcasting）" class="headerlink" title="广播消费（Broadcasting）:"></a>广播消费（Broadcasting）:</h3><p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。</p><h3 id="普通顺序消息（Normal-Ordered-Message）"><a href="#普通顺序消息（Normal-Ordered-Message）" class="headerlink" title="普通顺序消息（Normal Ordered Message）:"></a>普通顺序消息（Normal Ordered Message）:</h3><p>普通顺序消费模式下，消费者通过同一个消息队列（ Topic 分区，称作 Message Queue） 收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。</p><h3 id="严格顺序消息（Strictly-Ordered-Message）"><a href="#严格顺序消息（Strictly-Ordered-Message）" class="headerlink" title="严格顺序消息（Strictly Ordered Message）:"></a>严格顺序消息（Strictly Ordered Message）:</h3><p>严格顺序消息模式下，消费者收到的所有消息均是有顺序的。</p><h3 id="消息（Message）"><a href="#消息（Message）" class="headerlink" title="消息（Message）:"></a>消息（Message）:</h3><p><strong>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。</strong>RocketMQ中<strong>每个消息拥有唯一的Message ID</strong>，且<strong>可以携带具有业务标识的Key</strong>。系统提供了<strong>通过Message ID和Key查询消息</strong>的功能。</p><h3 id="标签（Tag）"><a href="#标签（Tag）" class="headerlink" title="标签（Tag）:"></a>标签（Tag）:</h3><p><strong>为消息设置的标志，用于同一主题下区分不同类型的消息。</strong>来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。<strong>标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统</strong>。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p><h3 id="MQ-Messages-Queue-三大优点"><a href="#MQ-Messages-Queue-三大优点" class="headerlink" title="MQ(Messages Queue)三大优点:"></a>MQ(Messages Queue)三大优点:</h3><ul><li>应用解耦: <strong>提高系统的容错性和可维护性</strong></li><li>削峰填谷: <strong>提升用户体验和系统的吞吐量</strong></li><li>异步提速:<strong>提高系统的稳定性</strong></li></ul><h3 id="通常的MQ-三大缺点"><a href="#通常的MQ-三大缺点" class="headerlink" title="通常的MQ 三大缺点:"></a>通常的MQ 三大缺点:</h3><ul><li><p>应用可用性降低</p><blockquote><p>系统引入的外部依赖越多, 系统的稳定性越差,一旦MQ宕机,就会对业造成影响.</p></blockquote></li><li><p>系统的复杂度提高</p><blockquote><p>MQ的加入大大增加了系统的复杂度,以前系统间是同步的远程调用,现在是通过MQ进行异步调用.</p></blockquote></li><li><p>一致性的问题(A B系统正常 但是C系统处理失败 会发生事务问题)</p><blockquote><p>A系统处理完业务,通过MQ给BCD三个系统发送消息数据,如果B系统,C系统处理成功,D系统处理失败.</p></blockquote></li></ul><hr><h2 id="单对单模式-初始RocketMQ"><a href="#单对单模式-初始RocketMQ" class="headerlink" title="单对单模式(初始RocketMQ)"></a>单对单模式(初始RocketMQ)</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><blockquote><ul><li>谁来发</li><li>发给谁</li><li>启动连接</li><li>发什么</li><li>怎么发</li><li>发的结果是?</li><li>关闭连接</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQBrokerException, RemotingException, InterruptedException, MQClientException &#123;</span><br><span class="line">        <span class="comment">//1. 谁来发?</span></span><br><span class="line">        <span class="comment">//创建一个生产者</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="comment">/*可以在这里设置名称*/</span><span class="string">&quot;group1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.发给谁</span></span><br><span class="line">        <span class="comment">//发送给命名服务器 通过Name Server分配Brokerip 再由生产者发送给broker</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动连接</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.怎么发</span></span><br><span class="line">        <span class="comment">//发送Message apache包下的 网络传输都是字节流传输</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic1&quot;</span>,<span class="string">&quot;Tag1&quot;</span>,(<span class="string">&quot;Hello World&quot;</span>).getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.发什么</span></span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.发的结果是什么</span></span><br><span class="line">        <span class="comment">//SendResult 就是发送后的结果</span></span><br><span class="line">        System.out.println(sendResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.打扫战场</span></span><br><span class="line">        <span class="comment">//生产者是与name Server建立了一个长连接进行发送消息 所以发送完毕后 关闭连接</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><blockquote><ul><li>谁来收</li><li>从哪里收</li><li>监听那个消息队列</li><li>处理业务流程</li><li>启动连接</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.谁来收</span></span><br><span class="line">        <span class="comment">//消费者有两种模式 一种是拉去(需要消费者自己去拉去) 一种是推送(消息主动推送给消费者)</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">pushConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.从哪里收</span></span><br><span class="line">        <span class="comment">//与生产者一样 消费者 也许要去name Server中获得对应broker的地址去获得消息</span></span><br><span class="line">        pushConsumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.监听那个消息队列</span></span><br><span class="line">        <span class="comment">//设置监听队列 subscribe:订阅 指定主题 和订阅表达式 &quot;*&quot;表示订阅主题中的所有</span></span><br><span class="line">        pushConsumer.subscribe(<span class="string">&quot;Topic1&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.处理业务流程</span></span><br><span class="line">        <span class="comment">//注册一个监听器 去监听是否有消息被生产 一有就立刻接收</span></span><br><span class="line">        pushConsumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                <span class="comment">//接收到的消息就是 List&lt;MessageExt&gt; msgs 这时我们就能写我们的业务逻辑</span></span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//启动连接</span></span><br><span class="line">        pushConsumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消费者启动起来了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意不要关闭消费者(如果还有对应主题的生产者的情况下 关闭就无法监听消息 就无法收到消息了)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一对多-单生产者-多消费者模式"><a href="#一对多-单生产者-多消费者模式" class="headerlink" title="一对多(单生产者 多消费者模式)"></a>一对多(单生产者 多消费者模式)</h2><h3 id="多消费者都在同一组中时"><a href="#多消费者都在同一组中时" class="headerlink" title="多消费者都在同一组中时"></a>多消费者都在同一组中时</h3><p><strong>消息会被分配到该组的不同消费者手中(当一个组中的消费者为偶数时平分)</strong></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220223173114990.png" alt="image-20220223173114990"></p><h3 id="多消费者在不同组时"><a href="#多消费者在不同组时" class="headerlink" title="多消费者在不同组时"></a>多消费者在不同组时</h3><p><strong>每个组都会有完整的消息数目和消息信息(广播式 消息先被复制到不同的消费者组)</strong></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220223173349238.png" alt="image-20220223173349238"></p><p>**特别的:**如果想在同一组中实现广播模式 可以在接收消息前设置消息的模式</p><blockquote><p><code>Consumer.setMessageModel(消息模式);</code></p><p>默认是CLUSTERING 负载均衡模式</p><p>可以设置为BROADCASTING 就是广播模式</p></blockquote><h2 id="多对多-多生产者-多消费者模式"><a href="#多对多-多生产者-多消费者模式" class="headerlink" title="多对多(多生产者 多消费者模式)"></a>多对多(多生产者 多消费者模式)</h2><p>对于生产者生产的消息而言</p><hr><h2 id="消息类别"><a href="#消息类别" class="headerlink" title="消息类别"></a>消息类别</h2><h3 id="同步消息"><a href="#同步消息" class="headerlink" title="同步消息"></a>同步消息</h3><p><strong>特征:</strong> 即时性较强,重要的消息,且必须有回执的消息,例如短息,通知(转账成功)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;Devilsproducer&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicTest&quot;</span>,<span class="string">&quot;TagA&quot;</span>,(<span class="string">&quot;Hello RocketMq &quot;</span>+ i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s%n&quot;</span>,sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步消息"><a href="#异步消息" class="headerlink" title="异步消息"></a>异步消息</h3><p><strong>特征:</strong> 即时性较弱,但需要有回执的消息,例如订单中的某些信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group3&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic3&quot;</span>, <span class="string">&quot;tag1&quot;</span>, msg.getBytes());</span><br><span class="line">            <span class="comment">//异步消息 Callback也是一个多线的接口</span></span><br><span class="line">            producer.send(message, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">                <span class="comment">//发送成功的回调方法a</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">                    System.out.println(sendResult);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//发送失败的回调方法</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                    System.out.println(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;异步发送完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单向消息"><a href="#单向消息" class="headerlink" title="单向消息"></a>单向消息</h3><p><strong>特征:</strong> 不需要有回执的信息,例如日志类消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneWayProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group3&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//单项消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>+i;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic1&quot;</span>, <span class="string">&quot;tag1&quot;</span>, msg.getBytes());</span><br><span class="line">            <span class="comment">//发送单项消息 没有回执消息</span></span><br><span class="line">            producer.sendOneway(message);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送完成了&quot;</span>);</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h3><p><strong>特征:</strong> 消息发送时并不直接发送到消息服务器,而是根据设定等待的时间到达,起到延时到达的缓冲作用</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220223203009432.png" alt="image-20220223203009432"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//延时消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>+i;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic1&quot;</span>, <span class="string">&quot;tag1&quot;</span>, msg.getBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置延时 能分别设置每一条消息的延时等级 数字对应等级 而不是真正的时间</span></span><br><span class="line">            message.setDelayTimeLevel(<span class="number">4</span>);</span><br><span class="line">            <span class="comment">//发送延时消息</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line">            System.out.println(sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送成功了&quot;</span>);</span><br><span class="line">        <span class="comment">//断开连接</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h3><p><strong>特征:</strong> 一次发送多条消息,节约网络开销</p><p>原理就是通过producer可以通过send方法发送Collection(集合)的缘故 这样我们就可以将Message对象封装到一个集合中 通过send方法完成批量消息的发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过producer的send方法可以传输Collection的机制 我们只需要将消息封装到一个集合中 我们就能发送批量消息了</span></span><br><span class="line">        ArrayList&lt;Message&gt; messages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>+i;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic1&quot;</span>, <span class="string">&quot;tag1&quot;</span>, msg.getBytes());</span><br><span class="line">            messages.add(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//批量发送</span></span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">send</span> <span class="operator">=</span> producer.send(messages);</span><br><span class="line">        System.out.println(send);</span><br><span class="line">        System.out.println(<span class="string">&quot;批量消息发送成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><blockquote><ul><li><p>这些批量消息应该有相同的topic</p></li><li><p>相同的waitStoreMsgOK</p></li><li><p>不能是延时消息</p></li><li><p>消息内容的总长度不能超过4M</p></li><li><p>消息内容总长度包含如下:</p><blockquote><ol><li>topic(字符串字节数)</li><li>body(字节数组长度)</li><li>消息追加的属性(key与value对应的字符串字节数)</li><li>日志(固定20字节)</li></ol></blockquote></li></ul></blockquote><h2 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h2><p>语法过滤(属性过滤&#x2F;语法过滤&#x2F;SQL过滤):按照消息的某些属性过滤;</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220223210153476.png" alt="image-20220223210153476"></p><p>针对消费者而言在设置订阅消息的模式时, 可以设置主题(Topic) 还可以设置订阅表达式 该订阅表示就是用来过滤你要接收的消息的</p><hr><h3 id="Tag过滤"><a href="#Tag过滤" class="headerlink" title="Tag过滤"></a>Tag过滤</h3><p><strong><code>pushConsumer.subscribe(&quot;Topic1&quot;,MessageSelector.byTag(&quot;Tag1 || vip&quot;));</code></strong></p><p>表示只接收标签为Tag1 或者 vip的消息(默认不指定也是以Tag执行)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.谁来收</span></span><br><span class="line">        <span class="comment">//消费者有两种模式 一种是拉去(需要消费者自己去拉去) 一种是推送(消息主动推送给消费者)</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">pushConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.从哪里收</span></span><br><span class="line">        <span class="comment">//与生产者一样 消费者 也许要去name Server中获得对应broker的地址去获得消息</span></span><br><span class="line">        pushConsumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.监听那个消息队列</span></span><br><span class="line">        <span class="comment">//设置监听队列 subscribe:订阅 指定主题 和订阅表达式 &quot;*&quot;表示订阅主题中的所有</span></span><br><span class="line">        pushConsumer.subscribe(<span class="string">&quot;Topic1&quot;</span>,<span class="string">&quot;Tag1 || vip&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.处理业务流程</span></span><br><span class="line">        <span class="comment">//注册一个监听器 去监听是否有消息被生产 一有就立刻接收</span></span><br><span class="line">        pushConsumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                <span class="comment">//接收到的消息就是 List&lt;MessageExt&gt; msgs 这时我们就能写我们的业务逻辑</span></span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//启动连接</span></span><br><span class="line">        pushConsumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消费者启动起来了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意不要关闭消费者(如果还有对应主题的生产者的情况下 关闭就无法监听消息 就无法收到消息了)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SQL过滤"><a href="#SQL过滤" class="headerlink" title="SQL过滤"></a>SQL过滤</h3><p>要是使用sql过滤首先生产者方在发送消息时需要给消息添加参数 <strong><code>message.putUserProperty(&quot;key&quot;,&quot;value&quot;);</code></strong>(因为这不是Tag过滤 并且tag也无法搭载过多的信息)</p><p>使用SQL过滤之前需要在broker.conf添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 开启对 propertyfilter的支持</span><br><span class="line">enablePropertyFilter = true</span><br><span class="line">filterSupportRetry = true</span><br></pre></td></tr></table></figure><p>然后再调用**<code>pushConsumer.subscribe(&quot;Topic1&quot;,MessageSelector.bySql(&quot;age&gt;18&quot;));</code>**</p><p><code>producer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic1&quot;</span>,<span class="string">&quot;vip&quot;</span>,(<span class="string">&quot;Hello World&quot;</span>).getBytes());</span><br><span class="line"></span><br><span class="line">message.putUserProperty(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">message.putUserProperty(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.发什么</span></span><br><span class="line"><span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br></pre></td></tr></table></figure><p><code>consumer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.谁来收</span></span><br><span class="line">        <span class="comment">//消费者有两种模式 一种是拉去(需要消费者自己去拉去) 一种是推送(消息主动推送给消费者)</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">pushConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.从哪里收</span></span><br><span class="line">        <span class="comment">//与生产者一样 消费者 也许要去name Server中获得对应broker的地址去获得消息</span></span><br><span class="line">        pushConsumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.监听那个消息队列</span></span><br><span class="line">        <span class="comment">//设置监听队列 subscribe:订阅 指定主题 和订阅表达式 &quot;*&quot;表示订阅主题中的所有</span></span><br><span class="line">        pushConsumer.subscribe(<span class="string">&quot;Topic1&quot;</span>, MessageSelector.bySql(<span class="string">&quot;age &gt; 16&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.处理业务流程</span></span><br><span class="line">        <span class="comment">//注册一个监听器 去监听是否有消息被生产 一有就立刻接收</span></span><br><span class="line">        pushConsumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                <span class="comment">//接收到的消息就是 List&lt;MessageExt&gt; msgs 这时我们就能写我们的业务逻辑</span></span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                    Map&lt;String, String&gt; properties = msg.getProperties();</span><br><span class="line">                    Iterator&lt;Map.Entry&lt;String,String&gt;&gt; iter = properties.entrySet().iterator();</span><br><span class="line">                    <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">                        Map.Entry&lt;String, String&gt; next = iter.next();</span><br><span class="line">                        System.out.println(next.getKey()+<span class="string">&quot; = &quot;</span>+next.getValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//启动连接</span></span><br><span class="line">        pushConsumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消费者启动起来了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意不要关闭消费者(如果还有对应主题的生产者的情况下 关闭就无法监听消息 就无法收到消息了)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Springboot整合RocketMQ"><a href="#Springboot整合RocketMQ" class="headerlink" title="Springboot整合RocketMQ"></a>Springboot整合RocketMQ</h2><ul><li>导入Springboot与RocketMQ整合starter</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>可以在application中配置rocketmq name-server的ip地址 和生产者的信息 或是消费者的信息</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="attr">name-server:</span> <span class="string">localhost:9876</span></span><br><span class="line">  <span class="attr">consumer:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">group1</span></span><br><span class="line">  <span class="attr">producer:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">group1</span></span><br></pre></td></tr></table></figure><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><ul><li><p>在使用时 我们需要将springboot容器中的RocketMQTemplate(使用@Autowired)注册到我们的类中</p></li><li><p><strong>RocketMQTemplate:RocketMQ模板类 : 建立连接 断开连接</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;<span class="comment">//RocketMQ模板类: 建连接 短链接</span></span><br></pre></td></tr></table></figure><ul><li><p>Springboot中传输的消息是Springboot框架提供的 <strong><code>org.springframework.messaging.Message&lt;T&gt;</code></strong></p></li><li><p>可以使用 <strong><code>org.springframework.messaging.support.MessageBuilder</code><strong>的</strong>静态方法withPayload(T payload)新建一个消息构建器 再调用build()方法</strong> 就可以将<strong>payload转换为一个Message对象</strong></p></li><li><p>上述都是使用send方法发送信息的需要做的 我们可以使用rocketMQTemplate的其他方法 例如 **<code>converAndSend()</code><strong>该方法由名字就知道它可以转化并且发送 它可以将java对象转化为</strong><code>org.springframework.messaging.Message&lt;T&gt;</code>**发送</p></li><li><p>除了上述两种方法 还有**<code>syncSend(), asyncSend(), sendOneWay() </code><strong>分别对应着同步,异步,单向消息 还可以在方法的参数上添加</strong><code>timeout delayLevel</code>**等参数以达到延时效果</p></li></ul><p><strong>注意:</strong> 这里不再是单纯的填入Topic了而是<strong>destination</strong> 并且格式是 <strong><code>topicName:tags</code></strong> </p><p>RocketMQ获取destination的源码</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220224202331947.png" alt="image-20220224202331947"></p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><ul><li><p>Consumer方面我们使用了监听器的方式来接收消息 实现RocketMQ自带的**<code>RocketMQListener&lt;T&gt;</code>** T指的**<code>withpayload</code>**中的消息类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span> <span class="comment">//注册到容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConsumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收成功的回调方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(User message)</span> &#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>设置了接收的监听器 我们还要设置监听的消息的主题 消息过滤 还有消费者组的名称 才能满足RocketMQ的规范</p><ul><li>这里我们使用**<code>rocketmq-spring-boot-starter</code><strong>的注解</strong><code>@RocketMQMessageListener</code>**设置参数 因为name-server在application.yml中我们已经设置了 springboot会自动识别并且设置.</li></ul></li><li><p>@RocketMQMessageListener</p><blockquote><ul><li>topic:主题</li><li>selectorExpression:过滤表达式</li><li>selectorType:设置过滤类型(Tag or Sql)</li><li>consumerGroup: 消费者组的名称</li><li>messageModel:消息的模式(广播或是集群)</li></ul></blockquote></li></ul></li></ul><p><strong><code>Producer</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;<span class="comment">//RocketMQ模板类: 建连接 短链接</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/send&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Devil&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        rocketMQTemplate.convertAndSend(<span class="string">&quot;Topic2&quot;</span>,user);<span class="comment">//convert: 消息转换为字节数组 甚至可以自动将对象转化为字节数组 但必须实现序列化</span></span><br><span class="line"></span><br><span class="line">        rocketMQTemplate.syncSend(<span class="string">&quot;Topic2&quot;</span>,user);<span class="comment">//发送同步消息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送异步消息</span></span><br><span class="line">        rocketMQTemplate.asyncSend(<span class="string">&quot;Topic2&quot;</span>, user, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">            <span class="comment">//发送成功的回调方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//发送失败的回调方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送单项消息</span></span><br><span class="line">        rocketMQTemplate.sendOneWay(<span class="string">&quot;Topic2&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送延时消息</span></span><br><span class="line">        rocketMQTemplate.syncSend(<span class="string">&quot;Topic2:tag1&quot;</span>, MessageBuilder.withPayload(user).build(),<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>Consumer</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(topic = &quot;Topic2&quot;,selectorExpression = &quot;tag1 || tag2&quot;,consumerGroup = &quot;$&#123;rocketmq.producer.group&#125;&quot;,</span></span><br><span class="line"><span class="meta">        selectorType = SelectorType.TAG,messageModel = MessageModel.BROADCASTING)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConsumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收成功的回调方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(User message)</span> &#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="消息顺序"><a href="#消息顺序" class="headerlink" title="消息顺序"></a>消息顺序</h2><p> <strong>消息错乱的原因:</strong></p><blockquote><p>默认消息的发送是每条消息按照 依次按照queue的顺序进入queue 即:<strong>队列内无序,队列外有序</strong></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220224214903923.png" alt="image-20220224214903923"></p><p><strong><code>Producer</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样发送会导致消息错乱</span></span><br><span class="line"><span class="keyword">for</span> (OrderStep orderStep : orderSteps) &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;topic3&quot;</span>, <span class="string">&quot;tag1&quot;</span>, orderStep.toString().getBytes());</span><br><span class="line">    <span class="type">SendResult</span> <span class="variable">send</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line"></span><br><span class="line">    System.out.println(send);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Consumer</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样接收会导致消息错乱</span></span><br><span class="line">pushConsumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">        <span class="comment">//接收到的消息就是 List&lt;MessageExt&gt; msgs 这时我们就能写我们的业务逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><p><strong>纠正消息错乱:</strong></p><blockquote><p>修改消息的顺序,即指定消息进入的队列, 完整的顺序(订单的完整流程 创建 支付 完成)应当进入同一个消息队列. 即:<strong>队列内有序,队列外无序</strong></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220224214826242.png" alt="image-20220224214826242"></p><p>为了使得生产的消息有序可以在producer中发送消息时指定消息进入的消息队列</p><p><strong><code>producer.send(message, new MessageQueueSelector() &#123;...&#125;,null);</code></strong> 其中的**<code>MessageQueueSelector()</code>**接口的select方法就可以指定消息填充的队列的队列id 更具这个id就可以获得这个队列 再通过send方法 发送到这个队列中</p><p><strong><code>Producer</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确的发送</span></span><br><span class="line"><span class="keyword">for</span> (OrderStep orderStep : orderSteps) &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;topic3&quot;</span>, <span class="string">&quot;tag1&quot;</span>, orderStep.toString().getBytes());</span><br><span class="line">    <span class="type">SendResult</span> <span class="variable">send</span> <span class="operator">=</span> producer.send(message, <span class="keyword">new</span> <span class="title class_">MessageQueueSelector</span>() &#123;</span><br><span class="line">        <span class="comment">//这个方法就是队列悬着的方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> MessageQueue <span class="title function_">select</span><span class="params">(List&lt;MessageQueue&gt; mqs<span class="comment">/*消息队里额*/</span>, Message msg, Object arg)</span> &#123;</span><br><span class="line">            <span class="comment">//队列数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> mqs.size();</span><br><span class="line">            <span class="comment">//确定的orderId对应确定的队列 取模运算</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">orderId</span> <span class="operator">=</span> (<span class="type">int</span>) (orderStep.getOrderId());</span><br><span class="line">            <span class="type">int</span> <span class="variable">queueId</span> <span class="operator">=</span> orderId % size;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//根据 计算出的queueId 从List&lt;MessageQueue&gt; mqs中获取消息队列</span></span><br><span class="line">            <span class="keyword">return</span> mqs.get(queueId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(send);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于Consumer需要注册<strong>顺序的监听器</strong> 作用就是一个线程只监听一个MessageQueue 这样就可以接收一个queue中的消息了</p><p>而一个queue中都是producer生产的顺序的消息.</p><blockquote><p> <strong><code>new MessageListenerOrderly()&#123;...&#125;</code></strong></p></blockquote><p><strong><code>Consumer</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者注册一个顺序的监听器 作用就是一个线程只监听一个MessageQueue</span></span><br><span class="line">pushConsumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerOrderly</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeOrderlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(context.getMessageQueue().getQueueId());</span><br><span class="line">        <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><h3 id="RocketMQ事务流程概要"><a href="#RocketMQ事务流程概要" class="headerlink" title="RocketMQ事务流程概要"></a>RocketMQ事务流程概要</h3><p>RocketMQ实现事务主要分为两个阶段: 正常事务的发送及提交、事务信息的补偿流程(都是针对生产者 因为事务只出现在DataBase中 有些情况需要将消息存储在数据库中 如果发生事务问题….)</p><p><strong>整体流程为:</strong></p><blockquote><ul><li>正常事务发送与提交阶段<ol><li>生产者发送一个半消息给broker(半消息是指的暂时不能消费的消息)</li><li>服务端响应消息写入结果,半消息发送成功</li><li>开始执行本地事务</li><li>根据本地事务的执行情况执行Commit或者Rollback</li></ol></li><li>事务信息的补偿流程<ol><li>如果broker长时间没有收到本地事务的执行状态,会向生产者发起一个确认会查的操作请求</li><li>生产者收到确认会查请求后,检查本地事务的执行状态</li><li>根据检查后的结果执行Commit或者Rollback操作 补偿阶段主要是用于解决生产者在发送Commit或者Rollbacke操作时发生超时或失败的情况</li></ol></li></ul><p><img src="https://pic3.zhimg.com/80/v2-325e5949a667b144f2684caac49dd41a_720w.png" alt="img"></p></blockquote><h3 id="RocketMQ事务流程关键"><a href="#RocketMQ事务流程关键" class="headerlink" title="RocketMQ事务流程关键"></a>RocketMQ事务流程关键</h3><ul><li><p><strong>事务消息在一阶段对用户不可见</strong> </p><p>事务消息相对普通消息最大的特点就是一阶段发送的消息对用户是不可见的,也就是说消费者不能直接消费.这里RocketMQ实现方法是原消息的主题与消息消费队列,然后把主题改成**<code>RMQ_SYS_TRANS_HALF_TOPIC</code>**.这样由于消费者没有订阅这个主题,所以不会消费.</p></li><li><p><strong>如何处理第二阶段的发送消息?</strong></p><p>在本地事务执行完成后回向Broker发送Commit或者Rollback操作,此时如果在发送消息的时候生产者出故障了,要保证这条消息最终被消费,broker就会向服务端发送回查请求,确认本地事务的执行状态.当然RocketMQ并不会无休止的发送事务状态回查请求,<strong>默认是15次</strong>,如果15次回查还是无法得知事务的状态,RocketMQ默认回滚消息(broker就会将这条半消息删除)</p></li><li><p>事务的三种状态:</p><blockquote><ul><li><strong>TransactionStatus.CommitTransaction</strong>：提交事务消息，消费者可以消费此消息</li><li><strong>TransactionStatus.RollbackTransaction</strong>：回滚事务，它代表该消息将被删除，不允许被消费。</li><li><strong>TransactionStatus.Unknown</strong> ：中间状态，它代表需要检查消息队列来确定状态。</li></ul></blockquote></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>创建生产者时我们不在简单地创建**<code>DefaultMQProducer</code>** 而是RocketMQ事务专属的 <strong><code>TransactionMQProducer</code></strong> 并且不再简单地发送消息了 而是设置一个事务监听器 <strong><code>setTransactionListener(new TransactionListener()&#123;...&#125;);</code></strong> 实现接口方法 并且由于监听器需要等待本地事务的执行情况我们不能再生产者发送完消息后关闭</p><p><strong><code>Producer</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TransactionMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionMQProducer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置事务监听</span></span><br><span class="line">        producer.setTransactionListener(<span class="keyword">new</span> <span class="title class_">TransactionListener</span>() &#123;</span><br><span class="line">            <span class="comment">//执行本地事务 这就是正常事务过程</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> &#123;</span><br><span class="line">                <span class="comment">//消息保存到数据库中</span></span><br><span class="line">                <span class="comment">//sql代码</span></span><br><span class="line">                <span class="comment">//根据数据库事务状态 返回事务状态</span></span><br><span class="line">                System.out.println(<span class="string">&quot;正常执行的过程&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//LocalTransactionState.ROLLBACK_MESSAGE 表示事务回滚 这时broker就会删除掉half消息 消费者接收不到</span></span><br><span class="line">                <span class="comment">//如果是LocalTransactionState.COMMIT_MESSAGE 表示提交消息 这时broker就会提交half消息 消费能接收</span></span><br><span class="line">                <span class="comment">//LocalTransactionState.UNKNOW 事务结果未知 执行事务补偿过程 即broker主动询问生产者事务结果</span></span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//检查本地事务 这就是事务补偿过程</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> LocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行事务补偿过程&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello Transaction&quot;</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;topic4&quot;</span>, <span class="string">&quot;tag1&quot;</span>, msg.getBytes());</span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">send</span> <span class="operator">=</span> producer.sendMessageInTransaction(message,<span class="literal">null</span>);</span><br><span class="line">        System.out.println(send);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消息生产完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能关闭 涉及事务的提交和回滚 以及事务与broker的交互过程 不能一发出消息就关闭</span></span><br><span class="line">        <span class="comment">//producer.shutdown();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Consumer</code></strong> 整个事务消息环节与Consumer相关不大,所以不用对原来的Consumer进行修改 正常接收消息即可.</p><h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><h3 id="集群分类"><a href="#集群分类" class="headerlink" title="集群分类"></a>集群分类</h3><ul><li><strong>单机</strong><ul><li>一个broker提供服务(宕机后服务瘫痪)</li></ul></li><li><strong>集群</strong><ul><li>多个broker提供服务(单机宕机后消息无法及时被消费)</li><li>多个master和多个slave<ul><li>master到slave消息同步方式为同步(较异步方式性能略低,消息无延迟)</li><li>master到slave消息同步方式为异步(较同步方式性能略高,数据略有延迟)</li></ul></li></ul></li><li><strong>根据配置文件中的信息来设置主从集群</strong></li></ul><h3 id="RocketMQ集群工作流程"><a href="#RocketMQ集群工作流程" class="headerlink" title="RocketMQ集群工作流程"></a>RocketMQ集群工作流程</h3><ul><li>NameServer启动,开启监听,等待broker,producer与consumer连接</li><li>broker启动,根据配置信息,连接所有的NameServer,并保持长连接 <ul><li>如果broker中现存数据,NameServer将保存topic与broker关系</li></ul></li><li>producer发送信息,连接某个NameServer,并建立长连接</li><li>producer发送消息<ul><li>如果topic存在,由NameServer直接分配</li><li>如果topic不存在,由NameServer创建topic与broker关系,并分配</li></ul></li><li>producer与broker的topic选择一个消息队列(从列表中选择)</li><li>producer与broker建立长连接,用于发送消息</li><li>producer发送消息</li></ul><p><strong><code>Consumer</code><strong>工作流程同</strong><code>Producer</code></strong></p><hr><h2 id="RocketMQ高级特性"><a href="#RocketMQ高级特性" class="headerlink" title="RocketMQ高级特性"></a>RocketMQ高级特性</h2><p><strong>RocketMQ消息发送底层</strong></p><ol><li><p>消息的生产者发送消息到MQ</p></li><li><p>MQ返回ACK给生产者</p></li><li><p>MQ push消息给对于的消费者</p></li><li><p>消息消费者返回ACK给MQ</p></li></ol><p>说明: ACK(Acknowledge character)</p><p>注意: <strong>如果broker出现问题不能发送和接收ACK  生产者就会接收不到broker发送的ACK 就会导致生产者一直发送同一条消息 也会导致消费者一直消费同一条消息</strong></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220225203843889.png" alt="image-20220225203843889"></p><h3 id="消息的存储"><a href="#消息的存储" class="headerlink" title="消息的存储"></a>消息的存储</h3><ol><li><p>消息生产者发送消息到MQ</p></li><li><p>MQ接收到消息,将消息持久化,存储该消息</p></li><li><p>MQ返回ACK给生产者</p></li><li><p>MQpush消息给对应的消费者</p></li><li><p>消息消费者返回ACK给MQ</p></li><li><p>MQ删除消息</p></li></ol><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220225204155340.png" alt="image-20220225204155340"></p><p><strong>注意:</strong></p><blockquote><ul><li>第5步 MQ在指定时间接收到消息消费者返回ACK, MQ认定消息消费成功,执行6</li><li>第5步 MQ在指定时间未接收到消息消费者返回ACK,MQ认定消费失败,重新执行456</li></ul></blockquote><h3 id="消息的存储介质"><a href="#消息的存储介质" class="headerlink" title="消息的存储介质"></a>消息的存储介质</h3><p>为了防止数据库出现故障和数据库I&#x2F;O降低性能(数据库最后也是将数据存储再磁盘上(文件系统))</p><p><strong>所以我们直接绕过数据库 直接将消息存在本地的文件系统上</strong></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220225204909019.png" alt="image-20220225204909019"></p><p><strong>数据库:</strong></p><ul><li>ActiveMQ使用</li><li>缺点: 数据库瓶颈将成为MQ瓶颈</li></ul><p><strong>文件系统:</strong></p><ul><li>RocketMQ&#x2F;Kafka&#x2F;RabbitMQ</li><li>解决方案: 采用消息刷盘的机制进行数据的存储</li><li>缺点:硬盘损坏的问题无法避免</li></ul><h3 id="高效的消息存储与读写方式"><a href="#高效的消息存储与读写方式" class="headerlink" title="高效的消息存储与读写方式"></a>高效的消息存储与读写方式</h3><ul><li><strong>SSD(Solid State Disk): 固态硬盘</strong><ul><li>随机写 100kb&#x2F;s</li><li>顺序写 600-3000m&#x2F;s</li></ul></li><li>由上可知 顺序写的速度是远远快于随机写的</li></ul><hr><ul><li><p><strong>RocketMQ中向文件系统预先申请了一定大小的磁盘空间 用于顺序读写</strong>(这就是RocketMQ高速读写的第一个原因)</p></li><li><p>Linux系统发送数据的方式</p><blockquote><p>“零拷贝”技术</p><ul><li>数据传输由传统的4次复制简化成3次复制,减少1次复制过程</li><li>java语言中使用MappedByteBuffer类实现了该技术</li><li>要求:预留存储空间,用于保存数据(1G存储空间起步)</li></ul></blockquote><p>传统模式</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220225211130484.png" alt="image-20220225211130484"></p></li></ul><p>“零拷贝模式”</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220225211155810.png" alt="image-20220225211155810"></p><p><strong>总结(RocketMQ高速读写的原因):</strong></p><blockquote><ul><li>磁盘读写方式</li><li>“零拷贝”技术</li></ul></blockquote><h3 id="消息存储的结构"><a href="#消息存储的结构" class="headerlink" title="消息存储的结构"></a>消息存储的结构</h3><p>MQ数据存储区域包括如下内容</p><ul><li><p>消息数据存储区域</p><ul><li>topic</li><li>queueId</li><li>message</li></ul></li><li><p>消费逻辑队列(会记录每一个队列被每一个消费者消费到了什么(多少偏移量))</p><ul><li>minOffset</li><li>maxOffset</li><li>consumerOffset</li></ul></li><li><p>索引</p><ul><li>key索引</li><li>创建时间索引</li><li>……</li></ul></li></ul><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220225212158831.png" alt="image-20220225212158831"></p><h3 id="刷盘机制"><a href="#刷盘机制" class="headerlink" title="刷盘机制"></a>刷盘机制</h3><h4 id="同步刷盘"><a href="#同步刷盘" class="headerlink" title="同步刷盘:"></a>同步刷盘:</h4><ol><li>生产者发送消息到MQ,MQ接到消息数据</li><li>MQ挂起生产者发送消息的线程</li><li>MQ将消息数据写入内存</li><li>内存数据写入硬盘</li><li>磁盘存储后返回SUCCESS</li><li>MQ回复挂起的生产者线程</li><li>发送ACK到生产者</li></ol><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220225212521664.png" alt="image-20220225212521664"></p><h4 id="异步刷盘"><a href="#异步刷盘" class="headerlink" title="异步刷盘"></a>异步刷盘</h4><ol><li><p>生产者发送消息到MQ,MQ接收到消息数据</p></li><li><p>MQ将消息写入内存</p></li><li><p>发送ACK到生产者</p></li><li><p>待到内存中的消息数据积累到一定量 就将消息数据写入硬盘</p></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><blockquote><ul><li>同步刷盘: 安全性高,效率低,速度慢(适用于对数据安全性要求较高的业务)</li><li>异步刷盘:安全性低,效率高,速度块(使用与对数据处理速度要求较高的业务)</li></ul></blockquote><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220225213018812.png" alt="image-20220225213018812"></p><hr><h3 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h3><ul><li>NameServer<ul><li>无状态(相互之间无联系)+全服务器注册</li></ul></li><li>消息服务器<ul><li>主从框架(2M-2S)</li></ul></li><li>消息生产<ul><li>生产者将相同的topic绑定到多个group组,保障master挂掉后,其他master仍可以正常进行消息接收</li></ul></li><li>消息消费<ul><li>RocketMQ自身会根据master的压力确认是否由master承担消息读取的功能,当master繁忙的时候,自动切换slave成单数据读取的工作(主从分离 当压力过大时 master只写入 因为slave中的数据与master实时更新 所以这时slave可以承担读的功能)</li></ul></li></ul><p><strong>主从数据复制</strong></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220225213710132.png" alt="image-20220225213710132"></p><hr><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul><li>**<code>Producer</code>**负载均衡</li></ul><blockquote><ul><li>内部实现了不同broker集群中对同一个topic对应消息队列的负载均衡</li></ul><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220225214232482.png" alt="image-20220225214232482"></p></blockquote><ul><li>**<code>Consumer</code>**负载均衡(针对相同的消费者组间)</li></ul><blockquote><ul><li>平均分配</li></ul><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220225214249237.png" alt="image-20220225214249237"></p><ul><li>循环平均分配(解决宕机问题)</li></ul><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220225214305341.png" alt="image-20220225214305341"></p></blockquote><hr><h3 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h3><p>当消息消费后未正常返回消费成功的消息将启动消息重试机制</p><p><strong>消息重试机制</strong></p><blockquote><ul><li><p><strong>顺序消息重试</strong></p><blockquote><p>当消费者消费失败后,RocketMQ会自动进行消息重试(每次间隔为1s)</p><p><strong>注意:</strong> 应用会出现消息消费被堵塞的情况,因此要对顺序消息的消费情况进行监控,避免阻塞的现象发生</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220225214842367.png" alt="image-20220225214842367"></p></blockquote></li><li><p><strong>无序消息重试</strong></p><blockquote><ul><li>无序消息包括普通消息、定时消息、延时消息、事务消息</li><li>无序消息重试仅适用于负载均衡（集群）模型下的消息消费，不适用于广播模式下的消息</li><li>消费为保障无序消息的消费，MQ设定了合理的消息重试间隔时长</li></ul><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220225215028265.png" alt="image-20220225215028265"></p></blockquote></li></ul></blockquote><hr><h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p><strong>死信队列就是那些重试无果的消息存在的队列</strong></p><ul><li><p><strong>死信队列特征</strong></p><blockquote><ul><li>归属某一个组（Gourp Id)，而不归属Topic，也不归属消费者。</li><li>一个死信队列中可以包含同一个组下的多个Topic中的死信消息</li><li>死信队列不会进行默认初始化，当第一个死信出现后，此队列首次初始化</li></ul></blockquote></li><li><p><strong>死信队列中消息特征</strong></p><blockquote><ul><li><p>不会被再次重复消费</p></li><li><p>死信队列中的消息有效期为3天，达到时限后将被清除</p></li></ul></blockquote></li><li><p><strong>死信处理</strong></p><blockquote><p>在监控平台中,通过查找死信,获取死信的messageId,然后通过id对死信进行精准消费</p></blockquote></li></ul><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h4><ul><li><p>死信</p><blockquote><ul><li><p>死信队列与死信</p></li><li><p>死信处理方式</p></li></ul></blockquote></li></ul><hr><h3 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h3><h4 id="消息重复发送的原因"><a href="#消息重复发送的原因" class="headerlink" title="消息重复发送的原因"></a>消息重复发送的原因</h4><ul><li>生产者发送了重复的消息<ul><li>网络闪断(例如: 消息服务器没有发送ACK给生产者)</li><li>生产者宕机</li></ul></li><li>消息服务器投递了重复的消息<ul><li>网络闪断(例如: 消费者没有发送ACK给消息服务器)</li></ul></li><li>动态的负载均衡过程<ul><li>网络闪断&#x2F;抖动</li><li>broker重启</li><li>订阅方应用重启(消费者)</li><li>客户端扩容</li><li>客户端缩容</li></ul></li></ul><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220225220215976.png" alt="image-20220225220215976"></p><h4 id="消息幂等"><a href="#消息幂等" class="headerlink" title="消息幂等"></a>消息幂等</h4><ul><li><p>对于同一条消息,无论消费了多少次,结果保持一致,称为<strong>消息幂等性</strong></p></li><li><p>解决方案</p><ul><li>使用业务id作为消息的key</li><li>在消费消息时,客户端对key做判定,未使用过放行,使用过抛弃</li></ul></li><li><p>注意: <strong>messageId由RocketMQ产生,MessageId并不具有唯一性,不能作用幂等判定条件</strong></p></li><li><p><strong>常见的幂等方法示例</strong></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220225220811978.png" alt="image-20220225220811978"></p></li></ul><h1 id="——End——"><a href="#——End——" class="headerlink" title="——End——"></a>——End——</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RocketMQ&quot;&gt;&lt;a href=&quot;#RocketMQ&quot; class=&quot;headerlink&quot; title=&quot;RocketMQ&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/apache/rocketmq/blob/master/docs/cn/concept.md&quot;&gt;RocketMQ&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;MQ(Message Queue)&lt;/strong&gt;:消息队列&lt;/p&gt;</summary>
    
    
    
    <category term="中间件" scheme="https://devildyw.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="java" scheme="https://devildyw.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot</title>
    <link href="https://devildyw.github.io/2022/02/28/Springboot/"/>
    <id>https://devildyw.github.io/2022/02/28/Springboot/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-03-06T15:58:38.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><ol><li>SpringBoot 相当于是一个Spring 和 SpringMVC的集成 又在其上增加了其他功能 对其他主流框架的支持也是非常好, 所以SpringBoot更新的非常频繁,需要时常关注它更新的内容</li><li>微服务架构<br> 　Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。<br> 　该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。　　<br> 　通过这种方式，Spring Boot 致力于在蓬勃发展的快速应用开发领域（rapidapplication development）成为领导者。</li></ol><span id="more"></span><h4 id="SpringBoot优点"><a href="#SpringBoot优点" class="headerlink" title="SpringBoot优点"></a>SpringBoot优点</h4><ul><li>Create stand-alone Spring applications</li></ul><ul><li><ul><li>创建独立Spring应用</li></ul></li><li><p>Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)</p></li><li><ul><li>内嵌web服务器</li></ul></li><li><p>Provide opinionated ‘starter’ dependencies to simplify your build configuration</p></li><li><ul><li>自动starter依赖，简化构建配置</li></ul></li><li><p>Automatically configure Spring and 3rd party libraries whenever possible</p></li><li><ul><li>自动配置Spring以及第三方功能</li></ul></li><li><p>Provide production-ready features such as metrics, health checks, and externalized configuration</p></li><li><ul><li>提供生产级别的监控、健康检查及外部化配置</li></ul></li><li><p>Absolutely no code generation and no requirement for XML configuration</p></li><li><ul><li><strong>无代码生成、无需编写XML</strong></li></ul></li></ul><blockquote><p>SpringBoot是整合Spring技术栈的一站式框架</p><p>SpringBoot是简化Spring技术栈的快速开发脚手架</p></blockquote><p>SpringBoot最大的特点就是 无需编写大量的配置文件 需要什么功能模块 只需要导入相应的starter即可 &lt; parent&gt;中也几乎包含所有需要用到的功能依赖的版本号</p><h4 id="SpringBoot缺点"><a href="#SpringBoot缺点" class="headerlink" title="SpringBoot缺点"></a>SpringBoot缺点</h4><ul><li>人称版本帝，迭代快，需要时刻关注变化</li><li>封装太深，内部原理复杂，不容易精通</li></ul><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a><strong>微服务</strong></h2><ul><li><p>微服务是一种架构风格</p></li><li><p>一个应用拆分为一组小型服务</p></li><li><p>每个服务运行在自己的进程内，也就是可独立部署和升级</p></li><li><p>服务之间使用轻量级HTTP交互</p></li><li><p>服务围绕业务功能拆分</p></li><li><p>可以由全自动部署机制独立部署</p></li><li><p>去中心化，服务自治。服务可以使用不同的语言、不同的存储技术</p></li></ul><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a><strong>分布式</strong></h2><p>就是把一个一个的服务细分为不同功能的微服务 再将这些服务部署到不同的服务器上 以达到性能能效最大化 同时也避免了一台服务器出现问题 整个系统业务完全瘫痪</p><p><strong>分布式的困难</strong></p><ul><li><p>远程调用</p></li><li><p>服务发现</p></li><li><p>负载均衡</p></li><li><p>服务容错</p></li><li><p>配置管理</p></li><li><p>服务监控</p></li><li><p>链路追踪</p></li><li><p>日志管理</p></li><li><p>任务调度</p></li><li><p>……</p></li></ul><p>分布式的解决: SpringBoot+SpringCloud</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/1599799119457-841ef47a-6585-4ca4-8e3d-8298e796012c.png" alt="img"></p><h2 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a><strong>云原生</strong></h2><p>原生应用如何上云。 Cloud Native</p><h4 id="上云的困难"><a href="#上云的困难" class="headerlink" title="上云的困难"></a><strong>上云的困难</strong></h4><ul><li><p>服务自愈</p></li><li><p>弹性伸缩</p></li><li><p>服务隔离</p></li><li><p>自动化部署</p></li><li><p>灰度发布</p></li><li><p>流量治理</p></li><li><p>……</p></li></ul><h4 id="上云的解决"><a href="#上云的解决" class="headerlink" title="上云的解决"></a>上云的解决</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/1599563498261-8b0b4d86-bd9b-49a3-aefc-89696a375dcb.png" alt="img"></h4><h2 id="学习SpringBoot"><a href="#学习SpringBoot" class="headerlink" title="学习SpringBoot"></a><strong>学习SpringBoot</strong></h2><ol><li><p>查看官方文档:<strong><a href="https://spring.io/">Spring官方 所有Spring的框架 包括分布式的解决方案</a></strong></p></li><li><p>查看SpringBoot官方文档 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/"><strong>Spring Boot官方文档</strong></a></p></li><li><p>查看版本新特性: <a href="https://github.com/spring-projects/spring-boot/wiki#release-notes"><strong>SpringBoot迭代更新文档</strong></a></p></li></ol><h2 id="SpringBoot2入门"><a href="#SpringBoot2入门" class="headerlink" title="SpringBoot2入门"></a><strong>SpringBoot2入门</strong></h2><h4 id="一-基础要求"><a href="#一-基础要求" class="headerlink" title="一: 基础要求"></a>一: 基础要求</h4><p><strong>系统要求</strong></p><ul><li><p><a href="https://www.java.com/">Java 8</a> &amp; 兼容java14 .</p></li><li><p>Maven 3.3+</p></li><li><p>idea 2019.1.2</p></li></ul><h4 id="二-开始步骤"><a href="#二-开始步骤" class="headerlink" title="二: 开始步骤"></a>二: 开始步骤</h4><h5 id="方式一-直接使用Maven创建SpringBoot项目"><a href="#方式一-直接使用Maven创建SpringBoot项目" class="headerlink" title="方式一:直接使用Maven创建SpringBoot项目"></a>方式一:直接使用Maven创建SpringBoot项目</h5><ol><li>需要导入&lt; parent&gt;&lt;&#x2F; parent&gt; 依赖 里面包含了几乎开发要用到的所用依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>开始一个web项目,就加入spring-boot-starter-web依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>加入插件 该插件可以简化部署</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该插件可以将 Spring Boot应用打包为可执行的jar或war文件，然后以通常的方式运行Spring Boot应用。</p><ol start="4"><li>如果想更改SpringBoot内置服务器的端口号 就创建一个application.properties</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8888</span></span><br></pre></td></tr></table></figure><p>这样SpringBoot就能识别出了并修改了</p><ol start="5"><li>创建主程序类 (也是SpringBoot的核心)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主程序类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@SpringBootApplication</span>: 这是一个SpringBoot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="6"><li>编写一个控制器 和 处理器方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-01-11-20:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handler01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello,Spring Boot2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="7"><li>运行主程序类 并测试</li></ol><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220120140741819.png" alt="image-20220120140741819"></p><h5 id="方式二-使用idea自带的模板创建-spring-initializr"><a href="#方式二-使用idea自带的模板创建-spring-initializr" class="headerlink" title="方式二: 使用idea自带的模板创建(spring initializr)"></a>方式二: 使用idea自带的模板创建(spring initializr)</h5><p>选择spring initalizr 填入相应的信息 然后点击next</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220120141041583.png" alt="image-20220120141041583"></p><p>因为我们是做web应用 所以这里选择springweb 如果是其他项目 选择相应的模块即可</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220120141138907.png" alt="image-20220120141138907"></p><p>然后等待创建 最后创建相应的Controller等 运行即可(剩下于方式一相同)</p><h5 id="方式三-spring官网创建-同样使用的是spring-initializr"><a href="#方式三-spring官网创建-同样使用的是spring-initializr" class="headerlink" title="方式三:spring官网创建(同样使用的是spring initializr)"></a>方式三:spring官网创建(同样使用的是spring initializr)</h5><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220120141750951.png" alt="image-20220120141750951"></p><p><strong>官网找到 project 点击SpringBoot 拉到最后</strong></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220120141836152.png" alt="image-20220120141836152"></p><p><strong>点击Spring initializr</strong></p><p>界面如图</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220120141947001.png" alt="image-20220120141947001"></p><p>方式于idea创建相同 只是创建后的形式不同 创建后是以压缩包的形式下载 下载后要导入idea 这种方式是用来应付idea无法联网的情况 </p><h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><ol><li>SpringBoot的配置文件一定要写到 resources目录下 且尽量以application为文件名 这样才能识别</li><li>所有的Controller类 等业务类都要写道SpringBootApplication(主程序类)的同级或是子级目录下 否则会报<strong>404</strong></li><li><strong>常用的方式是 一 和 二</strong></li></ol><h2 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a><strong>自动配置原理</strong></h2><h4 id="一-yin-yang-依赖管理"><a href="#一-yin-yang-依赖管理" class="headerlink" title="一:yin_yang:依赖管理"></a>一:yin_yang:依赖管理</h4><ul><li>SpringBoot使用了父项目做为项目管理</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">依赖管理    </span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">他的父项目</span><br><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">几乎声明了所有开发中常用的依赖的版本号,自动版本仲裁机制</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>开发只需要导入starter场景启动器(<strong>Starter就是一个包含了若干个坐标定义的pom管理文件, 即包含了若干个依赖的信息</strong>)</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、见到很多 spring-boot-starter-* ： *就某种场景</span><br><span class="line">2、只要引入starter，这个场景的所有常规需要的依赖我们都自动引入</span><br><span class="line">3、SpringBoot所有支持的场景</span><br><span class="line">https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter</span><br><span class="line">4、见到的  *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。</span><br><span class="line">5、所有场景启动器最底层的依赖</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>无需关注版本号，自动版本仲裁</li></ul><blockquote><p>1、引入依赖默认都可以不写版本<br>2、引入非版本仲裁的jar，要写版本号。</p></blockquote><p>修改默认版本号 是使用依赖覆盖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。</span><br><span class="line">2、在当前项目里面重写配置</span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.43<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">也可以直接在pom.xml中重写依赖来覆盖</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之所以在配置了&lt; parent&gt;之后不需要填写版本号 是因为 &lt; parent&gt;中使用了&lt; dependencyManagement&gt;管理</p><h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意:"></a>注意:</h5><ol><li>当导入一个Starter时又想导入一些其他技术 又不想直接导入其他的Starter 可以直接导入该技术的依赖 而且只需要写GAV中的GA而不需要写V 但是如果&lt; Parent&gt;中没有该依赖时 就需要完整写上GAV</li></ol><h4 id="二-first-quarter-moon-自动配置"><a href="#二-first-quarter-moon-自动配置" class="headerlink" title="二:first_quarter_moon:自动配置:"></a>二:first_quarter_moon:自动配置:</h4><ul><li><p>自动配好Tomcat</p></li><li><ul><li>引入Tomcat依赖。</li><li>配置Tomcat</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>自动配好SpringMVC</p></li><li><ul><li>引入SpringMVC全套组件</li><li>自动配好SpringMVC常用组件（功能）</li></ul></li><li><p>自动配好Web常见功能，如：字符编码问题</p></li><li><ul><li>SpringBoot帮我们配置好了所有web开发的常见场景</li></ul></li><li><p>默认的包结构</p></li><li><ul><li><strong>主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来</strong>(所以一般将组件都写在主程序的同级或是子级目录)</li><li>无需以前的包扫描配置</li></ul></li><li><ul><li>想要改变扫描路径，</li><li>@SpringBootApplication(scanBasePackages&#x3D;<strong>“com.atguigu”</strong>)</li></ul></li><li><ul><li>或者@ComponentScan 指定扫描路径(更改方式)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">等同于</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.boot&quot;)</span></span><br></pre></td></tr></table></figure><ul><li><p>各种配置拥有默认值</p></li><li><ul><li>默认配置最终都是映射到某个类上，如：MultipartProperties</li><li>配置文件的值最终会绑定每个类上，这个类会在容器中创建对象</li></ul></li><li><p>按需加载所有自动配置项</p></li><li><ul><li>非常多的starter</li><li>引入了哪些场景这个场景的自动配置才会开启</li></ul></li><li><ul><li>SpringBoot所有的自动配置功能都在 spring-boot-autoconfigure 包里面</li></ul></li><li><p>….</p></li></ul><hr><h4 id="容器中的注解的功能"><a href="#容器中的注解的功能" class="headerlink" title="容器中的注解的功能"></a>容器中的注解的功能</h4><h5 id="一-question-Configuration-配置类"><a href="#一-question-Configuration-配置类" class="headerlink" title="一:question:@Configuration(配置类):"></a>一:question:@Configuration(配置类):</h5><p><strong>使用:</strong></p><ol><li>用在类的上方 表示该类为配置类 可以与@Bean标签一起使用 作用类似于Spring.xml文件中&lt; bean&gt;创建对象</li></ol><p><strong>告诉springboot这个是一个配置类 &#x3D;&#x3D; 配置文件</strong></p><ul><li><p>配置类里面使用@Bean标注在方法的上面给容器注册组件,默认也是单实例的</p></li><li><p>配置类本身也是组件</p></li><li><p>proxyBeanMethods()方法:代理bean的方法</p></li><li><p>当@Configuration中的参数proxyBeanMethods 的值为true时为代理模式 Cglib代理 会在原来的方法上增加功能 判断容器中是否已有对象 单例模式</p></li><li><p>当@Configuration中的参数proxyBeanMethods 的值为false时为非代理模式 就是非单例模式</p></li><li><p>Full模式(proxyBeanMethods &#x3D; true)(保证每个@Bean方法被调用多少次返回的组件都是单实例的)</p></li><li><p>Lite模式(proxyBeanMethods &#x3D; false)(每个@Bean方法被调用多少次返回的组件都是新创建的)</p><blockquote><ul><li>配置 类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断</li><li>配置类组件之间有依赖关系，方法会被调用得到之前单实例组件，用Full模式</li></ul></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 外部无论对配置类中的这个组件注解方法调用多少次,获取的都是之前注册容器中的单实例对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * //给容器中添加组件.以方法名作为组件的id,返回类型的,就是组件在容器中的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Cat</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span> 方法名就是实例的名称</span><br><span class="line">    <span class="keyword">public</span> Cat <span class="title function_">cat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;彭芳姐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试发现 Full模式(proxyBea+nMethods &#x3D; true) 使用的是Cglib代理模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.dyw.application.config.MyConfig$$EnhancerBySpringCGLIB$$c5874a7@120d3fd</span><br></pre></td></tr></table></figure><p>Lite(proxyBeanMethods &#x3D; true)则是没有被代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.dyw.application.config.MyConfig@29fa6b65</span><br></pre></td></tr></table></figure><h6 id="1-1-Import"><a href="#1-1-Import" class="headerlink" title="1. 1 @Import"></a>1. 1 @Import</h6><p><code> @Import(&#123;Cat.class&#125;)</code> 给容器中自动创建出这个类型的组件  默认组件的名字为全类名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;User.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">bean</span> <span class="operator">=</span> context.containsBean(<span class="string">&quot;com.dyw.springboot.entity.User&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h6 id="1-2-Conditional"><a href="#1-2-Conditional" class="headerlink" title="1.2 @Conditional"></a>1.2 @Conditional</h6><ul><li>条件装配: 满足Conditional指定的条件,则进行组件注入</li><li>@ConditionalOnBean</li><li>@ConditionalOnMissingBean</li><li>@ConditionalOnMissingClass</li><li>@ConditionalOnResource</li><li>@ConditionalOnJava</li><li>@ConditionalOnWebApplication</li><li>@ConditionalOnNotWebApplication</li><li>@ConditionalOnClass</li></ul><p>使用在@Configuration注解类中的@Bean标签下 根据注解条件判断是否注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(Cat.class)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setCat(cat());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h5 id="二-SpringBootApplication-主程序类或引导类"><a href="#二-SpringBootApplication-主程序类或引导类" class="headerlink" title="二: @SpringBootApplication(主程序类或引导类)"></a>二: @SpringBootApplication(主程序类或引导类)</h5><ol><li>类上加上@SpringBootApplication 表示该类为主程序类 </li><li>在类中写上主方法(main) 调用 SpringApplication.run(主程序类.class, args);即可开始SpringBoot程序</li><li>注意 组件都要写到主程序类的同级或是子级目录</li><li>SpringApplication.run()方法会返回SpringBoot的容器 可以根据容器的getBean(“组件名”,类名.class)获取组件</li><li><strong>SpringApplication.run(主程序类.class, args)方法会返回一个Context上下文对象(容器), 里面包含了DispatcherServlet等对象, 这也是问什么运行此方法就可以达到实现web应用的功能. 通过内嵌的TomCat服务器核心就可以读取这个容器的组件</strong>.</li><li>SpringBoot内嵌的服务器核心同样也是通过组件的方式存在SpringBoot的Context上下文对象中.(因为TomCat是java写的 运行原理就是执行java对象 所以把Tomcat的对象的创建和管理交给了SpringBoot);</li></ol><hr><h5 id="三-Bean"><a href="#三-Bean" class="headerlink" title="三: @Bean"></a>三: @Bean</h5><ol><li><p>用于配置类的方法上 用来注册组件 使得组件管理的主权在容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cat <span class="title function_">cat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;彭芳姐&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法名就是组件的名称 也可以在@Bean中设置组件的名称 @Bean(“组件名”)</p></li><li><p>创建组件的方法有两种 </p><ol><li><p>一种是利用有参构造创建组件 可以利用有参构造注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cat <span class="title function_">cat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;彭芳姐&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>另一种是利用无参构造 需要后续使用set方法注入 或是利用spring中的注解注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cat <span class="title function_">cat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><hr><h5 id="四-RestController"><a href="#四-RestController" class="headerlink" title="四: @RestController"></a>四: @RestController</h5><ul><li><strong>@RestController &#x3D; @Controller + @ResponseBody</strong></li></ul><p>即**@RestController<strong>在</strong>@Controller<strong>的基础上 集成了</strong>@ResponseBody**的特性 即将java对象转换为json数据或是其他数据</p><ul><li><strong>@ResponseBody</strong> 注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是<a href="https://so.csdn.net/so/search?q=XML&spm=1001.2101.3001.7020">XML </a>数据。</li></ul><blockquote><p>注意：在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。</p></blockquote><ul><li>@ResponseBody是作用在方法上(可使用在类上表示整个类中的方法都受@ResponseBody的影响)的，@ResponseBody 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】。</li><li>注意：<strong>在使用 @RequestMapping后</strong>，<strong>返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。</strong> 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据。@RequestBody 将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。</li></ul><hr><h5 id="五-eagle-RequstMapping"><a href="#五-eagle-RequstMapping" class="headerlink" title="五:eagle:@RequstMapping"></a>五:eagle:@RequstMapping</h5><p>在SpringMVC的学习中我们知道 被它标注的方法称为<strong>处理器方法</strong> , 它可以标注一个处理器方法的请求路径, 被他修饰的处理器方法, 默认返回值通常解析为跳转路径</p><p>在SpringBoot中 它的功能被细分了</p><p>原本的**@RequestMapping**在不指定请求方法时,会接收任意请求方法的请求</p><p>但是SpringBoot中推荐不直接在方法而是使用功能更细的**@请求方法名Mapping** 例如**@GetMapping<strong>或是</strong>@PostMapping**</p><p>而把@RequstMapping用在类上 用来当访问路径的前缀</p><p><a href="http://localhost:8088/dyw/cat">http://localhost:8088/dyw/cat</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/dyw&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/cat&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doCat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="六：-PathVariable（常用于REST风格）"><a href="#六：-PathVariable（常用于REST风格）" class="headerlink" title="六：@PathVariable（常用于REST风格）"></a>六：@PathVariable（常用于REST风格）</h5><ul><li>绑定路径参数于处理器方法形参间的关系，要求路径参数名于形参名一一对应</li><li>使用： 用在SpringMVC控制器方法形参定义前面</li><li>@PathVariable常用于RESTful中且 请求路径参数只有较少数量时 如一个</li></ul><p><strong>注意</strong>：<strong>参数是在路径上的</strong>使用{参数名称}描述路径参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String delete(@PathVariable Integer id)&#123;</span><br><span class="line">        System.out.println(&quot;user delete...&quot;+id);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:user delete&#125;&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220120201849092.png" alt="image-20220120201849092"></p><h5 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h5><ul><li>用来接收Josn请求</li></ul><p>json请求传参方式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">12</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>使用键值对的方式传参 **键名+”:”+值 ** 键值放在{}中</p><h5 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h5><ul><li>用于接收url地址传来的参数 或是表单提交的参数 但路径传参的格式相对于RESTful的**@PathVariable**麻烦一点</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestParam</span><br><span class="line">http://localhost:0000/users?id=1 </span><br><span class="line">=====================================================</span><br><span class="line">@PathVariable</span><br><span class="line">http://localhost:0000/users/1</span><br></pre></td></tr></table></figure><h5 id="RequestBody、-RequestParam和-PathVariable总结"><a href="#RequestBody、-RequestParam和-PathVariable总结" class="headerlink" title="@RequestBody、@RequestParam和@PathVariable总结"></a>@RequestBody、@RequestParam和@PathVariable总结</h5><ul><li>应用<ul><li>后期开发中，发送请求参数超过一个时 ，以json格式为主，@RequestBody应用较广</li><li>如果发送非json格式数据，选用@RequestParam接收参数</li><li>采用RESTful进行开发，当参数数量较少时，例如一个可以采用@PathVariable接收请求路径变量，通常用于传递id值</li></ul></li></ul><hr><h5 id="七-ImportResource"><a href="#七-ImportResource" class="headerlink" title="七:@ImportResource"></a>七:@ImportResource</h5><ul><li><p>该注解可以导入原生的配置文件 例如Spring中的Bean.xml配置文件 让其生效</p></li><li><p>使用在任意配置类上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;Cat.class&#125;)</span></span><br><span class="line"><span class="meta">@ImportResource(&quot;classpath:Bean.xml&quot;)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    Bean.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.springboot.entity.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;cat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.springboot.entity.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><hr></li></ul><h5 id="八-ConfigurationProperties"><a href="#八-ConfigurationProperties" class="headerlink" title="八: @ConfigurationProperties"></a>八: @ConfigurationProperties</h5><ul><li><p>配置绑定 使用该注解 可以使用java读取到的配置文件(xml properties yml)中的内容,并且把它封装到JavaBean中,以供随时使用</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mycar.name</span>=<span class="string">BYD</span></span><br><span class="line"><span class="attr">mycar.price</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure></li><li><p>方式一: 在JavaBean上加上@Component(将其注册到springboot容器)和@ConfigurationPropertes注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式二:在JavaBean上只用加上@ConfigurationPropertes注解 并且在配置类(@Configuration)上加上@EnableConfigurationPropertes(Class&lt;?&gt;[])</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(Car.class)</span></span><br><span class="line"><span class="comment">//1. 开启Car配置绑定功能</span></span><br><span class="line"><span class="comment">//2. 把这个Car这个组件自动注册到容器中</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="REST风格"><a href="#REST风格" class="headerlink" title="REST风格"></a><strong>REST风格</strong></h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介:"></a>简介:</h4><ul><li><p>按照REST风格访问资源时使用<strong>行为动作</strong>区分对资源进行了何种操作</p><ul><li><a href="http://localhost:0/users">http://localhost:0000/users</a>                           查询全部用户信息  GET(查询)</li><li><a href="http://localhost:0/users/1">http://localhost:0000/users/1</a>                           查询指定用户信息  GET(查询)</li><li><a href="http://localhost:0/users">http://localhost:0000/users</a>                           添加用户信息  POST(新增&#x2F;保存)</li><li><a href="http://localhost:0/users">http://localhost:0000/users</a>                           修改用户信息  PUT(修改&#x2F;更新)</li><li><a href="http://localhost:0/users/1">http://localhost:0000/users/1</a>                           删除用户信息  DELETE(删除)</li></ul></li><li><p>根据REST风格对资源进行访问称为<strong>RESTful</strong></p></li><li><p>RESTful通常要使用四种访问的请求方法 如GET、POST、PUT、DELETE。</p></li></ul><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>隐藏资源的访问行为，无法通过地址得知资源是何种操作</li><li>书写简化</li></ul><h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意:"></a>注意:</h4><ul><li>上述行为是约定方式，约定方式不是规范，可以打破，所以称为REST风格，而不是REST规范 但是由于使用REST风格的公司越来越多，也就慢慢都认为它是一种规范（都去遵守它了）。</li><li>描述模块名称通常使用复数，也就是加s的格式描述，表示此类资源，而非单个资源，例如users、books….。</li></ul><h4 id="实例步骤："><a href="#实例步骤：" class="headerlink" title="实例步骤："></a>实例步骤：</h4><ol><li>设定http请求动作（动词）</li><li>设定请求参数（路径变量）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="comment">//保存用户</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user save...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:user save&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除用户</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user delete...&quot;</span>+id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:user delete&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改用户</span></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user update...&quot;</span>+user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:user update&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取指定用户</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getById</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user getById...&quot;</span>+id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:user getById&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取全部用户</span></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAll</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user getAll...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:user getAll&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a><strong>配置文件</strong></h2><p>配置文件（application.properties）前面提到可以修改Springboot内置的端口号 </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br></pre></td></tr></table></figure><p>还可以修改banner、log等配置信息</p><p>更多的、详细的配置信息都在<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties%E4%B8%AD">https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties中</a> </p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220120211025873.png" alt="image-20220120211025873"></p><p><strong>注意：</strong></p><ul><li>配置文件中的内容要与你导入的依赖相关，如果你没有导入相关的依赖那么配置的内容是不会生效的，例如没有导入tomcat的依赖，那么配置文件中修改server.port是不会有高亮提示的也不生效。</li></ul><h4 id="配置文件的格式"><a href="#配置文件的格式" class="headerlink" title="配置文件的格式"></a>配置文件的格式</h4><ul><li><strong>.properties(传统格式&#x2F;默认格式)</strong></li><li>.yaml</li><li>.<strong>yml(主流)</strong></li></ul><p>上述三种配置文件同时存在的执行的优先级（会加载覆盖） </p><p>是properties &gt;&gt; yml &gt;&gt; yaml</p><p>但上述情况一般不会出现</p><hr><h5 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h5><ul><li><p>YAML（YAML Ain’t Markup Language）,一种数据序列化格式</p></li><li><p><strong>优点：</strong></p><ul><li>容易阅读</li><li>容易与脚本语言交互</li><li>以数据为核心，重数据格式</li></ul></li><li><p><strong>YAML文件扩展名</strong></p><ul><li>.yaml</li><li><strong>.yml（主流）</strong></li></ul></li><li><p><strong>语法规则</strong></p><ul><li>大小写敏感</li><li>属性层级关系使用多行描述，每行结尾使用冒号结束</li><li>使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）</li><li>属性值前面添加空格（属性名与属性之间使用冒号+空格作为分隔）</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">country:</span> <span class="string">china</span></span><br></pre></td></tr></table></figure><ul><li><p>#表示注释</p></li><li><p>更多语法<a href="https://www.runoob.com/w3cnote/yaml-intro.html">YAML 入门教程 | 菜鸟教程 (runoob.com)</a></p><hr><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4></li></ul><h4 id="Java程序读取"><a href="#Java程序读取" class="headerlink" title="Java程序读取"></a><strong>Java程序读取</strong></h4><ul><li><p>使用Spring的IOC机制使用@Value注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;country&#125;&quot;)</span><span class="comment">//读取键值对中的值</span></span><br><span class="line"><span class="keyword">private</span> String Country;</span><br></pre></td></tr></table></figure><ul><li>使用java类读取 （YAML类）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> YamlReader.class.getClassLoader().getResourceAsStream(<span class="string">&quot;application.yml&quot;</span>);) &#123;</span><br><span class="line">properties = yaml.loadAs(in, HashMap.class);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">&quot;Init yaml failed !&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>使用环境变量对象来存储yaml配置文件中的键值对（使用@Autowire注入赋值）<strong>用来应对当yaml配置文件中对象过多的情况</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line">    </span><br><span class="line">System.out.println(env.getProperty(<span class="string">&quot;server.port&quot;</span>));</span><br><span class="line">System.out.println(env.getProperty(<span class="string">&quot;Country&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li><p><strong>使用自定义类封装yaml配置文件中的数据</strong></p><p>​    application.yaml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">User:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">丁杨维</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>自定义User类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span><span class="comment">//将对象的生命周期交给容器管理 也为了容器将配置文件中的信息赋值给该对象</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Controller.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getById</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220120224222972.png" alt="image-20220120224222972"></p></li><li><p>yaml文件中值的相互引用 直接使用${键名}即可</p></li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">BaseDir:</span> <span class="string">c\windows</span></span><br><span class="line"><span class="attr">TempDir:</span> <span class="string">$&#123;BaseDir&#125;\temp</span></span><br><span class="line"><span class="comment">#如果有转义字符想要显示出来 就加上双引号 如这里\t就是一个转义字符</span></span><br><span class="line"><span class="attr">TempDir:</span> <span class="string">&quot;$&#123;BaseDir&#125;\temp&quot;</span></span><br></pre></td></tr></table></figure><hr><p><strong>注意：</strong></p><ul><li><p>虽然配置文件格式多 单文件名可不是乱取的 名字一定是<strong>application.xxx</strong>才行</p></li><li><p>如果idea没有识别你的yaml文件或是yml文件为springboot配置文件（前提是文件名是applicaiton.xxx） 可以在Project Struct中设置</p></li></ul><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220120213544643.png" alt="image-20220120213544643"></p><p>选择Facts 选择Configuration Files 在点击那个绿叶标志</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220120213633139.png" alt="image-20220120213633139"></p><p>点击+号找到你的文件</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220120213807493.png" alt="image-20220120213807493"></p><h2 id="SpringBoot整合第三方技术"><a href="#SpringBoot整合第三方技术" class="headerlink" title="SpringBoot整合第三方技术"></a>SpringBoot整合第三方技术</h2><p><strong>注意：</strong>如果使用的第三方技术无法在Spring Initializr中勾选到 则需要手动添加（maven中央仓库中查找）</p><h4 id="SpringBoot整合Junit"><a href="#SpringBoot整合Junit" class="headerlink" title="SpringBoot整合Junit"></a>SpringBoot整合Junit</h4><p>使用Spring Initializr创建一个普通的SpringBoot程序（啥都不选） 会自动导入test依赖</p><p><strong>这是因为maven创建的项目，生命周期中离不开test的原因，所以不用我们导入它会自动引入。</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">&lt;/dependenc</span><br></pre></td></tr></table></figure><p>BookDao.java接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BookImpl.java实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book save&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Springboot05ApplicationTests.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Springboot05ApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookImpl book;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        book.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试类获得结果</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220120230704919.png" alt="image-20220120230704919"></p><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>使用测试类时要将测试类放在与classes目录下引导类的路径呈同级或子级关系 否则测试类会找不到**@SpringBootConfiguration**而出现异常，而引导类的注解中包含@SpringBootConfiguration 所以引导类也是一个SpringBootConfiguration。</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ol><li><strong>将测试类放在classes目录下与引导类的路径呈同级或是子级关系的包下。</strong></li><li>使用@ContextConfiguration(classes&#x3D;…)注解指定引导类</li><li><strong>使用@SpringBootTest(classes&#x3D;…)注解指定引导类</strong></li></ol><h4 id="SpringBoot整合Mybatis"><a href="#SpringBoot整合Mybatis" class="headerlink" title="SpringBoot整合Mybatis"></a>SpringBoot整合Mybatis</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><ol><li>使用Spring Initializr创建，<strong>需要勾选SQL中的MySQL Driver和MyBatis Framework，根据需要勾选WEB。</strong></li></ol><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220120232906258.png" alt="image-20220120232906258"></p><p>Mybatis与SpringBoot整合的依赖以及JDBC的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置数据库连接信息</li></ol><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/my_db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">devil</span></span><br></pre></td></tr></table></figure><ol start="3"><li>写实体类</li></ol><p>Student.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dyw.springboot06mybatis.Domain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Devil</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-01-20-23:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>写StudentDao接口 写入相关操作</li></ol><p>StudentDao.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentDao</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select id,name,age from student order by id&quot;)</span></span><br><span class="line">    List&lt;Student&gt; <span class="title function_">selectStudents</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不适用配置文件那么则加入**@Mapper**注解 就类似于配置文件 自动代理 在里面使用@Select注解（查找）配置操作 @Update（修改&#x2F;更新）….</p><p>执行测试类</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220120234846000.png" alt="image-20220120234846000"></p><h5 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h5><p>如果出现了serverTimezone异常 需要在配置文件URL后加入?serverTimezone&#x3D;UTC（时区任意）</p><h4 id="SpringBoot整合Mybatis-Plus"><a href="#SpringBoot整合Mybatis-Plus" class="headerlink" title="SpringBoot整合Mybatis-Plus"></a>SpringBoot整合Mybatis-Plus</h4><p>直接导入相应的依赖mybatis-plus-boot-starter即可</p><p>并且在配置文件中写上数据库相关配置即可</p><hr><h4 id="SpringBoot整合Mybatis-Druid"><a href="#SpringBoot整合Mybatis-Druid" class="headerlink" title="SpringBoot整合Mybatis+Druid"></a>SpringBoot整合Mybatis+Druid</h4><p>需要导入druid的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.yml配置数据源类型</p><p>方式一: 在spring.datasource中配置type为DruidDataSource</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/my_db?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">devil</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br></pre></td></tr></table></figure><p>方式二: 直接在spring.datasource.druid中配置数据源信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/my_db?serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">devil</span></span><br></pre></td></tr></table></figure><p>推荐第二种</p><h2 id="SSMP-SpringBoot-Mybatis-Plus-综合案例"><a href="#SSMP-SpringBoot-Mybatis-Plus-综合案例" class="headerlink" title="SSMP(SpringBoot+Mybatis-Plus)综合案例"></a>SSMP(SpringBoot+Mybatis-Plus)综合案例</h2><blockquote><ol><li><strong>pom.xml</strong>  配置起步依赖</li><li><strong>application.yml</strong> 设置数据源 端口 框架技术相关配置等</li><li><strong>dao</strong> 继承BaseMapper, 设置@Mapper</li><li><strong>dao 测试类</strong></li><li><strong>service</strong> 调用数据层接口或Mybatis-Plus提供的接口(ServiceImpl&lt;BookMapper,Book&gt;)快速开发</li><li><strong>service测试类</strong></li><li><strong>controller</strong> 基于Restful开发, 使用Postman测试跑通功能</li><li><strong>页面</strong> 放置在resources目录下的static目录中</li></ol></blockquote><p>使用<strong>Spring Initializr</strong>创建项目 勾选<strong>Spring web</strong> 和 <strong>Mysql Driver</strong> 额外加入依赖<strong>Druid Mybatis-Plus</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建数据库表 创建实体类</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220123202528206.png" alt="image-20220123202528206"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="comment">//@TableName(&quot;tbl_book&quot;)(这里可以选择在application.yml文件中配置mybaits-plus中的table_prefix=tbl_)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(value = &quot;id&quot;,type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/my_db?serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">devil</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">tbl_</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># mybatis-plus 日志配置    </span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><h3 id="表现层消息一致性处理"><a href="#表现层消息一致性处理" class="headerlink" title="表现层消息一致性处理"></a><strong>表现层消息一致性处理</strong></h3><ul><li>设计表现层返回结果的模型类,用于后端与前端进行数据格式的同意, 也称为<strong>前后端数据协议</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean flag;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Boolean flag)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Boolean flag, Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Boolean flag,String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>设计同一个返回值结果类型便于前端开发读取数据</li><li>返回值结果类型可以根据需求自行设定,没有固定格式</li><li>返回值结果模型类用于后端与前端进行数据格式同意, 也称为前后端数据协议</li></ol><h3 id="异常消息处理"><a href="#异常消息处理" class="headerlink" title="异常消息处理"></a><strong>异常消息处理</strong></h3><p>根据前文我们定义的<strong>前后端数据协议</strong> 如果遇到程序出现<strong>异常</strong> 会给前端返回一个异常数据 这并不在前后端数据协议定义范围 如果要进行消息处理 就必须进行<strong>异常消息处理</strong></p><ol><li><p>这里就要使用注解**@RestControllerAdvice**(控制器增强)定义SpringMVC异常处理器来处理异常的</p></li><li><p><strong>@ExceptionHandler</strong>(异常处理器)必须被扫描加载,否则无法生效</p></li><li><p>表现层返回结果中模型类中添加消息属性用来传递消息到页面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作为springmvc异常处理</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//拦截所有的异常信息</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">doException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        <span class="comment">//记录日志</span></span><br><span class="line">        <span class="comment">//通知运维</span></span><br><span class="line">        <span class="comment">//通知开发</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="string">&quot;服务器故障,请稍后再试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="运维部分"><a href="#运维部分" class="headerlink" title="运维部分"></a><a href="D:\BaiduNetdiskDownload\运维实用篇-资料\PPT\SpringBoot运维实用篇（发布版）.pdf"><strong>运维部分</strong></a></h2><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220124205028879.png" alt="image-20220124205028879"></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220124205017270.png" alt="image-20220124205017270"></p><h3 id="临时属性"><a href="#临时属性" class="headerlink" title="临时属性"></a>临时属性</h3><ol><li>使用命令行dos命令运行springboot工程是可以使用临时属性替换配置文件中的属性</li><li>临时属性添加方式: java -jar 工程名.jar –属性名&#x3D;值</li><li>多个临时属性之间使用空格分隔</li><li>临时属性必须是当前boot工程支持的属性,否则设置无效</li></ol><h3 id="配置文件的四级分类"><a href="#配置文件的四级分类" class="headerlink" title="配置文件的四级分类"></a>配置文件的四级分类</h3><ul><li>SpringBoot中4级配置文件(级别越高 优先级越高)</li></ul><blockquote><p>1级： file ：config&#x2F;application.yml  <strong>【最高】</strong> </p><p>2级： file ：application.yml</p><p>3级：classpath：config&#x2F;application.yml</p><p>4级：classpath：application.yml  <strong>【最低】</strong></p></blockquote><ul><li>作用：</li></ul><blockquote><p>1级与2级留做系统打包后设置通用属性，1级常用于运维经理进行线上整体项目部署方案调控</p><p>3级与4级用于系统开发阶段设置通用属性，3级常用于项目经理进行整体项目属性调控</p></blockquote><h3 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h3><ul><li><p>通过启动参数加载配置文件（无需书写配置文件扩展名)<img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220125222425964.png" alt="image-20220125222425964"></p></li><li><p>通过启动参数加载指定文件路径下的配置文件</p></li></ul><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220125222635339.png" alt="image-20220125222635339"></p><ul><li>通过启动参数加载指定文件路径下的配置文件时可以加载多个配置</li></ul><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220125222709306.png" alt="image-20220125222709306"></p><h4 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h4><blockquote><ul><li><p>单服务器项目：使用自定义配置文件需求较低</p></li><li><p>多服务器项目：使用自定义配置文件需求较高，将所有配置放置在一个目录中，统一管理</p></li><li><p>基于SpringCloud技术，所有的服务器将不再设置配置文件，而是通过配置中心进行设定，动态加载配置信息</p></li></ul></blockquote><h3 id="多环境开发-YAML版"><a href="#多环境开发-YAML版" class="headerlink" title="多环境开发(YAML版)"></a>多环境开发(YAML版)</h3><h4 id="单配置文件版本"><a href="#单配置文件版本" class="headerlink" title="单配置文件版本"></a>单配置文件版本</h4><ul><li><p>多环境开发需要设置若干种常用环境,例如开发 生产 测试环境</p></li><li><p>yaml格式中设置多环境使用<code>&quot;---&quot;</code>区分环境设置边界</p></li><li><p>每种环境的区别在于加载的配置属性不同</p></li><li><p>启用某种环境时需要指定启动时使用该环境</p></li><li><pre><code class="yml">#生成环境spring:  config:    activate:      on-profile: pro</code></pre></li><li><p>&#96;&#96;&#96;yml<br>#指定环境<br>spring:<br>  profiles:<br>active: test</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  实例</span><br><span class="line"></span><br><span class="line">```yml</span><br><span class="line">#应用环境</span><br><span class="line">#公共配置</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: test</span><br><span class="line">---</span><br><span class="line">#设置环境</span><br><span class="line">#生成环境</span><br><span class="line">spring:</span><br><span class="line">  config:</span><br><span class="line">    activate:</span><br><span class="line">      on-profile: pro</span><br><span class="line">server:</span><br><span class="line">  port: 81</span><br><span class="line">---</span><br><span class="line">#开发环境</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">server:</span><br><span class="line">  port: 82</span><br><span class="line">---</span><br><span class="line">#测试环境</span><br><span class="line">spring:</span><br><span class="line">  config:</span><br><span class="line">    activate:</span><br><span class="line">      on-profile: test</span><br><span class="line">server:</span><br><span class="line">  port: 83</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="多配置文件版本"><a href="#多配置文件版本" class="headerlink" title="多配置文件版本"></a>多配置文件版本</h4><ol><li>主启动配置文件 application.yml</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><ol start="2"><li>环境分类配置文件application-pro.yml</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">82</span></span><br></pre></td></tr></table></figure><ol start="3"><li>环境分类配置文件application-dev.yml</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">81</span></span><br></pre></td></tr></table></figure><ol start="4"><li>环境分类配置文件application-dev.yml</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">83</span></span><br></pre></td></tr></table></figure><p>环境的分类多配置文件其实就是在application后加上<code>-环境名称</code>即可</p><ul><li>可以独立配置文件定义环境属性</li><li>独立配置文件便于线上系统维护更新并保障系统安全性</li></ul><h3 id="多环境开发-Properties"><a href="#多环境开发-Properties" class="headerlink" title="多环境开发(Properties)"></a><strong>多环境开发(Properties)</strong></h3><p>步骤与yml版一致 只是由于与yml文件的格式不同导致两者的格式不同 </p><ul><li>但properties版本支支持多文件模式 不支持单一配置文件多环境模式</li></ul><h3 id="多环境分组管理"><a href="#多环境分组管理" class="headerlink" title="多环境分组管理"></a><strong>多环境分组管理</strong></h3><ul><li><p>根据功能对配置文件中的信息进行拆分,并制作成独立的配置文件,命名规则如下(实际开发中)</p><ul><li>applicaiton-devDB.yml</li><li>applicaiton-devRedis.yml</li><li>applicaiton-devMVC.yml</li></ul></li><li><p>使用include属性在激活指定环境的情况下,同时对多个环境进行加载使其生效,多个环境间使用逗号分隔(引入一个环境配置文件组)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">    <span class="attr">include:</span> <span class="string">devDB,devRedis,devMVC</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 当主环境有相同属性时,当主环境生效;其他环境中有相同属性时,最后加载的环境属性生效</p></li></ul><hr><ul><li>从SpringBoot2.4版本开始使用group替代了include属性,降低了配置书写量</li><li>使用group属性定义多种主环境与子环境的包含关系</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">    <span class="attr">group:</span> </span><br><span class="line">      <span class="attr">&quot;dev&quot;:</span> <span class="string">devDB,devRedis,devMVC</span></span><br><span class="line">      <span class="attr">&quot;pro&quot;:</span> <span class="string">proDB,proRedis,proMVC</span></span><br></pre></td></tr></table></figure><p><strong>实际开发中 常使用<code>&quot;group&quot;</code></strong></p><p>多环境开发中使用group属性设置配置文件分组,便于线上维护管理</p><h3 id="多环境开发控制"><a href="#多环境开发控制" class="headerlink" title="多环境开发控制"></a><strong>多环境开发控制</strong></h3><p><strong>SpringBoot在工作时是基于maven坐标运行的</strong></p><ul><li>当Maven与SpringBoot同时对多环境进行控制时,以Maven为主,SpringBoot使用<code>@..@</code>占位符读取Maven对应的配置属性值</li><li>基于SpringBoot读取Maven配置属性的前提下,如果在Idea下测试工程时p吗.xml每次更新需要手动compile或是刷新Maven方可生效</li></ul><ol><li>需要在Maven的pom.xml中配置多环境属性值</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置多环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span><span class="comment">&lt;!--设置获得profile--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span><span class="comment">&lt;!--是否默认生效--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_pro<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>pro<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在SpringBoot配置文件中指定获取Maven中活动的profile</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">@profile.active@</span></span><br></pre></td></tr></table></figure><hr><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a><strong>日志</strong></h3><h4 id="日志基础操作"><a href="#日志基础操作" class="headerlink" title="日志基础操作"></a>日志基础操作</h4><ul><li>日志(log)作用<ul><li>编程期调试diamagnetic</li><li>运营期记录信息<ul><li>记录日常运营重要信息(峰值流量 平均响应时长…..)</li><li>记录应用报错信息(错误堆栈)</li><li>记录运维过程数据(扩容 宕机 报警….)</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/log&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Controller3</span> &#123;</span><br><span class="line">    <span class="comment">//创建记录日志的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(Controller3.class);</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doLog</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;debug...&quot;</span>);</span><br><span class="line">        log.error(<span class="string">&quot;error...&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;infor...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;warn...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SpringBoot2 正在运行....&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="日志级别-从上往下依次升高"><a href="#日志级别-从上往下依次升高" class="headerlink" title="日志级别(从上往下依次升高)"></a>日志级别(从上往下依次升高)</h4><blockquote><ul><li><p><strong>TRACE</strong>：运行堆栈信息，使用率低</p></li><li><p><strong>DEBUG</strong>：程序员调试代码使用</p></li><li><p><strong>INFO</strong>：记录运维过程数据</p></li><li><p><strong>WARN</strong>：记录运维过程报警数据</p></li><li><p><strong>ERROR</strong>：记录错误堆栈信息</p></li><li><p><strong>FATAL</strong>：灾难信息，合并计入ERROR</p></li></ul></blockquote><p><strong>设置日志输出级别 可以在springboot配置文件中设置</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启debug模式，输出调试信息，常用于检查系统运行状况</span></span><br><span class="line"><span class="attr">debug:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 设置日志级别，root表示根节点，即整体应用日志级别</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><p><strong>设置日志组,控制指定包对应的日志输出级别,也可以直接空值指定包对应的日志输出级别</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="comment"># 设置日志组</span></span><br><span class="line">  <span class="attr">group:</span></span><br><span class="line"><span class="comment"># 自定义组名，设置当前组中所包含的包</span></span><br><span class="line">    <span class="attr">ebank:</span> <span class="string">com.itheima.controller</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">warn</span></span><br><span class="line"><span class="comment"># 为对应组设置日志级别</span></span><br><span class="line">    <span class="attr">ebank:</span> <span class="string">debug</span></span><br><span class="line"><span class="comment"># 为对包设置日志级别</span></span><br><span class="line">    <span class="attr">com.itheima.controller:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><h4 id="优化日志对象创建代码"><a href="#优化日志对象创建代码" class="headerlink" title="优化日志对象创建代码"></a>优化日志对象创建代码</h4><ul><li>使用lombok提供的注解**@Slf4j**简化开发,减少日志对象的声明操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/log&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Controller3</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doLog</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;debug...&quot;</span>);</span><br><span class="line">        log.error(<span class="string">&quot;error...&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;infor...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;warn...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SpringBoot2 正在运行....&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="日志输出格式"><a href="#日志输出格式" class="headerlink" title="日志输出格式"></a>日志输出格式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2022-01-26 14:07:21.604  INFO 1416 --- [           main] c.a.d.s.b.a.DruidDataSourceAutoConfigure : Init DruidDataSource</span><br><span class="line">2022-01-26 14:07:21.700  INFO 1416 --- [           main] com.alibaba.druid.pool.DruidDataSource   : &#123;dataSource-1&#125; inited</span><br></pre></td></tr></table></figure><p>上述即为日志的默认结构 分为 <strong>时间 日志级别 PID 所属线程 所属类&#x2F;接口名 日志信息</strong></p><ul><li>PID：进程ID，用于表明当前操作所处的进程，当多服务同时记录日志时，该值可用于协助程序员调试程序</li><li>所属类&#x2F;接口名：当前显示信息为SpringBoot重写后的信息，名称过长时，简化包名书写为首字母，甚至直接删除</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SpringBoot&quot;&gt;&lt;a href=&quot;#SpringBoot&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot&quot;&gt;&lt;/a&gt;SpringBoot&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;SpringBoot 相当于是一个Spring 和 SpringMVC的集成 又在其上增加了其他功能 对其他主流框架的支持也是非常好, 所以SpringBoot更新的非常频繁,需要时常关注它更新的内容&lt;/li&gt;
&lt;li&gt;微服务架构&lt;br&gt; 　Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。&lt;br&gt; 　该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。　　&lt;br&gt; 　通过这种方式，Spring Boot 致力于在蓬勃发展的快速应用开发领域（rapidapplication development）成为领导者。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="spring框架" scheme="https://devildyw.github.io/categories/spring%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="java" scheme="https://devildyw.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="https://devildyw.github.io/2022/02/28/Spring/"/>
    <id>https://devildyw.github.io/2022/02/28/Spring/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-03-06T15:58:25.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>spring全家桶：spring ， springmvc ，spring boot , spring cloud </p><p>  spring: 出现是在2002左右，解决企业开发的难度。减轻对项目模块之间的管理，<br>          类和类之间的管理， 帮助开发人员创建对象，管理对象之间的关系。<br>             spring核心技术 ioc ， aop 。能实现模块之间，类之间的解耦合。</p><span id="more"></span><p><strong>耦合</strong>:是指两个或两个以上的体系或两种运动形式间通过相互作用而彼此影响以至联合起来的现象。</p><p><strong>解耦合</strong>:指将程序的结构变得松散不是固定的而是可变化的 例如接口的实现类是可以更换的 而直接写的类是顶死的 <strong>解耦就是用数学方法将两种运动分离开来处理问题。</strong>程序的解耦合大概就是让代码和程序不绑定不互相依赖</p><p>  依赖：classa中使用classb的属性或者方法， 叫做classa依赖classb</p><hr><p>框架怎么学： 框架是一个软件，其它人写好的软件。<br> 1）知道框架能做什么， mybatis–访问数据库， 对表中的数据执行增删改查。<br> 2）框架的语法， 框架要完成一个功能，需要一定的步骤支持的，<br> 3）框架的内部实现， 框架内部怎么做。 原理是什么。<br> 4）通过学习，可以实现一个框架。</p><h3 id="IOC-反转控制"><a href="#IOC-反转控制" class="headerlink" title="IOC(反转控制)"></a>IOC(反转控制)</h3><p>spring的第一个核心功能 ioc</p><p>IoC (Inversion of Control) : 控制反转， 是一个理论，概念，思想。<br> 描述的：把对象的创建，赋值，管理工作都交给代码之外的容器实现， 也就是对象的创建是有其它外部资源完成。</p><p>控制： 创建对象，对象的属性赋值，对象之间的关系管理。<br>反转： 把原来的开发人员管理，创建对象的权限转移给代码之外的容器实现。 由容器代替开发人员管理对象。创建对象，<br>        给属性赋值。</p><p>正转：由开发人员在代码中，使用new 构造方法创建对象， 开发人员主动管理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">           <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(); <span class="comment">// 在代码中， 创建对象。--正转。</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>容器：是一个服务器软件， 一个框架（spring）</p><p>为什么要使用 ioc ： 目的就是减少对代码的改动， 也能实现不同的功能。 实现解耦合。 </p><p>java中创建对象有哪些方式：</p><ol><li>构造方法 ， new Student（）</li><li>反射</li><li>序列化</li><li>克隆</li><li>ioc ：容器创建对象</li><li>动态代理</li></ol><p>ioc的体现：<br>   servlet  1： 创建类继承HttpServelt<br>             2:  在web.xml 注册servlet ， 使用<servlet-name> myservlet </servlet-name><br>                                                 <servelt-class>com.bjpwernode.controller.MyServlet1</servlet-class></p><pre><code>3. 没有创建 Servlet对象， 没有 MyServlet myservlet = new MyServlet()4. Servlet 是Tomcat服务器它能你创建的。 Tomcat也称为容器 Tomcat作为容器：里面存放的有Servlet对象， Listener ， Filter对象</code></pre><p>IoC的技术实现 ，<br>  DI 是ioc的技术实现，<br>  DI（Dependency Injection） :依赖注入， 只需要在程序中提供要使用的对象名称就可以， 至于对象如何在容器中创建，<br>                              赋值，查找都由容器内部实现。</p><p>spring是使用的di实现了ioc的功能， spring底层创建对象，使用的是<strong>反射机制</strong>。</p><p>spring是一个容器，管理对象，给属性赋值， 底层是反射创建对象。</p><p><strong>几种一般注入</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        声明Student对象</span></span><br><span class="line"><span class="comment">        注入:就是赋值的意思</span></span><br><span class="line"><span class="comment">        简单类型</span></span><br><span class="line"><span class="comment">        di:给属性赋值</span></span><br><span class="line"><span class="comment">        1.set注入(设置注入):spring调用类的set方法;你可以再set方法中完成属性赋值&lt;property&gt;(普通赋值 调用类中写好的set方法)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba01.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span><span class="comment">&lt;!--调用类中的对应的set方法 setName()--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;丁杨维&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    对引用类型进行set设置注入</span></span><br><span class="line"><span class="comment">    引用类型的set注入:spring调用类的set方法</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba01.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;丁杨维&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;school&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mySchool&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mySchool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba02.School&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;成信大&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;四川成都双流区&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        2.构造注入:spring调用类有参构造方法,再创建对象的同时,在构造方法中给属性赋值.</span></span><br><span class="line"><span class="comment">        构造注入使用&lt;constructor-arg&gt;标签</span></span><br><span class="line"><span class="comment">        &lt;constructor-arg&gt;标签:一个&lt;constructor-arg&gt;标签表示构造方法的一个参数</span></span><br><span class="line"><span class="comment">        &lt;constructor-arg&gt;标签属性:</span></span><br><span class="line"><span class="comment">            name:表示构造方法的形参名</span></span><br><span class="line"><span class="comment">            index:表示构造方法的参数的位置.参数从左往右位置是0,1,2</span></span><br><span class="line"><span class="comment">            value:构造方法的形参类型是简单类型,使用value</span></span><br><span class="line"><span class="comment">            ref:构造方法的形参是引用类性,使用ref;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba01.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;丁杨维&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;school&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mySchool&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用index--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba01.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;丁杨维&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mySchool&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mySchool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba02.School&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cuit&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sccd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--省略index 但要按照0,1,2的顺序--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent02&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba01.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>  <span class="attr">value</span>=<span class="string">&quot;阿丁&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>  <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>  <span class="attr">ref</span>=<span class="string">&quot;mySchool&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>引用类型的自动注入</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        引用类型的自动注入:spring框架根据某些规则可以给引用类型赋值.不用我们自己给引用类型赋值了</span></span><br><span class="line"><span class="comment">        使用的规则常用的是byName,byType</span></span><br><span class="line"><span class="comment">        1.byName(按名称注入):java类中的引用类型的属性名和spring容器中(配置文件)&lt;bean&gt;的id一样</span></span><br><span class="line"><span class="comment">        且数据类型是一致的,这样的容器中的bean,spring能够赋值给引用类型.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1.ByName--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba03.Student&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;丁杨维&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;school&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba03.School&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cuit&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sccd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        ByType:按类型注入: java中引用的数据类型和spring容器中(配置文件)&lt;bean&gt;的class=&quot;&quot;中的</span></span><br><span class="line"><span class="comment">                            类是同源关系,这样的bean能够赋值给引用类型</span></span><br><span class="line"><span class="comment">                            同源就是一类的意思:</span></span><br><span class="line"><span class="comment">                            1.java类中引用类型的数据类型和bean的class的值是一样的</span></span><br><span class="line"><span class="comment">                            2.java类中引用类型的数据类型和bean的class的值是父子关系.</span></span><br><span class="line"><span class="comment">                            3.java类中引用类型的数据类型和bean的class的值是接口和实现类的关系.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意bean下是常规的set注入除了引用类型(它是由ByType注入)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--2.ByType--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Student01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba04.Student&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;丁杨维&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mSchool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba04.School&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cuit&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sccd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>spring-conetxt 和 spring-webmvc是spring中的两个模块</p><p>spring-context：是ioc功能的，创建对象的。<br>spring-webmvc做web开发使用的， 是servlet的升级。<br>spring-webmvc中也会用到spring-context中创建对象的功能的。</p><p>junit : 单元测试， 一个工具类库，做测试方法使用的。<br>  单元：指定的是方法， 一个类中有很多方法，一个方法称为单元。</p><p>  使用单元测试<br>   1.需要加入junit依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  2.创建测试作用的类：叫做测试类<br>    src&#x2F;test&#x2F;java目录中创建类</p><p>  3.创建测试方法</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）public 方法</span><br><span class="line"> 2）没有返回值 void </span><br><span class="line"> 3）方法名称自定义，建议名称是test + 你要测试方法名称</span><br><span class="line"> 4）方法没有参数</span><br><span class="line"> 5）方法的上面加入 @Test ,这样的方法是可以单独执行的。 不用使用main方法。</span><br></pre></td></tr></table></figure><hr><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ol><li>多个配置优势<br> 1.每个文件的大小比一个文件要小很多。效率高<br> 2.避免多人竞争带来的冲突。</li></ol><p>  如果你的项目有多个模块（相关的功能在一起） ，一个模块一个配置文件。<br>  学生考勤模块一个配置文件，  张三<br>  学生成绩一个配置文件，      李四</p><p>  多文件的分配方式：</p><ol><li>按功能模块，一个模块一个配置文件</li><li>按类的功能，数据库相关的配置一个文件配置文件， 做事务的功能一个配置文件， 做service功能的一个配置文件等</li></ol><h3 id="基于注解的DI"><a href="#基于注解的DI" class="headerlink" title="基于注解的DI"></a>基于注解的DI</h3><p>2.基于注解的di： 通过注解完成java对象创建，属性赋值。<br>  使用注解的步骤：<br>   1.加入maven的依赖 spring-context ，在你加入spring-context的同时， 间接加入spring-aop的依赖。<br>      使用注解必须使用spring-aop依赖</p><pre><code>2.在类中加入spring的注解（多个不同功能的注解）3.在spring的配置文件中，加入一个组件扫描器的标签，说明注解在你的项目中的位置</code></pre><p>   学习的注解：<br>     1.@Component </p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> 用于创建对象 等同于bean的功能</span><br><span class="line">value里的值就等同于&lt;bean&gt;中的id</span><br><span class="line">value的值应当是唯一的 创建的对象在整个spring容器中就一个</span><br><span class="line"></span><br><span class="line">位置:定义类的上面</span><br><span class="line"><span class="meta">@Component(value = &quot;myStudent&quot;)</span></span><br><span class="line">如果就只有value一个参数也可省略value</span><br><span class="line"><span class="meta">@Component(&quot;myStudent&quot;)</span>    </span><br><span class="line">也可不写(中的内容)spring提供默认名称(类的名称但首字母小写)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">一般用第二种</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> 声明组件扫描器(component-scan),组件指的就是java对象</span></span><br><span class="line"><span class="comment"> base-package:指定注解在你项目中的包名</span></span><br><span class="line"><span class="comment"> component-scan工作方式:spring会扫描遍历vase-package指定的包</span></span><br><span class="line"><span class="comment">     把包中和子包中的所有类遍历,找到类中的注解,按照注解的功能,按照注解的功能创建对象,或给属性赋值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--在配置文件中添加一个组件扫描器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw.Ba01&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--组件扫描器指定多个包的三种方式--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--第一种:使用多次组件扫描器,指定不同的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw.Ba01&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw.Ba02&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--第二种:使用分隔符(;或,)分隔多个包名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw.Ba01;com.dyw.Ba02&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--第三种方式:指定父包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></blockquote><p>​    2.@Respotory</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(用在持久层上的):放在dao实现类的上面</span><br><span class="line">表示创建dao对象,dao对象是可以访问数据库的.</span><br><span class="line">用法于@Component一致,但还有额外功能</span><br></pre></td></tr></table></figure><p>​     3.@Service</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(用在业务层上的):放在service的实现类上面,创建service对象,service对象是做业务处理的,可以有事务功能</span><br><span class="line">用法于@Component一致,但还有额外功能</span><br></pre></td></tr></table></figure><p>​     4.@Controller</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(用在控制器上的):放在控制器(处理器)类的上卖弄,创建控制器对象的,</span><br><span class="line">控制器对象,能够接收用户提交的参数,显示请求的处理结果</span><br><span class="line">用法于@Component一致,但还有额外功能</span><br></pre></td></tr></table></figure><hr><blockquote><p>​    <strong>@Respotory(持久层)  @Service(业务层) @Controller(控制层)用于给项目分层</strong></p></blockquote><p>5.@Value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@value</span>简单类型的属性赋值</span><br><span class="line">      属性: value 是String类型的,表示简单类型的属性值</span><br><span class="line">      位置:<span class="number">1.</span>在属性定义的上面,无需set方法,推荐使用.</span><br><span class="line">          <span class="number">2.</span>在set方法上面</span><br><span class="line">          </span><br><span class="line">    <span class="meta">@Value(value = &quot;20&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="meta">@Value(value = &quot;丁杨维&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;20&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​     6.@Autowired</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>应用类型赋值</span><br><span class="line">   <span class="meta">@Autowired</span>:spring框架提供的注解,实现引用类型的赋值.</span><br><span class="line">   spring中通过注解给引用类型赋值,使用的是自动注入原理,支持byName,byType</span><br><span class="line">   <span class="meta">@Atuowired</span>:默认使用的是byType自动注入</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Autowired</span>默认属性为  require = <span class="literal">true</span> 表示引用类型赋值失败,程序报错,并终止执行</span><br><span class="line">                        require=<span class="literal">false</span>:引用类型如果赋值失败,程序正常执行,引用类型是<span class="literal">null</span>    </span><br><span class="line">       </span><br><span class="line">       位置:<span class="number">1</span>) 在属性定义的上面,无需set方法,推荐使用</span><br><span class="line">            <span class="number">2</span>) 在set方法的上面</span><br><span class="line">           </span><br><span class="line">   如果使用byName方式 需要做的是:</span><br><span class="line">   <span class="number">1.</span>在属性上面加入<span class="meta">@Autowired</span></span><br><span class="line">   <span class="number">2.</span>在属性的上面加入<span class="meta">@Quallifier(value=&quot;bean的id&quot;)</span>:表示使用指定名称的bean完成赋值</span><br><span class="line">   <span class="comment">//byType    </span></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="meta">@Qualifier(value = &quot;school01&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> School school;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">   <span class="comment">//byName    </span></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="meta">@Qualifier(value = &quot;school01&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> School school;</span><br></pre></td></tr></table></figure><p>​     7.@Resource</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">是用之前需要再pom.xml中添加j2ee依赖</span><br><span class="line"><span class="meta">@Resource</span>赋值引用类型: 来自jdk中的注解,spring框架提供了对这个注解的功能的支持,可以使用它给引用类型赋值</span><br><span class="line">     *             使用的也是自动注入原理,支持byName,byType,默认是byName</span><br><span class="line">     * 位置: <span class="number">1</span>)在属性定义的上面,无需set方法,推荐使用</span><br><span class="line">     *       <span class="number">2</span>)在set方法的上面</span><br><span class="line">     *</span><br><span class="line">     * 默认是byName: 先使用byName自动注入,如果byName注入失败,再使用byType</span><br><span class="line">     * 不写(name = <span class="string">&quot;&quot;</span>)是默认属性名 写上就可以指定名称</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">    <span class="meta">@Resource(name = &quot;school03&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> School school;</span><br></pre></td></tr></table></figure><h4 id="其他注解"><a href="#其他注解" class="headerlink" title="其他注解"></a>其他注解</h4><p><strong>注解可以通过与配置文件结合的方式解耦合</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">name=丁杨维</span><br><span class="line">age=20</span><br><span class="line"><span class="comment">&lt;!--anno.properites--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw.Ba07&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--将配置文件路劲导入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:anno.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--然后便可再java文件中使用$&#123;&#125;加注解的方式赋值--&gt;</span></span><br><span class="line">public class Student &#123;</span><br><span class="line">    @Value(&quot;$&#123;age&#125;&quot;)</span><br><span class="line">    private int age;</span><br><span class="line">    @Value(&quot;$&#123;name&#125;&quot;)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">但是@Component好像不能使用这个方式赋值 会报错</span><br></pre></td></tr></table></figure><p>用户处理请求：<br>   用户form ,参数name ，age—–Servlet(接收请求name，age)—Service类（处理name，age操作）—dao类（访问数据库的）—mysql</p><hr><h2 id="aop"><a href="#aop" class="headerlink" title="aop"></a><strong>aop</strong></h2><p>1.动态代理<br>  实现方式：jdk动态代理，使用jdk中的Proxy，Method，InvocaitonHanderl创建代理对象。<br>             jdk动态代理要求目标类必须实现接口</p><p>  cglib动态代理：第三方的工具库，创建代理对象，原理是继承。 通过继承目标类，创建子类。<br>             子类就是代理对象。 要求目标类不能是final的， 方法也不能是final的</p><p>2.动态代理的作用：<br>   1）在目标类源代码不改变的情况下，增加功能。<br>    2）减少代码的重复<br>    3）专注业务逻辑代码<br>    4）解耦合，让你的业务功能和日志，事务非业务功能分离。</p><p>3.Aop:面向切面编程， 基于动态代理的，可以使用jdk，cglib两种代理方式。<br>  Aop就是动态代理的规范化， 把动态代理的实现步骤，方式都定义好了，<br>  让开发人员用一种统一的方式，使用动态代理。</p><ol start="4"><li>AOP（Aspect Orient Programming）面向切面编程<br> Aspect: 切面，给你的目标类增加的功能，就是切面。 像上面用的日志，事务都是切面。<br>   切面的特点： 一般都是非业务方法，独立使用的。<br> Orient：面向， 对着。<br> Programming：编程</li></ol><p>  oop: 面向对象编程</p><p>  怎么理解面向切面编程 ？<br>   1）需要在分析项目功能时，找出切面。<br>    2）合理的安排切面的执行时间（在目标方法前， 还是目标方法后）<br>    3）合理的安全切面执行的位置，在哪个类，哪个方法增加增强功能</p><p>  术语：<br>   1）Aspect:切面，表示增强的功能， 就是一堆代码，完成某个一个功能。非业务功能，<br>              常见的切面功能有日志， 事务， 统计信息， 参数检查， 权限验证。</p><p>   2）JoinPoint:连接点 ，连接业务方法和切面的位置。 就某类中的业务方法,一个类中的每一个方法都是连接点<br>    3）Pointcut : 切入点 ，对连接点的筛选,筛选出需要增强功能的方法<br>    4）目标对象： 给哪个类的方法增加功能， 这个类就是目标对象<br>    5）Advice:通知，通知表示切面功能执行的时间。</p><pre><code>说一个切面有三个关键的要素：1）切面的功能代码，切面干什么2）切面的执行位置，使用Pointcut表示切面执行的位置3）切面的执行时间，使用Advice表示时间，在目标方法之前，还是目标方法之后。</code></pre><p> 5.aop的实现<br>   aop是一个规范，是动态的一个规范化，一个标准<br>    aop的技术实现框架：<br>    1.spring：spring在内部实现了aop规范，能做aop的工作。<br>              spring主要在事务处理时使用aop。<br>                 我们项目开发中很少使用spring的aop实现。 因为spring的aop比较笨重。</p><p>   2.aspectJ: 一个开源的专门做aop的框架。spring框架中集成了aspectj框架，通过spring就能使用aspectj的功能。<br>      aspectJ框架实现aop有两种方式：<br>       1.使用xml的配置文件 ： 配置全局事务<br>        2.使用注解，我们在项目中要做aop功能，一般都使用注解， aspectj有5个注解。</p><p> 6.学习aspectj框架的使用。<br>   1）切面的执行时间， 这个执行时间在规范中叫做Advice(通知，增强)<br>       在aspectj框架中使用注解表示的。也可以使用xml配置文件中的标签</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>:是aspectj框架中的注解</span><br><span class="line">      作用:表示当前类是切面类</span><br><span class="line">      切面类:是用来给业务方法增加功能的类,在这个类中有切面的功能代码</span><br><span class="line">      位置:在类定义的上面</span><br><span class="line">切面类中的方法:</span><br><span class="line">定义方法:实现切面功能的</span><br><span class="line"> 方法的定义要求:</span><br><span class="line">      <span class="number">1.</span>公共方法 <span class="keyword">public</span></span><br><span class="line">      <span class="number">2.</span>方法没有返回值</span><br><span class="line">      <span class="number">3.</span>方法的名称自定义</span><br><span class="line">      <span class="number">4.</span>方法可以有参数,也可以没有参数</span><br><span class="line">           如果有参数,参数不是自定义的,有几个参数类型可以使用</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">     指定通知方法中的参数:JoinPoint</span><br><span class="line">     * JoinPoint:业务方法,要加入切面功能的业务方法</span><br><span class="line">     *      作用是:可以在通知方法中获取方法执行的信息,例如方法的名称,方法的实参.</span><br><span class="line">     *      如果你的切面功能中需要用到方法的信息,就加入JoinPoint.</span><br><span class="line">     *      这个JoinPoint参数的值是由框架赋予的,必须是第一个位置的参数,否装上述功能都没有 程序还会报错</span><br></pre></td></tr></table></figure><p>​        1）@Before</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>:表示前置通知</span><br><span class="line">     *      属性:value,是切入点表达式,表示切面的功能执行的位置.</span><br><span class="line">     *      位置:在方法的上面</span><br><span class="line">     *特点:  <span class="number">1.</span>在目标方法之前先执行</span><br><span class="line">     *       <span class="number">2.</span>不会改变目标方法的执行结果</span><br><span class="line">     *       <span class="number">3.</span>不会影响目标方法的执行.</span><br><span class="line">     *      execution(<span class="keyword">public</span> <span class="keyword">void</span> com.dyw.ba01.SomeServiceImpl.doSome(String,Integer)表示切入的位置</span><br></pre></td></tr></table></figure><p>​        2）@AfterReturning</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">* 后置通知定义方法,方法是实现切面功能的.</span><br><span class="line">     * 方法定义要求</span><br><span class="line">     * <span class="number">1.</span>公共方法<span class="keyword">public</span></span><br><span class="line">     * <span class="number">2.</span>方法没有返回值</span><br><span class="line">     * <span class="number">3.</span>方法名称自定义</span><br><span class="line">     * <span class="number">4.</span>方法有参数的,推荐Object,参数名自定义</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="meta">@AfterReturning</span>:后置通知</span><br><span class="line">     *      属性:<span class="number">1.</span>value 切入点表达式</span><br><span class="line">     *          <span class="number">2.</span>returning 自定义变量,表示方法的返回值的.</span><br><span class="line">     *          自定义变量名必须和通知方法的形参一样</span><br><span class="line">     *  .    位置:在方法定义的上面</span><br><span class="line">     * 特点:</span><br><span class="line">     * <span class="number">1</span>在目标方法之后生效</span><br><span class="line">     * <span class="number">2.</span>能够获取到目标方法的返回值,可以根据这个返回值做不同的处理功能</span><br><span class="line">     * <span class="number">3.</span>可以修改返回值</span><br><span class="line">     *</span><br><span class="line">     *</span><br><span class="line">     * 后置通知的执行</span><br><span class="line">     *      <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> doOther();</span><br><span class="line">     *      myAfterReturning(res);</span><br><span class="line">     *      System.out.println(res);     </span><br></pre></td></tr></table></figure><p>​        3）@Around</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> * 环绕通知方法的定义格式</span><br><span class="line"> * <span class="number">1.</span><span class="keyword">public</span></span><br><span class="line"> * <span class="number">2.</span>必须要有一个返回值,推荐使用Object</span><br><span class="line"> * <span class="number">3.</span>方法名称自定义</span><br><span class="line"> * <span class="number">4.</span>方法有参数,固定的参数ProceedingJoinPoint</span><br><span class="line"></span><br><span class="line"><span class="meta">@Around</span>: 环绕通知</span><br><span class="line">    属性:value 切入点表达式</span><br><span class="line">    位置:在方法的定义上面</span><br><span class="line">特点:</span><br><span class="line"> <span class="number">1.</span>他是功能最强的通知</span><br><span class="line"> <span class="number">2.</span>在目标方法的前和后都能被调用执行</span><br><span class="line"> <span class="number">3.</span>控制目标方法是否被调用执行</span><br><span class="line"> <span class="number">4.</span>修改原来的目标方法的执行结果.影响最后调用的结果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 环绕通知.等同于jdk动态代理的InvocationHandler接口</span><br><span class="line"></span><br><span class="line"> 参数: ProceedingJoinPoint就等同于jdk动态代理的Method</span><br><span class="line">     作用:执行目标方法的</span><br><span class="line"> 返回值:就是目标方法的执行结果,可以被修改</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      ProceedingJoinPoint是继承了JoinPoint 所以它具有JoinPoint的特性</span><br><span class="line"></span><br><span class="line"> 环绕通知:经常做事务,在目标方法之前开启事务,执行目标方法,在目标方法之后提交事务</span><br><span class="line"><span class="meta">@param</span> proceedingJoinPoint</span><br><span class="line"><span class="meta">@return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        4）@AfterThrowing <strong>异常通知</strong><br>​        5）@After <strong>后置通知</strong></p><p><strong>@Pointcut用于指定切入点的别名</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(value = &quot;myPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myBefore01</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Pointcut</span>:定义和管理切入点,如果你的项目中有多个切入点表达式是重复的,可以复用.</span></span><br><span class="line"><span class="comment">     *              可以使用<span class="doctag">@Pointcut</span></span></span><br><span class="line"><span class="comment">     *           属性:value 切入点表达式</span></span><br><span class="line"><span class="comment">     *           位置:自定义方法的上面</span></span><br><span class="line"><span class="comment">     *      特点:</span></span><br><span class="line"><span class="comment">     *          当使用<span class="doctag">@Pointcut</span>定义在一个方法的上面,此时这方法的名称就是切入点表达式的别名.</span></span><br><span class="line"><span class="comment">     *          当其他的通知中,value属性就可以使用这个方法的名称,代替切入点表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;execution(* *..SomeService.doSome(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myPointcut</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//无需代码 只是用该方法名代替切入点表达式</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>   2）表示切面执行的位置，使用的是切入点表达式。</p><pre><code>    com.service.impl    com.bjpowrnode.service.impl    cn.crm.bjpowernode.service  execution(* *..service.*.*(..))</code></pre><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">readme</span></span><br><span class="line"><span class="code">用aspectj框架实现aop</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"></span><br><span class="line">使用aop的目的是给已经存在的一些了业务方法,增加额外的功能,前提是不会更改原来类中的方法</span><br><span class="line"></span><br><span class="line"><span class="section">###使用aspectj实现aop的基本步骤</span></span><br><span class="line"><span class="section">####1.新建maven项目</span></span><br><span class="line"><span class="section">####2.加入依赖</span></span><br><span class="line"><span class="bullet"> 1.</span> spring依赖</span><br><span class="line"><span class="bullet"> 2.</span> aspectj依赖</span><br><span class="line"><span class="bullet"> 3.</span> junit单元测试</span><br><span class="line"><span class="section">####3.创建目标类:接口和他的实现类</span></span><br><span class="line"></span><br><span class="line"><span class="section">####4.创建切面类:普通类</span></span><br><span class="line"><span class="bullet"> 1.</span> 在类上面加入注解@Aspect</span><br><span class="line"><span class="bullet"> 2.</span> 在类中定义方法,方法就是切面要执行的功能代码</span><br><span class="line"><span class="code">    在方法上面加入aspectj中的通知注解,例如@Before</span></span><br><span class="line"><span class="code">    有需要指定切入点表达式execution()</span></span><br><span class="line"><span class="code"> </span></span><br><span class="line"><span class="code">####5.创建spring配置文件:声明对象,把对象交给容器去统一管理声明对象你可以使用注解或xml配置文件&lt;bean&gt;</span></span><br><span class="line"><span class="code">1. 声明目标对象</span></span><br><span class="line"><span class="code">2. 声明切面类对象</span></span><br><span class="line"><span class="code">3. 声明aspectj框架中的自动代理生成器标签.</span></span><br><span class="line"><span class="code">    自动代理生成器:用来完成代理对象的自动创建功能的.</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section">####6.创建测试类,从spring容器中获取目标对象(实际就是代理对象).通过代理执行方法,实现aop的功能</span></span><br></pre></td></tr></table></figure><hr><h3 id="mybatis框架和spring集成"><a href="#mybatis框架和spring集成" class="headerlink" title="mybatis框架和spring集成"></a>mybatis框架和spring集成</h3><p>第四章： 把mybatis框架和spring集成在一起，像一个框架一样使用。</p><p>用的技术是：ioc 。<br>为什么ioc：能把mybatis和spring集成在一起，像一个框架， 是因为ioc能创建对象。<br> 可以把mybatis框架中的对象交给spring统一创建， 开发人员从spring中获取对象。<br> 开发人员就不用同时面对两个或多个框架了， 就面对一个spring</p><p>mybatis使用步骤，对象<br>1.定义dao接口 ，StudentDao<br>2.定义mapper文件 StudentDao.xml<br>3.定义mybatis的主配置文件 mybatis.xml<br>4.创建dao的代理对象， StudentDao dao &#x3D; SqlSession.getMapper(StudentDao.class);</p><p>   List<Student> students  &#x3D; dao.selectStudents();</p><p>要使用dao对象，需要使用getMapper()方法，<br>怎么能使用getMapper()方法，需要哪些条件<br>1.获取SqlSession对象， 需要使用SqlSessionFactory的openSession()方法。<br>2.创建SqlSessionFactory对象。 通过读取mybatis的主配置文件，能创建SqlSessionFactory对象</p><p>需要SqlSessionFactory对象， 使用Factory能获取SqlSession ，有了SqlSession就能有dao ， 目的就是获取dao对象<br>Factory创建需要读取主配置文件</p><p>我们会使用独立的连接池类替换mybatis默认自己带的， 把连接池类也交给spring创建。</p><p>主配置文件：<br> 1.数据库信息<br> <environment id="mydev"><br>            <transactionManager type="JDBC"/><br>            <dataSource type="POOLED"><br>                <!--数据库的驱动类名--><br>                <property name="driver" value="com.mysql.jdbc.Driver"/><br>                <!--连接数据库的url字符串--><br>                <property name="url" value="jdbc:mysql://localhost:3306/springdb"/><br>                <!--访问数据库的用户名--><br>                <property name="username" value="root"/><br>                <!--密码--><br>                <property name="password" value="123456"/><br>            </dataSource></p><ol start="2"><li>mapper文件的位置<mappers>     <mapper resource="com/bjpowernode/dao/StudentDao.xml"/>     <!--<mapper resource="com/bjpowernode/dao/SchoolDao.xml" />--> </mappers></li></ol><hr><p>通过以上的说明，我们需要让spring创建以下对象<br>1.独立的连接池类的对象， 使用阿里的druid连接池 一般我么只需要配置url,user,password,maxActive(最大连接数);</p><p>2.SqlSessionFactory对象</p><p>3.创建出dao对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--DruidDataSource大部分属性都是参考DBCP的，如果你原来就是使用DBCP，迁移是十分方便的。--&gt;</span></span><br><span class="line">init-method 这里xml配置文件指定init是为了druid连接池启动时自动执行 destroy-method也是指销毁数据库连接池会制动执行close</span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc_url&#125;&quot;</span> /&gt;</span><span class="comment">&lt;!--可以使用properties文件指定jdbc的url等内容 然后加载 最后使用注解来解耦合或是隐藏敏感信息--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc_user&#125;&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc_password&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;filters&quot;</span> <span class="attr">value</span>=<span class="string">&quot;stat&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWait&quot;</span> <span class="attr">value</span>=<span class="string">&quot;6000&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;60000&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;300000&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnReturn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;poolPreparedStatements&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxOpenPreparedStatements&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;asyncInit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在上面的配置中，通常你需要配置url、username、password，maxActive这三项。</span></span><br><span class="line"><span class="comment">Druid会自动跟url识别驱动类名，如果连接的数据库非常见数据库，配置属性driverClassName</span></span><br><span class="line"><span class="comment">asyncInit是1.1.4中新增加的配置，如果有initialSize数量较多时，打开会加快应用启动时间--&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">                                            mybatis.xml</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置日志--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--设置别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--实体类所在的包名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.dyw.domain&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--name:是包名,是这个包中所有的mapper.xml一次都能加载--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.dyw.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">applicationContext.xml</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"> 0.使用了properties文件 加载</span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    1.声明数据源 这里用到了上面的druid数据库的spring<span class="tag">&lt;<span class="name">bean</span>&gt;</span>配置</span><br><span class="line">    <span class="comment">&lt;!--声明数据源DataSource ,作用是使用数据库的 这里声明的是DruidDataSource--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.root&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    2.声明SqlSessionFactoryBean(spring-mybatis集成中的类 通过这个工厂类可以创建SqlSessionFactory对象)</span><br><span class="line">    主要是指定数据源 因为mybatis.xml中我们是没有指定的 并且需要将mybatis.xml加载 将配置信息导入里面指定的mapper文件和domian类</span><br><span class="line">    <span class="comment">&lt;!--声明的是mybatis中提供的SqlSessionFactoryBean类,这个类内部创建SqlSessionFactory对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--set注入,把数据库的值付给了dataSource属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis主配置文件的位置</span></span><br><span class="line"><span class="comment">            configLocation属性是Resource类型,读取配置文件</span></span><br><span class="line"><span class="comment">            他的赋值,使用value,指定文件的路径,使用classpath:表示文件的位置</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    3.获取了SqlSessionFactory对象后 需要通过他生成的sqlSession对象 再调用getMapper(Dao.class)方法获取到dao接口的代理对象 让其放入到spring容器中管理</span><br><span class="line">    <span class="comment">&lt;!--创建dao对象,使用sqlSession的getMapper(StudentDao.class)</span></span><br><span class="line"><span class="comment">            MapperScannerConfigurer:在内部调用getMapper()生成每个dao接口的代理对象.</span></span><br><span class="line"><span class="comment">            不用指定id</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指定SqlSessionFactory对象的id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            指定包名,包名是dao接口所在的包名.</span></span><br><span class="line"><span class="comment">            MapperScannerConfigurer会扫描这个包中的所有接口,把每个接口都执行一次getMapper方法,得到每个接口的dao对象.</span></span><br><span class="line"><span class="comment">            创建好了的dao对象放入到spring的容器中的. 创建好的dao对象的名称时接口的首字母小写</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--简单复习 如果赋值时对象内的属性为简单类型 是使用value赋值 如果时引用对象则是ref--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--之所以扫描dao接口的包 是为了获得dao.class调用getMapper(Dao.class)方法创建dao接口的代理对象--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.dyw.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    4.创建业务类(有业务方法)的对象</span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.service.studentServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;studentDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;studentDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要学习就是上面三个对象的创建语法，使用xml的bean标签。</p><p>连接池：多个连接Connection对象的集合， List<Connection>  connlist : connList就是连接池</p><p>通常使用Connection访问数据库<br>Connection conn &#x3D;DriverManger.getConnection(url,username,password);<br>Statemenet stmt &#x3D; conn.createStatement(sql);<br>stmt.executeQuery();<br>conn.close();</p><p>使用连接池<br>在程序启动的时候，先创建一些Connection<br>Connection c1 &#x3D; …<br>Connection c2 &#x3D; …<br>Connection c3 &#x3D; …<br>List<Connection>  connlist &#x3D; new ArrayLits();<br>connList.add(c1);<br>connList.add(c2);<br>connList.add(c3);</p><p>Connection conn &#x3D; connList.get(0);<br>Statemenet stmt &#x3D; conn.createStatement(sql);<br>stmt.executeQuery();<br>把使用过的connection放回到连接池<br>connList.add(conn);</p><p>Connection conn1 &#x3D; connList.get(1);<br>Statemenet stmt &#x3D; conn1.createStatement(sql);<br>stmt.executeQuery();<br>把使用过的connection放回到连接池<br>connList.add(conn1);</p><hr><h2 id="spring的事务处理"><a href="#spring的事务处理" class="headerlink" title="spring的事务处理"></a>spring的事务处理</h2><h3 id="事务的基本要素-4大性质"><a href="#事务的基本要素-4大性质" class="headerlink" title="事务的基本要素 4大性质"></a><strong>事务的基本要素 4大性质</strong></h3><blockquote><ol><li>原子性:事务开始后的所有操作,要么全部成功,要么全部失败回滚,不可能停滞在中间环节.事务执行过程中出错,会回滚到事务开始之前的状态,所有操作就像没有发生一样.也就是说事务是一个不可分割的整体,就像化学中学过的原子,是事务构成的基本单位.</li><li>一致性:事务开始前和结束后,数据库的完整性约束没有被破坏,如A向B转张,不可能出现A扣了钱而B却没有加的情况</li><li>隔离性:同一时间,只允许一个事务请求同一数据,不同事务之间彼此没有任何干扰,如A正在从一张银行卡中取钱,在A取钱的过程结束前,B不能向这张卡转账.</li><li>持久性:事务完成之后,事务对数据库更新将会被保存写在数据库上,不能回滚.</li></ol></blockquote><p>回答问题<br>1.什么是事务<br>  讲mysql的时候，提出了事务。 事务是指一组sql语句的集合， 集合中有多条sql语句<br>  可能是insert ， update ，select ，delete， 我们希望这些多个sql语句都能成功，<br>  或者都失败， 这些sql语句的执行是一致的，作为一个整体执行。</p><p>2.在什么时候想到使用事务<br>  当我的操作，涉及得到多个表，或者是多个sql语句的insert，update，delete。需要保证<br>  这些语句都是成功才能完成我的功能，或者都失败，保证操作是符合要求的。</p><p>  在java代码中写程序，控制事务，此时事务应该放在那里呢？<br>     service类的业务方法上，因为业务方法会调用多个dao方法，执行多个sql语句</p><p>3.通常使用JDBC访问数据库， 还是mybatis访问数据库怎么处理事务<br>   jdbc访问数据库，处理事务  Connection conn ; conn.commit(); conn.rollback();<br>    mybatis访问数据库，处理事务， SqlSession.commit();  SqlSession.rollback();<br>    hibernate访问数据库，处理事务， Session.commit(); Session.rollback();</p><p>4.3问题中事务的处理方式，有什么不足<br>  1)不同的数据库访问技术，处理事务的对象，方法不同，<br>    需要了解不同数据库访问技术使用事务的原理<br>  2)掌握多种数据库中事务的处理逻辑。什么时候提交事务，什么时候回顾事务<br>  3)处理事务的多种方法。</p><p>  总结： 就是多种数据库的访问技术，有不同的事务处理的机制，对象，方法。</p><p>5.怎么解决不足<br>  spring提供一种处理事务的统一模型， 能使用统一步骤，方式完成多种不同数据库访问技术的事务处理。</p><p>  使用spring的事务处理机制，可以完成mybatis访问数据库的事务处理<br>  使用spring的事务处理机制，可以完成hibernate访问数据库的事务处理。</p><h3 id="spring事务的属性"><a href="#spring事务的属性" class="headerlink" title="spring事务的属性"></a><strong>spring事务的属性</strong></h3><p>Spring事务属性对应TransactionDefinition类里面的各个方法。TransactionDefinition类方法如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionDefinition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回事务传播行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getPropagationBehavior</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getIsolationLevel</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务超时时间，事务必须在多少秒之内完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getTimeout</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isReadOnly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。事务属性包含了5个方面：传播行为、隔离规则、回滚规则、事务超时、是否只读。</strong></p><p>6.处理事务，需要怎么做，做什么<br>  spring处理事务的模型，使用的步骤都是固定的。把事务使用的信息提供给spring就可以了</p><p>  1）事务内部提交，回滚事务，使用的事务管理器对象，代替你完成commit，rollback<br>     事务管理器是一个接口和他的众多实现类。<br>      接口：PlatformTransactionManager ，定义了事务重要方法 commit ，rollback<br>      实现类：spring把每一种数据库访问技术对应的事务处理类都创建好了。<br>               mybatis访问数据库—spring创建好的是DataSourceTransactionManager<br>                  hibernate访问数据库—-spring创建的是HibernateTransactionManager</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">怎么使用：你需要告诉spring 你用是那种数据库的访问技术，怎么告诉spring呢？</span><br><span class="line"> 声明数据库访问技术对于的事务管理器实现类， 在spring的配置文件中使用<span class="tag">&lt;<span class="name">bean</span>&gt;</span>声明就可以了</span><br><span class="line"> 例如，你要使用mybatis访问数据库，你应该在xml配置文件中</span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“xxx</span>&quot; <span class="attr">class</span>=<span class="string">&quot;...DataSourceTransactionManager&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure><h4 id="Spring事务的隔离级别"><a href="#Spring事务的隔离级别" class="headerlink" title="Spring事务的隔离级别"></a>Spring事务的隔离级别</h4><p>你的业务方法需要什么样的事务，说明需要事务的类型。<br>     说明方法需要的事务：<br>        1）事务的隔离级别：有4个值。<br>        ➢<strong>DEFAULT：采用 DB 默认的事务隔离级别。</strong>MySql 的默认为 REPEATABLE_READ； Oracle默认为 READ_COMMITTED。<br>        ➢ <strong>READ_UNCOMMITTED</strong>：<strong>读未提交</strong>(A事务在执行过程中,读到了B事务修改但未提交的数据,可能会发生B事务未修改回滚但被A事务读取到的情况,出现了<strong>脏读</strong>)。未解决任何并发问题。<br>        ➢ <strong>READ_COMMITTED：读已提交</strong>。解决脏读，存在不可重复读与幻读。<br>        ➢ <strong>REPEATABLE_READ：可重复读</strong>。解决脏读、不可重复读，存在幻读<br>        ➢ <strong>SERIALIZABLE：串行化</strong>(事务A执行完毕后才执行B事务)。不存在并发问题。</p><blockquote><p> <strong>ISOLATION_SERIALIZABLE(串行化)</strong> 隔离规则类型在开发中很少用到。举个很简单的例子。咱们使用了ISOLATION_SERIALIZABLE规则。A,B两个事务操作同一个数据表并发过来了。A先执行。A事务这个时候会把表给锁住，B事务执行的时候直接报错。</p><ol><li><p>事务隔离级别为**ISOLATION_READ_UNCOMMITTED(读未提交)**时，写数据只会锁住相应的行。</p></li><li><p>事务隔离级别为可**ISOLATION_REPEATABLE_READ(可重复读)**时，如果检索条件有索引(包括主键索引)的时候，默认加锁方式是next-key锁；如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。</p></li><li><p>事务隔离级别为**ISOLATION_SERIALIZABLE(串行化)**时，读写数据都会锁住整张表。</p></li><li><p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能(隔离级别越高 执行的时间越长)的影响也就越大。</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">2</span>) 事务的超时时间： 表示一个方法最长的执行时间，如果方法执行时超过了时间，事务就回滚。</span><br><span class="line">  单位是秒， 整数值， 默认是 -<span class="number">1.</span> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   为了使应用程序很好地运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，也会占用数据库资源。事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>) 事务是否只读:isReadOnly() : <span class="type">boolean</span> <span class="title function_">isReadOnlu</span><span class="params">()</span> <span class="literal">true</span>表示是只读,<span class="literal">false</span>表示非只读</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">如果在一个事务中所有关于数据库的操作都是只读的，也就是说，这些操作只读取数据库中的数据，而并不更新数据,　这个时候我们应该给该事务设置只读属性，这样可以帮助数据库引擎优化事务。提升效率。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>事务的传播行为:</strong> 控制业务方法是不是有事务的， 是什么样的事务的。<br>    7个传播行为，表示你的业务方法调用时，事务在方法之间是如果使用的.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**当前事务传播行为是REQUIRED时,如果存在一个事务那么直接使用当前事务,如果没有事务,那么就创建一个事务,如:单独MethodB时上下文没有事务,执行时会创建一个新的事务;如果MethodA方法中上下文存在事务,在A中调用B时B会发现上下文中存在事务,MethodB就不会创建一个新的事务,而是直接加入到A的事务中*/</span></span><br><span class="line">PROPAGATION_REQUIRED</span><br><span class="line">        </span><br><span class="line"><span class="comment">/** 需要使用 JtaTransactionManager作为事务管理器。 </span></span><br><span class="line"><span class="comment">上下文没有事务,它会开启一个新的事务。如果一个事务已经存在，则先将这个存在的事务挂起。*/</span></span><br><span class="line">PROPAGATION_REQUIRES_NEW</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/** 如果存在事务,支持当前事务,如果没有事务,则非事务的执行.但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。 */</span></span><br><span class="line">PROPAGATION_SUPPORTS</span><br><span class="line">以上三个需要掌握的</span><br><span class="line"><span class="comment">/** 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。即必须有事务,没有一个事务就抛出异常*/</span></span><br><span class="line">PROPAGATION_MANDATORY</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 如果一个活动的事务存在，则运行在一个嵌套的事务中。 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行。 */</span>   </span><br><span class="line">PROPAGATION_NESTED</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/** 总是非事务地执行，如果存在一个活动事务，则抛出异常。*/</span>  </span><br><span class="line">PROPAGATION_NEVER</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/** 总是非事务地执行，并挂起任何存在的事务。使用PROPAGATION_NOT_SUPPORTED,也需要使用JtaTransactionManager作为事务管理器。 */</span>  </span><br><span class="line">PROPAGATION_NOT_SUPPORTED  </span><br></pre></td></tr></table></figure><p>​    <a href="https://blog.csdn.net/weixin_39625809/article/details/80707695">PROPAGATION_NESTED 与PROPAGATION_REQUIRES_NEW的区别:</a></p><p>​    </p><ol start="4"><li><strong>事务提交事务，回滚事务的时机</strong><br> 1）当你的业务方法，执行成功，没有异常抛出，当方法执行完毕，spring在方法执行后提交事务。事务管理器commit</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">2</span>）(默认情况下)当你的业务方法抛出运行时异常或<span class="title function_">ERROR</span>(即未受查异常)， spring执行回滚，调用事务管理器的rollback</span><br><span class="line">     运行时异常的定义： <span class="title class_">RuntimeException</span>  和他的子类都是运行时异常， 例如<span class="title class_">NullPointException</span> , <span class="title class_">NumberFormatException</span></span><br><span class="line">  </span><br><span class="line">  <span class="number">3</span>) 当你的业务方法抛出非运行时异常， 主要是受查异常时，提交事务</span><br><span class="line">    受查异常：在你写代码中，必须处理的异常。例如<span class="title class_">IOException</span>, <span class="title class_">SQLException</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">注意:你可以声明事务遇到特定的受查异常时像遇到运行时异常那样回滚,同样,你还可以声明事务遇到特定的异常不回滚,即使这些异常是运行时异常.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>总结spring的事务<br>  1.管理事务的是 事务管理和他的实现类<br>  2.spring的事务是一个统一模型<br>     1）指定要使用的事务管理器实现类，使用<bean></bean>spring容器创建管理对象<br>      2）指定哪些类，哪些方法需要加入事务的功能<br>      3）指定方法需要的隔离级别，传播行为，超时</p><pre><code>  你需要告诉spring，你的项目中类信息，方法的名称，方法的事务传播行为。</code></pre><p>spring框架中提供的事务处理方案<br>1.适合中小项目使用的， 注解方案。<br>  spring框架自己用<strong>aop</strong>(aspectj框架的 @Around 环绕依赖)实现给业务方法增加事务的功能， 使用**@Transactional注解**增加事务。<br>  @Transactional注解是spring框架自己注解，放在public方法的上面，表示当前方法具有事务。<br>  可以给注解的属性赋值，表示具体的隔离级别，传播行为，异常信息等等</p><p>  使用@Transactional的步骤：<br>  1.需要声明事务管理器对象<br>    <bean id="xx" class="DataSourceTransactionManager"></p><hr><h3 id="Transactional注解"><a href="#Transactional注解" class="headerlink" title="@Transactional注解"></a><strong>@Transactional注解</strong></h3><h4 id="1-Transactional介绍"><a href="#1-Transactional介绍" class="headerlink" title="1. @Transactional介绍"></a>1. @Transactional介绍</h4><ol><li>@Transactional注解 <strong>可以作用于接口、接口方法、类以及类方法上。</strong>当作用于类上时，该类的所有 <strong>public 方法</strong>将都具有该类型的事务属性，同时，<strong>我们也可以在方法级别使用该标注来<em>覆盖</em>类级别的定义。</strong></li><li>虽然@Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， @Transactional注解应该<strong>只被应用到 public 方法上</strong>，这是由<strong>Spring AOP的本质决定的</strong>。如果你在 <strong>protected、private 或者默认可见性</strong>的方法上使用 @Transactional 注解，<strong>这将被忽略，也不会抛出任何异常。</strong></li><li><strong>默认情况下，只有来自外部的方法调用才会被AOP代理捕获</strong>，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰。</li></ol><h4 id="2-Transactional注解属性"><a href="#2-Transactional注解属性" class="headerlink" title="2. @Transactional注解属性"></a>2. @Transactional注解属性</h4><ol><li>@Transactional注解里面的各个属性和咱们在上面讲的事务属性里面是一一对应的。用来设置<strong>事务的传播行为、隔离规则、回滚规则、事务超时、是否只读</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transactional &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。myBatis是DataSourceTransactionManager 事务管理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;transactionManager&quot;)</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同上。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    String <span class="title function_">transactionManager</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务的传播行为，默认值为 REQUIRED。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Propagation <span class="title function_">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务的隔离规则，默认值采用 DEFAULT mysql中是可重复读。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Isolation <span class="title function_">isolation</span><span class="params">()</span> <span class="keyword">default</span> Isolation.DEFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务超时时间。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">timeout</span><span class="params">()</span> <span class="keyword">default</span> TransactionDefinition.TIMEOUT_DEFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否只读事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">readOnly</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于指定能够触发事务回滚的异常类型 Class对象的数组。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同上，指定类名 这个String类型的数组。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] rollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于指定不会触发事务回滚的异常类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;[] noRollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同上，指定类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] noRollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>value、transactionManager属性</li></ol><p>​    它们两个是一样的意思。当配置了多个事务管理器时，可以使用该属性指定选择哪个事务管理器。大多数项目只需要一个事务管理器。然而，有些项目为了提高效率、或者有多个完全不同又不相干的数据源，从而使用了多个事务管理器。机智的Spring的Transactional管理已经考虑到了这一点，首先定义多个transactional manager，并为qualifier属性指定不同的值；然后在需要使用@Transactional注解的时候指定TransactionManager的qualifier属性值或者直接使用bean名称。配置和代码使用的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;datasource1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">&quot;datasource1Tx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;datasource2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">&quot;datasource2Tx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionalService</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Transactional(&quot;datasource1Tx&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSomethingInDatasource1</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Transactional(&quot;datasource2Tx&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomethingInDatasource2</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p><strong>propagation属性</strong></p><p>propagation用于指定事务的传播行为，默认值为 REQUIRED。propagation有七种类型，就是我们在上文中讲到的事务属性传播行为的七种方式，如下所示:</p></li></ol><table><thead><tr><th>propagation属性</th><th>事务属性-传播行为</th><th>含义</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>REQUIRED</td><td>TransactionDefinition.PROPAGATION_REQUIRED</td><td>如果当前没有事务，就新建一个事务，如果已经存在一个事务，则加入到这个事务中。这是最常见的选择。</td><td></td><td></td><td></td></tr><tr><td>SUPPORTS</td><td>TransactionDefinition.PROPAGATION_SUPPORTS</td><td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td><td></td><td></td><td></td></tr><tr><td>MANDATORY</td><td>TransactionDefinition.PROPAGATION_MANDATORY</td><td>表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常。</td><td></td><td></td><td></td></tr><tr><td>REQUIRES_NEW</td><td>TransactionDefinition.PROPAGATION_REQUIRES_NEW</td><td>表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。</td><td></td><td></td><td></td></tr><tr><td>NOT_SUPPORTED</td><td>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</td><td>表示该方法不应该运行在事务中。如果当前存在事务，就把当前事务挂起。</td><td></td><td></td><td></td></tr><tr><td>NEVER</td><td>TransactionDefinition.PROPAGATION_NEVER</td><td>表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常。</td><td></td><td></td><td></td></tr><tr><td>NESTED</td><td>TransactionDefinition.PROPAGATION_NESTED</td><td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td><td></td><td></td><td></td></tr></tbody></table><ol start="4"><li><p><strong>isolation属性</strong></p><p>​    isolation用于指定事务的隔离规则，默认值为DEFAULT。@Transactional的隔离规则和上文事务属性里面的隔离规则也是一一对应的。总共五种隔离规则，如下所示:</p><table><thead><tr><th>@isolation属性</th><th>事务属性-隔离规则</th><th>含义</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>DEFAULT</td><td>TransactionDefinition.ISOLATION_DEFAULT</td><td>使用后端数据库默认的隔离级别</td><td></td><td></td><td></td></tr><tr><td>READ_UNCOMMITTED</td><td>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</td><td>允许读取尚未提交的数据变更(最低的隔离级别)</td><td>是</td><td>是</td><td>是</td></tr><tr><td>READ_COMMITTED</td><td>TransactionDefinition.ISOLATION_READ_COMMITTED</td><td>允许读取并发事务已经提交的数据</td><td>否</td><td>是</td><td>是</td></tr><tr><td>REPEATABLE_READ</td><td>TransactionDefinition.ISOLATION_REPEATABLE_READ</td><td>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改</td><td>否</td><td>否</td><td>是</td></tr><tr><td>SERIALIZABLE</td><td>TransactionDefinition.ISOLATION_SERIALIZABLE</td><td>最高的隔离级别，完全服从ACID的隔离级别，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的</td><td>否</td><td>否</td><td>否</td></tr></tbody></table></li></ol><hr><ol start="5"><li><p><strong>timeout</strong></p><p>​    timeout用于设置事务的超时属性。</p></li><li><p><strong>readOnly</strong></p><p>​    readOnly用于设置事务是否只读属性。</p></li><li><p><strong>rollbackFor、rollbackForClassName、noRollbackFor、noRollbackForClassName</strong></p><p>​    rollbackFor、rollbackForClassName用于设置那些异常需要回滚；noRollbackFor、noRollbackForClassName用于设置那些异常不需要回滚。他们就是在设置事务的回滚规则。</p></li></ol><h4 id="Transactional注解的使用"><a href="#Transactional注解的使用" class="headerlink" title="@Transactional注解的使用"></a><strong>@Transactional注解的使用</strong></h4><ol><li>@Transactional注解内部实现依赖于Spring AOP编程。而AOP在默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为。</li><li><strong>@Transactional 注解尽量直接加在方法上</strong>:因为每个方法的执行情况不一样,加载类上的话不能更好地区分每个方法的操作 比如查询只需要readOnly</li><li><strong>@Transactional 注解必须添加在public方法上，private、protected方法上是无效的</strong> spring的@Transactional是基于springAOP特性实现</li><li><strong>@Transactional注解在外部调用的函数上才有效果，内部调用的函数添加无效，</strong>要切记。这是由AOP的特性决定的。(即在同一个类中只有只有由@Transactional的方法调用另一个方法有效,两个方法都有@Transactional注解只有外部的生效,内部的不生效  <strong>@Transactional注解只有外部调用才有效。</strong>)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">         propagation = Propagation.REQUIRED,</span></span><br><span class="line"><span class="meta">         isolation = Isolation.DEFAULT,</span></span><br><span class="line"><span class="meta">         readOnly = false,</span></span><br><span class="line"><span class="meta">         rollbackFor = &#123;</span></span><br><span class="line"><span class="meta">                 NullPointerException.class,  NotEnoughException.class</span></span><br><span class="line"><span class="meta">         &#125;</span></span><br></pre></td></tr></table></figure><hr><p>  2.开启事务注解驱动， 告诉spring框架，我要使用注解的方式管理事务。<br>    spring使用aop机制，创建@Transactional所在的类代理对象，给方法加入事务的功能。<br>    spring给业务方法加入事务：<br>        在你的业务方法执行之前，先开启事务，在业务方法之后提交或回滚事务，使用aop的环绕通知</p><pre><code>     @Around(&quot;你要增加的事务功能的业务方法名称&quot;)     Object myAround()&#123;       开启事务，spring给你开启          try&#123;             buy(1001,10);              spring的事务管理器.commit();          &#125;catch(Exception e)&#123;         spring的事务管理器.rollback();          &#125;              &#125;</code></pre><p>3.在你的方法的上面加入@Trancational 在注解中配置参数</p><p>2.适合大型项目，有很多的类，方法，需要大量的配置事务，使用aspectj框架功能，在spring配置文件中<br>  声明类，方法需要的事务。这种方式业务方法和事务配置完全分离。</p><p>  实现步骤： 都是在xml配置文件中实现。 即不是用@Apest 和 @Trancational 注解 完全使用xml配置文件<br>   1)要使用的是aspectj框架，需要加入依赖<br>    <dependency><br>        <groupId>org.springframework</groupId><br>        <artifactId>spring-aspects</artifactId><br>        <version>5.2.5.RELEASE</version><br>    </dependency></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2）声明事务管理器对象</span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;xx&quot;</span> <span class="attr">class</span>=<span class="string">&quot;DataSourceTransactionManager&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><pre><code> 3) 声明方法需要的事务类型（配置方法的事务属性【隔离级别，传播行为，超时】） 4)  配置aop：指定哪些哪类要创建代理。</code></pre><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       把数据库的配置信息，写在一个独立的文件，编译修改数据库的配置内容</span></span><br><span class="line"><span class="comment">       spring知道jdbc.properties文件的位置</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明数据源DataSource, 作用是连接数据库的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--set注入给DruidDataSource提供连接数据库信息 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    使用属性配置文件中的数据，语法 $&#123;key&#125; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span><span class="comment">&lt;!--setUrl()--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.passwd&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.max&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明的是mybatis中提供的SqlSessionFactoryBean类，这个类内部创建SqlSessionFactory的</span></span><br><span class="line"><span class="comment">        SqlSessionFactory  sqlSessionFactory = new ..</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--set注入，把数据库连接池付给了dataSource属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;myDataSource&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis主配置文件的位置</span></span><br><span class="line"><span class="comment">           configLocation属性是Resource类型，读取配置文件</span></span><br><span class="line"><span class="comment">           它的赋值，使用value，指定文件的路径，使用classpath:表示文件的位置</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--创建dao对象，使用SqlSession的getMapper（StudentDao.class）</span></span><br><span class="line"><span class="comment">        MapperScannerConfigurer:在内部调用getMapper()生成每个dao接口的代理对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定SqlSessionFactory对象的id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定包名， 包名是dao接口所在的包名。</span></span><br><span class="line"><span class="comment">            MapperScannerConfigurer会扫描这个包中的所有接口，把每个接口都执行</span></span><br><span class="line"><span class="comment">            一次getMapper()方法，得到每个接口的dao对象。</span></span><br><span class="line"><span class="comment">            创建好的dao对象放入到spring的容器中的。 dao对象的默认名称是 接口名首字母小写</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.bjpowernode.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明service--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;buyService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.bjpowernode.service.impl.BuyGoodsServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;goodsDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;goodsDao&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;saleDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;saleDao&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明式事务处理：和源代码完全分离的--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.声明事务管理器对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;myDataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--2.声明业务方法它的事务属性（隔离级别，传播行为，超时时间）</span></span><br><span class="line"><span class="comment">          id:自定义名称，表示 &lt;tx:advice&gt; 和 &lt;/tx:advice&gt;之间的配置内容的</span></span><br><span class="line"><span class="comment">          transaction-manager:事务管理器对象的id 不设置就是默认配置</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--tx:attributes：配置事务属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--tx:method：给具体的方法配置事务属性，method可以有多个，分别给不同的方法设置事务属性</span></span><br><span class="line"><span class="comment">                name:方法名称，1）完整的方法名称，不带有包和类。</span></span><br><span class="line"><span class="comment">                              2）方法可以使用通配符,* 表示任意字符</span></span><br><span class="line"><span class="comment">                propagation：传播行为，枚举值</span></span><br><span class="line"><span class="comment">                isolation：隔离级别</span></span><br><span class="line"><span class="comment">                rollback-for：你指定的异常类名，全限定类名。 发生异常一定回滚</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;buy&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;DEFAULT&quot;</span></span></span><br><span class="line"><span class="tag">                       <span class="attr">rollback-for</span>=<span class="string">&quot;java.lang.NullPointerException,com.bjpowernode.excep.NotEnoughException&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--使用通配符，指定很多的方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRES_NEW&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指定修改方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;modify*&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--删除方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;remove*&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--查询方法，query，search，find--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置aop--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切入点表达式：指定哪些包中类，要使用事务</span></span><br><span class="line"><span class="comment">            id:切入点表达式的名称，唯一值</span></span><br><span class="line"><span class="comment">            expression：切入点表达式，指定哪些类要使用事务，aspectj会创建代理对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            com.bjpowernode.service</span></span><br><span class="line"><span class="comment">            com.crm.service</span></span><br><span class="line"><span class="comment">            com.service</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;servicePt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..service..*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--配置增强器：关联adivce和pointcut</span></span><br><span class="line"><span class="comment">           advice-ref:通知，上面tx:advice哪里的配置</span></span><br><span class="line"><span class="comment">           pointcut-ref：切入点表达式的id</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;servicePt&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="web项目中怎么使用容器对象。"><a href="#web项目中怎么使用容器对象。" class="headerlink" title="web项目中怎么使用容器对象。"></a>web项目中怎么使用容器对象。</h2><ol><li><p>做的是javase项目有main方法的，执行代码是执行main方法的，<br>  在main里面创建的容器对象<br>  ApplicationContext ctx &#x3D; new ClassPathXmlApplicationContext(“applicationContext.xml”);</p></li><li><p>web项目是在tomcat服务器上运行的。 tomcat一起动，项目一直运行的。</p></li></ol><p><strong>需求：</strong><br>web项目中容器对象只需要创建一次，  把容器对象放入到全局作用域ServletContext中。</p><p><strong>怎么实现：</strong><br>   使用监听器 当全局作用域对象被创建时 创建容器 存入ServletContext</p><pre><code>监听器作用：1）创建容器对象，执行 ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);2）把容器对象放入到ServletContext， ServletContext.setAttribute(key,ctx)监听器可以自己创建，也可以使用框架中提供好的ContextLoaderListener private WebApplicationContext context; public interface WebApplicationContext extends ApplicationContext</code></pre><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> ApplicationContext:javase项目中使用的容器对象</span><br><span class="line">WebApplicationContext：web项目中的使用的容器对象</span><br><span class="line"></span><br><span class="line">把创建的容器对象，放入到全局作用域</span><br><span class="line"> key： WebApplicationContext.ROOT<span class="built_in">_</span>WEB<span class="built_in">_</span>APPLICATION<span class="built_in">_</span>CONTEXT<span class="built_in">_</span>ATTRIBUTE</span><br><span class="line">       WebApplicationContext.ROOT<span class="built_in">_</span>WEB<span class="built_in">_</span>APPLICATION<span class="built_in">_</span>CONTEXT<span class="built_in">_</span>ATTRIBUTE</span><br><span class="line"> value：this.context</span><br><span class="line"></span><br><span class="line"> servletContext.setAttribute(WebApplicationContext.ROOT<span class="built_in">_</span>WEB<span class="built_in">_</span>APPLICATION<span class="built_in">_</span>CONTEXT<span class="built_in">_</span>ATTRIBUTE, this.context);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;spring全家桶：spring ， springmvc ，spring boot , spring cloud &lt;/p&gt;
&lt;p&gt;  spring: 出现是在2002左右，解决企业开发的难度。减轻对项目模块之间的管理，&lt;br&gt;          类和类之间的管理， 帮助开发人员创建对象，管理对象之间的关系。&lt;br&gt;             spring核心技术 ioc ， aop 。能实现模块之间，类之间的解耦合。&lt;/p&gt;</summary>
    
    
    
    <category term="spring框架" scheme="https://devildyw.github.io/categories/spring%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="java" scheme="https://devildyw.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="https://devildyw.github.io/2022/02/28/SpringMVC/"/>
    <id>https://devildyw.github.io/2022/02/28/SpringMVC/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-03-06T15:58:43.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a><strong>SpringMVC</strong></h1><p>SpringMVC：是基于spring的一个框架， 实际上就是spring的一个模块， 专门是做web开发的。<br>           理解是servlet的一个升级</p><pre><code>   web开发底层是servlet ， 框架是在servlet基础上面加入一些功能，让你做web开发方便。</code></pre><p>SpringMVC就是一个Spring。 Spring是容器，ioc能够管理对象，使用<bean>, @Component, @Repository, @Service, @Controller<br>  SpringMVC能够创建对象， 放入到容器中（SpringMVC容器）， springmvc容器中放的是控制器对象，</p><p>  我们要做的是 使用@Contorller创建控制器对象， 把对象放入到springmvc容器中， 把创建的对象作为控制器使用<br>  这个控制器对象能接收用户的请求， 显示处理结果，就当做是一个servlet使用。</p><p>  使用@Controller注解创建的是一个普通类的对象， 不是Servlet。 springmvc赋予了控制器对象一些额外的功能。</p><p>  web开发底层是servlet， springmvc中有一个对象是Servlet ：DispatcherServlet(中央调度器)<br>  DispatcherServlet: 负责接收用户的所有请求， 用户把请求给了DispatherServlet， 之后DispatcherServlet把请求转发给<br>                    我们的Controller对象， 最后是Controller对象处理请求。</p><p>​    <span id="more"></span></p><blockquote><p>  index.jsp—–DispatcherServlet(Servlet)—-转发，分配给—Controller对象（@Controller注解创建的对象）<br>  main.jsp                                                   MainController<br>  addUser.jsp                                                UserController</p></blockquote><h3 id="SpringMVC核心-DispatcherServlet"><a href="#SpringMVC核心-DispatcherServlet" class="headerlink" title="SpringMVC核心 DispatcherServlet"></a><strong>SpringMVC核心 DispatcherServlet</strong></h3><h4 id="DispatcherServlet处理流程"><a href="#DispatcherServlet处理流程" class="headerlink" title="DispatcherServlet处理流程"></a>DispatcherServlet处理流程</h4><p><strong>和其他Servlet一样他也是通过Tomcat服务器创建的</strong>需要在web.xml文件中配置这个Servlet类的<servlet>和<servlet-mapping>只有这样Tomcat服务器才知道什么时候去创建这个指定的Servlet </p><p><strong>DispatcherServlet</strong>主要负责在tomcat启动的一开始 创建一个Springmvc容器放入ServletContext中, DispatcherServlet初始化时会读取<servlet-name>.xml文件,创建容器和里面的类的实例 比如组件扫描器配置后 @Controller注解所指的类的对象</p><p>在整个 Spring MVC 框架中，DispatcherServlet 处于核心位置，它负责协调和组织不同组件完成请求处理并返回响应工作。DispatcherServlet 是 SpringMVC统一的入口，所有的请求都通过它。DispatcherServlet 是前端控制器，配置在web.xml文件中，Servlet依自已定义的具体规则拦截匹配的请求，分发到目标Controller来处理。 初始化 DispatcherServlet时，该框架在web应用程序WEB-INF目录中寻找一个名为[servlet-名称]-servlet.xml的文件，并在那里定义相关的Beans，重写在全局中定义的任何Beans。在看DispatcherServlet 类之前，我们先来看一下请求处理的大致流程：</p><blockquote><ol><li><p>Tomcat 启动，(前提是在&lt;servlet中配置了<load-on-startup>标签 他会告诉tomcat在它启动时实例化该Servlet)对 DispatcherServlet 进行实例化，然后调用它的 init() 进行初始化，在这个初始化过程中完成了：对 web.xml 中初始化参数的加载；建立 WebApplicationContext(SpringMVC的IOC容器)；进行组件的初始化；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DispatcherServlet的初始化会执行init()方法.DispatcherServlet在inti()中&#123;</span><br><span class="line">            <span class="comment">//创建SpringMVC的IOC容器,读取配置文件</span></span><br><span class="line">            <span class="type">WebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;springmvc.xml&quot;</span>);</span><br><span class="line">            <span class="comment">//把容器对象放到ServletContext中(全局作用域)</span></span><br><span class="line">            getServletContext().getAttribute(key,ctx);</span><br><span class="line">                                                         </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端发出请求，由 Tomcat 接收到这个请求，如果匹配 DispatcherServlet 在 web.xml中配置的映射路径，Tomcat 就将请求转交给 DispatcherServlet 处理；</p></li><li><p>DispatcherServlet 从容器中取出所有 HandlerMapping 实例（每个实例对应一个 HandlerMapping接口的实现类）并遍历，每个 HandlerMapping 会根据请求信息，通过自己实现类中的方式去找到处理该请求的 Handler(执行程序，如 Controller 中的方法)，并且将这个 Handler 与一堆 HandlerInterceptor (拦截器)封装成一个 HandlerExecutionChain 对象，一旦有一个 HandlerMapping 可以找到 Handler则退出循环；</p></li><li><p>DispatcherServlet 取出 HandlerAdapter 组件，根据已经找到的 Handler，再从所有HandlerAdapter 中找到可以处理该 Handler 的 HandlerAdapter 对象；</p></li><li><p>执行 HandlerExecutionChain 中所有拦截器的 preHandler()，然后再利用 HandlerAdapter 执行 Handler ，执行完成得到 ModelAndView，再依次调用拦截器的 postHandler()；</p></li><li><p>利用 ViewResolver 将 ModelAndView 或是 Exception (可解析成 ModelAndView)解析成View，然后 View 会调用 render() 再根据 ModelAndView 中的数据渲染出页面；</p></li><li><p>最后再依次调用拦截器的 afterCompletion()，这一次请求就结束了。</p></li></ol></blockquote><hr><h2 id="SpringMVC配置文件"><a href="#SpringMVC配置文件" class="headerlink" title="SpringMVC配置文件"></a><strong>SpringMVC配置文件</strong></h2><p>web,xml配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明,注册springmvc的核心对象DispatcherServlet</span></span><br><span class="line"><span class="comment">        需要在tomcat服务器启动后,创建DispatcherServlet对象的实例</span></span><br><span class="line"><span class="comment">        为什么要创建DispatcherServlet对象的实例呢?</span></span><br><span class="line"><span class="comment">        因为DispatcherServlet在他创建的过程中会同时创建springmvc容器对象</span></span><br><span class="line"><span class="comment">        读取springmvc的配置文件,把这个配置文件中的对象创建好,当用户发起请求时就可以直接直接使用对象了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        servlet的初始化会执行init()方法.DispatcherServlet在inti()中&#123;</span></span><br><span class="line"><span class="comment">            //创建容器,读取配置文件</span></span><br><span class="line"><span class="comment">            WebApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;springmvc.xml&quot;);</span></span><br><span class="line"><span class="comment">            //把容器对象放到ServletContext中</span></span><br><span class="line"><span class="comment">            getServletContext().getAttribute(key,ctx);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--自定义springmvc读取的配置文件的位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--springmvc读取的配置文件的位置的属性--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指定配置文件的位置--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--默认tomcat启动后不创建Servlet对象 只有接收到请求才会创建对象</span></span><br><span class="line"><span class="comment">            为了能够在tomcat启动后,创建Servlet对象 load-on-startup:表示tomcat启动后创建对象的顺序</span></span><br><span class="line"><span class="comment">            ,他的值时整数,数值越小,tomcat创建对象的时间越早,大于等于零的整数</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            使用框架的时候,url-pattern可以使用两种值</span></span><br><span class="line"><span class="comment">            1.使用扩展名,语法*.xxx,xxx是自定义扩展名.常用方式 *.do,*.action,*.mvc等</span></span><br><span class="line"><span class="comment">            表示以xxx结尾的请求都由&lt;servlet-name&gt;对应的servlet处理</span></span><br><span class="line"><span class="comment">            http://localhost:8088/myweb/web.do</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            2.使用&quot;/&quot; 与一般servlet使用无差 即拦截所有请求</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置组件扫描器 配合扫描组件的@Controller和其中的@RequestMapping--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw.controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置视图解析器 原理就是字符串的拼接--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/page/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是SpringMVC-config.xml;</p><hr><h2 id="SpringMVC请求处理过程"><a href="#SpringMVC请求处理过程" class="headerlink" title="SpringMVC请求处理过程"></a><strong>SpringMVC请求处理过程</strong></h2><p>springmvc请求的处理流程</p><p> 1）发起some.do<br> 2）tomcat(web.xml–url-pattern知道 *.do的请求给DispatcherServlet)<br> 3）DispatcherServlet（根据springmvc.xml配置知道 some.do—doSome()）<br> 4）DispatcherServlet把some.do转发个MyController.doSome()方法<br> 5）框架执行doSome（）把得到ModelAndView进行处理， 转发到show.jsp</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/18868114-b856800a4b003e56.png" alt="img"></p><p>上面的过程简化的方式</p><p><strong>some.do—DispatcherServlet—MyController</strong></p><p>springmvc执行过程源代码分析</p><ol><li>tomcat启动，创建容器的过程<br>通过load-on-start标签指定的1，创建DisaptcherServlet对象，<br>DisaptcherServlet它的父类是继承HttpServlet的， 它是一个serlvet， 在被创建时，会执行init（）方法。<br>在init（）方法中<br>&#x2F;&#x2F;创建容器，读取配置文件<br> WebApplicationContext ctx &#x3D; new ClassPathXmlApplicationContext(“springmvc.xml”);<br> &#x2F;&#x2F;把容器对象放入到ServletContext中<br> getServletContext().setAttribute(key, ctx);</li></ol><p>  上面创建容器作用： 创建@controller注解所在的类的对象， 创建MyController对象，<br>   这个对象放入到 springmvc的容器中， 容器是map ， 类似 map.put(“myController”,MyController对象)</p><p>2.请求的处理过程<br>  1）执行servlet的service()<br>       protected void service(HttpServletRequest request, HttpServletResponse response)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected void doService(HttpServletRequest request, HttpServletResponse response)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DispatcherServlet.doDispatch(request, response)&#123;</span><br><span class="line"></span><br><span class="line">    调用MyController的.doSome()方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   doDispatch：springmvc中DispatcherServlet的核心方法， 所有的请求都在这个方法中完成的。</p><hr><h2 id="SpringMVC中的注解"><a href="#SpringMVC中的注解" class="headerlink" title="SpringMVC中的注解"></a><strong>SpringMVC中的注解</strong></h2><h4 id="Controller-控制器"><a href="#Controller-控制器" class="headerlink" title="@Controller(控制器)"></a>@Controller(控制器)</h4><blockquote><p>@Controller:创建处理器对象,对象放在springmvc容器中.<br>位置:类的上面<br>和spring中讲的@service和@Component一样</p><p>能处理请求的都是控制器(处理器):MyController能处理请,叫做后端控制器(back controller)</p></blockquote><h4 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h4><blockquote><p><strong>表示当前方法为处理器方法。该方法要对 value 属性所指定的 URI进行处理与响应。被注解的方法的方法名可以随意。</strong></p><p>@RequestMapping:请求映射:作用是把一个请求地址和一个方法绑定在一起.<br>         一个请求指定一个方法处理<br>    属性: 1.value是一个String,表示请求的uri地址的(some.do). 可以使用数组表示多个请求路径都有这个方法处理<br>         2.value的值必须是唯一的,不能重复. 再使用时推荐地址以”&#x2F;“开头</p><p>​            </p><pre><code>位置:1.在方法上面,常用的        2.在类上面</code></pre><p>说明:使用RequestMapping修饰的方法叫做处理器方法或者控制器方法<br>使用@RequestMapping修饰的方法可以处理请求的,类似与Servlet中的doGet() or doPost()</p><p>可以在@RequestMapping指定请求的方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">@RequestMapping(value = &quot;/some.do&quot;,method = RequestMethod.GET)</span></span><br></pre></td></tr></table></figure><p>RequestMethod.GET、RequestMethod.POST</p></blockquote><p>​    如果不设置就是任意请求方法都能处理不会报405错</p><h2 id="请求传参"><a href="#请求传参" class="headerlink" title="请求传参"></a><strong>请求传参</strong></h2><h4 id="处理器方法的参数"><a href="#处理器方法的参数" class="headerlink" title="处理器方法的参数"></a>处理器方法的参数</h4><blockquote><p>处理器方法可以包含以下四类参数，这些参数会在系统调用时由系统自动赋值，即程序员可在方法内直接使用。<br>➢ HttpServletRequest<br>➢ HttpServletResponse<br>➢ HttpSession<br>➢ 请求中所携带的请求参数</p></blockquote><h4 id="方式一-直接在方法中写入与前端页面同样名称的参数（同名匹配规则）"><a href="#方式一-直接在方法中写入与前端页面同样名称的参数（同名匹配规则）" class="headerlink" title="方式一 直接在方法中写入与前端页面同样名称的参数（同名匹配规则）"></a>方式一 直接在方法中写入与前端页面同样名称的参数（同名匹配规则）</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;/springmvc_03/doSome.do&quot;</span>&gt;</span><br><span class="line">        姓名:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span> /&gt;</span><br><span class="line">        年龄:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;age&quot;</span>/&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/doSome.do&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">doSome</span><span class="params">(String name,Integer age)</span>&#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        mv.addObject(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">        mv.addObject(<span class="string">&quot;age&quot;</span>,age);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名:&quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄:&quot;</span>+Integer.valueOf(age));</span><br><span class="line">        mv.setViewName(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式二-使用-RequestParam-“前台参数名”-注入"><a href="#方式二-使用-RequestParam-“前台参数名”-注入" class="headerlink" title="方式二 使用@RequestParam(“前台参数名”) 注入"></a>方式二 使用@RequestParam(“前台参数名”) 注入</h4><p>防止前台名称与后台名称不一致导致出错 同时也防止同名匹配规则与前台的耦合 利于更好的分离开发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/doSome.do&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">doSome</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String sname, <span class="meta">@RequestParam(&quot;age&quot;)</span> Integer sage)</span>&#123;</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    mv.addObject(<span class="string">&quot;name&quot;</span>,sname);</span><br><span class="line">    mv.addObject(<span class="string">&quot;age&quot;</span>,sage);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;姓名:&quot;</span>+sname);</span><br><span class="line">    System.out.println(<span class="string">&quot;年龄:&quot;</span>+Integer.valueOf(sage));</span><br><span class="line">    mv.setViewName(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>@RequestParam</code> 注解细节：</strong></p><blockquote><p>该注解有三个变量：**<code>value</code>、<code>required</code>、<code>defaultvalue</code>**</p><p><strong>value</strong> ：指定 <code>name</code> 属性的名称是什么，<code>value</code> 属性都可以默认不写</p><p><strong>required</strong> ：是否必须要有该参数，可以设置为【true】或者【false】防止出现空指针异常</p><p><strong>defaultvalue</strong> ：设置默认值</p></blockquote><h4 id="方式三-使用模型传参（使用对象）"><a href="#方式三-使用模型传参（使用对象）" class="headerlink" title="方式三 使用模型传参（使用对象）"></a>方式三 使用模型传参（使用对象）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/doSome.do&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">doSome</span><span class="params">(People people)</span>&#123;</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    mv.addObject(<span class="string">&quot;name&quot;</span>,people.getName());</span><br><span class="line">    mv.addObject(<span class="string">&quot;age&quot;</span>,people.getAge());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;姓名:&quot;</span>+people.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;年龄:&quot;</span>+people.getAge());</span><br><span class="line">    mv.setViewName(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用模型传参 要求参数的形参名要和对象的属性名一样,  框架会调用模型类的构造方法 创建一个模型 在调用模型的set方法完成注入 </p><p><strong>优点</strong>：可以避免方法参数过多而引起的参数过长，乱而不方便查看，而且可以隐藏信息</p><h4 id="注意-："><a href="#注意-：" class="headerlink" title="注意 ："></a>注意 ：</h4><p><strong>中文乱码问题</strong> </p><p>这种问题主要出现在POST请求中 对于这种问题如果我们没写一个方法都去写一个setCharacterEncoding的话会 程序会出现很多冗余。</p><p>解决方案：使用过滤器 <strong>通过配置 Spring MVC 字符编码过滤器</strong>来解决POST请求传参乱码问题 </p><p>**注意:**最好将该过滤器注册在其它过滤器之前。因为过滤器的执行是按照其注册顺序进行的。</p><p>在web.xml中配置这样一段</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置过滤器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--设置编码格式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--强制请求的编码为utf-8--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceRequestEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--强制响应的编码为utf-8--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--对所有请求路径都修改编码--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="控制器回显数据"><a href="#控制器回显数据" class="headerlink" title="控制器回显数据"></a><strong>控制器回显数据</strong></h2><p>Controller处理器中的方法返回值为String就代表 视图名  一般用在同步请求</p><h4 id="方式一：使用-Spring-MVC-所提供的-ModelAndView-对象"><a href="#方式一：使用-Spring-MVC-所提供的-ModelAndView-对象" class="headerlink" title="方式一：使用 Spring MVC 所提供的 ModelAndView 对象"></a>方式一：使用 Spring MVC 所提供的 ModelAndView 对象</h4><p>​        在使用他之前需要创建一个show.jsp 用来充当视图 前面的演示中也是使用的这样的方式</p><p><strong>index.jsp</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;/springmvc_03/doSome.do&quot;</span>&gt;</span><br><span class="line">        姓名:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span> /&gt;</span><br><span class="line">        年龄:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;age&quot;</span>/&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>MyController</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/doSome.do&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">doSome</span><span class="params">(People people)</span>&#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        mv.addObject(<span class="string">&quot;name&quot;</span>,people.getName());</span><br><span class="line">        mv.addObject(<span class="string">&quot;age&quot;</span>,people.getAge());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名:&quot;</span>+people.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄:&quot;</span>+people.getAge());</span><br><span class="line">        mv.setViewName(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>show.jsp</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h3&gt;$&#123;name&#125;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt;$&#123;age&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>结果如图：</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220109182433561.png" alt="image-20220109182433561"></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220109182513274.png" alt="image-20220109182513274"></p><h4 id="方式二-使用-Model-对象"><a href="#方式二-使用-Model-对象" class="headerlink" title="方式二 使用 Model 对象"></a>方式二 使用 Model 对象</h4><p>在 Spring MVC 中，我们通常都是使用这样的方式来绑定数据</p><p>index.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a href=<span class="string">&quot;/springmvc_04/some.do&quot;</span>&gt;test1-Model方式回显数据&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>MyController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/some.do&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doSome</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;这是使用Model方式回显数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;show&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值就是一个就是一个jsp资源可以使用完整路径 也可以使用视图解析器简化</p><p>show.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h3&gt;$&#123;msg&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220109194719801.png" alt="image-20220109194719801"></p><h4 id="方式三-使用-ModelAttribute-注解："><a href="#方式三-使用-ModelAttribute-注解：" class="headerlink" title="方式三 使用 @ModelAttribute 注解："></a>方式三 <strong>使用 <code>@ModelAttribute</code> 注解：</strong></h4><p>单独创建一个方法model用于在一开始向Model中添加数据</p><p>MyController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">model</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;这是方式三使用@ModelAttribute&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/some.do&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;show&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样写就会在访问控制器方法 handleRequest() 时，会首先调用 model() 方法将 <code>message</code> 添加进页面参数中去，在视图中可以直接调用，但是这样写会导致该控制器所有的方法都会首先调用 model() 方法，但同样的也很方便，因为可以加入各种各样的数据。</p><h4 id="方式四-使用void-了解"><a href="#方式四-使用void-了解" class="headerlink" title="方式四:使用void(了解)"></a>方式四:使用void(了解)</h4><p>对于处理器方法返回 void 的应用场景，AJAX 响应.</p><p>若处理器对请求处理后，无需跳转到其它任何资源，此时可以让处理器方法返回 void。</p><p>例如，对于 AJAX 的异步请求的响应。</p><h4 id="方式五-使用Object"><a href="#方式五-使用Object" class="headerlink" title="方式五:使用Object"></a>方式五:使用Object</h4><p><strong>主要用于响应Ajax请求</strong></p><blockquote><p>处理器方法也可以返回 Object 对象。这个 Object 可以是 Integer，String，自定义对象，Map，List 等。但返回的对象不是作为逻辑视图出现的，而是作为直接在页面显示的数据出现的。</p><p>返回对象，需要使用@ResponseBody 注解，将转换后的 JSON 数据放入到响应体中。</p></blockquote><p><strong>环境搭建:</strong></p><p>由于返回 Object 数据，一般都是将数据转化为了 JSON 对象后传递给浏览器页面的。而这个由 Object 转换为 JSON，是由 Jackson 工具完成的。所以需要导入 Jackson 的相关 Jar 包。所以需要在maven的pom.xml中添加jackson相关依赖 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>声明注解驱动:</strong></p><p>将 Object 数据转化为 JSON 数据，需要由消息转换器 HttpMessageConverter 完成。而转换器的开启，需要由<a href="mvc:annotation-driven/">mvc:annotation-driven/</a>来完成。(注意:一定时路径带有mvc的)</p><p>SpringMVC 使用消息转换器实现请求数据和对象，处理器方法返回对象和响应输出之间的自动转换</p><p>当 Spring 容器进行初始化过程中，在<a href="mvc:annotation-driven/">mvc:annotation-driven/</a>处创建注解驱动时，默认创建了七个 HttpMessageConverter 对象。也就是说，我们注册<a href="mvc:annotation-driven/">mvc:annotation-driven/</a>，就是为了让容器为我们创建 <strong>HttpMessageConverter</strong> 对象。(对应七个转换不同类型的对象)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">没有加入注解驱动标签时的状态</span><br><span class="line">org.springframework.http.converter.ByteArrayHttpMessageConverter </span><br><span class="line">org.springframework.http.converter.StringHttpMessageConverter</span><br><span class="line">org.springframework.http.converter.xml.SourceHttpMessageConverter</span><br><span class="line">org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter</span><br><span class="line"></span><br><span class="line">加入注解驱动标签时的状态</span><br><span class="line">org.springframework.http.converter.ByteArrayHttpMessageConverter</span><br><span class="line">org.springframework.http.converter.StringHttpMessageConverter</span><br><span class="line">org.springframework.http.converter.ResourceHttpMessageConverter</span><br><span class="line">org.springframework.http.converter.ResourceRegionHttpMessageConverter</span><br><span class="line">org.springframework.http.converter.xml.SourceHttpMessageConverter </span><br><span class="line">org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter </span><br><span class="line">org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverter</span><br><span class="line">org.springframework.http.converter.json.MappingJackson2HttpMessageConverter</span><br></pre></td></tr></table></figure><p><strong>HttpMessageConverter 接口 :</strong> HttpMessageConverter<T>是 Spring3.0 新添加的一个接口，负责将请求信息转换为一个对象（类型为 T），将对象（类型为 T）输出为响应信息</p><p><em><strong>HttpMessageConverter<T>接口定义的方法：</strong></em></p><ol><li><p><strong>boolean canRead(Class&lt;?&gt; clazz,MediaType mediaType)</strong>: 指定转换器可以读取的对象类型，即转 换 器 是 否 可 将 请 求 信 息 转 换 为 clazz 类 型 的 对 象 ， 同 时 指 定 支 持 MIME 类 型(text&#x2F;html,applaiction&#x2F;json 等)</p></li><li><p>**boolean canWrite(Class&lt;?&gt; clazz,MediaType mediaType):**指定转换器是否可将 clazz 类型的对象写到响应流中，响应流支持的媒体类型在 MediaType 中定义。<br> <strong>LIst<MediaType> getSupportMediaTypes()：</strong>该转换器支持的媒体类型</p></li><li><p><strong>T read(Class&lt;? extends T&gt; clazz,HttpInputMessage inputMessage)：</strong>将请求信息流转换为 T 类型的对象。</p></li><li><p>**void write(T t,MediaType contnetType,HttpOutputMessgae outputMessage):**将 T 类型的对象写到响应流中，同时指定相应的媒体类型为 contentType</p></li></ol><p>加入注解驱动<a href="mvc:annotation-driven/">mvc:annotation-driven/</a>后适配器类的 messageConverters 属性值</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/18868114-5a5b24aab0a648c9.webp" alt="18868114-5a5b24aab0a648c9"></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/18868114-0248cc96bbce4592.webp" alt="18868114-0248cc96bbce4592"></p><p><strong>返回自定义类型对象</strong></p><p>返回自定义类型对象时，不能以对象的形式直接返回给客户端浏览器，而是将对象转换为 JSON 格式的数据发送给浏览器的。</p><p><strong>在处理器方法上使用@ResponseBody即可使得返回值可以以数据的形式响应</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;myajax.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Student <span class="title function_">doStudentJson</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//创建Student对象</span></span><br><span class="line">    <span class="comment">//返回Student对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>返回其他对象也同样可以按照这个方法</strong></p><hr><h2 id="客户端跳转-重定向"><a href="#客户端跳转-重定向" class="headerlink" title="客户端跳转(重定向)"></a><strong>客户端跳转(重定向)</strong></h2><h4 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h4><p>​    框架的底层会在我们使用@Controller方法时, 在指定<strong>视图名称和Model</strong>后,帮助我们将<strong>Modl封装到request请求域</strong>中,然后自动调用**request.getRequestDispatcher(“地址”).forward(request, response);**也就是请求转发. 也就是说 这些都是服务端的跳转</p><p>​    在学习servlet中我们可知 请求转发是一次请求 用法为<strong>request.getRequestDispatcher(“xx.jsp”).forward()</strong></p><p>重定向是两次转发:<strong>response.sendRedirect(“xxx.jsp”)</strong></p><p>​    在SpringMVC框架中把原来 Servlet 中的请求转发和重定向操作进行了封装。现在可以使用简单的方式实现转发和重定向。</p><h4 id="服务端跳转"><a href="#服务端跳转" class="headerlink" title="服务端跳转"></a>服务端跳转</h4><p>​    前面对框架的介绍时我说过SpringMVC框架在你指定视图名称之后是自动帮你转发到视图资源上的(来让其获得Model中的资源).</p><p>​    也可以手动指定只需要在前方加入”forward”即可</p><p>**方式一:**以ModelAndView对象的方式返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(...)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">ModelAndView mv= <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line"></span><br><span class="line">    mv.set(<span class="string">&quot;forward:/...jsp&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**方式二:**以String方式返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(...)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/...jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> **方式三:**以ModelAndView初始化的方式 且 以ModelAndView对象的方式返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(...)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">ModelAndView mv= <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;forward:/...jsp&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何进行客户端跳转?</strong></p><p>注意: <strong>ModeAndView的构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当没有模型数据要公开时，方便的构造函数。也可以与 &#123;<span class="doctag">@code</span> addObject&#125; 结合使用。 <span class="doctag">@param</span> viewName 要渲染的视图名称，由 DispatcherServlet 的 ViewResolver 解析 <span class="doctag">@see</span> addObject</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 即可以在创建ModelAndView对象时 没有设置返回的ViewName时 可以指定视图路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ModelAndView</span><span class="params">(String viewName)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.view = viewName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**方式一:**MyController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/jump&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">jump</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;redirect:/jump.jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以在创建 ModelAndView对象时指定重定向的资源(html、jsp、controller、servlet等)路径  </p><p>格式为 <strong>ModelAndView mav &#x3D; new ModelAndView(“redirect:&#x2F;资源路径”);</strong> 相当于服务器又发了一次请求但这个不能使用视图解析器 因为这是浏览器发来的另一次请求</p><p><strong>方式二:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/jump&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">jump</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        mav.setViewName(<span class="string">&quot;redirect:/jump.jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>方式三:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/jump&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">jump</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/jump.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><blockquote><p>​    1. 对于请求转发的页面，可以是WEB-INF中页面；而重定向的页面，是不能为WEB-INF中页的。因为重定向相当于用户再次发出一次请求，而用户是不能直接访问 WEB-INF 中资源的。</p></blockquote><hr><h2 id="解读-lt-url-pattern-gt"><a href="#解读-lt-url-pattern-gt" class="headerlink" title="解读&lt; url-pattern &gt;"></a><strong>解读&lt; url-pattern &gt;</strong></h2><h4 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h4><p><strong>（1） “*.xxx”</strong></p><p>​    以指定后缀结尾的请求都交由DispatcherServlet处理</p><p><strong>（2） “&#x2F;“</strong></p><p>​    “&#x2F;“将会 <strong>覆盖容器的default servlet</strong>, 凡是在web.xml文件中找不到匹配的URL，它们的访问请求都将交给该Servlet处理(静态资源也将会拦截). 所以web.xml没有配置其他特殊路径的servlet, 基本上 <strong>所有的请求</strong>都交由DispatcherServlet处理.但DispacherServlet是不能处理图片这样的静态资源的 但也有解决方法 但还是尽量让交给Tomcat去做</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220110145823608.png" alt="image-20220110145823608"></p><p><strong>（3）”&#x2F;*”</strong></p><p>​    <code>&#39;/*&#39;</code> <strong>错误的配置</strong>,会拦截 <code>*.jsp, *.jspx</code>的请求, 使用这种配置最终要转发到一个JSP页面,仍然会由DispatcherServlet, 解析jsp地址, 不能根据jsp页面找到handler, 会报错</p><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>发起的请求是由哪些服务器程序处理的。</p><p><a href="http://localhost:8080/ch05_url_pattern/index.jsp">http://localhost:8080/ch05_url_pattern/index.jsp</a> ：tomcat（jsp底层本质是Servlet）<br><a href="http://localhost:8080/ch05_url_pattern/js/jquery-3.4.1.js">http://localhost:8080/ch05_url_pattern/js/jquery-3.4.1.js</a> ： tomcat<br><a href="http://localhost:8080/ch05_url_pattern/images/p1.jpg">http://localhost:8080/ch05_url_pattern/images/p1.jpg</a> ： tomcat<br><a href="http://localhost:8080/ch05_url_pattern/html/test.html%EF%BC%9A">http://localhost:8080/ch05_url_pattern/html/test.html：</a> tomcat<br><a href="http://localhost:8080/ch05_url_pattern/some.do">http://localhost:8080/ch05_url_pattern/some.do</a> ：  DispatcherServlet（springmvc框架处理的）</p><p>tomcat本身能处理静态资源的访问， 像html， 图片， js文件都是静态资源</p><h4 id="Tomcat的default"><a href="#Tomcat的default" class="headerlink" title="Tomcat的default"></a>Tomcat的default</h4><p>tomcat的web.xml文件有一个servlet 名称是 default ， 在服务器启动时创建的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>listings<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  表示静态资源和未映射的请求都这个default处理</span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>default这个servlet作用：</strong> </p><blockquote><p>The default servlet for all web applications, that serves static<br>resources.  It processes all requests that are not mapped to other<br>servlets with servlet mappings (defined either here or in your own<br>web.xml file).</p><hr><p>所有 Web 应用程序的默认 servlet，提供静态服务<br>资源。它处理所有未映射到其他请求的请求<br>带有 servlet 映射的 servlet（在此处定义或在您自己的<br>web.xml 文件）。</p></blockquote><ol><li>处理静态资源(也就是说Tomcat服务器中的DefaultServlet会处理静态资源)</li><li>处理未映射到其它servlet的请求。</li></ol><h4 id="解决DisPatcherServlet-配置为”-x2F-“-无法处理图片等静态资源的问题"><a href="#解决DisPatcherServlet-配置为”-x2F-“-无法处理图片等静态资源的问题" class="headerlink" title="解决DisPatcherServlet 配置为”&#x2F;“ 无法处理图片等静态资源的问题"></a>解决DisPatcherServlet 配置为”&#x2F;“ 无法处理图片等静态资源的问题</h4><p><url-pattern/>的值并不是说写为&#x2F;后，静态资源就无法访问了。经过一些配置后，该问题也是可以解决的。(.jsp还是可以访问的)</p><p><strong>（1） 使用&lt; mvc:default-servlet-handler &#x2F;&gt;</strong></p><p>​    声 明 了 <strong>&lt;mvc:default-servlet-handler &#x2F;&gt;</strong> 后 ， springmvc 框 架 会 在 容 器 中 创 建DefaultServletHttpRequestHandler 处理器对象。它会像一个检查员，对进入 DispatcherServlet的 URL 进行筛查，如果发现是静态资源的请求，就将该请求转由 Web 应用服务器默认的Servlet 处理。一般的服务器都有默认的 Servlet。</p><p>​    在 Tomcat 中，有一个专门用于处理静态资源访问的 Servlet 名叫 DefaultServlet。其<servlet-name/>为 default。可以处理各种静态资源访问请求。该 Servlet 注册在 Tomcat 服务器的 web.xml 中。在 Tomcat 安装目录&#x2F;conf&#x2F;web.xml。</p><p><img src="https://upload-images.jianshu.io/upload_images/18868114-31aa480553735354.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/897/format/webp" alt="img"></p><p>​    项目：url-pattern-2。在项目 url-pattern 基础上修改。</p><p>​    只需要在 springmvc.xml 中添加&lt; mvc:default-servlet-handler&#x2F;&gt;标签即可。</p><p><img src="https://upload-images.jianshu.io/upload_images/18868114-6cea9309a84d3376.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/589/format/webp" alt="img"></p><p>​    &lt; mvc:default-servlet-handler&#x2F;&gt;表示使用 DefaultServletHttpRequestHandler 处理器对象。而该处理器调用了 Tomcat 的 DefaultServlet 来处理静态资源的访问请求。</p><p>当然了，要想使用&lt;mvc: …&#x2F;&gt;标签，需要引入 mvc 约束</p><p><img src="https://upload-images.jianshu.io/upload_images/18868114-f8b1be1ab1fc19ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/883/format/webp" alt="img"></p><p>​    该约束可从 Spring 帮助文档中搜索关键字 spring-mvc.xsd 即可获取：<br> docs&#x2F;spring-framework-reference&#x2F;htmlsingle&#x2F;index.html</p><p><strong>（2） 使用&lt; mvc:resources&#x2F;&gt;（掌握）</strong></p><p>项目：url-pattern-3。在项目 url-pattern 基础上修改。</p><p>​    在 Spring3.0 版本后，Spring 定义了专门用于处理静态资源访问请求的处理器ResourceHttpRequestHandler。并且添加了**&lt; mvc:resources&#x2F;&gt;**标签，专门用于解决静态资源无法访问问题。需要在 springmvc 配置文件中添加如下形式的配置：</p><p><img src="https://upload-images.jianshu.io/upload_images/18868114-9c8075b366097d7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/729/format/webp" alt="img"></p><p>​    location 表示静态资源(webapp-statics)所在目录。当然，目录不要使用&#x2F;WEB-INF&#x2F;及其子目录。</p><p>​    mapping 表 示 对 该 资 源 的 请 求 （ 以 &#x2F;images&#x2F; 开 始 的 请 求 ， 如 &#x2F;image&#x2F;beauty.jpg , &#x2F;images&#x2F;car.png 等）。注意，后面是两个星号**。</p><p><strong>（3） 声明注解驱动</strong></p><p>​    解决动态资源和静态资源冲突的问题，在 springmvc 配置文件加入：</p><p><img src="https://upload-images.jianshu.io/upload_images/18868114-9226df82b7068704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/463/format/webp" alt="img"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--为了解决静态资源和动态资源冲突的问题,可以加入 &lt;mvc:annotation-driven/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方案一 调用Tomcat的默认Servlet去实现静态资源的请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方案二 通过Springmvc框架去处理静态资源的请求 使用&lt; mvc:resources/&gt;且将静态资源放入webapp下的statics文件夹统一处理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;statics/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/statics/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><ol><li><p>使用”&#x2F;“符合当今流行的REST风格</p></li><li><p>处理静态资源文件时应该将尽可能交给Tomcat服务器去做  可以通过配置&lt; mvc:resources&#x2F;&gt;实现 </p></li><li><p>我们在配置DisPatcherServlet时 应该尽可能将他的<url-pattern>配置为”*.xxxx”的形式 减少DisPatcherServlet的处理压力 增强其功能</p></li></ol><hr><h2 id="相对与绝对路径的问题"><a href="#相对与绝对路径的问题" class="headerlink" title="相对与绝对路径的问题"></a><strong>相对与绝对路径的问题</strong></h2><p>在jsp ， html中使用的地址， 都是在前端页面中的地址，都是相对地址</p><p><strong>地址分类：</strong></p><ol><li><p>绝对地址 ， 带有协议名称的是绝对地址，  <a href="http://www.baidu.com/">http://www.baidu.com</a> , <a href="ftp://202.122.23.1/">ftp://202.122.23.1</a></p></li><li><p>相对地址， 没有协议开头的， 例如 user&#x2F;some.do  , &#x2F;user&#x2F;some.do<br>          相对地址不能独立使用，必须有一个参考地址。 通过参考地址+相对地址本身才能指定资源。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">张三同学， 1班有张三， 2班也有张三</span><br></pre></td></tr></table></figure><ol start="3"><li>参考地址<ol><li>在你的页面中的，访问地址不加 “&#x2F;“</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">访问的是： http://localhost:8080/ch06_path/index.jsp</span><br><span class="line">  路径： http://localhost:8080/ch06_path/</span><br><span class="line">资源： index.jsp</span><br><span class="line"></span><br><span class="line">在index.jsp发起 user/some.do请求，访问地址变为 http://localhost:8080/ch06_path/user/some.do</span><br><span class="line">   当你的地址 没有斜杠开头,例如 user/some.do , 当你点击链接时， 访问地址是当前页面的地址</span><br><span class="line">加上链接的地址。</span><br><span class="line">  http://localhost:8080/ch06_path/ + user/some.do</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> index.jsp  访问 user/some.do  ， 返回后现在的地址： http://localhost:8080/ch06_path/user/some.do</span><br><span class="line"></span><br><span class="line"> http://localhost:8080/ch06_path/user/some.do</span><br><span class="line"> 路径：  http://localhost:8080/ch06_path/user/</span><br><span class="line"> 资源：   some.do</span><br><span class="line"></span><br><span class="line"> 在index.jsp 再访问 user/some.do ，就变为 http://localhost:8080/ch06_path/user/user/some.do</span><br><span class="line"></span><br><span class="line"> 解决方案：</span><br><span class="line">  1.加入$&#123;pageContext.request.contextPath&#125;</span><br><span class="line">2.加入一个base标签， 是html语言中的标签。 表示当前页面中访问地址的基地址。</span><br><span class="line">  你的页面中所有 没有“/”开头的地址，都是以base标签中的地址为参考地址</span><br><span class="line">   使用base中的地址 + user/some.do 组成访问地址</span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>index.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a href=<span class="string">&quot;user/some.do&quot;</span>&gt;带有不带斜杠的发起请求&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MyController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user/some.do&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        mv.setViewName(<span class="string">&quot;/index.jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后出现如下问题</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>在你的页面中的，访问地址加 “&#x2F;“<br>    访问的是： <a href="http://localhost:8080/ch06_path/index.jsp">http://localhost:8080/ch06_path/index.jsp</a><br>   路径： <a href="http://localhost:8080/ch06_path/">http://localhost:8080/ch06_path/</a><br>       资源： index.jsp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">点击 /user/some.do, 访问地址变为 http://localhost:8080/user/some.do</span><br><span class="line">参考地址是 你的服务器地址， 也就是 http://localhost:8080</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果你的资源不能访问： 加入$&#123;pageContext.request.contextPath&#125;</span><br><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/some.do&quot;&gt;发起user/some.do的get请求&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>​    </p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h4><ol><li><p>前端页面中href&#x3D;””中最前方加入”&#x2F;“表示为绝对地址 即除去域名端口后的地址包括(&#x2F;项目名&#x2F;资源路径)</p></li><li><p>前端页面中href&#x3D;””中最前方不加入”&#x2F;“表示为相对地址 即在(1)的基础上还去除了项目名(资源路径)</p></li><li><p>为了避免使用相对路径出现<img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220110155717000.jpg" alt="image-20220110155717000">的错误可以使用绝对路径 </p><blockquote><ol><li>使用在前面加入完整路径的方式(<a href="http://localhost:8088/%E9%A1%B9%E7%9B%AE%E5%90%8D/%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84)%E7%9A%84%E6%96%B9%E5%BC%8F">http://localhost:8088/项目名/资源路径)的方式</a></li><li>在jsp页面中使用${pageContext.request.contextPath}&#x2F;</li><li>在jsp页面中使用<base href="http://localhost:8088/项目名/">的方式 他会在所有的请求路径之前加上base中的内容</li><li>但前三种始终是静态的 所以第四种为动态地获取 在jsp页面上方加入如下语句</li></ol><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    <span class="type">String</span> <span class="variable">basePath</span> <span class="operator">=</span> request.getScheme()+<span class="string">&quot;://&quot;</span></span><br><span class="line">            +request.getServerName()+<span class="string">&quot;:&quot;</span>+</span><br><span class="line">            request.getServerPort()+</span><br><span class="line">            request.getContextPath()+<span class="string">&quot;/&quot;</span>;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>再再base标签中配置&lt;%&#x3D;basePath%&gt;即可 与第三种的区别在于 第四种可以动态获取前方的地址</p><p>这些情况都是解决前端请求路径中不加入”&#x2F;“问题的处理方法</p><p>如果使用”&#x2F;“就上项目名即可</p></blockquote></li></ol><hr><h2 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a><strong>SSM整合</strong></h2><h4 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h4><p>SSM 编程，即 SpringMVC + Spring + MyBatis 整合，是当前最为流行的 JavaEE 开发技术架构。其实 SSM 整合的实质，仅仅就是将 MyBatis整合入 Spring。因为 SpringMVC原本就是 Spring的一部分，不用专门整合。</p><p>**第一个容器:**SpringMVC容器,管理Controller控制器对象的.</p><p>**第二个容器:**Spring容器,管理Service,Dao,工具类对象的.</p><p><strong>整合思路就是:</strong></p><ol><li><p>我们要将使用的对象交给合适的容器去创建、管理,把Controller还有web开发相关的对象交给SpringMVC容器，这些web用的对象写在SpringMVC配置文件中</p></li><li><p>service，dao对象定义在Spring的配置文件中，让spring创建和创建这些对象</p></li></ol><p><strong>关键：</strong>由于SpringMVC容器时Spring容器的子容器，类似于java中的继承 子是可以访问父的内容的。也就是说springmvc容器中的对象可以访问spring容器中的对象。</p><p><strong>SSM 整合的实现方式可分为两种：</strong>基于 XML 配置方式，基于注解方式。</p><h4 id="搭建-SSM-开发环境"><a href="#搭建-SSM-开发环境" class="headerlink" title="搭建 SSM 开发环境"></a>搭建 SSM 开发环境</h4><p><strong>一：</strong>搭建SSM开发环境需要 再maven中添加如下依赖</p><blockquote><ol><li><p>Servlet依赖 (J2EE WEB核心)</p></li><li><p>JSP依赖</p></li><li><p>SpringMVC依赖</p></li><li><p>Spring依赖</p></li><li><p>Mybatis依赖</p></li><li><p>jackson依赖</p></li><li><p>mysql依赖</p></li><li><p>druid依赖</p></li></ol></blockquote><p>需要添加的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--servlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--jsp--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--springmvc--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--spring事务的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--事务相关的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--jackson工具包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- spring-mybatis整合用到的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql驱动依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--druid连接池依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>build中需要添加的Resources</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>二：</strong>编写web.xml</p><blockquote><ol><li>创建DispatcherServlet,<ol><li>目的创建springmvc容器,才能船舰controller类对象</li><li>创建的时Servlet才能接收请求</li></ol></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册DispatcherServlet中央调度器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:conf/springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​     配置中央调度器时需要注意，SpringMVC的配置文件名与其它 Spring配置文件名不相同。这样做的目的是 Spring 容器创建管理 Spring 配置文件中的 bean， SpringMVC 容器中负责视图层 bean 的初始。</p><hr><ol start="2"><li>创建spring的监听器:ContextLoaderListener<ol><li>目的创建spring的容器对象,才能那个创建service,doo等对象.</li></ol></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册ContextLoadListener 监听器 用于初始化Spring容器的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:conf/spring.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    注册 ServletContext 监听器的实现类 ContextLoaderListener，用于创建 Spring 容器及将创建好的 Spring 容器对象放入到 ServletContext 的作用域中。</p><hr><ol start="3"><li>注册字符集过滤器,解决post请求乱码问题</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册请求字符集过滤器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceRequestEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    注册字符集过滤器，用于解决请求参数中携带中文时产生乱码问题。</p></blockquote><p>**三:**创建包,Controller包,service,dao,实体类包</p><p>**四:**Spring、SpringMVC、Mybatis配置文件</p><blockquote><ol><li>Spring配置文件</li><li>SpringMVC配置文件</li><li>Mybatis主配置文件</li><li>数据库的属性配置文件(.properties)</li></ol></blockquote><p>**五:**编写代码</p><ol><li><strong>写代码、dao接口、mapper配置文件</strong></li><li><strong>Service和实现类、controller、实体类</strong></li></ol><p><strong>六：</strong>写页面</p><h4 id="项目执行流程"><a href="#项目执行流程" class="headerlink" title="项目执行流程"></a>项目执行流程</h4><p>index.jsp–addStudent.jsp—student&#x2F;addStudent.do( service的方法，调用dao的方法)–result.jsp</p><hr><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h2><p><strong>异常处理：</strong><br>springmvc框架采用的是统一，全局的异常处理。<br>把controller中的所有异常处理都集中到一个地方。 采用的是aop的思想。把业务逻辑和异常处理代码分开。解耦合。</p><p>SpringMVC 框架处理异常的常用方式：使用**@ExceptionHandler** 注解处理异常和**@ControllerAdvice**</p><h4 id="ExceptionHandler-注解"><a href="#ExceptionHandler-注解" class="headerlink" title="@ExceptionHandler 注解"></a>@ExceptionHandler 注解</h4><blockquote><p>​    使用注解@ExceptionHandler 可以将一个方法指定为异常处理方法。该注解只有一个可选属性 value，为一个 Class&lt;?&gt;数组，用于指定该注解的方法所要处理的异常类，即所要匹配的异常。</p><p>​    对于异常处理注解的用法，也可以直接将异常处理方法注解于 Controller 之中。</p><p><strong>注意</strong>:如果指定参数那么只处理参数中指定的异常,如果参数为空，则默认为方法参数列表中列出的任何异常</p></blockquote><h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法:"></a>使用方法:</h5><blockquote><p>​    定义在Controller类的方法上(一般不用在由@RequestMapping的方法上),在方法上面加入**@ExceptionHandler 注解**并且根据需求指定参数即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doException</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    不过,一般不这样使用,而是将异常处理方法专门定义在一个类中,作为全局的异常处理类.    这时需要使用注解**@ControllerAdvice**</p></blockquote><h4 id="ControllerAdvice注解"><a href="#ControllerAdvice注解" class="headerlink" title="@ControllerAdvice注解"></a>@ControllerAdvice注解</h4><blockquote><p>​    字面理解就是“控制器增强”，是给控制器对象增强功能的。使用@ControllerAdvice 修饰的类中可以使用**@ExceptionHandler**。</p><p>​    当使用**@RequestMapping** 注解修饰的方法抛出异常时，会执行**@ControllerAdvice** 修饰的类中的异常处理方法。</p><p>​    <strong>@ControllerAdvice</strong> 是使用**@Component** 注解修饰的，可以&lt; context:component-scan&gt;扫描到@ControllerAdvice 所在的类路径(包名)，创建对象。</p></blockquote><h5 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法:"></a>使用方法:</h5><blockquote><p>定义在一个类的上面 然后里面的方法使用**@ExceptionHandler注解**, 表示异常处理方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionController</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doException</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringMVC.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用@ControllerAdvice注解需要注册注解驱动</span><br><span class="line"><span class="comment">&lt;!--声明组件扫描器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw.Controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw.Execp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注册注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a><strong>拦截器</strong></h2><h4 id="拦截器-1"><a href="#拦截器-1" class="headerlink" title="拦截器"></a>拦截器</h4><p>​    SpringMVC 中的 Interceptor 拦截器是非常重要和相当有用的，它的主要作用是拦截指定的用户请求，并进行相应的预处理与后处理。其拦截的时间点在“处理器映射器根据用户提交的请求映射出了所要执行的处理器类，并且也找到了要执行该处理器类的处理器适配器，在处理器适配器执行处理器之前”。当然，在处理器映射器映射出所要执行的处理器类时，已经将拦截器与处理器组合为了一个处理器执行链，并返回给了中央调度器。</p><h4 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h4><p>​    自定义拦截器，需要实现 HandlerInterceptor 接口。而该接口中含有三个方法：</p><blockquote><p>➢ <strong>preHandle(request,response, Object handler)：</strong><br> 该方法在处理器方法执行之前执行。其返回值为 boolean，若为 true，则紧接着会执行处理器方法，且会将 afterCompletion()方法放入到一个专门的方法栈中等待执行。</p><p>➢ <strong>postHandle(request,response, Object handler,modelAndView)：</strong><br> 该方法在处理器方法执行之后执行。处理器方法若最终未被执行，则该方法不会执行。由于该方法是在处理器方法执行完后执行，且该方法参数中包含 ModelAndView，所以该方法可以修改处理器方法的处理结果数据，且可以修改跳转方向。</p><p>➢ <strong>afterCompletion(request,response, Object handler, Exception ex)：</strong><br> 当 preHandle()方法返回 true 时，会将该方法放到专门的方法栈中，等到对请求进行响应的所有工作完成之后才执行该方法。即该方法是在中央调度器渲染（数据填充）了响应页面之后执行的，此时对 ModelAndView 再操作也对响应无济于事。</p><p><strong>afterCompletion 最后执行的方法，清除资源，例如在 Controller 方法中加入数据</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行MyInterceptor-------preHandle()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行MyInterceptor-------postHandle()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行MyInterceptor-------afterCompletion()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>拦截器中的方法与处理器方法的执行顺序如下：（会在请求到达处理器方法之前进行拦截的预处理，也会在处理器方法返回后响应前进行后处理）</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/18868114-b27c6ef989f87246.webp" alt="18868114-b27c6ef989f87246"></p><h4 id="注册拦截器"><a href="#注册拦截器" class="headerlink" title="注册拦截器"></a>注册拦截器</h4><p>需要在SpringMVC.xml配置文件中 注册拦截器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册拦截器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Interceptor.MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中 &lt; mvc:mapping&#x2F;&gt;用于指定当前所注册的拦截器可以拦截的请求路径，而&#x2F;**表示拦截所有请求。</p><p>MyController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/some.do&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">doSome</span><span class="params">(String name, Integer age, HttpSession session)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行MyController处理器方法&quot;</span>);</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;myname&quot;</span>,name);</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;myage&quot;</span>,age);</span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;atter&quot;</span>,<span class="string">&quot;session中的数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220110213638275.png" alt="image-20220110213638275"></p><h4 id="多个拦截器的执行"><a href="#多个拦截器的执行" class="headerlink" title="多个拦截器的执行"></a>多个拦截器的执行</h4><p>再创建一个拦截器 Myinterceptor2.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor2</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;124&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;125&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个拦截器可以注册再一个&lt; mvc:interceptors&gt;&lt; &#x2F;mvc:interceptors&gt;中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册多个拦截器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Interceptor.MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Interceptor.MyInterceptor2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行情况：</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220110214156717.png" alt="image-20220110214156717"></p><p><strong>可以推断出 一个请求的拦截会依次经过注册的拦截器 且拦截器的处理顺序与注册顺序有关</strong></p><blockquote><p>当有多个拦截器时，形成拦截器链。拦截器链的执行顺序，与其注册顺序一致。需要再次强调一点的是，当某一个拦截器的 preHandle()方法返回 true 并被执行到时，会向一个专门的方法栈中放入该拦截器的 afterCompletion()方法。</p></blockquote><p>多个拦截器中方法与处理器方法的执行顺序如下：</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/18868114-97a75714642e9b19.png" alt="img"></p><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>我们将第一个拦截器的preHandle（）方法返回值设为false</p><p>执行结果</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220110214845745.png" alt="image-20220110214845745"></p><p>可以发现 后面的的Interceptor没有执行结合上图（多个拦截器执行情况图）可知 只要有一个 preHandle()方法返回 false，则上部的执行链将被断开，其后续的处理器方法与 postHandle()方法将无法执行。但，无论执行链执行情况怎样，只要方法栈中有方法，即执行链中只要有 preHandle()方法返回 true，就会执行方法栈中的afterCompletion()方法。最终都会给出响应。</p><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>可以用作检查用户权限 当用户访问一个资源时可以通过注册拦截器的方式 去检测用户的权限、用户登录处理和记录日志</p><p>例如：只有经过登录的用户方可访问处理器，否则，将返回“无权访问”提示。</p><h4 id="解惑："><a href="#解惑：" class="headerlink" title="解惑："></a>解惑：</h4><p><strong>拦截器与过滤器的区别：</strong></p><ol><li><p>过滤器是servlet中的对象，  拦截器是框架中的对象</p></li><li><p>过滤器实现Filter接口的对象， 拦截器是实现HandlerInterceptor</p></li><li><p>过滤器是用来设置request，response的参数，属性的，侧重对数据过滤的。<br>拦截器是用来验证请求的，能截断请求。</p></li><li><p>过滤器是在拦截器之前先执行的。</p></li><li><p>过滤器是tomcat服务器创建的对象<br>拦截器是springmvc容器中创建的对象</p></li><li><p>过滤器是一个执行时间点。<br>  拦截器有三个执行时间点</p></li><li><p>过滤器可以处理jsp，js，html等等<br>拦截器是侧重拦截对Controller的对象。 如果你的请求不能被DispatcherServlet接收， 这个请求不会执行拦截器内容</p></li><li><p>拦截器拦截普通类方法执行，过滤器过滤servlet请求响应</p></li></ol><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p><strong>拦截器：</strong></p><ol><li>拦截器是springmvc中的一种，需要实现HandlerInterceptor接口。</li><li>拦截器和过滤器类似，功能方向侧重点不同。 过滤器是用来过滤器请求参数，设置编码字符集等工作。<br>拦截器是拦截用户的请求，做请求做判断处理的。</li><li>拦截器是全局的，可以对多个Controller做拦截。 一个项目中可以有0个或多个拦截器， 他们在一起拦截用户的请求。<br>拦截器常用在：用户登陆验证，权限验证，日志记录</li></ol><p><strong>拦截器的使用步骤：</strong><br> 1.定义类实现HandlerInterceptor接口<br> 2.在springmvc配置文件中，声明拦截器， 让框架知道拦截器的存在。</p><p><strong>拦截器的执行时间：</strong><br>  1）在请求处理之前， 也就是controller类中的方法执行之前先被拦截。<br>  2）在控制器方法执行之后也会执行拦截器。<br>  3）在请求处理完成后也会执行拦截器。</p><p><strong>拦截器：看做是多个Controller中公用的功能，集中到拦截器统一处理。使用的aop的思想</strong></p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SpringMVC&quot;&gt;&lt;a href=&quot;#SpringMVC&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC&quot;&gt;&lt;/a&gt;&lt;strong&gt;SpringMVC&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;SpringMVC：是基于spring的一个框架， 实际上就是spring的一个模块， 专门是做web开发的。&lt;br&gt;           理解是servlet的一个升级&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   web开发底层是servlet ， 框架是在servlet基础上面加入一些功能，让你做web开发方便。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SpringMVC就是一个Spring。 Spring是容器，ioc能够管理对象，使用&lt;bean&gt;, @Component, @Repository, @Service, @Controller&lt;br&gt;  SpringMVC能够创建对象， 放入到容器中（SpringMVC容器）， springmvc容器中放的是控制器对象，&lt;/p&gt;
&lt;p&gt;  我们要做的是 使用@Contorller创建控制器对象， 把对象放入到springmvc容器中， 把创建的对象作为控制器使用&lt;br&gt;  这个控制器对象能接收用户的请求， 显示处理结果，就当做是一个servlet使用。&lt;/p&gt;
&lt;p&gt;  使用@Controller注解创建的是一个普通类的对象， 不是Servlet。 springmvc赋予了控制器对象一些额外的功能。&lt;/p&gt;
&lt;p&gt;  web开发底层是servlet， springmvc中有一个对象是Servlet ：DispatcherServlet(中央调度器)&lt;br&gt;  DispatcherServlet: 负责接收用户的所有请求， 用户把请求给了DispatherServlet， 之后DispatcherServlet把请求转发给&lt;br&gt;                    我们的Controller对象， 最后是Controller对象处理请求。&lt;/p&gt;
&lt;p&gt;​</summary>
    
    
    
    <category term="spring框架" scheme="https://devildyw.github.io/categories/spring%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="java" scheme="https://devildyw.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis/Mybatis-Plus</title>
    <link href="https://devildyw.github.io/2022/02/28/MyBatis/"/>
    <id>https://devildyw.github.io/2022/02/28/MyBatis/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-03-06T15:57:47.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a><strong>MyBatis</strong></h1><h2 id="第一章-ssm-x3D-spring-springmvc-mybatis"><a href="#第一章-ssm-x3D-spring-springmvc-mybatis" class="headerlink" title="第一章(ssm &#x3D; spring + springmvc + mybatis)"></a><strong>第一章(ssm &#x3D; spring + springmvc + mybatis)</strong></h2><ol><li>三层架构<br>界面层： 和用户打交道的， 接收用户的请求参数， 显示处理结果的。（jsp ，html ，servlet）<br>业务逻辑层： 接收了界面层传递的数据，计算逻辑，调用数据库，获取数据<br>数据访问层： 就是访问数据库， 执行对数据的查询，修改，删除等等的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">三层对应的包</span><br><span class="line">  界面层： controller包 （servlet）</span><br><span class="line">  业务逻辑层： service 包（XXXService类）</span><br><span class="line">  数据访问层： dao包（XXXDao类）</span><br></pre></td></tr></table></figure><pre><code> 三层中类的交互   用户使用界面层--&gt; 业务逻辑层---&gt;数据访问层（持久层）--&gt;数据库（mysql）</code></pre><p>​     三层对应的处理框架<br>​       界面层—servlet—springmvc（框架）<br>​       业务逻辑层—service类–spring（框架）<br>​       数据访问层—dao类–mybatis（框架）</p>  <span id="more"></span><p> 2.框架<br>   框架是一个舞台， 一个模版</p><p>   模版：<br>     1. 规定了好一些条款，内容。<br>          2. 加入自己的东西</p><p>   框架是一个模块<br>    1.框架中定义好了一些功能。这些功能是可用的。<br>    2.可以加入项目中自己的功能， 这些功能可以利用框架中写好的功能。</p><p>   框架是一个软件，半成品的软件，定义好了一些基础功能， 需要加入你的功能就是完整的。<br>   基础功能是可重复使用的，可升级的。</p><p>   框架特点：<br>    1. 框架一般不是全能的， 不能做所有事情<br>        2. 框架是针对某一个领域有效。 特长在某一个方面，比如mybatis做数据库操作强，但是他不能做其它的。<br>        3. 框架是一个软件</p><p> mybatis框架<br>   一个框架，早期叫做ibatis,  代码在github。<br>   mybatis是 MyBatis SQL Mapper Framework for Java （sql映射框架）<br>   1）sql mapper :sql映射<br>         可以把数据库表中的一行数据  映射为 一个java对象。<br>     一行数据可以看做是一个java对象。操作这个对象，就相当于操作表中的数据</p><p>   2） Data Access Objects（DAOs） : 数据访问 ， 对数据库执行增删改查。</p><p> mybatis提供了哪些功能：</p><ol><li>提供了创建Connection ,Statement, ResultSet的能力 ，不用开发人员创建这些对象了</li><li>提供了执行sql语句的能力， 不用你执行sql</li><li>提供了循环sql， 把sql的结果转为java对象， List集合的能力<br> while (rs.next()) {<br>   Student stu &#x3D; new Student();<br>   stu.setId(rs.getInt(“id”));<br>   stu.setName(rs.getString(“name”));<br>   stu.setAge(rs.getInt(“age”));<br>   &#x2F;&#x2F;从数据库取出数据转为 Student 对象，封装到 List 集合<br>   stuList.add(stu);<br> }</li></ol><pre><code>4.提供了关闭资源的能力，不用你关闭Connection, Statement, ResultSet</code></pre><p> 开发人员做的是： 提供sql语句<br> 最后是： 开发人员提供sql语句–mybatis处理sql—开发人员得到List集合或java对象（表中的数据）</p><p> 总结：<br>  mybatis是一个sql映射框架，提供的数据库的操作能力。增强的JDBC,<br>  使用mybatis让开发人员集中精神写sql就可以了，不必关心Connection,Statement,ResultSet<br>  的创建，销毁，sql的执行。 </p><h2 id="第二章："><a href="#第二章：" class="headerlink" title="第二章："></a><strong>第二章：</strong></h2><p>  1 主要类的介绍<br>   1） Resources： mybatis中的一个类， 负责读取主配置文件<br>      InputStream in &#x3D; Resources.getResourceAsStream(“mybatis.xml”);</p><pre><code>2)SqlSessionFactoryBuilder : 创建SqlSessionFactory对象，      SqlSessionFactoryBuilder builder  = new SqlSessionFactoryBuilder();    //创建SqlSessionFactory对象    SqlSessionFactory factory = builder.build(in);</code></pre><p>  3）SqlSessionFactory ： 重量级对象， 程序创建一个对象耗时比较长，使用资源比较多。<br>        在整个项目中，有一个就够用了。</p><pre><code> SqlSessionFactory:接口  ， 接口实现类： DefaultSqlSessionFactory  SqlSessionFactory作用： 获取SqlSession对象。SqlSession sqlSession = factory.openSession();  openSession()方法说明：   1. openSession() ：无参数的， 获取是非自动提交事务的SqlSession对象    2. openSession(boolean): openSession(true)  获取自动提交事务的SqlSession.                              openSession(false)  非自动提交事务的SqlSession对象</code></pre><p> 4)SqlSession:<br>   SqlSession接口 ：定义了操作数据的方法 例如 selectOne() ,selectList() ,insert(),update(), delete(), commit(), rollback()<br>   SqlSession接口的实现类DefaultSqlSession。</p><pre><code>使用要求： SqlSession对象不是线程安全的，需要在方法内部使用， 在执行sql语句之前，使用openSession()获取SqlSession对象。在执行完sql语句后，需要关闭它，执行SqlSession.close(). 这样能保证他的使用是线程安全的。</code></pre><h2 id="第三章："><a href="#第三章：" class="headerlink" title="第三章："></a><strong>第三章：</strong></h2><ol><li><p>动态代理： 使用SqlSession.getMapper(dao接口.class) 获取这个dao接口的对象</p></li><li><p>传入参数： 从java代码中把数据传入到mapper文件的sql语句中。<br>1）parameterType ： 写在mapper文件中的 一个属性。 表示dao接口中方法的参数的数据类型。<br>例如StudentDao接口<br> public Student  selectStudentById(Integer id) </p><ol start="2"><li>一个简单类型的参数：<br>简单类型： mybatis把java的基本数据类型和String都叫简单类型。<br>在mapper文件获取简单类型的一个参数的值，使用 #{任意字符}</li></ol><p> 接口：public Student  selectStudentById(Integer id)<br> mapper:select id,name, email,age from student where id&#x3D;#{studentId}</p></li></ol><pre><code>3) 多个参数，使用@Param命名参数  接口 public List&lt;Student&gt; selectMulitParam(@Param(&quot;myname&quot;) String name, @Param(&quot;myage&quot;) Integer age)  使用  @Param(&quot;参数名&quot;)  String name  mapper文件：     &lt;select&gt;         select * from student where name=#&#123;myname&#125; or age=#&#123;myage&#125;      &lt;/select&gt;4) 多个参数，使用java对象   语法 #&#123;属性名&#125;</code></pre><p>   vo: value object , 放一些存储数据的类。比如说 提交请求参数， name ,age<br>         现在想把name ,age 传给一个service 类。</p><p>   vo: view object , 从servlet把数据返回给浏览器使用的类，表示显示结果的类。</p><p>   pojo: 普通的有set， get方法的java类。 普通的java对象</p><pre><code>      Servlet --- StudentService( addStudent( MyParam  param)  )</code></pre><p>   entity（domain域）: 实体类， 和数据库中的表对应的类， </p><pre><code>5) # 和  $  select id,name, email,age from student where id=#&#123;studentId&#125;  # 的结果： select id,name, email,age from student where id=?    select id,name, email,age from student where id=$&#123;studentId&#125;  $ 的结果：select id,name, email,age from student where id=1001  String sql=&quot;select id,name, email,age from student where id=&quot; + &quot;1001&quot;;  使用的Statement对象执行sql， 效率比PreparedStatement低。  $:可以替换表名或者列名， 你能确定数据是安全的。可以使用$  # 和 $区别  1. #使用 ？在sql语句中做站位的， 使用PreparedStatement执行sql，效率高  2. #能够避免sql注入，更安全。  3. $不使用占位符，是字符串连接方式，使用Statement对象执行sql，效率低  4. $有sql注入的风险，缺乏安全性。  5. $:可以替换表名或者列名</code></pre><ol start="3"><li><p>mybatis的输出结果<br>mybatis执行了sql语句，得到java对象。</p><p> 1）resultType结果类型， 指sql语句执行完毕后， 数据转为的java对象， java类型是任意的。<br>   resultType结果类型的它值 1. 类型的全限定名称   2. 类型的别名， 例如 java.lang.Integer别名是int</p><pre><code>处理方式：   1. mybatis执行sql语句， 然后mybatis调用类的无参数构造方法，创建对象。    2. mybatis把ResultSet指定列值付给同名的属性。    &lt;select id=&quot;selectMultiPosition&quot; resultType=&quot;com.bjpowernode.domain.Student&quot;&gt;  select id,name, email,age from student&lt;/select&gt;  对等的jdbc  ResultSet rs = executeQuery(&quot; select id,name, email,age from student&quot; )  while(rs.next())&#123;       Student  student = new Student();            student.setId(rs.getInt(&quot;id&quot;));            student.setName(rs.getString(&quot;name&quot;))  &#125;</code></pre></li></ol><ol start="2"><li>定义自定义类型的别名<br> 1）在mybatis主配置文件中定义，使<typeAlias>定义别名<br>  2）可以在resultType中使用自定义别名</li></ol><p>   3）resultMap:结果映射， 指定列名和java对象的属性对应关系。<br>        1）你自定义列值赋值给哪个属性<br>         2）当你的列名和属性名不一样时，一定使用resultMap</p><pre><code>     resultMap和resultType不要一起用，二选一</code></pre><p>dao接口中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示使用ResultMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> List&lt;Student&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;Student&gt; <span class="title function_">selectStudents</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>StudentDao.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用ResultMap 必须先定义ResultMap</span></span><br><span class="line"><span class="comment">可以防止实体类中的属性名与数据库表中的列名的不同的囧境--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--定义ResultMap--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.dyw.Domain.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--主键列使用 id标签</span></span><br><span class="line"><span class="comment">        column 表的列名</span></span><br><span class="line"><span class="comment">        property java类型的属性名</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--非主键列使用result标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudents&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentMap&quot;</span>&gt;</span></span><br><span class="line">    select id,name,age from student order by id;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>输出:</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220111153344824.png" alt="image-20220111153344824"></p><p><strong>注意</strong>:如果Dao接口使用Map作为返回结果的话 需要在ResultType中配置Map的全限定名称 而不是实体类的名称(如果返回值为List则依旧使用实体类的全限定名称) 并且返回的结果是以列名作为键 列值作为值  </p><h2 id="第四章动态sql"><a href="#第四章动态sql" class="headerlink" title="第四章动态sql"></a><strong>第四章动态sql</strong></h2><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询:"></a>模糊查询:</h4><p>​    **like:**在dao.xml配置文件中 直接使用like即可 当使用#{}拼接时 我们前面说过 他是以占位符?(即preparedStatement)所以格式为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--模糊查询的两种方式</span></span><br><span class="line"><span class="comment">        1.直接传入一个字符串 类似与%丁%</span></span><br><span class="line"><span class="comment">        2.使用字符串拼接</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentsByLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.dyw.Domain.Student&quot;</span>&gt;</span></span><br><span class="line">        select id,name,age from student where name like &quot;%&quot; #&#123;name&#125; &quot;%&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">底层为</span><br><span class="line"><span class="comment">&lt;!--Preparing: select id,name,age from student where name like &quot;%&quot; ? &quot;%&quot;--&gt;</span></span><br></pre></td></tr></table></figure><p>​    但是使用${}时不一样它是使用Statement即字符串拼接 所以格式为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentsByLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.dyw.Domain.Student&quot;</span>&gt;</span></span><br><span class="line">        select id,name,age from student where name like &quot;%$&#123;name&#125;%&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">底层</span><br><span class="line"><span class="comment">&lt;!--Preparing: select id,name,age from student where name like &quot;%丁%&quot;--&gt;</span></span><br></pre></td></tr></table></figure><p> 动态sql: sql的内容是变化的，可以根据条件获取到不同的sql语句。<br>           主要是where部分发生变化。</p><p> 动态sql的实现，使用的是mybatis提供的标签， <if> ,<where>,<foreach></p><p> 1)<if>是判断条件的，<br>   语法<if test="判断java对象的属性值"><br>            部分sql语句<br>        </if></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用标签&lt;if&gt;可以判断条件 如果条件满足要求则将条件拼接在where后 可以防止sql运行时报错--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    多个if拼接的时候一般在where后面加一个1=1 保证拼接时不会出错</span></span><br><span class="line"><span class="comment">        注意使用动态sql语句 一定要传java对象作为参数</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentsByLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.dyw.Domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select id,name,age from student</span><br><span class="line">        where 1=1</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name !=null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and name like #&#123;name&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age &gt; 0&quot;</span>&gt;</span></span><br><span class="line">            and age &gt; #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但这样有弊端，就是为了避免拼接错误，需要使用or 1&#x3D;1， 但是这样又会导致另一个错误，那就是可以会将所有的内容都查出来，这是我们不想看到的。</p><p> 2)<where> 用来包含 多个<if>的， 当多个if有一个成立的， <where>会自动增加一个where关键字，<br>            并去掉 if中多余的 and ，or等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用where标签时就不会出现拼接错误现象 底层会自动判别然后进行拼接 可以自动去除and or等连接词比直接用&lt;if&gt;安全性好--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentsByLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.dyw.Domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select id,name,age from student</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null and name !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and name like #&#123;name&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age &gt; 0&quot;</span>&gt;</span></span><br><span class="line">            and age &gt;#&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    使用&lt; where&gt;标签就不会出现上述&lt; if&gt;的情况 &lt; where&gt;标签可以智能帮助我们去除and or 等 防止拼接错误</p><p> 3）<foreach> 循环java中的数组，list集合的。 主要用在sql的in语句中。(用于当传入的参数为集合时 为了获取里面的数据)<br>    学生id是 1001,1002,1003的三个学生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select * from student where id <span class="title function_">in</span> <span class="params">(<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">selectFor</span><span class="params">(List&lt;Integer&gt; idlist)</span></span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ...</span><br><span class="line">list.add(<span class="number">1001</span>);</span><br><span class="line">list.add(<span class="number">1002</span>);</span><br><span class="line">list.add(<span class="number">1003</span>);</span><br><span class="line"></span><br><span class="line">dao.selectFor(list)</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;&quot;</span> <span class="attr">item</span>=<span class="string">&quot;&quot;</span> <span class="attr">open</span>=<span class="string">&quot;&quot;</span> <span class="attr">close</span>=<span class="string">&quot;&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">         #&#123;xxx&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"></span><br><span class="line">collection:表示接口中的方法参数的类型， 如果是数组使用array , 如果是list集合使用list</span><br><span class="line"> item:自定义的，表示数组和集合成员的变量</span><br><span class="line"> open:循环开始是的字符</span><br><span class="line"> close:循环结束时的字符</span><br><span class="line">separator:集合成员之间的分隔符</span><br></pre></td></tr></table></figure><p>  4）sql代码片段， 就是复用一些语法<br>    步骤<br>     1.先定义 <sql id="自定义名称唯一">  sql语句， 表名，字段等 </sql><br>    2.再使用， <include refid="id的值" /></p><h2 id="第五章："><a href="#第五章：" class="headerlink" title="第五章："></a><strong>第五章：</strong></h2><ol><li>数据库的属性配置文件： 把数据库连接信息放到一个单独的文件中。 和mybatis主配置文件分开。<br>目的是便于修改，保存，处理多个数据库的信息。<br><!--便于维护,管理与使用--><ol><li><p>在resources目录中定义一个属性配置文件， xxxx.properties ,例如 jdbc.properties<br>   在属性配置文件中， 定义数据，格式是 key&#x3D;value<br>     key： 一般使用 . 做多级目录的。<br>     例如 jdbc.mysql.driver    , jdbc.driver, mydriver<br>     jdbc.driver&#x3D;com.mysql.jdbc.Driver<br>     jdbc.url&#x3D;jdbc:mysql&#x2F;&#x2F;…..<br>     jdbc.username&#x3D;root<br>     jdbc.password&#x3D;123456</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定properties文件路径 从类路径根开始查找--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>​     </p></li><li><p>在mybatis的主配置文件，使用<property> 指定文件的位置<br> 在需要使用值的地方， ${key}</p></li></ol></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.user&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p> 2.mapper文件，使用package指定路径<br>    在MyBatis-config文件中可以指定多个mapper文件 第一个中方式直接在<mappers></mappers>中加入多个<mapper/><br>    注意mapper的路径从类路径的根开始(target&#x2F;classes)<br>     <mappers></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!--第二种方式： 使用包名</span></span><br><span class="line"><span class="comment">        name: xml文件（mapper文件）所在的包名, 这个包中所有xml文件一次都能加载给mybatis</span></span><br><span class="line"><span class="comment">        使用package的要求：</span></span><br><span class="line"><span class="comment">         1. mapper文件名称需要和接口名称一样， 区分大小写的一样</span></span><br><span class="line"><span class="comment">         2. mapper文件和dao接口需要在同一目录</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.bjpowernode.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="第六章：PageHelper"><a href="#第六章：PageHelper" class="headerlink" title="第六章：PageHelper"></a><strong>第六章：PageHelper</strong></h2><p> <strong>PageHelper做数据分页的。</strong>(国人写的)</p><ol><li><p>maven中添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在MyBatis-config中配置插件<br>注意:<strong>MyBatis-config配置顺序如下properties, settings,plugins</strong>;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在&lt;plugins&gt;标签中配置--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置pageHelper插件放在setting后面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置完成后在使用时调用 pagehelper.startpage(页码(int),每页显示条数(int))方法 注意放在执行sql语句之前 输出会自动显示参数指定的几条</p></li></ol><hr><h2 id="MyBatis的缓存机制"><a href="#MyBatis的缓存机制" class="headerlink" title="MyBatis的缓存机制"></a><strong>MyBatis的缓存机制</strong></h2><p>​                                                                            <a href="https://segmentfault.com/a/1190000041193993">https://segmentfault.com/a/1190000041193993</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">缓存机制减轻数据库压力，提高数据库性能</span><br><span class="line">mybatis的缓存分为两级：一级缓存、二级缓存</span><br></pre></td></tr></table></figure><h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存:"></a><strong>一级缓存</strong>:</h4><p>​    一级缓存为 <code>sqlsession</code> 缓存，缓存的数据只在 SqlSession 内有效。在操作数据库的时候需要先  创建 SqlSession 会话对象，在对象中有一个 HashMap 用于存储缓存数据，此 HashMap 是当前    会话对象私有的，别的 SqlSession 会话对象无法访问。</p><p>​    具体流程：</p><p>​    第一次执行 select 完毕会将查到的数据写入 <strong>SqlSession</strong> 内的 <strong>HashMap</strong> 中缓存起来</p><p>​    第二次执行(可能多次) select 会从<strong>缓存</strong>中查数据，如果 select 同传参数一样，那么就能从缓存中返回数据，不用去数据库了，从而提高了效率</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h4><p>​    1、如果 在<strong>同</strong>一个SqlSession 执行了 DML 操作（insert、update、delete），并 commit 了，那么 mybatis 就会清空当前 SqlSession 缓存中的所有缓存数据，这样可以保证缓存中的存的数据永远和数据库中一致，避免出现差异</p><p>​    2、当一个 SqlSession 结束后那么他里面的一级缓存也就不存在了， mybatis 默认是开启一级缓存且默认作用范围时SESSION，也可以手动配置为STATEMENT(让一级缓存仅针对当前执行的<code>SQL</code>语句生效；)，不需要配置二级缓存默认时没有开启的为false 需要手动在Mybatis-config中配置(<setting></setting>中)</p><p>​    3、 mybatis 的缓存是基于 [namespace:sql语句:参数] 来进行缓存的，意思就是， SqlSession 的 HashMap 存储缓存数据时，是使用 [namespace:sql:参数] 作为 key ，查询返回的语句作为 value 保存的,**即{key&#x3D;namespace:sql:参数，value&#x3D;查询到的数据}**。</p><p>​    4. 不同会话持有不同的一级缓存，本会话内的操作不会影响其它会话内的一级缓存。</p><h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a><strong>二级缓存</strong></h4><p>二级缓存是<code> mapper</code> 级别的缓存，也就是同一个 namespace 的 mapper.xml ，当多个 SqlSession 使用同一个 Mapper 操作数据库的时候，得到的数据会缓存在同一个二级缓存区域</p><p>二级缓存默认是没有开启的。需要在 setting 全局参数中配置开启二级缓存</p><p>开启二级缓存步骤：</p><p>1、<code>conf.xml</code> 配置全局变量开启二级缓存</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>默认是false：关闭二级缓存</span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、在<code>userMapper.xml</code>中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">&quot;LRU&quot;</span> <span class="attr">type</span>=<span class="string">&quot;org.apache.ibatis.cache.impl.PerpetualCache&quot;</span> <span class="attr">flushInterval</span>=<span class="string">&quot;60000&quot;</span> <span class="attr">size</span>=<span class="string">&quot;512&quot;</span> <span class="attr">readOnly</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>当前mapper下所有语句开启二级缓存</span><br></pre></td></tr></table></figure><p>这里配置了一个 LRU 缓存，并每隔60秒刷新，最大存储512个对象，而返回的对象是只读的</p><p>若想禁用当前<code>select</code>语句的二级缓存，添加 <code>useCache=&quot;false&quot;</code>修改如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getCountByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.Map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;INTEGER&quot;</span> <span class="attr">statementType</span>=<span class="string">&quot;CALLABLE&quot;</span> <span class="attr">useCache</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>具体流程：</p><p>1.当一个<code>sqlseesion</code>执行了一次<code> select</code> 后，在关闭此<code> session</code> 的时候，会将查询结果缓存到二级缓存</p><p>2.当另一个<code>sqlsession</code>执行<code> select</code> 时，（前提二级缓存开启时）首先会在他自己的二级缓存中找，如果没找到，就回去一级缓存中找，找到了就返回，就不用去数据库了，从而减少了数据库压力提高了性能</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><ol><li><p>如果 <code>SqlSession</code> 执行了 DML 操作<code>（insert、update、delete）</code>，并 <code>commit</code> 了，那么 <code>mybatis</code> 就会清空当前<code> mapper</code> 缓存中的所有缓存数据，这样可以保证缓存中的存的数据永远和数据库中一致，避免出现差异（如果没有commit）就不会清空mybatis中的二级缓存</p></li><li><p><code> mybatis</code> 的缓存是基于<code>[namespace:sql语句:参数]</code>来进行缓存的，意思就是，<code>SqlSession</code> 的 <code>HashMap</code> 存储缓存数据时，是使用 <code>[namespace:sql:参数] </code>作为 <code>key</code> ，查询返回的语句作为 <code>value</code> 保存的。</p></li><li><p><code>Mybatis</code>中需要在映射文件中添加<code>&lt;cache&gt;</code>标签来为映射文件配置二级缓存，也可以在映射文件中添加<code>&lt;cache-ref&gt;</code>标签来引用其它映射文件的二级缓存以达到多个映射文件持有同一份二级缓存的效果。</p></li><li><p><cache-ref namespace="com.mybatis.learn.dao.BookMapper"/>该语句可以在另一个mybatis-mapper中指定二级缓存（一个mapper拥有一个二级缓存 这里指定了缓存的指向）这样两个mapper可以共享一个二级缓存</p><hr></li></ol><p><strong><code>&lt;cache&gt;</code>标签如下所示。</strong></p><table><thead><tr><th>属性</th><th>含义</th><th>默认值</th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>eviction</strong></td><td>缓存淘汰策略。<strong>LRU</strong>表示最近使用频次最少的优先被淘汰；<strong>FIFO</strong>表示先被缓存的会先被淘汰；<strong>SOFT</strong>表示基于软引用规则来淘汰；<strong>WEAK</strong>表示基于弱引用规则来淘汰</td><td><strong>LRU</strong></td><td></td><td></td><td></td></tr><tr><td><strong>flushInterval</strong></td><td>缓存刷新间隔。单位毫秒</td><td>空，表示永不过期</td><td></td><td></td><td></td></tr><tr><td><strong>type</strong></td><td>缓存的类型</td><td><code>PerpetualCache</code>(永久缓存)</td><td></td><td></td><td></td></tr><tr><td><strong>size</strong></td><td>最多缓存的对象个数</td><td>1024</td><td></td><td></td><td></td></tr><tr><td><strong>blocking</strong></td><td>缓存未命中时是否阻塞</td><td><strong>false</strong></td><td></td><td></td><td></td></tr><tr><td><strong>readOnly</strong></td><td>缓存中的对象是否只读。配置为<strong>true</strong>时，表示缓存对象只读，命中缓存时会直接将缓存的对象返回，性能更快，但是线程不安全；配置为<strong>false</strong>时，表示缓存对象可读写，命中缓存时会将缓存的对象克隆然后返回克隆的对象，性能更慢，但是线程安全</td><td><strong>false</strong></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th align="left">属性</th><th>含义</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td align="left"><strong>namespace</strong></td><td>其它映射文件的命名空间，设置之后则当前映射文件将和其它映射文件将持有同一份二级缓存</td><td></td><td></td><td></td><td></td></tr><tr><td align="left"></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h1 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a><strong>MyBatis-Plus</strong></h1><p><strong>注意</strong>：引入 <code>MyBatis-Plus</code> 之后请不要再次引入 <code>MyBatis</code> 以及 <code>MyBatis-Spring</code>，以避免因版本差异导致的问题。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus (opens new window)</a>（简称 MP）是一个 <a href="https://www.mybatis.org/mybatis-3/">MyBatis (opens new window)</a>的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><blockquote><p> 愿景</p><p>我们的愿景是成为 MyBatis 最好的搭档，就像 <a href="https://www.mybatis-plus.com/img/contra.jpg">魂斗罗</a> 中的 1P、2P，基友搭配，效率翻倍。</p></blockquote><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h3 id="支持数据库"><a href="#支持数据库" class="headerlink" title="#支持数据库"></a><a href="https://www.mybatis-plus.com/guide/#%E6%94%AF%E6%8C%81%E6%95%B0%E6%8D%AE%E5%BA%93">#</a>支持数据库</h3><blockquote><p>任何能使用 <code>mybatis</code> 进行 CRUD, 并且支持标准 SQL 的数据库，具体支持情况如下，如果不在下列表查看分页部分教程 PR 您的支持。</p></blockquote><ul><li>mysql，oracle，db2，h2，hsql，sqlite，postgresql，sqlserver，Phoenix，Gauss ，clickhouse，Sybase，OceanBase，Firebird，cubrid，goldilocks，csiidb</li><li>达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库</li></ul><h3 id="框架结构"><a href="#框架结构" class="headerlink" title="#框架结构"></a><a href="https://www.mybatis-plus.com/guide/#%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84">#</a>框架结构</h3><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/mybatis-plus-framework.jpg" alt="framework"></p><p><strong>就是在mybatis的基础上再次简化操作 让原来需要程序员写的curd代码都节省了</strong> 同时还优化了性能</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a><strong>快速开始</strong></h2><h4 id="一：创建一个boot工程（SpringBoot-Initializr）"><a href="#一：创建一个boot工程（SpringBoot-Initializr）" class="headerlink" title="一：创建一个boot工程（SpringBoot Initializr）"></a>一：创建一个boot工程（SpringBoot Initializr）</h4><p>勾选SQL中的MySQL Driver</p><h4 id="二：引入mybatis-plus相关依赖"><a href="#二：引入mybatis-plus相关依赖" class="headerlink" title="二：引入mybatis-plus相关依赖"></a>二：引入mybatis-plus相关依赖</h4><p>引入 Spring Boot Starter 父工程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>spring-latest-version<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入 <code>spring-boot-starter</code>、<code>spring-boot-starter-test</code>、<code>mybatis-plus-boot-starter</code> <code>、mysql-connector-java、lombok</code>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="三：配置"><a href="#三：配置" class="headerlink" title="三：配置"></a>三：配置</h4><ul><li>在application.yml中配置数据库连接的相关信息</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/my_db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">devil</span></span><br></pre></td></tr></table></figure><ul><li>在 Spring Boot 启动类中添加 <code>@MapperScan</code> 注解，扫描 Mapper 文件夹：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.dyw.mybatisplus01pre.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlus01PreApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MybatisPlus01PreApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>借助lombok插件编写实体类 Student.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@TableId</span> 指定之间的方式：</span></span><br><span class="line"><span class="comment">     * value：主键字段的名称，如果时id，可以不用写</span></span><br><span class="line"><span class="comment">     * type:指定主键的类型，主键的值如何生成。idType.AUTO,表示自动增长</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableId(</span></span><br><span class="line"><span class="meta">            type = IdType.AUTO</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编写Mapper接口 <code>StudentMapper.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义Mapper，就是Dao接口</span></span><br><span class="line"><span class="comment"> * 1.要继承BaseMapper</span></span><br><span class="line"><span class="comment"> * 2.指定实体类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BaseMapper是Mp框架中的对象，定义了十七个方法（CRUD）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Student&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类 测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MybatisPlus01PreApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentMapper studentMapper;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Student&gt; students = studentMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220121180912055.png" alt="image-20220121180912055"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>*　通过以上几个简单的步骤，我们就实现了 Student 表的 CRUD 功能，甚至连 XML 文件都不用编写！<br>*　从以上步骤中，我们可以看到集成<code>MyBatis-Plus</code>非常的简单，只需要引入 starter 工程，并配置 mapper 扫描路径即可。<br>*　<strong>对于mapper的扫描可以选择在启动类中写@MapperScan() 也可以在mapper接口上加@mapper 前者适合mapper接口多的情况 后者则书写更方便。</strong><br>*　在执行插入操作时 执行成功后 会将结果返回到传入的对象中（例如我们可以通过传入的对象获得主键自增长的主键值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">People</span> <span class="variable">people1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="literal">null</span>, <span class="string">&quot;王裴豫川&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> peopleMapper.insert(people1);</span><br><span class="line"></span><br><span class="line">        System.out.println(row&gt;<span class="number">0</span>?<span class="string">&quot;成功&quot;</span>:<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;主键id：&quot;</span>+people1.getId());</span><br><span class="line">        System.out.println();</span><br><span class="line">        List&lt;People&gt; people = peopleMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">for</span> (People person : people) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    可以看到我们没有对传入的对象的主键赋值（自动增长）但我们通过执行操作后的对象获得了插入到表中的该行数据的主    键 证实了上述结论</p><h2 id="Spring整合Mybatis-Plus"><a href="#Spring整合Mybatis-Plus" class="headerlink" title="Spring整合Mybatis-Plus"></a><strong>Spring整合Mybatis-Plus</strong></h2><ul><li>上面的快速开始我们介绍了通过SpringBoot整合MyBatis-Plus</li></ul><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p><strong>加入Spring依赖和数据库JDBC依赖后还需要加入Mybatis-Plus的依赖</strong></p><p><strong>引入 <code>MyBatis-Plus</code> 之后请不要再次引入 <code>MyBatis</code> 以及 <code>MyBatis-Spring</code>，以避免因版本差异导致的问题。</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>MyBatis-Plus 的配置异常的简单，我们仅需要一些简单的配置即可使用 MyBatis-Plus 的强大功能！</p><p>配置 MapperScan  spring.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.dyw.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>要想使用mybatis-plus的日志功能 需要在application.yml中添加如下语句</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><h2 id="CRUD接口"><a href="#CRUD接口" class="headerlink" title="CRUD接口"></a><strong>CRUD接口</strong></h2><h2 id="Service-CRUD-接口"><a href="#Service-CRUD-接口" class="headerlink" title="Service CRUD 接口"></a><a href="https://www.mybatis-plus.com/guide/crud-interface.html#service-crud-%E6%8E%A5%E5%8F%A3">Service CRUD 接口</a></h2><blockquote><p>说明:</p><ul><li><p>通用 Service CRUD 封装<a href="https://gitee.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-extension/src/main/java/com/baomidou/mybatisplus/extension/service/IService.java">IService (opens new window)</a>接口，进一步封装 CRUD 采用 <code>get 查询单行</code> <code>remove 删除</code> <code>list 查询集合</code> <code>page 分页</code> 前缀命名方式区分 <code>Mapper</code> 层避免混淆，</p></li><li><p>泛型 <code>T</code> 为任意实体对象</p></li><li><p>建议如果存在自定义通用 Service 方法的可能，请创建自己的 <code>IBaseService</code> 继承 <code>Mybatis-Plus</code> 提供的基类</p></li><li><p>对象 <code>Wrapper</code> 为 <a href="https://www.mybatis-plus.com/guide/wrapper.html">条件构造器</a></p></li><li><p>&#96;&#96;&#96;java<br>@SuppressWarnings(“all”)<br>public interface BookService extends IService<Book> {<br>&#x2F;&#x2F;boolean save(Book book);<br>&#x2F;&#x2F;boolean update(Book book);<br>&#x2F;&#x2F;boolean delete(Integer id);<br>&#x2F;&#x2F;Book getById(Integer id);<br>List<Book> getAll();<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 可以追加自定义操作 需要自己编写方法实体 模板如下</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  @Service</span><br><span class="line">  @SuppressWarnings(&quot;all&quot;)</span><br><span class="line">  public class BookServiceImpl extends ServiceImpl&lt;BookMapper,Book&gt; implements BookService&#123;</span><br><span class="line">      @Autowired</span><br><span class="line">      private BookMapper mapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public List&lt;Book&gt; getAll() &#123;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></blockquote><hr><h2 id="Mapper-CRUD-接口"><a href="#Mapper-CRUD-接口" class="headerlink" title="Mapper CRUD 接口"></a><a href="https://www.mybatis-plus.com/guide/crud-interface.html#mapper-crud-%E6%8E%A5%E5%8F%A3">Mapper CRUD 接口</a></h2><blockquote><p>说明:</p><ul><li>通用 CRUD 封装<a href="https://gitee.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-core/src/main/java/com/baomidou/mybatisplus/core/mapper/BaseMapper.java">BaseMapper (opens new window)</a>接口，为 <code>Mybatis-Plus</code> 启动时自动解析实体表关系映射转换为 <code>Mybatis</code> 内部对象注入容器</li><li>泛型 <code>T</code> 为任意实体对象</li><li>参数 <code>Serializable</code> 为任意类型主键 <code>Mybatis-Plus</code> 不推荐使用复合主键约定每一张表都有自己的唯一 <code>id</code> 主键</li><li>对象 <code>Wrapper</code> 为 <a href="https://www.mybatis-plus.com/guide/wrapper.html">条件构造器</a></li></ul></blockquote><hr><p>以下是Mapper接口中的CRUD方法介绍</p><h4 id="一-查询"><a href="#一-查询" class="headerlink" title="一:查询"></a>一:查询</h4><ol><li>selectById() 通过单个主键值查询 只需要传入主键值即可  <strong>SELECT id,name FROM people WHERE id&#x3D;?</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * selectById 根据单个主键值查询</span></span><br><span class="line"><span class="comment"> * 参数:主键值</span></span><br><span class="line"><span class="comment"> * 返回值:实体对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">People</span> <span class="variable">people1</span> <span class="operator">=</span> peopleMapper.selectById(<span class="number">1</span>);</span><br><span class="line">System.out.println(people1);</span><br></pre></td></tr></table></figure><p><strong>如果id值对应的行不存在 会返回空 所以一般使用会判断是否为空 再做其他操作</strong></p><ol start="2"><li>selectBatchIds() 批处理查询 通过多个主键值的一个集合 来查询满足条件的数据 返回值是一个集合 如果没有满足条件的数据 则返回null  <strong>SELECT id,name FROM people WHERE id IN ( ? , ? , ? )</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * selectBatchIds 批处理查询 根据多个主键值查询</span></span><br><span class="line"><span class="comment"> * 参数:id的集合</span></span><br><span class="line"><span class="comment"> * 返回值:集合List&lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;Integer&gt; collect = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>).collect(Collectors.toList());</span><br><span class="line">List&lt;People&gt; people1 = peopleMapper.selectBatchIds(collect);</span><br><span class="line">System.out.println(people1);</span><br><span class="line"><span class="keyword">for</span> (People people2 : people1) &#123;</span><br><span class="line">    System.out.println(people2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>selectByMap() 通过将多条件字段字段封装到map中 通过读取map中的值来拼接条件 来实现  <strong>SELECT id,name FROM people WHERE name &#x3D; ? AND id &#x3D; ?</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * selectMap 使用map封装多条件字段查询</span></span><br><span class="line"><span class="comment">  * 参数:Map&lt;String,Object&gt;</span></span><br><span class="line"><span class="comment">  * 返回值:集合List&lt;T&gt;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"> map.put(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>);</span><br><span class="line"> map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;易顺坤&quot;</span>);</span><br><span class="line"> List&lt;People&gt; people1 = peopleMapper.selectByMap(map);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (People people2 : people1) &#123;</span><br><span class="line">     System.out.println(people2);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>4.selectList() 通过传入实体类 更具实体类中的字段值解析为条件 查询</p><p>……</p><p><strong>注意:</strong> 当select操作条件为null时默认查询表中全部数据</p><h4 id="二-更新"><a href="#二-更新" class="headerlink" title="二:更新"></a>二:更新</h4><ol><li>updateById(实体类对象);</li></ol><p>通过传入实体类对象根据实体类对象中的声明主键的值, 自动生成where条件 where id&#x3D;?  , 然后以实体类中的其他非null属性的值对表中的数据进行修改(<strong>注意:包装类的默认值是null 而基本数据类型默认值不一定是null 如int类型默认值是0</strong>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新操作（update）</span></span><br><span class="line"><span class="comment">     * 通过对象的形式传入要修改的数据 默认修改传入对象中非null属性的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">        people.setId(<span class="number">2</span>);</span><br><span class="line">        people.setName(<span class="string">&quot;易顺坤&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * updateById()顾名思义就是条件是根据id的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> peopleMapper.updateById(people);</span><br><span class="line">        System.out.println(i&gt;<span class="number">0</span>?<span class="string">&quot;cg&quot;</span>:<span class="string">&quot;sb&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;People&gt; people1 = peopleMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">for</span> (People people2 : people1) &#123;</span><br><span class="line">            System.out.println(people2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="三-删除"><a href="#三-删除" class="headerlink" title="三:删除"></a>三:删除</h4><ol><li>deleteById 通过传入的实体类中声明的主键值 来生成where条件 delete from tablename where id &#x3D; ?  也可以直接传入一个id值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> peopleMapper.deleteById(<span class="number">3</span>);</span><br><span class="line"><span class="comment">/**************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">people.setId(<span class="number">2</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* deleteById()顾名思义就是条件是根据id的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> peopleMapper.deleteById(people);</span><br></pre></td></tr></table></figure><ol start="2"><li>deleteByMap 将字段条件通过键值对的方式封装到map中 再调用deleteByMap方法 将map中的值读取填入where之后 多个字段以and方式连接 <strong>DELETE FROM people WHERE name &#x3D; ? AND id &#x3D; ?</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deleteByMap()通过map存储条件字段键值对 多个字段 在where条件后用and连接</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DELETE FROM people WHERE name = ? AND id = ?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;丁杨维&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> peopleMapper.deleteByMap(map);</span><br></pre></td></tr></table></figure><ol start="3"><li>deleteBatchIds 通过id批量删除 是通过in关键字 填入where条件关键字之后 <strong>DELETE FROM people WHERE id IN ( ? , ? )</strong></li></ol><blockquote><ul><li><p>deleteBatchIds() 批处理方式:使用多个主键值,删除数据</p></li><li><p>参数:Collection&lt;? extends Serializable&gt; </p></li><li><p>返回值删除的记录数</p></li></ul></blockquote><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * deleteBatchIds() 批处理方式:使用多个主键值,删除数据</span></span><br><span class="line"><span class="comment">         * 参数:Collection&lt;? extends Serializable&gt;</span></span><br><span class="line"><span class="comment">         * 返回值删除的记录数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">6</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> peopleMapper.deleteBatchIds(list);</span><br></pre></td></tr></table></figure><p>新知识:可以通过Stream.Of().collect(Collectors.toList())的方式创建List集合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = Stream.of(Object,Object....).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h4 id="四-插入"><a href="#四-插入" class="headerlink" title="四:插入"></a>四:插入</h4><ul><li>insert() 通过创建一个实体对象 再调用mapper的insert方法即可完成插入 <strong>INSERT INTO people ( name ) VALUES ( ? )</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">People</span> <span class="variable">people1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="literal">null</span>, <span class="string">&quot;fan&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> peopleMapper.insert(people1);</span><br></pre></td></tr></table></figure><h2 id="AR操作"><a href="#AR操作" class="headerlink" title="AR操作"></a><strong>AR操作</strong></h2><h4 id="ActiveRecord简介"><a href="#ActiveRecord简介" class="headerlink" title="ActiveRecord简介:"></a>ActiveRecord简介:</h4><ul><li>每一个数据库表对应创建一个类,类的每一个对象实例对应于数据库中表的一行记录;通常表的每个字段在类中都有相应的Field;</li><li>ActiveRecord 负责把自己持久化,在ActiveRecord中封装了对数据库的访问,通过对象自己实现CRUD,实现优雅的数据库操作</li><li>ActiveRecord也封住给你了部分业务逻辑.可以作为业务对象使用</li></ul><h4 id="快速开始-1"><a href="#快速开始-1" class="headerlink" title="快速开始"></a>快速开始</h4><ul><li>创建表</li><li>创建springboot整合mybatis-plus项目 与前面操作一致</li><li>编写实体类 继承Model<T>(这个Model时Mybatis-plus中的 这个Model中封装了很多crud方法实现机制 也是mybatis中的sqlsession)</li></ul><p>​    entity.People.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-01-21-23:08</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用AR,要求实体类需要继承MP中的Model</span></span><br><span class="line"><span class="comment"> *Model中提供了对数据库的CRUD的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">extends</span> <span class="title class_">Model</span>&lt;People&gt; &#123;</span><br><span class="line">    <span class="comment">//定义属性,属性名和表的列名一样</span></span><br><span class="line">    <span class="meta">@TableId(</span></span><br><span class="line"><span class="meta">            value = &quot;id&quot;,</span></span><br><span class="line"><span class="meta">            type = IdType.AUTO</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编写Mapper接口继承BaseMapper<T></li></ul><p>​    加上@Mapper注解</p><p>​    注意:<strong>我们后续使用不使用该mapper而是使用实体类的对象(继承了Model的原因 实体类对象已经具有了对数据库表的crud操作)</strong> 该mapper是不需要使用的,MP需要使用该mapper获取数据库的表的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-01-21-23:22</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PeopleMapper是不需要使用的,Mp需要使用PeopleMapper获取数据库的表的信息.</span></span><br><span class="line"><span class="comment"> * 如果不定义DeptMapper,MP会报错</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PeopleMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;People&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AR的CRUD操作"><a href="#AR的CRUD操作" class="headerlink" title="AR的CRUD操作"></a>AR的CRUD操作</h4><h5 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h5><ul><li>创建一个实体对象 设置属性 再使用该对象调用继承来的insert方法 就可以完成插入操作</li><li>返回值是一个boolean值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">people.setId(<span class="number">4</span>);</span><br><span class="line">people.setName(<span class="string">&quot;xie&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">insert</span> <span class="operator">=</span> people.insert();</span><br></pre></td></tr></table></figure><h5 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h5><ul><li>deleteById() 创建一个实体对象 只需要设置属性主键值(也可不设置 直接在方法参数上写) 再调用该方法 就会识别主键值 并根据主键值进行删除操作 <strong>DELETE FROM people WHERE id&#x3D;?</strong></li><li>返回值是boolean(注意与其他操作不同 这里的删除操作只要语句正确就不会为false)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">people.setId(<span class="number">5</span>);</span><br><span class="line"><span class="comment">/** 根据对象设置的主键id的值删除记录*/</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">delete</span> <span class="operator">=</span> people.deleteById();</span><br></pre></td></tr></table></figure><h5 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h5><ul><li>selectById() 创建一个实体对象 只需要设置属性主键值(也可不设置 直接在方法参数上写) 再调用该方法 就会识别主键值 并根据主键值进行查询操作 <strong>SELECT id,name FROM people WHERE id&#x3D;?</strong></li><li><strong>有记录返回值是一个Object 如果在创建实体类时继承Model设置了泛型那么返回值就是实体类的类型 无记录就是一个null</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">        people.setId(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/** 根据对象设置的主键id的值查询记录*/</span></span><br><span class="line">        <span class="type">People</span> <span class="variable">people1</span> <span class="operator">=</span> people.selectById(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>还有如下方法</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220122174725782.png" alt="image-20220122174725782"></p><h5 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h5><ol><li>updateById() 创建一个实体对象 设置属性主键值 和其他属性 调用对象的updateById()方法 它会自动识别主键值(前面我们创建类时 设置了主键信息)并 修改 <strong>默认修改对象中非空的值</strong><ul><li>返回值是boolean</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">        people.setId(<span class="number">1</span>);</span><br><span class="line">        people.setName(<span class="string">&quot;kun&quot;</span>);</span><br><span class="line">        <span class="comment">/** 根据对象设置的主键id的值更新记录*/</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">update</span> <span class="operator">=</span> people.updateById();</span><br></pre></td></tr></table></figure><hr><h2 id="主键类型"><a href="#主键类型" class="headerlink" title="主键类型"></a><strong>主键类型</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">IdType</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库ID自增</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;该类型请确保数据库设置了 ID自增 否则无效&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AUTO(<span class="number">0</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该类型为未设置主键类型(注解里等于跟随全局,全局里约等于 INPUT)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NONE(<span class="number">1</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户输入ID</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;该类型可以通过自己注册自动填充插件进行填充&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INPUT(<span class="number">2</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以下3种类型、只有当插入对象ID 为空，才自动填充。 */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分配ID (主键类型为number或string）,</span></span><br><span class="line"><span class="comment">     * 默认实现类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator&#125;(雪花算法)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.3.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ASSIGN_ID(<span class="number">3</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分配UUID (主键类型为 string)</span></span><br><span class="line"><span class="comment">     * 默认实现类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator&#125;(UUID.replace(&quot;-&quot;,&quot;&quot;))</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ASSIGN_UUID(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">    IdType(<span class="type">int</span> key) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述枚举类型 我们可以知道共有五种主键类型</p><p><strong>IdType</strong> 对于自动填充 只有当插入对象ID 为空，才自动填充。</p><ul><li><strong>0.NONE</strong> : 没有主键类型</li><li><strong>1.AUTO</strong> : 自动增长 前提是确保数据库设置了 ID自增 否则无效</li><li><strong>2.INPUT</strong> : 手工输入</li><li><strong>3.ASSIGN_ID</strong> :</li></ul><blockquote><p>分配ID (主键类型为number或string）  </p><p>默认实现类 {@link com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator}(雪花算法) </p></blockquote><ul><li><strong>4.ASSIGN_UUID</strong> :</li></ul><blockquote><p> 分配UUID (主键类型为 string)</p><p>默认实现类 {@link com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator}(UUID.replace(“-“,””))</p></blockquote><p>​    </p><h4 id="IdType-AUTO"><a href="#IdType-AUTO" class="headerlink" title="IdType.AUTO"></a>IdType.AUTO</h4><ol><li>表中建表使用数字作为主键, 设置主键id自增</li></ol><p>​    <img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220122180836796.png" alt="image-20220122180836796"></p><ol start="2"><li>实体类表中主键值也要为数字类型 并添加注解@TableId 设置主键以及主键类型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">extends</span> <span class="title class_">Model</span>&lt;People&gt; &#123;</span><br><span class="line">    <span class="comment">//定义属性,属性名和表的列名一样</span></span><br><span class="line">    <span class="meta">@TableId(</span></span><br><span class="line"><span class="meta">            value = &quot;id&quot;,</span></span><br><span class="line"><span class="meta">            type = IdType.AUTO</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IdType-ASSIGN-ID"><a href="#IdType-ASSIGN-ID" class="headerlink" title="IdType.ASSIGN_ID"></a>IdType.ASSIGN_ID</h4><ol><li>使用时需要在数据库表中 需要取消主键自动增长 并且设置主键类型时bigint 因为这个主键的值很大 int类型大小不够 <strong>还可以使用varchar(50)类型</strong></li></ol><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220122182035368.png" alt="image-20220122182035368"></p><ol start="2"><li>实体类中将主键类型设置为Long原因与上述一样 并且设置注解@TableId中type的值为<strong>IdType.ASSIGN_ID</strong> <strong>如果数据库中主键使用varchar(50)那么相应的实体类中的主键类型也应当为String类型</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">extends</span> <span class="title class_">Model</span>&lt;People&gt; &#123;</span><br><span class="line">    <span class="comment">//定义属性,属性名和表的列名一样</span></span><br><span class="line">    <span class="meta">@TableId(</span></span><br><span class="line"><span class="meta">            value = &quot;id&quot;,</span></span><br><span class="line"><span class="meta">            type = IdType.ASSIGN_ID</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> Long/String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220122182324329.png" alt="image-20220122182324329"></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220122182719124.png" alt="image-20220122182719124"></p><h4 id="IdType-ASSIGN-UUID"><a href="#IdType-ASSIGN-UUID" class="headerlink" title="IdType.ASSIGN_UUID"></a>IdType.ASSIGN_UUID</h4><ol><li>使用时需要在数据库表中, 将主键类型设置为varchar(50)类型</li></ol><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220122183109184.png" alt="image-20220122183109184"></p><ol start="2"><li>实体类中的主键类型设置为String类型 并且注解@TableId中需要将type设置为<strong>IdType.ASSIGN_UUID</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">extends</span> <span class="title class_">Model</span>&lt;People&gt; &#123;</span><br><span class="line">    <span class="comment">//定义属性,属性名和表的列名一样</span></span><br><span class="line">    <span class="meta">@TableId(</span></span><br><span class="line"><span class="meta">            value = &quot;id&quot;,</span></span><br><span class="line"><span class="meta">            type = IdType.ASSIGN_UUID</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220122183419332.png" alt="image-20220122183419332"></p><p>分布式中推荐使用 <strong>IdType.ASSIGN_ID</strong> 它可以生成数字而且长度更短更有规律</p><hr><h2 id="指定表名"><a href="#指定表名" class="headerlink" title="指定表名"></a><strong>指定表名</strong></h2><ul><li>定义实体类,默认的表名和实体类同名; 如果不一致,在实体类上面使用@TableName说明表名称</li><li>例如: <strong>@TableName(value&#x3D;”数据库表名”)</strong> </li><li>使用: 在实体类的上方</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(value = &quot;people&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">extends</span> <span class="title class_">Model</span>&lt;People&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定列名"><a href="#指定列名" class="headerlink" title="指定列名"></a><strong>指定列名</strong></h2><ul><li>在实际开发中, 不能完全出现实体类中的属性名与 数据库表中的列名完全一致; 如果不一致,在实体类上面使用@TableField完成两者之间的映射关系</li><li>例如:<strong>@TableField(value&#x3D;”数据库表中的列名”)</strong> 查询时需要将结果封装成一个一个的对象时 需要在@TableName中设置<strong>autoResultMap &#x3D; true</strong> 否则在使用了@TableField后可能会出现控制的情况</li><li>使用: 在实体类中的属性的上方</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义属性,属性名和表的列名一样</span></span><br><span class="line"><span class="meta">@TableId(</span></span><br><span class="line"><span class="meta">        value = &quot;pid&quot;,</span></span><br><span class="line"><span class="meta">        type = IdType.ASSIGN_UUID</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@TableField(value = &quot;pid&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String id;</span><br></pre></td></tr></table></figure><hr><h4 id="驼峰命名"><a href="#驼峰命名" class="headerlink" title="驼峰命名"></a>驼峰命名</h4><p>上述 在开发中使用@TableField指定属性与表中的列名的映射关系十分麻烦</p><p>一般在设计数据库表时采用下划线的方式命名 如<strong>user_name</strong></p><p>​    这就引申出Mybatis-plus的另一个特性 驼峰命名 即: <strong>列名使用下划线,属性名时驼峰命名的方式.Mybatis-plus默认支持这种规则.</strong> (即列名为: user_name  属性名为:userName 不需要使用@TableField Mybatis-plus同样能够识别)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">列名: people_name</span><br><span class="line">属性名: <span class="keyword">private</span> String peopleName;</span><br></pre></td></tr></table></figure><h2 id="自定义mapper"><a href="#自定义mapper" class="headerlink" title="自定义mapper"></a><strong>自定义mapper</strong></h2><p>自定义mapper</p><p>与mybatis一样 需要在创建一个接口写入自定义的方法 然后再编写一个mapper.xml文件 声明namespace 方法标签 resultType 和自定义方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.dyw.mybatisplus05mapper.mapper.PersonMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAllPerson&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.dyw.mybatisplus05mapper.entity.Person&quot;</span>&gt;</span></span><br><span class="line">        select pid,people_name from people order by pid</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>做完一切之后可以选择再mapper接口上加上@Mapper注解 或者 在启动类上加上@MapperScan(value&#x3D;”mapper接口路径”) 用来指明mapper的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonMapper</span> &#123;</span><br><span class="line">    List&lt;Person&gt; <span class="title function_">selectAllPerson</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在application.yml中声明mapper.xml的路径</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath*:xml/*mapper.xml</span></span><br></pre></td></tr></table></figure><p><strong>这样的方法也同样适用于Springboot+mybatis(@Mapper&#x2F;@MapperScan+mapper.xml)</strong></p><p><strong>还有一种方法 @Mapper&#x2F;@MapperScan+@crud操作</strong> 也同样适用于mybatis 或者说正是因为mybatis有 所以mybatis-plus也支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">@SuppressWarnings(&quot;all&quot;)</span><br><span class="line">public interface PersonMapper &#123;</span><br><span class="line">    @Select(&quot;select pid,people_name from people order by pid&quot;)</span><br><span class="line">    List&lt;Person&gt; selectAllPerson();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Mapper和@MapperScan作用 告诉了程序mapper接口在哪 </p><h2 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a><strong>条件构造器</strong></h2><h4 id="条件构造器-Wrapper"><a href="#条件构造器-Wrapper" class="headerlink" title="条件构造器: Wrapper"></a>条件构造器: Wrapper</h4><p>QueryWrapper(LambdaQueryWrapper) 和 UpdateWrapper(LambdaUpdateWrapper)的父类 用于生成sql的where条件,entity属性也用于生成sql的where条件,MP3.0开始支持lambda表达式, LambdaQueryWrapper, LambdaUpdateWrapper 支持lambda表达式的构造查询条件</p><p><strong>注意:</strong> entity 生成的 where 条件与 使用各个 api 生成的 where 条件<strong>没有任何关联行为</strong></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220122210417087.png" alt="image-20220122210417087"></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220122210440192.png" alt="image-20220122210440192"></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220122210457290.png" alt="image-20220122210457290"></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220122210545890.png" alt="image-20220122210545890"></p><p><strong>使用时根据不同的crud操作选择不同的条件封装类</strong></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220122211725390.png" alt="image-20220122211725390"></p><p>实际使用的例子都在官方文档中可以查看<a href="https://www.mybatis-plus.com/guide/wrapper.html#abstractwrapper">条件构造器</a></p><p>具体使用</p><h5 id="allEq"><a href="#allEq" class="headerlink" title="allEq"></a>allEq</h5><h6 id="1-allEq-Map-lt-R-V-gt-params"><a href="#1-allEq-Map-lt-R-V-gt-params" class="headerlink" title="1. allEq(Map&lt;R, V&gt; params)"></a>1. allEq(Map&lt;R, V&gt; params)</h6><ul><li>根据不同的crud选择不同的条件封装类 创建相应的条件封装类实体 </li><li>由于要使用allEq(Map&lt;R, V&gt; params)方法, 它的参数是一个map 所以需要新建一个map, map中的键值对 就是条件 用<strong>and连接</strong></li><li>再调用mapper的方法将封装类实体传入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 alleq</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/*map&lt;key,value&gt; key:列名 value:条件的值 */</span></span><br><span class="line">map.put(<span class="string">&quot;pid&quot;</span>,<span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;people_name&quot;</span>,<span class="string">&quot;kun&quot;</span>);</span><br><span class="line"><span class="comment">/*封装到Wrapper中*/</span></span><br><span class="line">qw.allEq(map);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220122212326283.png" alt="image-20220122212326283"></p><hr><h6 id="2-allEq-Map-lt-R-V-gt-params-boolean-null2IsNull"><a href="#2-allEq-Map-lt-R-V-gt-params-boolean-null2IsNull" class="headerlink" title="2. allEq(Map&lt;R, V&gt; params,boolean null2IsNull)"></a>2. allEq(Map&lt;R, V&gt; params,boolean null2IsNull)</h6><ul><li><p>后面的boolean值是用来处理传入的map中的value空值的.</p><blockquote><p>true: 将map中value控制用is 拼接</p><p>false: 忽略空value和key 不对该字段进行拼接</p></blockquote></li></ul><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220122213108202.png" alt="image-20220122213108202"></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220122213134669.png" alt="image-20220122213134669"></p><hr><h5 id="eq-封装单个条件"><a href="#eq-封装单个条件" class="headerlink" title="eq: 封装单个条件"></a>eq: 封装单个条件</h5><h6 id="eq-R-column-Object-val-列名-值"><a href="#eq-R-column-Object-val-列名-值" class="headerlink" title="eq(R column, Object val): 列名,值"></a>eq(R column, Object val): 列名,值</h6><p>使用条件封装类的实体类的eq方法 调用直接填入列名和相应的值即可 是使用的’&#x3D;’连接</p><p><code>SELECT pid,people_name FROM people WHERE (pid = ?)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 eq</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/*封装到Wrapper中*/</span></span><br><span class="line">qw.eq(<span class="string">&quot;pid&quot;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure><hr><h5 id="ne-不等于"><a href="#ne-不等于" class="headerlink" title="ne:不等于"></a>ne:不等于</h5><h6 id="ne-R-column-Object-val-表示-lt-gt-和-x3D"><a href="#ne-R-column-Object-val-表示-lt-gt-和-x3D" class="headerlink" title="ne(R column, Object val) 表示&lt;&gt; 和 !&#x3D;"></a>ne(R column, Object val) 表示&lt;&gt; 和 !&#x3D;</h6><ul><li>使用列名, 值 通过&lt;&gt; 拼接  </li><li><code>Preparing: SELECT pid,people_name FROM people WHERE (pid &lt;&gt; ?)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 eq</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/*封装到Wrapper中*/</span></span><br><span class="line">qw.ne(<span class="string">&quot;pid&quot;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure><hr><h5 id="gt-大于"><a href="#gt-大于" class="headerlink" title="gt:大于"></a>gt:大于</h5><h6 id="gt-R-column-Object-val-表示-gt"><a href="#gt-R-column-Object-val-表示-gt" class="headerlink" title="gt(R column, Object val) 表示 &gt;"></a>gt(R column, Object val) 表示 &gt;</h6><ul><li>使用列名, 值 通过&gt; 拼接  </li><li><code>SELECT pid,people_name FROM people WHERE (pid &gt; ?)</code></li></ul><hr><h5 id="ge-大于等于"><a href="#ge-大于等于" class="headerlink" title="ge:大于等于"></a>ge:大于等于</h5><h6 id="ge-R-column-Object-val-表示-gt-x3D"><a href="#ge-R-column-Object-val-表示-gt-x3D" class="headerlink" title="ge(R column, Object val) 表示 &gt;&#x3D;"></a>ge(R column, Object val) 表示 &gt;&#x3D;</h6><ul><li>使用列名, 值 通过&gt;&#x3D; 拼接  </li><li><code>SELECT pid,people_name FROM people WHERE (pid &gt;= ?)</code></li></ul><hr><h5 id="lt-小于"><a href="#lt-小于" class="headerlink" title="lt:小于"></a>lt:小于</h5><h6 id="lt-R-column-Object-val-表示-lt"><a href="#lt-R-column-Object-val-表示-lt" class="headerlink" title="lt(R column, Object val) 表示 &lt;"></a>lt(R column, Object val) 表示 &lt;</h6><ul><li>使用列名, 值 通过&lt; 拼接  </li><li><code>SELECT pid,people_name FROM people WHERE (pid &lt; ?)</code></li></ul><hr><h5 id="le-小于等于"><a href="#le-小于等于" class="headerlink" title="le:小于等于"></a>le:小于等于</h5><h6 id="lt-R-column-Object-val-表示-lt-x3D"><a href="#lt-R-column-Object-val-表示-lt-x3D" class="headerlink" title="lt(R column, Object val) 表示 &lt;&#x3D;"></a>lt(R column, Object val) 表示 &lt;&#x3D;</h6><ul><li>使用列名, 值 通过&lt;&#x3D; 拼接  </li><li><code>SELECT pid,people_name FROM people WHERE (pid &lt;= ?)</code></li></ul><hr><h5 id="between-两个值范围之间-gt-x3D-and-lt-x3D"><a href="#between-两个值范围之间-gt-x3D-and-lt-x3D" class="headerlink" title="between: 两个值范围之间(&gt;&#x3D; and &lt;&#x3D;)"></a>between: 两个值范围之间(&gt;&#x3D; and &lt;&#x3D;)</h5><h6 id="1-between-R-column-Object-val1-Object-val2-列名-值1-值2"><a href="#1-between-R-column-Object-val1-Object-val2-列名-值1-值2" class="headerlink" title="1.between(R column, Object val1, Object val2) 列名 值1 值2"></a>1.between(R column, Object val1, Object val2) 列名 值1 值2</h6><ul><li><p>通过列名相同的两个值 来创建两个值范围之间的条件 通过<strong>between</strong>拼接</p></li><li><p><code>SELECT pid,people_name FROM people WHERE (pid BETWEEN ? AND ?)</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 between</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/*封装到Wrapper中*/</span></span><br><span class="line">qw.between(<span class="string">&quot;pid&quot;</span>,<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure><hr><h6 id="2-notBetween-R-column-Object-val1-Object-val2-列名-值1-值2"><a href="#2-notBetween-R-column-Object-val1-Object-val2-列名-值1-值2" class="headerlink" title="2. notBetween(R column, Object val1, Object val2) 列名 值1 值2"></a>2. notBetween(R column, Object val1, Object val2) 列名 值1 值2</h6><ul><li><p>通过列名相同的两个值 来创建两个值范围之间的条件 通过<strong>between</strong>拼接</p></li><li><p><code>SELECT pid,people_name FROM people WHERE (pid NOT BETWEEN ? AND ?)</code></p></li></ul><hr><h5 id="like-模糊查询"><a href="#like-模糊查询" class="headerlink" title="like 模糊查询"></a>like 模糊查询</h5><h6 id="1-like-R-column-Object-val-列名-值"><a href="#1-like-R-column-Object-val-列名-值" class="headerlink" title="1. like(R column, Object val) 列名 值"></a>1. like(R column, Object val) 列名 值</h6><ul><li>like模糊查询 在值的前后都是用%拼接( %val% ) 查询之中存在val的数据</li><li><code>SELECT pid,people_name FROM people WHERE (people_name LIKE ?)  Parameters: %k%(String)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 like</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/*封装到Wrapper中*/</span></span><br><span class="line">qw.like(<span class="string">&quot;people_name&quot;</span>,<span class="string">&quot;k&quot;</span>);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure><hr><h6 id="2-notLike-R-column-Object-val-列名-值"><a href="#2-notLike-R-column-Object-val-列名-值" class="headerlink" title="2. notLike(R column, Object val) 列名 值"></a>2. notLike(R column, Object val) 列名 值</h6><ul><li>notLike模糊查询 在值的前后都是用%拼接( %val%)  查询之中不存在val的数据</li><li><code>SELECT pid,people_name FROM people WHERE (people_name NOT LIKE ?)  Parameters: %k%(String)</code></li></ul><hr><h6 id="3-likeLeft-R-column-Object-val-列名-值"><a href="#3-likeLeft-R-column-Object-val-列名-值" class="headerlink" title="3. likeLeft(R column, Object val) 列名 值"></a>3. likeLeft(R column, Object val) 列名 值</h6><ul><li>likeLeft模糊查询 在值的左边用%拼接( %val)  查询以val结尾的的数据</li><li><code>SELECT pid,people_name FROM people WHERE (people_name LIKE ?)  Parameters: %k(String)</code></li></ul><hr><h6 id="4-likeLeft-R-column-Object-val-列名-值"><a href="#4-likeLeft-R-column-Object-val-列名-值" class="headerlink" title="4. likeLeft(R column, Object val) 列名 值"></a>4. likeLeft(R column, Object val) 列名 值</h6><ul><li>likeLeft模糊查询 在值的右边用%拼接( val%)  查询以val开头的的数据</li><li><code>SELECT pid,people_name FROM people WHERE (people_name LIKE ?)  Parameters: k%(String)</code></li></ul><hr><h5 id="null-判空"><a href="#null-判空" class="headerlink" title="null: 判空"></a>null: 判空</h5><h6 id="1-isNull-R-column-列名"><a href="#1-isNull-R-column-列名" class="headerlink" title="1.isNull(R column) 列名"></a>1.isNull(R column) 列名</h6><ul><li>判断所指列名为空的情况 以 is null 连接</li><li><code>SELECT pid,people_name FROM people WHERE (people_name IS NULL)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 like</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/*封装到Wrapper中*/</span></span><br><span class="line">qw.isNull(<span class="string">&quot;people_name&quot;</span>);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure><hr><h6 id="1-isNull-R-column-列名-1"><a href="#1-isNull-R-column-列名-1" class="headerlink" title="1.isNull(R column) 列名"></a>1.isNull(R column) 列名</h6><ul><li>判断所指列名为不为空的情况 以 is not null 连接</li><li><code>SELECT pid,people_name FROM people WHERE (people_name IS NOT NULL)</code></li></ul><hr><h5 id="in-集合查询"><a href="#in-集合查询" class="headerlink" title="in 集合查询"></a>in 集合查询</h5><h6 id="1-in-R-column-Object…-values-列名-值1…-也可以传入一个集合"><a href="#1-in-R-column-Object…-values-列名-值1…-也可以传入一个集合" class="headerlink" title="1. in(R column, Object… values) 列名,值1…..  也可以传入一个集合"></a>1. in(R column, Object… values) 列名,值1…..  也可以传入一个集合</h6><ul><li>in查询 将值封装到一个集合中 底层是or连接 查询满足集合范围中条件的数据</li><li><code>SELECT pid,people_name FROM people WHERE (pid IN (?,?,?))</code></li></ul><h6 id="2-notIn-R-column-Object…-values-列名-值1…-也可以传入一个集合"><a href="#2-notIn-R-column-Object…-values-列名-值1…-也可以传入一个集合" class="headerlink" title="2. notIn(R column, Object… values) 列名,值1…..  也可以传入一个集合"></a>2. notIn(R column, Object… values) 列名,值1…..  也可以传入一个集合</h6><ul><li>in查询 将值封装到一个集合中 底层是or连接 查询不符合集合范围中条件的数据</li><li><code>SELECT pid,people_name FROM people WHERE (pid NOT IN (?,?,?))</code></li></ul><hr><h5 id="inSql-子查询"><a href="#inSql-子查询" class="headerlink" title="inSql 子查询"></a>inSql 子查询</h5><h6 id="1-inSql-R-column-String-inValue-列名-子查询语句"><a href="#1-inSql-R-column-String-inValue-列名-子查询语句" class="headerlink" title="1. inSql(R column, String inValue) 列名, 子查询语句"></a>1. inSql(R column, String inValue) 列名, 子查询语句</h6><ul><li>类型于in(),  前面的列名用来筛选子查询结果中符合条件的值 将其放在in()的集合中 后续步骤与in查询一致  </li><li><code>SELECT pid,people_name FROM people WHERE (people_name IN (select people_name from people where pid = 1))</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 inSql</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/*封装到Wrapper中*/</span></span><br><span class="line">qw.inSql(<span class="string">&quot;people_name&quot;</span>,<span class="string">&quot;select people_name from people where pid = 1&quot;</span>);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure><hr><h6 id="2-notInSql-R-column-String-inValue-列名-子查询语句"><a href="#2-notInSql-R-column-String-inValue-列名-子查询语句" class="headerlink" title="2. notInSql(R column, String inValue) 列名, 子查询语句"></a>2. notInSql(R column, String inValue) 列名, 子查询语句</h6><ul><li>类型于notIn(),  前面的列名用来筛选子查询结果中符合条件的值 将其放在in()的集合中 后续步骤与notIn查询一致  </li><li><code>SELECT pid,people_name FROM people WHERE (people_name NOT IN (select people_name from people where pid = 1))</code></li></ul><hr><h5 id="groupBy-分组函数"><a href="#groupBy-分组函数" class="headerlink" title="groupBy 分组函数"></a>groupBy 分组函数</h5><h6 id="1-groupBy-R-column-列名"><a href="#1-groupBy-R-column-列名" class="headerlink" title="1. groupBy(R column): 列名"></a>1. groupBy(R column): 列名</h6><ul><li><p>在使用分组函数之前 需要调用Wrapper的select方法 指定要输出的参数 例如<code>select(&quot;people_name, count(*)&quot;);</code></p></li><li><p>按指定的列名进行分组</p></li><li><p><code>SELECT people_name, count(*) FROM people GROUP BY people_name</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 groupBy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/*封装到Wrapper中*/</span></span><br><span class="line">qw.select(<span class="string">&quot;people_name, count(*)&quot;</span>);</span><br><span class="line">qw.groupBy(<span class="string">&quot;people_name&quot;</span>);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure><hr><h5 id="orderBy-排序"><a href="#orderBy-排序" class="headerlink" title="orderBy 排序"></a>orderBy 排序</h5><h6 id="1-orderByAsc-R-column-列名"><a href="#1-orderByAsc-R-column-列名" class="headerlink" title="1. orderByAsc(R column) 列名"></a>1. orderByAsc(R column) 列名</h6><ul><li><p>按列名字段升序排序 还可以设置多个列名字段 来作为第二排序字段 也可以是集合</p></li><li><p><code>SELECT pid,people_name FROM people ORDER BY pid ASC</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 orderBy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">qw.orderByAsc(<span class="string">&quot;pid&quot;</span>);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure><hr><h6 id="2-orderByDesc-R-column-列名"><a href="#2-orderByDesc-R-column-列名" class="headerlink" title="2. orderByDesc(R column) 列名"></a>2. orderByDesc(R column) 列名</h6><ul><li><p>按列名字段降序排序 还可以设置多个列名字段 来作为第二排序字段 也可以是集合</p></li><li><p><code>SELECT pid,people_name FROM people ORDER BY pid DESC</code></p></li></ul><hr><h6 id="3-orderBy-boolean-condition-boolean-isAsc-R-column-条件-是否升序-列名字段"><a href="#3-orderBy-boolean-condition-boolean-isAsc-R-column-条件-是否升序-列名字段" class="headerlink" title="3. orderBy(boolean condition, boolean isAsc, R column) 条件 是否升序 列名字段"></a>3. orderBy(boolean condition, boolean isAsc, R column) 条件 是否升序 列名字段</h6><ul><li><p>按列isAsc来判断是否是升序 还是降序排序 还可以设置多个列名字段 来作为第二排序字段 也可以是集合</p></li><li><p><code>SELECT pid,people_name FROM people ORDER BY pid ASC/DESC</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 orderBy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">qw.orderBy(<span class="literal">true</span>,<span class="literal">true</span>,<span class="string">&quot;pid&quot;</span>);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure><h6 id="4-多字段不同排序规则排序"><a href="#4-多字段不同排序规则排序" class="headerlink" title="4. 多字段不同排序规则排序"></a>4. 多字段不同排序规则排序</h6><ul><li><p>可以在上述的方法后再调用orderBy()相关方法 完成多字段不同排序规则排序 可拼接多个</p></li><li><p><code>qw.orderBy(true,true,&quot;pid&quot;).orderBy(true,false,&quot;people_name&quot;);</code></p></li><li><p><code>SELECT pid,people_name FROM people ORDER BY pid ASC,people_name DESC</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 orderBy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">qw.orderBy(<span class="literal">true</span>,<span class="literal">true</span>,<span class="string">&quot;pid&quot;</span>).orderBy(<span class="literal">true</span>,<span class="literal">false</span>,<span class="string">&quot;people_name&quot;</span>);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure><hr><h5 id="or-and-连接词"><a href="#or-and-连接词" class="headerlink" title="or and 连接词"></a>or and 连接词</h5><h6 id="1-and"><a href="#1-and" class="headerlink" title="1. and"></a>1. and</h6><ul><li>与or() 有关 再显式调用or()方法时 时使用or来连接 不调用or()方法连接 默认使用and连接</li><li><code>qw.eq(&quot;pid&quot;,1).eq(&quot;people_name&quot;,&quot;k&quot;);</code></li><li><code>SELECT pid,people_name FROM people WHERE (pid = ? AND people_name = ?)</code></li></ul><hr><h6 id="2-or-无参"><a href="#2-or-无参" class="headerlink" title="2.or() 无参"></a>2.or() 无参</h6><ul><li>在单个条件方法后面使用 or() 再拼接另一个条件 以此类推 可拼接多个</li><li><code>qw.eq(&quot;pid&quot;,1).or().eq(&quot;people_name&quot;,&quot;k&quot;);</code></li><li><code>SELECT pid,people_name FROM people WHERE (pid = ? OR people_name = ?)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 or</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">qw.eq(<span class="string">&quot;pid&quot;</span>,<span class="number">1</span>).or().eq(<span class="string">&quot;people_name&quot;</span>,<span class="string">&quot;k&quot;</span>);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure><p>还有or 和 and 的嵌套用法 再官方文档可以了解<a href="https://www.mybatis-plus.com/guide/wrapper.html#or">or and 的嵌套</a></p><hr><h5 id="last-末尾拼接"><a href="#last-末尾拼接" class="headerlink" title="last 末尾拼接"></a>last 末尾拼接</h5><h6 id="1-last-String-lastSql-拼接的sql语句"><a href="#1-last-String-lastSql-拼接的sql语句" class="headerlink" title="1. last(String lastSql) 拼接的sql语句"></a>1. last(String lastSql) 拼接的sql语句</h6><ul><li>无视优化规则直接拼接到 sql 的最后</li><li>会将参数中的sql语句 拼接到末尾 可以调用了方法之后调用</li><li><code>qw.gt(&quot;pid&quot;,1).last(&quot;limit 1,10&quot;);</code></li><li><code>SELECT pid,people_name FROM people WHERE (pid &gt; ?) limit 1,10</code></li></ul><p><strong>这种方法存在sql注入风险</strong></p><p>**注意: **只能调用一次,多次调用以最后一次为准 有sql注入的风险,请谨慎使用</p><hr><h5 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h5><h6 id="1-exists-String-existsSql-sql语句"><a href="#1-exists-String-existsSql-sql语句" class="headerlink" title="1. exists(String existsSql) sql语句"></a>1. exists(String existsSql) sql语句</h6><ul><li>判断参数中的sql语句 是否成立 符合条件即成立</li><li><code> qw.exists(&quot;select pid from people where pid &gt; 7&quot;);</code></li><li><code>SELECT pid,people_name FROM people WHERE (EXISTS (select pid from people where pid &gt; 7))</code></li></ul><hr><h6 id="1-notExists-String-existsSql-sql语句"><a href="#1-notExists-String-existsSql-sql语句" class="headerlink" title="1. notExists(String existsSql) sql语句"></a>1. notExists(String existsSql) sql语句</h6><ul><li>判断参数中的sql语句 是否成立 不符合条件即成立</li><li><code> qw.notExists(&quot;select pid from people where pid &lt;0 &quot;);</code></li><li><code>SELECT pid,people_name FROM people WHERE (NOT EXISTS (select pid from people where pid &lt;0 ))</code></li></ul><hr><h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意:"></a>注意:</h5><p>方法参数<strong>boolean condition</strong> (可以防止条件判断例如name!&#x3D;null)决定后面该条件是否添加 true:添加 false:不添加</p><hr><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a><strong>分页</strong></h2><h3 id="InnerInterceptor插件"><a href="#InnerInterceptor插件" class="headerlink" title="InnerInterceptor插件"></a>InnerInterceptor插件</h3><p>我们提供的插件都将基于此接口来实现功能</p><p>目前已有的功能:</p><ul><li>自动分页: <strong>PaginationInnerInterceptor</strong></li><li>多租户: TenantLineInnerInterceptor</li><li>动态表名: DynamicTableNameInnerInterceptor</li><li>乐观锁: OptimisticLockerInnerInterceptor</li><li>sql性能规范: IllegalSQLInnerInterceptor</li><li>防止全表更新与删除: BlockAttackInnerInterceptor</li></ul><p>前提: 配置分页插件,实现物理分页. 默认是内存分页</p><h3 id="spring-boot"><a href="#spring-boot" class="headerlink" title="spring-boot"></a>spring-boot</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;scan.your.mapper.package&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新的分页插件,一缓和二缓遵循mybatis的规则,需要设置 MybatisConfiguration#useDeprecatedExecutor = false 避免缓存出现问题(该属性会在旧插件移除后一同移除)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    @Bean</span></span><br><span class="line"><span class="comment">    public ConfigurationCustomizer configurationCustomizer() &#123;</span></span><br><span class="line"><span class="comment">        return configuration -&gt; configuration.setUseDeprecatedExecutor(false);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringBoot中创建配置上述配置类 @Configuration @Bean</p><p>将MybatisPlusInterceptor组件交给SpringBoot容器</p><p>再在使用的时候创建IPage接口对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IPage&lt;Person&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;();<span class="comment">//也可使用有参构造</span></span><br></pre></td></tr></table></figure><p>设置完参数过后 使用mapper对象的selectPage方法 返回一个Ipage对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IPage&lt;Person&gt; personIPage = peopleMapper.selectPage(page, qw);</span><br></pre></td></tr></table></figure><p>通过该对象 可以获得分页相关的信息(包括查询的记录)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">        qw.ge(<span class="string">&quot;pid&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        IPage&lt;Person&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//设置分页的数据</span></span><br><span class="line"></span><br><span class="line">        page.setCurrent(<span class="number">1</span>);<span class="comment">//设置第几页</span></span><br><span class="line">        page.setSize(<span class="number">4</span>);<span class="comment">//显示多少条记录</span></span><br><span class="line">        IPage&lt;Person&gt; personIPage = peopleMapper.selectPage(page, qw);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取分页后的记录 getRecords()</span></span><br><span class="line">        List&lt;Person&gt; records = personIPage.getRecords();</span><br><span class="line">        System.out.println(records.size());</span><br><span class="line">        <span class="keyword">for</span> (Person record : records) &#123;</span><br><span class="line">            System.out.println(record);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//页数</span></span><br><span class="line">        System.out.println(personIPage.getPages());</span><br><span class="line">        <span class="comment">//总记录数</span></span><br><span class="line">        System.out.println(personIPage.getTotal());</span><br><span class="line">        <span class="comment">//当前页码</span></span><br><span class="line">        System.out.println(personIPage.getCurrent());</span><br><span class="line">        <span class="comment">//每页记录数</span></span><br><span class="line">        System.out.println(personIPage.getSize());</span><br></pre></td></tr></table></figure><p><strong>会根据指定的数据库选择分页操作</strong>(mysql是limit)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT pid,people_name FROM people <span class="title function_">WHERE</span> <span class="params">(pid &gt;= ?)</span> LIMIT ?</span><br></pre></td></tr></table></figure><hr><h3 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis-config.xml"></a>mybatis-config.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;@page&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;page:dbType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a><strong><a href="https://www.mybatis-plus.com/guide/generator-new.html#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8-3-5-1-%E7%89%88%E6%9C%AC">代码生成器</a></strong></h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><p>AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。</p><blockquote><p>特别说明:</p><p>自定义模板有哪些可用参数？<a href="https://github.com/baomidou/generator/blob/develop/mybatis-plus-generator/src/main/java/com/baomidou/mybatisplus/generator/engine/AbstractTemplateEngine.java">Github (opens new window)</a>AbstractTemplateEngine 类中方法 getObjectMap 返回 objectMap 的所有值都可用。</p></blockquote><h4 id="使用"><a href="#使用" class="headerlink" title="使用:"></a>使用:</h4><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   // 注意！！当前包未传递依赖 mp 包，需要自己引入</span><br><span class="line">   <span class="comment">&lt;!--模板引擎--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在工程包下建立一个实体类(启动类)如下 修改相应的信息即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/my_db&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;devil&quot;</span>;</span><br><span class="line"></span><br><span class="line">        FastAutoGenerator.create(url,name,password)</span><br><span class="line">                <span class="comment">//全局配置</span></span><br><span class="line">                .globalConfig((scanner,builder) -&gt;</span><br><span class="line">                        builder.author(scanner.apply(<span class="string">&quot;Devil&quot;</span>))</span><br><span class="line">                                <span class="comment">//输出目录</span></span><br><span class="line">                                .outputDir(<span class="string">&quot;E:\\MyBatis\\mybatis-puls-07-generator&quot;</span>+<span class="string">&quot;\\src\\main\\java&quot;</span>)</span><br><span class="line">                                <span class="comment">//覆盖已生成的文件</span></span><br><span class="line">                                .fileOverride()</span><br><span class="line">                                <span class="comment">//禁止打开输出目录: 默认true</span></span><br><span class="line">                                .disableOpenDir()</span><br><span class="line">                )</span><br><span class="line">                <span class="comment">//包配置</span></span><br><span class="line">                .packageConfig((scanner,builder)-&gt;</span><br><span class="line">                        builder.parent(<span class="string">&quot;com.dyw.mybatispuls07generator&quot;</span>)</span><br><span class="line">                                <span class="comment">//自定义实体包名</span></span><br><span class="line">                                .entity(<span class="string">&quot;entity&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">                <span class="comment">//策略配置</span></span><br><span class="line">                .strategyConfig((scanner,builder) -&gt;</span><br><span class="line">                        builder.addInclude(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                                <span class="comment">//控制层配置</span></span><br><span class="line">                                .controllerBuilder().enableRestStyle().enableHyphenStyle()</span><br><span class="line">                                <span class="comment">//服务层配置</span></span><br><span class="line">                                .serviceBuilder()</span><br><span class="line">                                    <span class="comment">//去除服务接口的I前缀 %s表示实体类名:</span></span><br><span class="line">                                    .formatServiceFileName(<span class="string">&quot;%sServcie&quot;</span>)</span><br><span class="line">                                <span class="comment">//实体层配置</span></span><br><span class="line">                                .entityBuilder()</span><br><span class="line">                                .enableLombok()</span><br><span class="line">                                <span class="comment">//主键策略</span></span><br><span class="line">                                .idType(IdType.AUTO)</span><br><span class="line">                                <span class="comment">//时间自动填充</span></span><br><span class="line"><span class="comment">//                                .addTableFills(new Column(&quot;gmt_create&quot;, FieldFill.INSERT))</span></span><br><span class="line"><span class="comment">//                                .addTableFills(new Column(&quot;gmt_modified&quot;, FieldFill.INSERT_UPDATE))</span></span><br><span class="line">                                <span class="comment">//乐观锁</span></span><br><span class="line">                                .versionColumnName(<span class="string">&quot;version&quot;</span>)</span><br><span class="line">                                .versionPropertyName(<span class="string">&quot;version&quot;</span>)</span><br><span class="line">                                <span class="comment">//逻辑删除</span></span><br><span class="line">                                .logicDeleteColumnName(<span class="string">&quot;deleted&quot;</span>)</span><br><span class="line">                                .logicDeletePropertyName(<span class="string">&quot;deleted&quot;</span>)</span><br><span class="line">                ).templateEngine(<span class="keyword">new</span> <span class="title class_">VelocityTemplateEngine</span>()).execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a><a href="https://baomidou.com/pages/6b03c5/#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">逻辑删除</a></h3><p><strong>简介:</strong> 通过在数据库中设定的逻辑删除字段 达到并未真正删除 而是逻辑删除的效果</p><p><strong>说明:</strong></p><ul><li><p>只针对Mybatis-plus自动注入的sql语句起效(即 自定义的sql不能享受)</p></li><li><p>插入: 不做限制</p></li><li><p>查找: 会在where条件后面过滤掉已删除数据,且使用wrapper.entity生产的where条件会忽略此字段(<strong>如有特殊要求 需要查询历史所有字段 需要自定义sql语句</strong>)</p></li><li><p>更新: 会追加where条件防止更新到已删除的数据, 且使用wrapper.entity生产的where条件会忽略此字段</p></li><li><p>删除: 转变为更新(即将逻辑删除字段设置为逻辑删除属性)</p></li></ul><p><strong>例如:</strong></p><ul><li>删除(实际sql): <code>update user set deleted=1 where id = 1 and deleted = 0 </code></li><li>查找(实际sql): <code>select id,name,deleted from user where deleted = 0</code></li></ul><p><strong>字段类型支持说明:</strong></p><ul><li>支持所有数据类型(推荐使用 <code>Integer</code>,<code>Boolean</code>,<code>LocalDateTime</code>)</li><li>如果数据库字段使用<code>datetime</code>,逻辑未删除值和已删除值支持配置为字符串<code>null</code>,另一个值支持配置为函数来获取值如<code>now()</code></li></ul><p><strong>附录:</strong></p><ul><li>逻辑删除是为了方便数据恢复和保护数据本身价值等等的一种方案，但实际就是删除。</li><li>如果你需要频繁查出来看就不应使用逻辑删除，而是以一个状态去表示。</li></ul><hr><p><strong>使用</strong>(pringBoot):</p><ul><li>配置 application.yml文件</li></ul><blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment"># logic-delete-field: flag # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure></blockquote><ul><li>在实体类的逻辑删除字段上添加@TableLogic注解(加上此字段可以不用配置logic-delete-field)</li></ul><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给逻辑删除字段加上<span class="doctag">@TableLogic</span>注解 使其生效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> Integer deleted;</span><br></pre></td></tr></table></figure></blockquote><ul><li>配置完成后 正常调用mybatis-plus自动注入的sql语句即可</li></ul><hr><p><strong>注意</strong>: 数据库中的逻辑删除字段不要设置为 <strong><code>delete</code></strong> 敏感字段会报错</p><h3 id="通用枚举"><a href="#通用枚举" class="headerlink" title="通用枚举"></a><a href="https://baomidou.com/pages/8390a4/#_1%E3%80%81%E5%A3%B0%E6%98%8E%E9%80%9A%E7%94%A8%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7">通用枚举</a></h3><p><strong>简介:</strong> 使用mybatis-plus 通用枚举功能 可以在存储是存储value 查询自动显示为desc</p><hr><p><strong>使用:</strong> </p><blockquote><ul><li>方式一:  使用@EnumValue注解枚举属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">GradeEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    PRIMARY(<span class="number">1</span>, <span class="string">&quot;小学&quot;</span>),  SECONDORY(<span class="number">2</span>, <span class="string">&quot;中学&quot;</span>),  HIGH(<span class="number">3</span>, <span class="string">&quot;高中&quot;</span>);</span><br><span class="line"></span><br><span class="line">    GradeEnum(<span class="type">int</span> code, String descp) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.descp = descp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EnumValue</span><span class="comment">//标记数据库存的值是code</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String descp;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.descp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方式二: 枚举属性,实现IEnum接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">AgeEnum</span> <span class="keyword">implements</span> <span class="title class_">IEnum</span>&lt;Integer&gt; &#123;</span><br><span class="line">    ONE(<span class="number">1</span>, <span class="string">&quot;一岁&quot;</span>),</span><br><span class="line">    TWO(<span class="number">2</span>, <span class="string">&quot;二岁&quot;</span>),</span><br><span class="line">    THREE(<span class="number">3</span>, <span class="string">&quot;三岁&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一定重写toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>配置扫描通用枚举(SpringBoot): </p><blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">    <span class="comment"># 支持统配符 * 或者 ; 分割 通用枚举所在包</span></span><br><span class="line">    <span class="attr">typeEnumsPackage:</span> <span class="string">com.baomidou.springboot.entity.enums</span></span><br><span class="line">  <span class="string">....</span></span><br></pre></td></tr></table></figure><p>或是使用配置类配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusPropertiesCustomizer <span class="title function_">mybatisPlusPropertiesCustomizer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> properties -&gt; &#123;</span><br><span class="line">            <span class="type">GlobalConfig</span> <span class="variable">globalConfig</span> <span class="operator">=</span> properties.getGlobalConfig();</span><br><span class="line">            globalConfig.setBanner(<span class="literal">false</span>);</span><br><span class="line">            <span class="type">MybatisConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisConfiguration</span>();</span><br><span class="line">            configuration.setDefaultEnumTypeHandler(MybatisEnumTypeHandler.class);</span><br><span class="line">            properties.setConfiguration(configuration);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote></li></ul></blockquote><h3 id="自动填充功能"><a href="#自动填充功能" class="headerlink" title="自动填充功能"></a><a href="https://baomidou.com/pages/4c6bcf/">自动填充功能</a></h3><p><strong>原理:</strong></p><ul><li>实现元对象处理器接口：com.baomidou.mybatisplus.core.handlers.MetaObjectHandler</li><li>注解填充字段 <code>@TableField(.. fill = FieldFill.INSERT)</code> 生成器策略部分也可以配置！</li></ul><ul><li><p>自定义实现类 MyMetaObjectHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在这里配置insert时填充的字段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        setFieldValByName(<span class="string">&quot;sex&quot;</span>, UserSexEnum.MAN,metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里配置update时填充的字段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置好了之后 只要指定字段再插入&#x2F;更新时 为null 就能自动填充</li></ul></li></ul><p><strong>注意:</strong></p><blockquote><ul><li>填充原理是直接给<code>entity</code>的属性设置值!!!</li><li>注解则是指定该属性在对应情况下必有值,如果无值则入库会是<code>null</code></li><li><code>MetaObjectHandler</code>提供的默认方法的策略均为:如果属性有值则不覆盖,如果填充值为<code>null</code>则不填充</li><li>字段必须声明<code>TableField</code>注解,属性<code>fill</code>选择对应策略,该声明告知<code>Mybatis-Plus</code>需要预留注入<code>SQL</code>字段</li><li>填充处理器<code>MyMetaObjectHandler</code>在 Spring Boot 中需要声明<code>@Component</code>或<code>@Bean</code>注入</li><li>要想根据注解<code>FieldFill.xxx</code>和<code>字段名</code>以及<code>字段类型</code>来区分必须使用父类的<code>strictInsertFill</code>或者<code>strictUpdateFill</code>方法</li><li>不需要根据任何来区分可以使用父类的<code>fillStrategy</code>方法</li><li>update(T t,Wrapper updateWrapper)时t不能为空,否则自动填充失效</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MyBatis&quot;&gt;&lt;a href=&quot;#MyBatis&quot; class=&quot;headerlink&quot; title=&quot;MyBatis&quot;&gt;&lt;/a&gt;&lt;strong&gt;MyBatis&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;第一章-ssm-x3D-spring-springmvc-mybatis&quot;&gt;&lt;a href=&quot;#第一章-ssm-x3D-spring-springmvc-mybatis&quot; class=&quot;headerlink&quot; title=&quot;第一章(ssm &amp;#x3D; spring + springmvc + mybatis)&quot;&gt;&lt;/a&gt;&lt;strong&gt;第一章(ssm &amp;#x3D; spring + springmvc + mybatis)&lt;/strong&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;三层架构&lt;br&gt;界面层： 和用户打交道的， 接收用户的请求参数， 显示处理结果的。（jsp ，html ，servlet）&lt;br&gt;业务逻辑层： 接收了界面层传递的数据，计算逻辑，调用数据库，获取数据&lt;br&gt;数据访问层： 就是访问数据库， 执行对数据的查询，修改，删除等等的。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;三层对应的包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  界面层： controller包 （servlet）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  业务逻辑层： service 包（XXXService类）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  数据访问层： dao包（XXXDao类）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


&lt;pre&gt;&lt;code&gt; 三层中类的交互
   用户使用界面层--&amp;gt; 业务逻辑层---&amp;gt;数据访问层（持久层）--&amp;gt;数据库（mysql）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​     三层对应的处理框架&lt;br&gt;​       界面层—servlet—springmvc（框架）&lt;br&gt;​       业务逻辑层—service类–spring（框架）&lt;br&gt;​       数据访问层—dao类–mybatis（框架）&lt;/p&gt;</summary>
    
    
    
    <category term="持久层框架" scheme="https://devildyw.github.io/categories/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="databese" scheme="https://devildyw.github.io/tags/databese/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo</title>
    <link href="https://devildyw.github.io/2022/02/28/DUBBO/"/>
    <id>https://devildyw.github.io/2022/02/28/DUBBO/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-03-07T05:31:52.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DUBBO"><a href="#DUBBO" class="headerlink" title="DUBBO"></a>DUBBO</h1><h2 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a><a href="https://github.com/guangxush/SpringBoot_GRPC">RPC框架</a></h2><h3 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h3><p>RPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。</p><span id="more"></span><p>比较正式的描述是：一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p><p>那么我们至少从这样的描述中挖掘出几个要点：</p><ul><li>RPC是协议：既然是协议就只是一套规范，那么就需要有人遵循这套规范来进行实现。目前典型的RPC实现包括：Dubbo、Thrift、GRPC、Hetty等。</li><li>网络协议和网络IO模型对其透明：既然RPC的客户端认为自己是在调用本地对象。那么传输层使用的是TCP&#x2F;UDP还是HTTP协议，又或者是一些其他的网络协议它就不需要关心了。</li><li>信息格式对其透明：我们知道在本地应用程序中，对于某个对象的调用需要传递一些参数，并且会返回一个调用结果。至于被调用的对象内部是如何使用这些参数，并计算出处理结果的，调用方是不需要关心的。那么对于远程调用来说，这些参数会以某种信息格式传递给网络上的另外一台计算机，这个信息格式是怎样构成的，调用方是不需要关心的。</li><li>应该有跨语言能力：为什么这样说呢？因为调用方实际上也不清楚远程服务器的应用程序是使用什么语言运行的。那么对于调用方来说，无论服务器方使用的是什么语言，本次调用都应该成功，并且返回值也应该按照调用方程序语言所能理解的形式进行描述。</li></ul><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/640.png" alt="640"></p><hr><h3 id="为什么要用RPC"><a href="#为什么要用RPC" class="headerlink" title="为什么要用RPC"></a>为什么要用RPC</h3><p>其实这是应用开发到一定的阶段的强烈需求驱动的。如果我们开发简单的单一应用，逻辑简单、用户不多、流量不大，那我们用不着。当我们的系统访问量增大、业务增多时，我们会发现一台单机运行此系统已经无法承受。此时，我们可以将业务拆分成几个互不关联的应用，分别部署在各自机器上，以划清逻辑并减小压力。此时，我们也可以不需要RPC，因为应用之间是互不关联的。</p><p>当我们的业务越来越多、应用也越来越多时，自然的，我们会发现有些功能已经不能简单划分开来或者划分不出来。此时，可以将公共业务逻辑抽离出来，将之组成独立的服务Service应用 。而原有的、新增的应用都可以与那些独立的Service应用 交互，以此来完成完整的业务功能。</p><p>所以此时，我们急需一种高效的应用程序之间的通讯手段来完成这种需求，所以你看，RPC大显身手的时候来了！</p><p>其实描述的场景也是服务化 、微服务和分布式系统架构的基础场景。即RPC框架就是实现以上结构的有力方式。</p><h3 id="常用的RPC框架"><a href="#常用的RPC框架" class="headerlink" title="常用的RPC框架"></a>常用的RPC框架</h3><ul><li>Thrift：thrift是一个软件框架，用来进行可扩展且跨语言的服务的开发。它结合了功能强大的软件堆栈和代码生成引擎，以构建在 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml 这些编程语言间无缝结合的、高效的服务。</li><li>gRPC：一开始由 google 开发，是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。</li><li><strong>Dubbo</strong>：Dubbo是一个分布式服务框架，以及SOA治理方案。其功能主要包括：高性能NIO通讯及多协议集成，服务动态寻址与路由，软负载均衡与容错，依赖分析与降级等。Dubbo是阿里巴巴内部的SOA服务化治理方案的核心框架，Dubbo自2011年开源后，已被许多非阿里系公司使用。</li><li><strong>Spring Cloud</strong>：Spring Cloud由众多子项目组成，如Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Consul 等，提供了搭建分布式系统及微服务常用的工具，如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性token、全局锁、选主、分布式会话和集群状态等，满足了构建微服务所需的所有解决方案。Spring Cloud基于Spring Boot, 使得开发部署极其简单。</li></ul><h2 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h2><h3 id="RPC调用流程"><a href="#RPC调用流程" class="headerlink" title="RPC调用流程"></a>RPC调用流程</h3><p>要让网络通信细节对使用者透明，我们需要对通信细节进行封装，我们先看下一个RPC调用的流程涉及到哪些通信细节：</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220306235426986.png" alt="image-20220306235426986"></p><ol><li>服务消费方（client）调用以本地调用方式调用服务；</li><li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li><li>client stub找到服务地址，并将消息发送到服务端；</li><li>server stub收到消息后进行解码；</li><li>server stub根据解码结果调用本地的服务；</li><li>本地服务执行并将结果返回给server stub；</li><li>server stub将返回结果打包成消息并发送至消费方；</li><li>client stub接收到消息，并进行解码；</li><li>服务消费方得到最终结果。</li></ol><p>RPC的目标就是要2~8这些步骤都封装起来，让用户对这些细节透明。</p><p>下面是网上的另外一幅图，感觉一目了然：</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220306235500320.png" alt="image-20220306235500320"></p><h3 id="如何做到透明化远程服务调用"><a href="#如何做到透明化远程服务调用" class="headerlink" title="如何做到透明化远程服务调用"></a>如何做到透明化远程服务调用</h3><p>怎么封装通信细节才能让用户像以本地调用方式调用远程服务呢？对java来说就是使用代理！java代理有两种方式：1） jdk 动态代理；2）字节码生成。尽管字节码生成方式实现的代理更为强大和高效，但代码维护不易，大部分公司实现RPC框架时还是选择动态代理方式。</p><blockquote><p>其实就是通过动态代理模式，在执行该方法的前后对数据进行封装和解码等，让用于感觉就像是直接调用该方法一样，殊不知，我们对方法前后都经过了复杂的处理。(通过代理实现在调用方法前后进行编码和译码)</p></blockquote><h3 id="如何对消息进行编码和解码"><a href="#如何对消息进行编码和解码" class="headerlink" title="如何对消息进行编码和解码"></a>如何对消息进行编码和解码</h3><h4 id="确定消息数据结构"><a href="#确定消息数据结构" class="headerlink" title="确定消息数据结构"></a>确定消息数据结构</h4><p>客户端的请求消息结构一般需要包括以下内容：</p><ul><li>接口名称：在我们的例子里接口名是“HelloWorldService”，如果不传，服务端就不知道调用哪个接口了；</li><li>方法名：一个接口内可能有很多方法，如果不传方法名服务端也就不知道调用哪个方法；</li><li>参数类型&amp;参数值：参数类型有很多，比如有bool、int、long、double、string、map、list，甚至如struct等，以及相应的参数值；</li><li>超时时间 + requestID（标识唯一请求id）</li></ul><p>服务端返回的消息结构一般包括以下内容：</p><ul><li>状态code + 返回值</li><li>requestID(<strong>可以根据requestID去查验调用结果</strong>)</li></ul><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>一旦确定了消息的数据结构后，下一步就是要考虑序列化与反序列化了。</p><p>什么是序列化？序列化就是将数据结构或对象转换成二进制串的过程，也就是编码的过程。</p><p>什么是反序列化？将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。</p><p>为什么需要序列化？转换为二进制串后才好进行网络传输嘛！</p><p>为什么需要反序列化？将二进制转换为对象才好进行后续处理！</p><p>现如今序列化的方案越来越多，每种序列化方案都有优点和缺点，它们在设计之初有自己独特的应用场景，那到底选择哪种呢？从RPC的角度上看，主要看三点：</p><ul><li>通用性：比如是否能支持Map等复杂的数据结构；</li><li>性能：包括时间复杂度和空间复杂度，由于RPC框架将会被公司几乎所有服务使用，如果序列化上能节约一点时间，对整个公司的收益都将非常可观，同理如果序列化上能节约一点内存，网络带宽也能省下不少；</li><li>可扩展性：对互联网公司而言，业务变化飞快，如果序列化协议具有良好的可扩展性，支持自动增加新的业务字段，而不影响老的服务，这将大大提供系统的灵活度。</li></ul><p>目前互联网公司广泛使用Protobuf、Thrift、Avro等成熟的序列化解决方案来搭建RPC框架，这些都是久经考验的解决方案。</p><h3 id="如何发布自己的服务"><a href="#如何发布自己的服务" class="headerlink" title="如何发布自己的服务"></a>如何发布自己的服务</h3><p>通过注册中心将生产者和消费者联系起来,将生产者(消息的提供者)注册到注册中心,消费者通过与注册中心的长连接获得生产者的ip去获得服务. <strong>java常用的是zookeeper</strong></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220306235517192.png" alt="image-20220306235517192"></p><hr><h2 id="Dubbo-Architecture"><a href="#Dubbo-Architecture" class="headerlink" title="Dubbo Architecture"></a><a href="https://dubbo.apache.org/zh/docs/">Dubbo Architecture</a></h2><p>Dubbo 提供了构建云原生微服务业务的一站式解决方案，可以使用 Dubbo 快速定义并发布微服务组件，同时基于 Dubbo 开箱即用的丰富特性及超强的扩展能力，构建运维整个微服务体系所需的各项服务治理能力，如 Tracing、Transaction 等，Dubbo 提供的基础能力包括：</p><ul><li>服务发现</li><li>流式通信</li><li>负载均衡</li><li>流量治理</li><li>…..</li></ul><p>Dubbo 计划提供丰富的多语言客户端实现，其中 Java、Golang 版本是当前稳定性、活跃度最好的版本，其他多语言客户端[]正在持续建设中。</p><p><strong>Dubbo的优点</strong>:</p><blockquote><ul><li>开箱即用<ul><li>易用性高，如 Java 版本的面向接口代理特性能实现本地透明调用</li><li>功能丰富，基于原生库或轻量扩展即可实现绝大多数的微服务治理能力</li></ul></li><li>超大规模微服务集群实践<ul><li>高性能的跨进程通信协议</li><li>地址发现、流量治理层面，轻松支持百万规模集群实例</li></ul></li><li>企业级微服务治理能力<ul><li>服务测试</li><li>服务Mock</li></ul></li></ul></blockquote><p>Dubbo3 是在云原生背景下诞生的，使用 Dubbo 构建的微服务遵循云原生思想，能更好的复用底层云原生基础设施、贴合云原生微服务架构。这体现在：</p><ul><li>服务支持部署在容器、Kubernetes平台，服务生命周期可实现与平台调度周期对齐；</li><li>支持经典 Service Mesh 微服务架构，引入了 Proxyless Mesh 架构，进一步简化 Mesh 的落地与迁移成本，提供更灵活的选择；</li><li>作为桥接层，支持与 SpringCloud、gRPC 等异构微服务体系的互调互通</li></ul><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>服务发现，即消费端自动发现服务地址列表的能力，是微服务框架需要具备的关键能力，借助于自动化的服务发现，微服务之间可以在无需感知对端部署位置与 IP 地址的情况下实现通信。</p><p>Dubbo提供的是一种Client-Based的服务发现机制,通常还需要部署第三方的注册中心来实现,例如Nacos,Consul,Zookeeper等,Dubbo自身也提供了对多种注册中心组件的对接,用户可以灵活选择.</p><p>Dubbo 基于消费端的自动服务发现能力，其基本工作原理如下图：</p><p><img src="https://dubbo.apache.org/imgs/architecture.png" alt="//imgs/architecture.png"></p><p><img src="https://dubbo.apache.org/imgs/v3/concepts/threecenters.png" alt="//imgs/v3/concepts/threecenters.png"></p><p>服务发现的一个核心组件是注册中心,Provider注册ip地址到注册中心,Consumer从注册中心读取和订阅Provider地址列表,因此要启用服务发现需要为Dubbo增加注册中心的配置</p><p><code>dubbo-spring-boot-starter</code>使用方式 增加registry配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"><span class="string">dubbo</span></span><br><span class="line"> <span class="string">registry</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">zookeeper://127.0.0.1:2181</span></span><br></pre></td></tr></table></figure><h3 id="Dubbo的协议-RPC-通信协议-Apache-Dubbo"><a href="#Dubbo的协议-RPC-通信协议-Apache-Dubbo" class="headerlink" title="]Dubbo的协议](RPC 通信协议 | Apache Dubbo)"></a>]Dubbo的协议](<a href="https://dubbo.apache.org/zh/docs/concepts/rpc-protocol/">RPC 通信协议 | Apache Dubbo</a>)</h3><ul><li><p><strong>Triple</strong></p><blockquote><p><strong>Triple</strong>是一种兼容 gRPC ，以 HTTP2 作为传输层构建新的协议.</p></blockquote></li></ul><h3 id="Dubbo-服务流量管理-服务流量管理-Apache-Dubbo"><a href="#Dubbo-服务流量管理-服务流量管理-Apache-Dubbo" class="headerlink" title="[Dubbo 服务流量管理](服务流量管理 | Apache Dubbo)"></a>[Dubbo 服务流量管理](<a href="https://dubbo.apache.org/zh/docs/concepts/traffic-management/">服务流量管理 | Apache Dubbo</a>)</h3><h4 id="流量管理"><a href="#流量管理" class="headerlink" title="流量管理"></a>流量管理</h4><p>流量管理的本质是将请求根据制定好的路由规则分发到应用服务上，如下图所示：</p><p><img src="https://dubbo.apache.org/imgs/v3/concepts/what-is-traffic-control.png" alt="What is traffic control"></p><ul><li>路由规则可以有多个，不同的路由规则之间存在优先级。如：<strong>Router(1) -&gt; Router(2) -&gt; …… -&gt; Router(n)</strong></li><li>一个路由规则可以路由到多个不同的应用服务。如：Router(2)既可以路由到Service(1)也可以路由到Service(2)</li><li>多个不同的路由规则可以路由到同一个应用服务。如：Router(1)和Router(2)都可以路由到Service(2)</li><li>路由规则也可以不路由到任何应用服务。如：Router(m)没有路由到任何一个Service上，所有命中Router(m)的请求都会因为没有对应的应用服务处理而导致报错</li><li>应用服务可以是单个的实例，也可以是一个应用集群。</li></ul><h3 id="Dubbo的配置"><a href="#Dubbo的配置" class="headerlink" title="Dubbo的配置"></a>Dubbo的配置</h3><h4 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h4><p>即采用xml格式的配置文件 配置Dubbo 详情参数和配置参考官方文档</p><p><a href="https://dubbo.apache.org/zh/docs/references/xml/">Schema 配置参考手册 | Apache Dubbo</a></p><h4 id="注解配置-注解配置-Apache-Dubbo"><a href="#注解配置-注解配置-Apache-Dubbo" class="headerlink" title="[注解配置](注解配置 | Apache Dubbo)"></a>[注解配置](<a href="https://dubbo.apache.org/zh/docs/references/configuration/annotation/#%E5%A2%9E%E5%8A%A0%E5%BA%94%E7%94%A8%E5%85%B1%E4%BA%AB%E9%85%8D%E7%BD%AE">注解配置 | Apache Dubbo</a>)</h4><h5 id="服务提供方"><a href="#服务提供方" class="headerlink" title="服务提供方"></a>服务提供方</h5><p>**<code>@DubboService</code>**注解暴露服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DubboService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AnnotationService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;annotation: hello, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="增加应用共享配置"><a href="#增加应用共享配置" class="headerlink" title="增加应用共享配置"></a>增加应用共享配置</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dubbo-provider.properties</span></span><br><span class="line"><span class="attr">dubbo.application.name</span>=<span class="string">annotation-provider</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="attr">dubbo.protocol.name</span>=<span class="string">dubbo</span></span><br><span class="line"><span class="attr">dubbo.protocol.port</span>=<span class="string">20880</span></span><br></pre></td></tr></table></figure><h5 id="增加spring扫描路径"><a href="#增加spring扫描路径" class="headerlink" title="增加spring扫描路径"></a>增加spring扫描路径</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableDubbo(scanBasePackages = &quot;org.apache.dubbo.samples.simple.annotation.impl&quot;)</span><span class="comment">//也可以在启动类上配置 启动类本身也就是一个配置类</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/spring/dubbo-provider.properties&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderConfiguration</span> &#123;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="服务消费方"><a href="#服务消费方" class="headerlink" title="服务消费方"></a>服务消费方</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;annotationAction&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationAction</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DubboReference</span></span><br><span class="line">    <span class="keyword">private</span> AnnotationService annotationService;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doSayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> annotationService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="增加应用共享配置-1"><a href="#增加应用共享配置-1" class="headerlink" title="增加应用共享配置"></a>增加应用共享配置</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dubbo-consumer.properties</span></span><br><span class="line"><span class="attr">dubbo.application.name</span>=<span class="string">annotation-consumer</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="attr">dubbo.consumer.timeout</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure><h5 id="指定Spring扫描路径"><a href="#指定Spring扫描路径" class="headerlink" title="指定Spring扫描路径"></a>指定Spring扫描路径</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableDubbo(scanBasePackages = &quot;org.apache.dubbo.samples.simple.annotation.action&quot;)</span><span class="comment">//同样可以在启动类中配置 也可在配置文件中配置</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/spring/dubbo-consumer.properties&quot;)</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &#123;&quot;org.apache.dubbo.samples.simple.annotation.action&quot;&#125;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用服务"><a href="#调用服务" class="headerlink" title="调用服务"></a>调用服务</h4><p>配置完一切就可以(先启动生产者 在启动消费者)像调用本地方法一样去调用远程服务了(不用去考虑底层的传输协议 编码解码之类的繁琐的东西)</p><hr><h3 id="Dubbo的使用"><a href="#Dubbo的使用" class="headerlink" title="Dubbo的使用"></a>Dubbo的使用</h3><p>对于Dubbo而言一个完整的简单的Dubbo项目应该有如下三个模块 生产者(服务的提供者) 消费者(服务的消费者) API(暴露的接口名称和公共可用的信息)</p><ul><li><p>创建一个简单的Demo Maven工程</p></li><li><p>创建三个子工程分别是**<code>consumer provider dubbo-api</code>**</p></li><li><p>首先编写dubbo-api编写其中的service接口和需要用的其他信息(consumer和provider都能用到的信息 比如实体类 访问的param对象等)注意: 类应当实现序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MailUserService</span> &#123;</span><br><span class="line">    Result <span class="title function_">save</span><span class="params">(MailUser mailUser)</span>;</span><br><span class="line"></span><br><span class="line">    Result&lt;MailUser&gt; <span class="title function_">selectUserById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    Result&lt;MailUser&gt; <span class="title function_">selectUserByInfo</span><span class="params">(MailUser mailUser)</span>;</span><br><span class="line"></span><br><span class="line">    Result&lt;List&lt;MailUser&gt;&gt; <span class="title function_">selectUserList</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Result&lt;String&gt; <span class="title function_">sendMail</span><span class="params">(MailDTO mailDTO)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220306214920772.png" alt="image-20220306214920772"></p><p><strong>然后将其打包上传到本地仓库或是远程仓库供生产者和消费者使用</strong></p></li><li><p>在provider 和 consumer中都加入 </p><blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--这个是dubbo的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这个是注册中心的依赖 这里使用的是zookeeper--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-dependencies-zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这个是公用的api依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dyw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Demo-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.2-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>在provider中实现dubbo-api中的编写的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@DubboService</span> <span class="comment">//使用该注解可以将该服务注册到注册中心 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailUserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MailUserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(MailUser mailUser)</span> &#123;</span><br><span class="line">        userMapper.insert(mailUser);</span><br><span class="line">        <span class="keyword">return</span> R.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;MailUser&gt; <span class="title function_">selectUserById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;MailUser&gt; mailUserLambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        mailUserLambdaQueryWrapper.eq(MailUser::getId, id).last(<span class="string">&quot;last 1&quot;</span>);</span><br><span class="line">        <span class="type">MailUser</span> <span class="variable">mailUser</span> <span class="operator">=</span> userMapper.selectOne(mailUserLambdaQueryWrapper);</span><br><span class="line">        <span class="keyword">return</span> R.success(mailUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;MailUser&gt; <span class="title function_">selectUserByInfo</span><span class="params">(MailUser mailUser)</span> &#123;</span><br><span class="line">        <span class="type">MailUser</span> <span class="variable">mailUser1</span> <span class="operator">=</span> userMapper.selectById(mailUser);</span><br><span class="line">        <span class="keyword">return</span> R.success(mailUser1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;MailUser&gt;&gt; <span class="title function_">selectUserList</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;MailUser&gt; mailUsers = userMapper.selectList(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> R.success(mailUsers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">sendMail</span><span class="params">(MailDTO mailDTO)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; idList = mailDTO.getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sendTime</span> <span class="operator">=</span> mailDTO.getSendTime();</span><br><span class="line">        <span class="type">String</span> <span class="variable">subject</span> <span class="operator">=</span> mailDTO.getSubject();</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> mailDTO.getContent();</span><br><span class="line">        List&lt;MailUser&gt; userList = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(subject) || StringUtils.isBlank(content)) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.fail(<span class="string">&quot;参数有误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idList.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            userList = userMapper.selectList(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            userList = userMapper.selectBatchIds(idList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(sendTime)) &#123;</span><br><span class="line">            sendTime = <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        mailDTO.setUserList(userList);</span><br><span class="line">        mailDTO.setSendTime(sendTime);</span><br><span class="line"></span><br><span class="line">        rocketMQTemplate.asyncSend(<span class="string">&quot;notice:mail&quot;</span>, mailDTO, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;发送信息成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;发送失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> R.success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>编写实现完所有的接口后 记得将服务注册到注册中心 这里需要配置dubbo 和 服务中心的信息</p><blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&gt;dubbo:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Demo-provider</span> <span class="comment">#应用名称</span></span><br><span class="line"><span class="attr">registry:</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">zookeeper://localhost:2181</span> <span class="comment">#注册中心地址</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">6000</span> <span class="comment">#获取配置的超时时间</span></span><br><span class="line"><span class="attr">protocol:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">20880</span> <span class="comment">#服务端口</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dubbo</span> <span class="comment">#协议名称</span></span><br><span class="line"><span class="attr">scan:</span></span><br><span class="line">  <span class="attr">base-packages:</span> <span class="string">com.dyw.demoprovider.service.Impl</span> <span class="comment"># 扫描服务实现的包的位置 使用注解时才使用</span></span><br></pre></td></tr></table></figure><p>紧接着就是配置需要注册到注册中心的服务的信息(可以使用注解)如果使用spring-config配置服务的信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">     http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;demo-provider&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20890&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.dubbo.samples.basic.impl.DemoServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;org.apache.dubbo.samples.basic.api.DemoService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;demoService&quot;</span>/&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>在consumer中也需要配置注册中心的信息 来获取远端信息</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;dubbo:</span><br><span class="line">registry:</span><br><span class="line">  address: zookeeper:<span class="comment">//localhost:2181</span></span><br><span class="line">application:</span><br><span class="line">  name: Demo-Consumer</span><br></pre></td></tr></table></figure><p>完成上述配置后 就可以进行接口的调用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">@RestController</span></span><br><span class="line">&gt;<span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="meta">@DubboReference</span></span><br><span class="line">  MailUserService mailUserService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span></span><br><span class="line">  <span class="keyword">public</span> Result&lt;List&lt;MailUser&gt;&gt; <span class="title function_">selectUserList</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mailUserService.selectUserList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span></span><br><span class="line">  <span class="keyword">public</span> Result&lt;MailUser&gt; <span class="title function_">addUser</span><span class="params">(<span class="meta">@RequestBody</span> MailUser mailUser)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mailUserService.save(mailUser);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Result&lt;MailUser&gt; <span class="title function_">selectUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mailUserService.selectUserById(id);</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">@RestController</span></span><br><span class="line">&gt;<span class="meta">@RequestMapping(&quot;mail&quot;)</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailController</span> &#123;</span><br><span class="line">  <span class="meta">@DubboReference</span></span><br><span class="line">  MailUserService mailUserService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span></span><br><span class="line">  <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">sendMail</span><span class="params">(<span class="meta">@RequestBody</span> MailDTO mailDTO)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mailUserService.sendMail(mailDTO);</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><p>你会发现一个有意思的事情 比如 我的mybatis log配置在生产者端 但是确实我的消费端看到了日志信息. 这也说明了服务是在消费者端实现的 证明了上述RPC框架的图</p></li></ul><h2 id="Dubbo高级用法"><a href="#Dubbo高级用法" class="headerlink" title="Dubbo高级用法"></a>Dubbo高级用法</h2><p>参考官方文档 用法很多</p><p><a href="https://dubbo.apache.org/zh/docs/advanced/">高级用法 | Apache Dubbo</a></p><h1 id="—-END—"><a href="#—-END—" class="headerlink" title="—-END—-"></a>—-END—-</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;DUBBO&quot;&gt;&lt;a href=&quot;#DUBBO&quot; class=&quot;headerlink&quot; title=&quot;DUBBO&quot;&gt;&lt;/a&gt;DUBBO&lt;/h1&gt;&lt;h2 id=&quot;RPC框架&quot;&gt;&lt;a href=&quot;#RPC框架&quot; class=&quot;headerlink&quot; title=&quot;RPC框架&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/guangxush/SpringBoot_GRPC&quot;&gt;RPC框架&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;什么是RPC&quot;&gt;&lt;a href=&quot;#什么是RPC&quot; class=&quot;headerlink&quot; title=&quot;什么是RPC&quot;&gt;&lt;/a&gt;什么是RPC&lt;/h3&gt;&lt;p&gt;RPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。&lt;/p&gt;</summary>
    
    
    
    <category term="中间件" scheme="https://devildyw.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="java" scheme="https://devildyw.github.io/tags/java/"/>
    
  </entry>
  
</feed>
