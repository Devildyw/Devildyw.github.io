<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Devil的个人博客</title>
  
  <subtitle>永远相信美好的事情即将发生</subtitle>
  <link href="https://devildyw.github.io/atom.xml" rel="self"/>
  
  <link href="https://devildyw.github.io/"/>
  <updated>2022-10-26T07:59:51.994Z</updated>
  <id>https://devildyw.github.io/</id>
  
  <author>
    <name>Devil</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NIO</title>
    <link href="https://devildyw.github.io/2022/10/25/NIO/"/>
    <id>https://devildyw.github.io/2022/10/25/NIO/</id>
    <published>2022-10-25T09:14:40.000Z</published>
    <updated>2022-10-26T07:59:51.994Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><h2 id="NIO-与-BIO的区别"><a href="#NIO-与-BIO的区别" class="headerlink" title="NIO 与 BIO的区别"></a>NIO 与 BIO的区别</h2><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>Java IO 核心就是流。流只能单向，要么输入，要么输出。只能选其一。</p><p>Java IO 就是典型的 BIO 模型，即面向流编程，一个流要么是输入，要么是输出。</p><p>BIO 是阻塞的，即在准备读取数据到数据返回期间需要等待内核将数据准备完毕，再通过 IO 阻塞传输到用户空间。</p><h3 id="NIO-1"><a href="#NIO-1" class="headerlink" title="NIO"></a>NIO</h3><p>Java NIO 与 BIO 不同，NIO 有三个核心组件 Channel、Buffer、Selector，在 NIO 中我们是<strong>面向块(block) <strong>或是</strong>缓冲区(buffer)</strong> 编程的。与 Stream 不同的是，Channel 是<strong>双向的</strong>，流只能<strong>单向</strong>所以区分 <strong>In</strong> 和 <strong>Out</strong>，所以 Channel 打开后可以进行<strong>读取、写入或是读写</strong>。</p><p>NIO 是非阻塞的，在数据准备阶段不需要等待，需要启动一个线程一直监听内核是否将数据准备完毕，准备完毕后，监听线程通知 IO 线程阻塞读取数据（这一块还是阻塞的）。</p><blockquote><p>由于 Channel 是双向的，因此它能更好地反映出底层操作系统的真实情况；在 Linux 系统中，底层操作系统的通道就是双向的。</p></blockquote><h2 id="NIO-核心组件介绍"><a href="#NIO-核心组件介绍" class="headerlink" title="NIO 核心组件介绍"></a>NIO 核心组件介绍</h2><p><strong>NIO 包含3个核心的组件：</strong></p><ul><li>Channel(通道)</li><li>Buffer(缓冲区)</li><li>Selector(选择器)</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0facff245004ef7adb37a1846c176fb~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><h3 id="缓冲区（Buffer）"><a href="#缓冲区（Buffer）" class="headerlink" title="缓冲区（Buffer）"></a>缓冲区（Buffer）</h3><p>在谈到缓冲区，<strong>我们说缓冲区对象本质上是一个数组，但它其实是一个特殊的数组，缓冲区对象内置了一些机制，能够追踪和记录缓冲区的状态变化情况</strong>，如果我们使用 <code>get()</code> 方法从缓冲区获取数据或者使用 <code>put()</code> 方法把数据写入缓冲区，都会引起缓冲区状态的变化。</p><blockquote><p>缓冲区三个重要属性：</p><ul><li>position：<strong>指定下一个将要被写入或者读取的元素索引，它的值由 get()&#x2F;put() 方法自动更新，在新创建一个 Buffer 对象时，position 被初始化为 0。</strong></li><li>limit：<strong>指定还有多少数据需要取出（在从缓冲区写入通道时），或者还有多少空间可以放入数据（在从通道读入缓冲区时）。</strong></li><li>capacity：<strong>指定了可以存储在缓冲区的最大数据容量，实际上，它指定了底层数据的大小，或者至少时指定了准许我们使用的底层数组的容量。</strong></li></ul><p>注：<strong>0&lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity</strong></p></blockquote><p>缓冲区的容量（capacity）是不变的，而位置（position）和上限（limit）以根据实际需要改变。也就是说可以通过改变当前位置和上限来操作缓冲区内任意位置的数据。</p><p>通过源码控制初始化时的上限（limit）和容量（capacity）是相同的，而位置（position）则是被初始化为了 0。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocate</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="comment">//调用初始化的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeapByteBuffer</span>(capacity, capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HeapByteBuffer(<span class="type">int</span> cap, <span class="type">int</span> lim) &#123;            <span class="comment">// package-private</span></span><br><span class="line">    <span class="comment">//传入了一个初始化容量为 cap 的数组</span></span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, <span class="number">0</span>, lim, cap, <span class="keyword">new</span> <span class="title class_">byte</span>[cap], <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    hb = new byte[cap];</span></span><br><span class="line"><span class="comment">    offset = 0;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/72fdf9989461473a9f481e9882a99785.png" alt="在这里插入图片描述"></p><hr><p>在 NIO 中，所有的缓冲区类型都继承与抽象类 Buffer，最常用的就是 ByteBuffer，对于 Java 中的基本类型，基本都有一个具体 Buffer 类型与之相对应。</p><ul><li><p><strong>缓存区的分配</strong>：可以通过调用静态方法 <code>allocate()</code> 来指定缓冲区的容量，其实调用 allocate 方法相当于<strong>创建了一个指定大小的数组，并把它包装为缓冲区对象</strong>。我们也可以<strong>自己创建一个数组通过调用静态方法 <code>wrap()</code> 来将其包装为缓冲区对象。</strong> </p></li><li><p><strong>缓冲区分片</strong>：根据现有的缓冲区对象创建一个子缓冲区，<strong>即在现有缓冲区上切出一片作为一个新的缓冲区，但现有的缓冲区与创建的子缓冲区在底层数面上是数据共享的（子缓冲区相当于现有缓冲区的一个视图窗口）。</strong>可以通过调用缓冲区对象的 <code>slice()</code> 创建。</p></li><li><p><strong>只读缓冲区</strong>：通过调用缓冲区对象的 <code>asReadOnlyBuffer()</code> 方法，将任何<strong>常规缓冲区转换为只读缓冲区</strong>，这个方法返回一个与原缓冲区<strong>完全相同</strong>的缓冲区，并与原缓冲区<strong>共享数据</strong>，只不过它是只读的。如果<strong>原缓冲区的内容发生了变化，只读缓冲区的内容也随之发生变化</strong>。<strong>注意：尝试修改只读缓冲区的内容，则会报 ReadOnlyBufferException 异常；只可以 常规–&gt; 只读 不可以 只读 –&gt; 可写</strong></p></li><li><p><strong>直接缓冲区</strong>：直接缓冲区是为了加快 I&#x2F;O 速度，使用一种特殊方式为其分配内存的缓冲区。<strong>该缓冲区会在每一次调用底层操作系统的本机 I&#x2F;O 操作之前（或之后），尝试避免将缓冲区内容拷贝到一个中间缓冲区拷贝数据。</strong>通过调用静态方法 <code>allocateDirect()</code> 方法</p></li><li><p><strong>内存映射</strong>：比常规的基于流或者基于通道的 I&#x2F;O 快得多。 <strong>内存映射文件 I&#x2F;O 通过使文件的数据表现为内存数组的内容来完成</strong>。一般来说，<strong>只有文件中实际读取或写入的部分才会映射到内存中</strong>。</p></li></ul><hr><h4 id="Buffer-数据类型"><a href="#Buffer-数据类型" class="headerlink" title="Buffer 数据类型"></a>Buffer 数据类型<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2570db1b8d254311a4287daf087d585a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></h4><p>从类图中可以看到，7中数据类型对应着 7 中子类，这些名字是 Heap 开头子类，数据是存放在 JVM 堆中的。</p><h5 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h5><p>与 HeapByteBuffer 数据存放在 JVM 堆中的不同，MappedByteBuffer 是将数据存放在<strong>堆以外</strong>的<strong>直接内存</strong>的，可以映射到文件。</p><p>通过 java.nio 包和 MappedByteBuffer 允许 Java 程序直接从内存中读取文件内容，通过整个或部分文件映射到内存，由操作系统来处理加载请求和写文件，应用只需要和内存打交道，这使得 IO 很快。</p><p>Mmap 内存映射和普通标准 IO 操作的本质区别在于<strong>它并不需要将文件中的数据先拷贝至 OS 的内核 IO 缓冲区</strong>，而是可以<strong>直接将用户进程私有地址空间一块区域与文件对象建立映射关系</strong>，这样程序就好像可以<strong>直接从内存中完成对文件 读&#x2F;写 操作一样</strong>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed673b99773a48bbbdc1d99182e01e50~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p>采用Mmap的方式其读&#x2F;写的效率和性能都非常高，大家熟知的 <strong>RocketMQ</strong> 就使用了该技术。</p><hr><h3 id="选择器（Selector）"><a href="#选择器（Selector）" class="headerlink" title="选择器（Selector）"></a>选择器（Selector）</h3><p>NIO 中非阻塞 I&#x2F;O 采用了基于 Reactor 模式的工作方式， I&#x2F;O 调用不会被阻塞，而是注册感兴趣的特定 I&#x2F;O 事件，如可读数据到达、新的套接字连接等，在发生特定事件时，系统再通知我们。NIO 中实现非阻塞 I&#x2F;O 的核心对象是 Selector，Selector 是注册各种 I&#x2F;O 事件的地方，而且当那些事情发生时，就是 Selector 告诉我们所发生的事件。</p><p>Selector 会不断地轮询注册在上面所有 Channel，如果某个 channel 为读写等事件做好准备，那么就处于就绪状态，通过 Selector 可以不断轮询发现出就绪的 channel，进行后续的 IO 操作。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b35e7714003440ad93c6695772295de2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p>一个Selector能够同时轮询多个channel，这样，一个单独的线程就可以管理多个channel，从而管理多个网络连接，这样就不用为每一个连接都创建一个线程，同时也避免了多线程之间上下文切换导致的开销。（较与 BIO 的优点）。</p><h3 id="通道（Channel）"><a href="#通道（Channel）" class="headerlink" title="通道（Channel）"></a>通道（Channel）</h3><p>通道是一个对象，通过它可以读取和写入数据，当然所有数据都通过 Buffer 对象来处理。我们永远不会将字节直接写入通道，而是将数据写入包含一个或者多个字节的缓冲区。同样也不会直接从通道中读取字节，而是通过数据从通道读入缓冲区，再从缓冲区获取这个字节。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f2e88ae541f420d9f59c433b68cdcb8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><h3 id="反应堆"><a href="#反应堆" class="headerlink" title="反应堆"></a>反应堆</h3><p>阻塞 I&#x2F;O 的通信模型如下图所示。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210091808348.png" alt="image-20221009180839283"></p><p>每个客户端连接成功后，服务端都会启动一个线程区处理该客户端请求。</p><p><strong>阻塞 I&#x2F;O 通信模型缺点</strong></p><ol><li>当客户端多时，会创建大量的处理线程。且每个线程都要占用栈空间和一些 CPU 时间。</li><li>阻塞可能带来频繁的上下文切换，且大部分上下文切换可能是无意义的。</li></ol><p>在这种情况下非阻塞 I&#x2F;O 就有了它的应用前景。</p><p><strong>Java NIO 工作原理。</strong></p><ol><li><strong>有一个专门的线程来处理所有 I&#x2F;O 事件，并负责分发。</strong></li><li><strong>事件驱动机制</strong>：事件到的时候出发，而不是同步地去监视事件。</li><li><strong>线程通信</strong>：线程之间通过 wait、notify 等方式通信。保证每次上下文切换都是<strong>有意义的</strong>，<strong>减少无谓的线程切换</strong>。</li></ol><blockquote><p> Java NIO 反应堆工作原理图。</p><p> <img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210091814247.png" alt="image-20221009181444168"></p><p> （注：每个线程的处理流程大概都是读取数据、解码、计算处理、编码和发送响应。）</p></blockquote><h2 id="NIO-理解与使用"><a href="#NIO-理解与使用" class="headerlink" title="NIO 理解与使用"></a>NIO 理解与使用</h2><h3 id="Buffer-的常用方法"><a href="#Buffer-的常用方法" class="headerlink" title="Buffer 的常用方法"></a>Buffer 的常用方法</h3><p>NIO提供一系列方法来操作Buffer的位置（position）和上限（limit），以及向缓冲区读写数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">put() <span class="comment">//向缓冲区position位置添加数据。并且position往后移动，不能超过limit上限。</span></span><br><span class="line">get() <span class="comment">//读取当前position位置的数据。并且position往后移动，不能超过limit上限。</span></span><br><span class="line">flip() <span class="comment">//将limit置位为当前position位置，再讲position设置为0 切换读写模式。</span></span><br><span class="line">rewind() <span class="comment">//仅将当前position位置设置为0</span></span><br><span class="line">remaining <span class="comment">//获取缓冲区中当前position位置和limit上限之间的元素数（有效的元素数）</span></span><br><span class="line">hasRemaining() <span class="comment">//判断当前缓冲区是否存在有效的元素数</span></span><br><span class="line">mark() <span class="comment">//在当前position位置打一个标记</span></span><br><span class="line">reset() <span class="comment">//将当前position位置恢复到mark标记的位置。</span></span><br><span class="line">duplicate() <span class="comment">//复制缓冲区</span></span><br></pre></td></tr></table></figure><hr><h4 id="创建缓冲区"><a href="#创建缓冲区" class="headerlink" title="创建缓冲区"></a>创建缓冲区</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个容量为10的缓冲区</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用线程的数组将其包装为缓冲区</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer2</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;abcdef&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure><p>–</p><h4 id="获取-x2F-设置缓冲区参数"><a href="#获取-x2F-设置缓冲区参数" class="headerlink" title="获取&#x2F;设置缓冲区参数"></a>获取&#x2F;设置缓冲区参数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;位置：&quot;</span>+byteBuffer.position());</span><br><span class="line">System.out.println(<span class="string">&quot;上限：&quot;</span>+byteBuffer.limit());</span><br><span class="line">System.out.println(<span class="string">&quot;容量：&quot;</span>+byteBuffer.capacity());</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/e0edccc64c2742eb93d99a090bb419ea.png" alt="在这里插入图片描述"></p><hr><h4 id="添加数据到缓冲区"><a href="#添加数据到缓冲区" class="headerlink" title="添加数据到缓冲区"></a>添加数据到缓冲区</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加数据到缓冲区</span></span><br><span class="line">byteBuffer.put(<span class="string">&quot;abcde&quot;</span>.getBytes());</span><br><span class="line">System.out.println(<span class="string">&quot;position位置:&quot;</span>+byteBuffer.position()); <span class="comment">//5</span></span><br><span class="line">System.out.println(<span class="string">&quot;limit上限:&quot;</span>+byteBuffer.limit()); <span class="comment">//10</span></span><br><span class="line">System.out.println(<span class="string">&quot;capacity容量:&quot;</span>+byteBuffer.capacity()); <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/cbbd61adc5d04be882e4943bd2cabe65.png" alt="在这里插入图片描述"></p><h4 id="rewind-重置缓冲区"><a href="#rewind-重置缓冲区" class="headerlink" title="rewind 重置缓冲区"></a>rewind 重置缓冲区</h4><p>rewind 函数将 position 置为 0 位置，并清除标记。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加数据到缓冲区</span></span><br><span class="line">byteBuffer.put(<span class="string">&quot;abcde&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;position位置:&quot;</span>+byteBuffer.position()); <span class="comment">//5</span></span><br><span class="line">System.out.println(<span class="string">&quot;limit上限:&quot;</span>+byteBuffer.limit()); <span class="comment">//10</span></span><br><span class="line">System.out.println(<span class="string">&quot;capacity容量:&quot;</span>+byteBuffer.capacity()); <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;---------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重置缓冲区</span></span><br><span class="line">byteBuffer.rewind();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;position位置:&quot;</span>+byteBuffer.position()); <span class="comment">//0</span></span><br><span class="line">System.out.println(<span class="string">&quot;limit上限:&quot;</span>+byteBuffer.limit()); <span class="comment">//10</span></span><br><span class="line">System.out.println(<span class="string">&quot;capacity容量:&quot;</span>+byteBuffer.capacity()); <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/ba388b104135439b87f08419cafb7549.png" alt="在这里插入图片描述"></p><h4 id="flip-重置缓冲区"><a href="#flip-重置缓冲区" class="headerlink" title="flip() 重置缓冲区"></a><code>flip()</code> 重置缓冲区</h4><p>flip 函数将 limit 设置为 position 位置，再将 position 置为 0 位置，并清除 mar 标记。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加数据到缓冲区</span></span><br><span class="line">byteBuffer.put(<span class="string">&quot;abcde&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;position位置:&quot;</span>+byteBuffer.position()); <span class="comment">//5</span></span><br><span class="line">System.out.println(<span class="string">&quot;limit上限:&quot;</span>+byteBuffer.limit()); <span class="comment">//10</span></span><br><span class="line">System.out.println(<span class="string">&quot;capacity容量:&quot;</span>+byteBuffer.capacity()); <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;---------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重置缓冲区</span></span><br><span class="line">byteBuffer.rewind();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;position位置:&quot;</span>+byteBuffer.position()); <span class="comment">//0</span></span><br><span class="line">System.out.println(<span class="string">&quot;limit上限:&quot;</span>+byteBuffer.limit()); <span class="comment">//5</span></span><br><span class="line">System.out.println(<span class="string">&quot;capacity容量:&quot;</span>+byteBuffer.capacity()); <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/15d5036a46674cd68d1ba24c94af9170.png" alt="在这里插入图片描述"></p><hr><h4 id="clear-清空缓冲区"><a href="#clear-清空缓冲区" class="headerlink" title="clear() 清空缓冲区"></a><code>clear()</code> 清空缓冲区</h4><p><code>clear()</code> 方法也将 position 置为0，同时将 limit 置为 capacity 的大小，并清除 mark 标记。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个容量为 10 的缓冲区</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置上限为5</span></span><br><span class="line">byteBuffer.limit(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加数据到缓冲区</span></span><br><span class="line">byteBuffer.put(<span class="string">&quot;abcde&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;position位置:&quot;</span>+byteBuffer.position()); <span class="comment">//5</span></span><br><span class="line">System.out.println(<span class="string">&quot;limit上限:&quot;</span>+byteBuffer.limit()); <span class="comment">//5</span></span><br><span class="line">System.out.println(<span class="string">&quot;capacity容量:&quot;</span>+byteBuffer.capacity()); <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;---------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空缓冲区</span></span><br><span class="line">byteBuffer.clear();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;position位置:&quot;</span>+byteBuffer.position()); <span class="comment">//0</span></span><br><span class="line">System.out.println(<span class="string">&quot;limit上限:&quot;</span>+byteBuffer.limit()); <span class="comment">//10</span></span><br><span class="line">System.out.println(<span class="string">&quot;capacity容量:&quot;</span>+byteBuffer.capacity()); <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/3b16d8a5eb8e4e73ad0c552f5da62867.png" alt="在这里插入图片描述"></p><hr><h4 id="标记和恢复"><a href="#标记和恢复" class="headerlink" title="标记和恢复"></a>标记和恢复</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个容量为 10 的缓冲区</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加数据到缓冲区</span></span><br><span class="line">byteBuffer.put(<span class="string">&quot;abcde&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//打一个标记</span></span><br><span class="line">byteBuffer.mark();</span><br><span class="line">System.out.println(<span class="string">&quot;标记位置:&quot;</span>+byteBuffer.position()); <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//再添加5个字节</span></span><br><span class="line">byteBuffer.put(<span class="string">&quot;fijkl&quot;</span>.getBytes());</span><br><span class="line">System.out.println(<span class="string">&quot;标记位置:&quot;</span>+byteBuffer.position()); <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将position恢复到mark标记位置</span></span><br><span class="line">byteBuffer.reset();</span><br><span class="line">System.out.println(<span class="string">&quot;恢复标记位置:&quot;</span>+byteBuffer.position()); <span class="comment">//5</span></span><br></pre></td></tr></table></figure><h3 id="FileChannel-通道"><a href="#FileChannel-通道" class="headerlink" title="FileChannel 通道"></a>FileChannel 通道</h3><p>本地文件 IO 通道，用于读取、写入、映射和操作文件的通道。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建读取文件通道</span></span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">fisChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;day05/src/a.txt&quot;</span>).getChannel();</span><br><span class="line"><span class="comment">//创建写入文件的通道</span></span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">fosChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;day05/src/b.txt&quot;</span>).getChannel();</span><br><span class="line"><span class="comment">//创建缓冲区</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span> (fisChannel.read(buffer)!=-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;position:&quot;</span>+buffer.position()); <span class="comment">//0</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit:&quot;</span>+buffer.limit());<span class="comment">//2</span></span><br><span class="line">    <span class="comment">//锁定缓冲区(为输出buffer数据做准备) limit 指向 position 位置 准备读取 </span></span><br><span class="line">    buffer.flip();</span><br><span class="line">    <span class="comment">//读取</span></span><br><span class="line">    fosChannel.write(buffer);</span><br><span class="line">    <span class="comment">//重置缓冲区(为输入buffer数据做准备) 将 limit指向 cap position 指向 0 重置为初始状态 准备下一次读取</span></span><br><span class="line">    buffer.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭通道</span></span><br><span class="line">fisChannel.close();</span><br><span class="line">fosChannel.close();</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/ee6c83e973094678b1ddbdf7855b330c.png" alt="在这里插入图片描述"></p><h3 id="SocketChannel-通道"><a href="#SocketChannel-通道" class="headerlink" title="SocketChannel 通道"></a>SocketChannel 通道</h3><p>使用 SocketChannel 通道上传文件到服务器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketChannelDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建缓冲区</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//读取本地文件通过管道读取数据到缓冲区</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fisChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;day05/src/a.txt&quot;</span>).getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fisChannel.read(byteBuffer)!=-<span class="number">1</span>)&#123;</span><br><span class="line">            byteBuffer.flip();<span class="comment">//为写入做准备</span></span><br><span class="line">            socketChannel.write(byteBuffer);</span><br><span class="line">            byteBuffer.clear(); <span class="comment">//清除缓冲区为读取做准备</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭本地通道</span></span><br><span class="line">        fisChannel.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取服务器回写的数据</span></span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> socketChannel.read(byteBuffer);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array(),<span class="number">0</span>,read));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭socket通道</span></span><br><span class="line">        socketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ServerSocketChannel-通道"><a href="#ServerSocketChannel-通道" class="headerlink" title="ServerSocketChannel 通道"></a>ServerSocketChannel 通道</h3><p>使用 ServerSocketChannel 通道接收文件并保存在服务器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerSocketChannelDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建ServerSocketChannel通道</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定端口号</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器已开启&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//获取客户端通道，如果有客户端连接直接返回客户端通道，否则直接返回false</span></span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">            <span class="comment">//创建本地通道，用于往文件中写数据</span></span><br><span class="line">            <span class="type">UUID</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID();</span><br><span class="line">            FileChannel fosChannel=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;day05/src/&quot;</span>+uuid+<span class="string">&quot;.txt&quot;</span>).getChannel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (socketChannel.read(buffer)!=-<span class="number">1</span>)&#123;</span><br><span class="line">                buffer.flip(); <span class="comment">//准备吧缓冲区数据输出</span></span><br><span class="line">                <span class="comment">//把缓冲区数据写入文件</span></span><br><span class="line">                fosChannel.write(buffer);</span><br><span class="line">                <span class="comment">//清除缓冲区 重置 limit 和 pos</span></span><br><span class="line">                buffer.clear(); <span class="comment">//方便下一次读取</span></span><br><span class="line">            &#125;</span><br><span class="line">            fosChannel.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//会写数据到客户端</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">resultBuffer</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;上传文件成功&quot;</span>.getBytes());</span><br><span class="line">            <span class="comment">//将缓冲区中的数据写入socketChannel通道。</span></span><br><span class="line">            socketChannel.write(resultBuffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//关闭客户端通道。</span></span><br><span class="line">            socketChannel.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NIO-Selector-的服务器"><a href="#NIO-Selector-的服务器" class="headerlink" title="NIO Selector 的服务器"></a>NIO Selector 的服务器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">//循环阻塞读取就绪事件</span></span><br><span class="line">            <span class="comment">//获取就绪事件的个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">readyNum</span> <span class="operator">=</span> selector.select();</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> (readyNum == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果就绪事件个数不为0 就取出就绪事件遍历 执行相应逻辑业务</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">//接受链接</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                    <span class="comment">//通道可读</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    <span class="comment">//通道可写</span></span><br><span class="line">                &#125;</span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码可以当作是一个模板。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NIO&quot;&gt;&lt;a href=&quot;#NIO&quot; class=&quot;headerlink&quot; title=&quot;NIO&quot;&gt;&lt;/a&gt;NIO&lt;/h1&gt;&lt;h2 id=&quot;NIO-与-BIO的区别&quot;&gt;&lt;a href=&quot;#NIO-与-BIO的区别&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Netty" scheme="https://devildyw.github.io/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://devildyw.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty</title>
    <link href="https://devildyw.github.io/2022/10/25/Netty/"/>
    <id>https://devildyw.github.io/2022/10/25/Netty/</id>
    <published>2022-10-25T03:49:55.000Z</published>
    <updated>2022-11-08T10:09:30.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ol><li>Netty 是由 JBOSS 提供的一个 java 开源框架。它是一个<strong>异步的</strong>、<strong>基于事件驱动</strong>的<strong>网络</strong>应用框架，开源快速开发高性能、高可靠性的网络 IO 程序。</li><li>Netty 主要针对在 <strong>TCP</strong> 协议下，面向 Clients 端的<strong>高并发</strong>应用。或者 Peer-to-Peer 场景下的大量数据持续传输的应用。</li><li>Netty 是一个 NIO 框架，将 Java 底层的 NIO API 再次做了一个封装和优化，简化和流程化了 NIO 的开发过程。可以帮助你快速、简单的开发出一个网络应用。</li><li>Netty 是目前最流行的 NIO 框架，Netty 在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，知名的 Elasticsearch 、Dubbo（RPC） 框架内部都采用了 Netty。</li></ol><h2 id="2-五种-I-x2F-O-通信模型"><a href="#2-五种-I-x2F-O-通信模型" class="headerlink" title="2. 五种 I&#x2F;O 通信模型"></a>2. 五种 I&#x2F;O 通信模型</h2><p>在网络环境下，通俗地讲，将 I&#x2F;O 分为两步：<strong>第一步是等待；第二步是数据搬迁。</strong></p><p>如果想要提高 I&#x2F;O 效率，需要将<strong>等待时间降低</strong>。因此发展出来五种 I&#x2F;O 模型，分别是：<strong>阻塞 I&#x2F;O 模型、非阻塞 I&#x2F;O 模型、多路复用 I&#x2F;O 模型、信号驱动 I&#x2F;O 模型、异步 I&#x2F;O 模型。其中前四种被称为同步 I&#x2F;O</strong>，下面对每一种 I&#x2F;O 模型进行详细分析。</p><h3 id="阻塞-I-x2F-O-模型"><a href="#阻塞-I-x2F-O-模型" class="headerlink" title="阻塞 I&#x2F;O 模型"></a>阻塞 I&#x2F;O 模型</h3><p>阻塞 I&#x2F;O 模型的通信过程示意如下图所示。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210251224203.png" alt="image-20221006205039163"></p><p>我们第一次接触的到的网络编程都是从 <code>listen()</code>、<code>send()</code>、<code>recv()</code> 等接口开始的，这些接口都是阻塞型的。都属于阻塞 I&#x2F;O 模型。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210251224250.png" alt="image-20221006205154439"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210251311000.png" alt="image-20221025131137955"></p><blockquote><p>后续模型都是在 BIO 的基础上演化而来的。</p></blockquote><h3 id="非阻塞-I-x2F-O-模型"><a href="#非阻塞-I-x2F-O-模型" class="headerlink" title="非阻塞 I&#x2F;O 模型"></a>非阻塞 I&#x2F;O 模型</h3><p>示意图如下。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210251224321.png" alt="image-20221006205243625"></p><p>当用户进程发出 read 操作时，如果内核中的数据还没有准备好，那么它并不会阻塞用户进程，而是立刻返回一个 error。从用户进程的角度讲，他发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果，用户进程判断结果是一个 error 时，他就知道数据还没有准备好。于是它可以再次发送 read 操作，一旦内核中的数据准备好了，并且再次收到了用户进程的系统调用，那么它会马上将数据拷贝到用户内存，然后返回，非阻塞接口相比于阻塞接口的显著差异在于，在被调用之后立即返回。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210251224275.png" alt="image-20221006205945061"></p><blockquote><p>非阻塞模式套接字与阻塞模式相比，不容易使用，使用非阻塞模式套接字，要编写更多的代码，但是，非阻塞模式套接字在控制建立多个链接、时间不定时，具有明显优势。</p></blockquote><h3 id="多路复用-I-x2F-O-模型"><a href="#多路复用-I-x2F-O-模型" class="headerlink" title="多路复用 I&#x2F;O 模型"></a>多路复用 I&#x2F;O 模型</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210251224314.png" alt="image-20221008183741246"></p><p>多个进程的 I&#x2F;O 可以注册到一个复用器（Selector）上，当用户进程调用该 Selector，Selector 会监听注册进来的所有 I&#x2F;O，如果Selector 监听的所有 I&#x2F;O 在内核缓冲区都没有可读数据，select 调用进程会被阻塞，而当任一 I&#x2F;O 在内核缓冲区中有可读数据时，select 调用进程就会返回，而后 select 调用进程可以自己或通知另外的进程（注册进程）再次发起读取 I&#x2F;O，读取内核中准备好的数据，多个进程注册 I&#x2F;O 后，只有一个 select 调用进程被阻塞。</p><blockquote><p>其实多路复用 I&#x2F;O 模型和阻塞 I&#x2F;O 模型并没有太大的不同，事实上由于这里要使用两个系统调用而比阻塞 I&#x2F;O 模型的性能还要差些。</p><p>多路复用 I&#x2F;O 不一定比使用多线程加阻塞 I&#x2F;O 的模式更优，甚至性能更佳，多路复用的优势在于可以处理更多的连接，而不是单个连接处理更快。</p></blockquote><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210251224264.png" alt="image-20221008184759480"></p><h3 id="信号驱动-I-x2F-O-模型"><a href="#信号驱动-I-x2F-O-模型" class="headerlink" title="信号驱动 I&#x2F;O 模型"></a>信号驱动 I&#x2F;O 模型</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210251224247.png" alt="image-20221008184819467"></p><p>信号驱动 I&#x2F;O 是指进程预先告知内核，向内核注册一个信号处理函数，然后用户进程返回<strong>不阻塞</strong>，当内核<strong>数据就绪时会发送一个信号给进程</strong>，用户进程便在信号处理函数中调用 I&#x2F;O 读取数据，从上图可以看出，<strong>实际上 I&#x2F;O 内核拷贝到用户进程的过程还是阻塞的，信号驱动 I&#x2F;O 并没有实现真正的异步，因为通知到进程后，依然由进程来完成 I&#x2F;O 操作。</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210251224253.png" alt="image-20221008185312018"></p><h3 id="异步-I-x2F-O-模型"><a href="#异步-I-x2F-O-模型" class="headerlink" title="异步 I&#x2F;O 模型"></a>异步 I&#x2F;O 模型</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210251224250.png" alt="image-20221008185359939"></p><p>用户进程发起 aio_read 操作后，给内核传递与 read 相同的描述符、缓冲区指针、缓冲区大小三个参数及文件偏移，告诉内核当整个操作完成时，如何通知我们立刻就可以开始去做其他的事；而另一方面，从内核的角度，当他收到一个 aio_read 之后，首先他会立刻返回，所以不会对用户进程产生任何阻塞，内核会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，内核会给用户进程发送一个信号，告诉它 aio_read 操作完成。</p><blockquote><p>异步 I&#x2F;O 的工作机制是：告知内核启动某个操作，并让内核在整个操作完成后通知我们，这种模型与信号驱动 I&#x2F;O 模型的区别在于，<strong>信号驱动 I&#x2F;O 模型是由内核通知我们何时可以启动一个 I&#x2F;O 操作，这个 I&#x2F;O 操作由用户自定义的信号函数来实现，而异步 I&#x2F;O 模型由内核告知我们 I&#x2F;O 操作何时完成。</strong></p></blockquote><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210251224272.png" alt="image-20221008192424929"></p><h3 id="各-I-x2F-O-模型的对比与总结"><a href="#各-I-x2F-O-模型的对比与总结" class="headerlink" title="各 I&#x2F;O 模型的对比与总结"></a>各 I&#x2F;O 模型的对比与总结</h3><p>前四种 I&#x2F;O 模型都是同步 I&#x2F;O 操作，它们的区别在于第一阶段，而第二阶段是一样的：数据（准备好后）从内核拷贝到应用缓冲区期间（用户空间），进程阻塞于 <code>recvfrom</code> 调用。</p><blockquote><p>recvfrom 会将数据从内核（Kernel）拷贝到用户内存中，这个时候进程就被阻塞了。在这段时间内，进程是被阻塞的。</p></blockquote><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210251224382.png" alt="image.png"></p><p>由上图可以看出，阻塞程度：阻塞 I&#x2F;O &gt; 非阻塞 I&#x2F;O &gt; 多路复用 I&#x2F;O &gt; 信号驱动 I&#x2F;O &gt; 异步 I&#x2F;O，效率是由低到高的。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210251224287.png" alt="image-20221008193056732"></p><p>Java BIO 和 NIO 之间的主要差异。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210081952389.png" alt="image-20221008195234349"></p><h2 id="易混淆概念解释"><a href="#易混淆概念解释" class="headerlink" title="易混淆概念解释"></a>易混淆概念解释</h2><ul><li>同步与异步：主要看请求发起方对消息结果的获取是主动发起还是被动通知的。</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210251224283.png" alt="image-20221008193426801"></p><ul><li>阻塞与非阻塞：调用一个函数后，在等待这个函数返回结果之前，当前的线程是处于挂起状态还是运行状态。</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210081936694.png" alt="image-20221008193611650"></p><ul><li>同步阻塞：请求方主动发起的，一直等待应答结果（用户线程阻塞挂起）；</li><li>异步非阻塞：请求方主动发起，但是可以去做其他的事情，但是需要不断轮询查看发起的请求是否有结果；</li><li>异步阻塞：请求方发起请求，一直阻塞等待答应结果（实际不应用）；</li><li>异步非阻塞：请求方发起请求，可以去干自己的事，服务会主动通知该请求已完成。</li></ul><h2 id="NIO-介绍"><a href="#NIO-介绍" class="headerlink" title="NIO 介绍"></a>NIO 介绍</h2><h3 id="为什么不选择-Java-原生-NIO-编程的原因"><a href="#为什么不选择-Java-原生-NIO-编程的原因" class="headerlink" title="为什么不选择 Java 原生 NIO 编程的原因"></a>为什么不选择 Java 原生 NIO 编程的原因</h3><p>一般不建议开发者直接使用 JDK 的 NIO 类库进行开发，具体原因如下：</p><ul><li><strong>NIO 的类库和 API 繁杂，使用麻烦</strong>，你需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等。</li><li><strong>需要熟练其他的额外技能作为铺垫</strong>，例如 Java 多线程编程。这是因为 NIO 编程涉及到 Reactor   模式，你必须对多线程和网络编程都十分熟悉，才能编写出高质量的 NIO 程序。</li><li><strong>可靠性能力补齐，工作量和难度都非常大</strong>。例如客户端面临断连接、网络闪断、半包读写、失败缓存，网络阻塞和异常码流的处理等问题，NIO 编程的特点是功能开发相对容易，但是可靠性能力补齐的工作量和难度都会非常大。</li><li><strong>JDK NIO 的 BUG，例如 epoll bug</strong>，它会导致 Selector 空轮询，最终导致 CPU 100%，虽然官方声称会在 JDK 1.6 的 update 18 修复这些问题，但是到了 JDK 1.7 问题依然还存在，他根本没有得到解决，只是该 BUG 发生概率降低了一些。</li></ul><p>综上原因，在大多数场景下，不建议直接使用 JDK 的 NIO 类库，除非在有精通 NIO 编程的实力或者特殊的需求下，在大多数的业务场景中，完美可以使用 NIO 框架 Netty 来进行 NIO 编程。下面来看看 Netty 作为基础通信框架有哪些优点。</p><h3 id="为什么选择-Netty"><a href="#为什么选择-Netty" class="headerlink" title="为什么选择 Netty"></a>为什么选择 Netty</h3><p>Netty 是业界最流行的 NIO 框架之一，它的健壮性、功能、性能、可定制性和可扩展性在同类框架中都是首屈一指的，它已经得到成百上千的商业项目验证，例如 Hadoop 的 RPC 框架 avro 使用 Netty 作为底层通信框架；很多其他业界主流的 RPC 框架（Dubbo、RocketMQ），也是用 Netty 来构建高性能的异步通信能力。</p><p>Netty 优点总结如下：</p><ul><li>API 简单，开发门槛低；</li><li>功能强大，预置了多种编解码功能，支持多种主流协议；</li><li>定制能力强，可以通过 ChannelHandler 对通信框架进行灵活地扩展。</li><li>性能高，通过与其他业界主流的 NIO 框架对比，Netty 的综合性能最优；</li><li>成熟、稳定，Netty 修复了已经发现的所有 JDK NIO BUG，业务人员不需要再为 NIO 的 BUG 而发愁；</li><li>社区活跃，版本迭代周期短，发现的 BUG 可以被及时修复，同时，更多的新功能会加入；</li><li>经历了大规模的商业应用考验，质量得到验证。被多个行业商业应用使用，证明了它已经完全能够满足不能行业的商业需求了。</li></ul><p>正因为有上述的这些优点，Netty 逐渐称为了 Java NIO 编程的首选框架。</p><h2 id="Netty-入门应用"><a href="#Netty-入门应用" class="headerlink" title="Netty 入门应用"></a>Netty 入门应用</h2><p>导入 Netty 依赖即可。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.netty/netty-all --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.84.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="TimeServer"><a href="#TimeServer" class="headerlink" title="TimeServer"></a>TimeServer</h3><p><code>TimeServer.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.devildyw.netty.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-11-07-15:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TimeServer</span>().bind(port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//配置服务端的 NIO 线程组 创建两个 bossGroup线程组专用于接受客户端的请求，而workerGroup则专注于对客户端Channel请求的读写</span></span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//ServerBootstrap 对象是用于启动 NIO 服务端的辅助启动类，目的是降低开发的复杂度</span></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            <span class="comment">//将刚刚创建的两个线程组作为参数加入group方法中 根据前后顺序 前面的group 为 parent 后面的group为 child</span></span><br><span class="line">            bootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    <span class="comment">//设置创建的 Channel为 NioServerSocketChannel</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">//配置tcp参数，设置backlog参数为1024</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">1024</span>)</span><br><span class="line">                    <span class="comment">//配置childGroup 的Handler 用来处理网络I/O 事件，例如记录日志、对消息进行编解码等。</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChildChannelHandler</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绑定端口，同步等待成功 返回ChannelFuture，功能类似与 JDK的 java.util.concurrent.Future 主要用于异步操作的通知回调。</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> bootstrap.bind(port).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//阻塞等待服务器监听端口关闭</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//优雅退出，释放线程池资源</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ChildChannelHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">TimeServerHandler</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TimeServerHandler</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.devildyw.netty.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-11-07-15:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//ByteBuf 类似与 JDK 中的 java.nio.ByteBuffer 对象，不过它提供了更强大和灵活的功能。</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ByteBuf 的 readableBytes 方法可以获取缓冲区可读字节数，</span></span><br><span class="line">        <span class="type">byte</span>[] req = <span class="keyword">new</span> <span class="title class_">byte</span>[buf.readableBytes()];</span><br><span class="line">        <span class="comment">//将缓冲区的字节数组复制到新建的byte数组中</span></span><br><span class="line">        buf.readBytes(req);</span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(req, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;The time server receive order : &quot;</span>+body);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">currentTime</span> <span class="operator">=</span> <span class="string">&quot;QUERY TIME ORDER&quot;</span>.equalsIgnoreCase(body)?<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis()).toString():<span class="string">&quot;BAD ORDER&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">resp</span> <span class="operator">=</span> Unpooled.copiedBuffer(currentTime.getBytes());</span><br><span class="line">        <span class="comment">//写回</span></span><br><span class="line">        ctx.write(resp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//为了防止频繁地唤醒Selector进行消息的发送，Netty 的 write 方法并不直接地将消息发送到缓存数组中，再通过 flush 方法，将发送缓冲区中的消息全部写入 SocketChannel</span></span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//发生异常时，关闭ChannelHandlerContext，释放相关联的资源。</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="TimeClient"><a href="#TimeClient" class="headerlink" title="TimeClient"></a>TimeClient</h3><p> <code>TimeClient.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.devildyw.netty.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-11-07-17:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TimeClient</span>().connect(<span class="string">&quot;127.0.0.1&quot;</span>,port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(String host, <span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//配置客户端 NIO 线程组 创建客户端处理 I/O 读写的 线程组</span></span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端辅助启动类</span></span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    <span class="comment">//配置Channel 类型 为 NIOSocketChannel 与 JDK 中的 java.nio.SocketChannel 类似</span></span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line"></span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY,<span class="literal">true</span>)</span><br><span class="line">                    <span class="comment">//添加处理 I/O 的handler 作用在初始化它的时候将它的 ChannelHandler 设置到 ChannelPipeline 中 用于处理网络 I/O 事件。</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">TimeClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//发起异步连接操作 ，调用同步方法等待连接成功</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.connect(host, port).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//阻塞等待客户端链路关闭</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//优雅退出，释放NIO 线程组</span></span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TimeClientHandler</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.devildyw.netty.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-11-07-18:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ByteBuf firstMessage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TimeClientHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] req = <span class="string">&quot;QUERY TIME ORDER&quot;</span>.getBytes();</span><br><span class="line"></span><br><span class="line">        firstMessage = Unpooled.buffer(req.length);</span><br><span class="line">        firstMessage.writeBytes(req);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端和服务端 TCP 链路建立成功之后，Netty 的 NIO 线程会调用 channel Active 方法，发送查询时间的指令给服务段</span></span><br><span class="line"><span class="comment">     * 调用 ChannelHandlerContext 的 writeAndFlush 方法将请求消息发送给服务端。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.writeAndFlush(firstMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当服务端返回应答消息时，channelRead 方法被调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        <span class="type">byte</span>[] req = <span class="keyword">new</span> <span class="title class_">byte</span>[buf.readableBytes()];</span><br><span class="line">        buf.readBytes(req);</span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(req,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;Now is : &quot;</span>+body);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发生异常时，打印异常日志。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP-粘包-x2F-拆包问题的解决之道"><a href="#TCP-粘包-x2F-拆包问题的解决之道" class="headerlink" title="TCP 粘包&#x2F;拆包问题的解决之道"></a>TCP 粘包&#x2F;拆包问题的解决之道</h2><p>TCP 是一个”<strong>流</strong>“协议，所谓流，就是没有界限的一大串的数据，就像河里的水是连成一片的，其间并没有分界线。TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分，所以在业务上认为，<strong>一个完成的包可能会被 TCP 拆分成多个包进行发送，也有可能把多个小的包封装成一个打的数据包发送，这就是所谓的 TCP 粘包和拆包问题。</strong></p><h3 id="TCP-粘包-x2F-拆包"><a href="#TCP-粘包-x2F-拆包" class="headerlink" title="TCP 粘包&#x2F;拆包"></a>TCP 粘包&#x2F;拆包</h3><h4 id="TCP-粘包-x2F-拆包问题说明"><a href="#TCP-粘包-x2F-拆包问题说明" class="headerlink" title="TCP 粘包&#x2F;拆包问题说明"></a>TCP 粘包&#x2F;拆包问题说明</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20221108134049344.png" alt="image-20221108134049344"></p><p>问题描述：假设客户端分别发送了两个数据包 D1 和 D2 给服务端， 由于服务端一次读取到的字节数是不确定的，故可能存在以下四种情况。</p><ol><li>服务器分两次读取到了两个独立的数据包，分别是 D1 和 D2，没有粘包和拆包；</li><li>服务端一次接收到了两个数据包，D1 和 D2 粘合在了一起，被称为 TCP 粘包；</li><li>服务端分两次读取到了两个数据包，第一次读取到了完成的 D1 包和 D2 包的部分内容，第二次读取到了 D2 包的剩余内存，这被称为 TCP 拆包。</li><li>服务端分两次读取到了两个数据包，第一次读取到了 D1  包的部分内容 D1_1，第二次读取到了 D1 包的剩余内容 D1_2 和 D2 包的整包。</li></ol><p>如果此时服务端 TCP 接收滑动窗口非常小，而数据包 D1 和 D2 非常大，很有可能会发生第五种可能，即<strong>服务端分多次才能将 D1 和 D2 包完全接收，期间发生多次拆包。</strong></p><h4 id="TCP-粘包-x2F-拆包发生的原因"><a href="#TCP-粘包-x2F-拆包发生的原因" class="headerlink" title="TCP 粘包&#x2F;拆包发生的原因"></a>TCP 粘包&#x2F;拆包发生的原因</h4><p>原因共有三点，分别如下：</p><ol><li><p>应用程序 write 写入的字节大小大于套接口发生缓冲区大小；</p></li><li><p>进行 MSS 大小的 TCP 分段；</p><blockquote><p>MSS——MSS（Maximum Segment Size，最大报文段大小）的概念是<strong>指TCP层所能够接收的最大段大小，该值只包括TCP段的数据部分，不包括选项部分。</strong></p></blockquote></li><li><p>以太网帧的 payload 大于 MTU 进行 IP 分片。</p><blockquote><p>MTU——<em><strong>MTU</strong></em>（Maximum Transmission Unit，最大传输单元）来<em><strong>限制所能传输的数据包大小</strong></em> 。<strong>MTU是指一次传送的数据最大长度，不包括数据链路层数据帧的帧头。</strong>如以太网的MTU为1500字节，实际上数据帧的最大长度为1514字节，其中以太网数据帧的帧头为14字节。</p></blockquote></li></ol><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20221108162011707.png" alt="image-20221108162011707"></p><h4 id="粘包问题的解决策略"><a href="#粘包问题的解决策略" class="headerlink" title="粘包问题的解决策略"></a>粘包问题的解决策略</h4><p>由于底层的 TCP 无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界主流协议的解决方案，可以归纳如下：</p><ol><li>消息定长，例如每个报文的大小为固定长度 200 字节，如果不够，空格补位。</li><li>在包尾添加回车换行符进行分割，例如 FTP 协议；</li><li>将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路为消息头的第一个字段使用一个 int32 来表示消息的总长度；</li><li>此外就是更复杂的应用层协议。</li></ol><p>下面我们来看看如何使用 Netty 提供的半包解码器来解决 TCP 粘包&#x2F;拆包问题。</p><h3 id="未考虑-TCP-粘包导致功能异常的案例"><a href="#未考虑-TCP-粘包导致功能异常的案例" class="headerlink" title="未考虑 TCP 粘包导致功能异常的案例"></a>未考虑 TCP 粘包导致功能异常的案例</h3><p>前面编写的 Netty 入门应用中，我们并没有考虑读半包问题，这在功能测试时往往是没有问题的，但是一旦压力上来，或者发送大报文之后，就会存在<strong>粘包&#x2F;拆包</strong>问题。如果不考虑，往往就会出现节码错位或者错误，导致程序不能正常工作。</p><p>下面我们来模拟故障场景。</p><h4 id="TimeServer-的改造"><a href="#TimeServer-的改造" class="headerlink" title="TimeServer 的改造"></a>TimeServer 的改造</h4><p>Netty 时间服务器服务端处理器 <code>TimeServerHandler.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.devildyw.netty.stick_unpacking.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-11-07-15:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> counter;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//ByteBuf 类似与 JDK 中的 java.nio.ByteBuffer 对象，不过它提供了更强大和灵活的功能。</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ByteBuf 的 readableBytes 方法可以获取缓冲区可读字节数，</span></span><br><span class="line">        <span class="type">byte</span>[] req = <span class="keyword">new</span> <span class="title class_">byte</span>[buf.readableBytes()];</span><br><span class="line">        <span class="comment">//将缓冲区的字节数组复制到新建的byte数组中</span></span><br><span class="line">        buf.readBytes(req);</span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(req, <span class="string">&quot;UTF-8&quot;</span>).substring(<span class="number">0</span>,req.length - System.getProperty(<span class="string">&quot;line.separator&quot;</span>).length());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;The time server receive order : &quot;</span>+body +<span class="string">&quot; ; the counter is &quot;</span> + ++counter);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">currentTime</span> <span class="operator">=</span> <span class="string">&quot;QUERY TIME ORDER&quot;</span>.equalsIgnoreCase(body)?<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis()).toString():<span class="string">&quot;BAD ORDER&quot;</span>;</span><br><span class="line">        currentTime = currentTime+System.getProperty(<span class="string">&quot;line.separator&quot;</span>);</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">resp</span> <span class="operator">=</span> Unpooled.copiedBuffer(currentTime.getBytes());</span><br><span class="line">        ctx.writeAndFlush(resp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//发生异常时，关闭ChannelHandlerContext，释放相关联的资源。</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每读到一条消息后，就计数一次，然后发送应答消息给客户端。按照设计，服务端接收到消息总数应该是跟客户端发送的消息总数相同，而且请求消息删除回城换行符后应该为 “QUERY TIME ORDER”。</p><h4 id="TimeClient-的改造"><a href="#TimeClient-的改造" class="headerlink" title="TimeClient 的改造"></a>TimeClient 的改造</h4><p>Netty 时间服务器客户端 <code>TimeClientHandler.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.devildyw.netty.stick_unpacking.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-11-07-18:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] req;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TimeClientHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        req = (<span class="string">&quot;QUERY TIME ORDER&quot;</span>+System.getProperty(<span class="string">&quot;line.separator&quot;</span>)).getBytes();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端和服务端 TCP 链路建立成功之后，Netty 的 NIO 线程会调用 channel Active 方法，发送查询时间的指令给服务段</span></span><br><span class="line"><span class="comment">     * 调用 ChannelHandlerContext 的 writeAndFlush 方法将请求消息发送给服务端。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">message</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            message = Unpooled.buffer(req.length);</span><br><span class="line">            <span class="comment">//将请求写入缓冲区</span></span><br><span class="line">            message.writeBytes(req);</span><br><span class="line">            <span class="comment">//将缓冲区中的数据写入到客户端的通道中</span></span><br><span class="line">            ctx.writeAndFlush(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当服务端返回应答消息时，channelRead 方法被调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        <span class="type">byte</span>[] req = <span class="keyword">new</span> <span class="title class_">byte</span>[buf.readableBytes()];</span><br><span class="line">        buf.readBytes(req);</span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(req,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;Now is : &quot;</span>+body+<span class="string">&quot; ; the counter is : &quot;</span>+ ++counter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发生异常时，打印异常日志。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要是修改了发送请求那一块，客户端与服务端建立连接后，循环发送 1000 条消息，没发送一条就刷新一次，保证每条消息都会被写入到 Channel 中。按照我们的计划服务端应该接收到 100 条查询时间指令的请求消息。</p><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>因结果较长，这里只放出部分结果。</p><p>服务端</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20221108171311075.png" alt="image-20221108171311075"></p><p>服务端明确表明了它只接收到了 283 条消息，每一条都包含了不同数量的 ”QUERY TIME ORDER“ 指令，总数正好是 1000 条，我们期待的是收到 1000 条消息，每条包含一条 “QUERY TIME ORDER” 指令。这说明发生了 <strong>TCP 粘包</strong>。(<strong>一次读取 读取到了多个包</strong>)</p><p>客户端</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20221108171640166.png" alt="image-20221108171640166"></p><p>设计初衷，客户端应该收到 1000 条当前系统时间的消息，但实际上只收到了 2 条应答，由于请求消息不满足查询条件，所以返回许多条 “BAD ORDER” 应答消息。但是实际上客户端只收到了2条包含若干条 “BAD ORDER” 指令的消息，说明服务端返回的应答消息也发生了粘包。</p><hr><p>由于上述案例没有考虑 TCP 的粘包&#x2F;拆包，所以当发生 TCP 粘包时，我们的程序就不能正常工作了。下面将 演示如何通过 Netty 的 <code>LineBasedFrameDecoder</code> 和 <code>StringDecoder</code> 来解决 TCP 粘包问题。</p><h3 id="利用-LineBasedFrameDecoder-解决-TCP-粘包问题"><a href="#利用-LineBasedFrameDecoder-解决-TCP-粘包问题" class="headerlink" title="利用 LineBasedFrameDecoder 解决 TCP 粘包问题"></a>利用 LineBasedFrameDecoder 解决 TCP 粘包问题</h3><p>Netty 默认提供了多种编解码器用于处理半包，只要能熟练掌握这些类库的使用，TCP 粘包问题会从此变得非常容易，你甚至不需要要去关注他们，这也是其他 NIO 框架 和 JDK 原生 NIO API 所无法匹敌的。</p><p>下面就演示如何使用 Netty 默认提供的编解码器来解决上述我们遇到的 TCP 粘包问题。还是以修正时间服务器为目标进行演示。</p><h4 id="支持-TCP-粘包的-TimeServer"><a href="#支持-TCP-粘包的-TimeServer" class="headerlink" title="支持 TCP 粘包的 TimeServer"></a>支持 TCP 粘包的 TimeServer</h4><p><code>TimeServer.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.devildyw.netty.slove_stick_unpacking.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.LineBasedFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-11-07-15:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LogManager.getLogger(TimeServer.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8081</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TimeServer</span>().bind(port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//省略重复代码</span></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//省略重复代码</span></span><br><span class="line">        ......</span><br><span class="line">                    <span class="comment">//配置childGroup 的Handler 用来处理网络I/O 事件，例如记录日志、对消息进行编解码等。</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChildChannelHandler</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//省略重复代码</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ChildChannelHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LineBasedFrameDecoder</span>(<span class="number">1024</span>)); <span class="comment">//新增ChannelHandler</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>()); <span class="comment">//新增ChannelHandler</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">TimeServerHandler</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在原来的 TimeServerHandler 之前新增了两个解码器：第一个是 <code>LineBasedFrameDecoder</code>，第二个是 <code>StringDecoder</code>。</p><p><code>TimeServerHandler.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.devildyw.netty.slove_stick_unpacking.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-11-07-15:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> counter;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//ByteBuf 类似与 JDK 中的 java.nio.ByteBuffer 对象，不过它提供了更强大和灵活的功能。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> (String) msg; <span class="comment">//仔细观察</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;The time server receive order : &quot;</span>+body +<span class="string">&quot; ; the counter is &quot;</span> + ++counter);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">currentTime</span> <span class="operator">=</span> <span class="string">&quot;QUERY TIME ORDER&quot;</span>.equalsIgnoreCase(body)?<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis()).toString():<span class="string">&quot;BAD ORDER&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        currentTime = currentTime+System.getProperty(<span class="string">&quot;line.separator&quot;</span>);</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">resp</span> <span class="operator">=</span> Unpooled.copiedBuffer(currentTime.getBytes());</span><br><span class="line">        ctx.writeAndFlush(resp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//发生异常时，关闭ChannelHandlerContext，释放相关联的资源。</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>可以发现接收到的 msg 就是删除回车换行符后的请求消息，不需要额外考虑处理读半包问题，也不需要对消息进行编码，代码非常简洁。</strong>（这就是新加两个 ChannelHandler 的作用）</p><h4 id="支持-TCP-粘包的-TimeClient"><a href="#支持-TCP-粘包的-TimeClient" class="headerlink" title="支持 TCP 粘包的 TimeClient"></a>支持 TCP 粘包的 TimeClient</h4><p><code>TimeClient.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.devildyw.netty.slove_stick_unpacking.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.LineBasedFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-11-07-17:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LogManager.getLogger(TimeClient.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8081</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TimeClient</span>().connect(<span class="string">&quot;127.0.0.1&quot;</span>,port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(String host, <span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//省略重复代码</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//省略重复代码</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LineBasedFrameDecoder</span>(<span class="number">1024</span>)); <span class="comment">//新增 ChannelHandler</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>()); <span class="comment">//新增 ChannelHandler</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">TimeClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">        <span class="comment">//省略重复代码</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是直接在 TimeClientHandler 之前新增 <code>LineBasedFrameDecoder</code> 和 <code>StringDecoder</code> 解码器。</p><p><code>TimeClientHandler.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.devildyw.netty.slove_stick_unpacking.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-11-07-18:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"><span class="comment">//省略重复代码</span></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当服务端返回应答消息时，channelRead 方法被调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> (String) msg;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Now is : &quot;</span>+body+<span class="string">&quot; ; the counter is : &quot;</span>+ ++counter);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//省略重复代码</span></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现 <code>channelRead(...)</code> 拿到的 msg <strong>已经是解码成字符串之后的消息了</strong>，相比于之前的代码简洁了许多。</p><h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><p>客户端连续发送 1000 条请求给服务端，查看服务端和客户端的运行结果。</p><p>同样因为测试结果过长这里只放出关键部分。</p><p><strong>服务端</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20221108175300709.png" alt="image-20221108175300709"></p><p><strong>客户端</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20221108175518462.png" alt="image-20221108175518462"></p><p>程序的运行结果完全符合预期，说明通过使用 <code>LineBasedFrameDecoder</code> 和 <code>StringDecoder</code> 成功解决了 TCP 粘包导致的读半包问题。对于使用者来说，<strong>只要将支持半包解码的 handler 添加到 ChannelPipeline 中即可</strong>，操作简单，代码简洁。</p><hr><h4 id="LineBasedFrameDecoder-和-StringDecoder-的原理分析"><a href="#LineBasedFrameDecoder-和-StringDecoder-的原理分析" class="headerlink" title="LineBasedFrameDecoder 和 StringDecoder 的原理分析"></a>LineBasedFrameDecoder 和 StringDecoder 的原理分析</h4><p><code>LineBaseFrameDecoder</code> 的工作原理是它<strong>依次遍历 ByteBuf 中的可读字节，判断看是否有 “\n” 或者 “\r\n”，如果有，就以此位置为结束位置，从可读索引到结束位置区间的字节就组成了一行。</strong></p><p>它是<strong>以换行符为结束标志</strong>的解码器，支持<strong>携带结束符</strong>或者<strong>不携带结束符</strong>两种解码方式，同时支持<strong>配置单行最大长度</strong>，如果<strong>连续读取到最大长度</strong>后仍然没有发现换行符，就会<strong>抛出异常</strong>，同时<strong>忽略</strong>掉之前读到的异常码流。</p><hr><p><code>StringDecoder</code> 的功能很简单，就是<strong>将接收到的对象转换为字符串，然后继续调用后面的 handler。</strong></p><p>LineBasedFrameDecoder  + StringDecoder 组合就是<strong>按行切换的文本解码器</strong>，它被设计用来支持 TCP 的粘包和拆包。</p><p>上述这种组合<strong>只能针对以换行符或者回车换行符的消息解码</strong>。其他类型的解码，Netty 也支持，Netty 提供了多种支持 TCP 粘包&#x2F;拆包的解码器，用来满足用户的不同诉求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Netty&quot;&gt;&lt;a href=&quot;#Netty&quot; class=&quot;headerlink&quot; title=&quot;Netty&quot;&gt;&lt;/a&gt;Netty&lt;/h1&gt;&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述</summary>
      
    
    
    
    <category term="Netty" scheme="https://devildyw.github.io/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://devildyw.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC之RequestContextHolder</title>
    <link href="https://devildyw.github.io/2022/10/19/SpringMVC%E4%B9%8BRequestContextHolder/"/>
    <id>https://devildyw.github.io/2022/10/19/SpringMVC%E4%B9%8BRequestContextHolder/</id>
    <published>2022-10-19T15:56:05.000Z</published>
    <updated>2022-10-20T07:46:54.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringMVC-之-RequestContextHolder"><a href="#SpringMVC-之-RequestContextHolder" class="headerlink" title="SpringMVC 之 RequestContextHolder"></a>SpringMVC 之 RequestContextHolder</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在业务编写中，常常会出现将 <code>request</code> 和 <code>response</code> 传来传去的场景，正常来说在 <code>service</code> 层是没有 <code>request</code> 的，然而直接从 <code>Controller</code> 传过来的话方法太粗暴了，而 <code>SpringMVC</code> 提供的 <code>RequestContextHolder</code> <strong>可以在一个请求线程的中获取到 <code>Request</code> 并将其存储在底层的 <code>ThreadLocal</code> 中</strong>，避免了 <code>Request</code> 从头传到尾的情况。一般项目中，会对这个类进行再次封装，便于获取请求的相关信息，常见的比如用户信息。</p><h2 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h2><p><code>RequestContextHolder</code> 基于 <code>ThreadLocal</code> 实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RequestContextHolder</span>  &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">jsfPresent</span> <span class="operator">=</span></span><br><span class="line">         ClassUtils.isPresent(<span class="string">&quot;javax.faces.context.FacesContext&quot;</span>, RequestContextHolder.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RequestAttributes&gt; requestAttributesHolder =</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;Request attributes&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//用于子线程的</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RequestAttributes&gt; inheritableRequestAttributesHolder =</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">NamedInheritableThreadLocal</span>&lt;&gt;(<span class="string">&quot;Request context&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <code>SpringMVC</code>  源码入手，在 <code>FrameworkServlet#processRequest</code> 中，会在进入处理请求前，将 Request 封装为 <code>RequestAttributes</code>，放到 <code>RequestContextHolder</code> 中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">      <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">   <span class="type">LocaleContext</span> <span class="variable">previousLocaleContext</span> <span class="operator">=</span> LocaleContextHolder.getLocaleContext();</span><br><span class="line">   <span class="type">LocaleContext</span> <span class="variable">localeContext</span> <span class="operator">=</span> buildLocaleContext(request);</span><br><span class="line"></span><br><span class="line">   <span class="type">RequestAttributes</span> <span class="variable">previousAttributes</span> <span class="operator">=</span> RequestContextHolder.getRequestAttributes();</span><br><span class="line">   <span class="type">ServletRequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line"></span><br><span class="line">   <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">   asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> <span class="title class_">RequestBindingInterceptor</span>());</span><br><span class="line"></span><br><span class="line">   initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initContextHolders</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> LocaleContext localeContext, <span class="meta">@Nullable</span> RequestAttributes requestAttributes)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (localeContext != <span class="literal">null</span>) &#123;</span><br><span class="line">LocaleContextHolder.setLocaleContext(localeContext, <span class="built_in">this</span>.threadContextInheritable);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (requestAttributes != <span class="literal">null</span>) &#123;</span><br><span class="line">RequestContextHolder.setRequestAttributes(requestAttributes, <span class="built_in">this</span>.threadContextInheritable);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RequestContextHolder</code> 会根据 <code>threadContextInheritable</code> 选择将 <code>RequestAttributes</code> 放入 <code>inheritableRequestAttributesHolder</code> 或者 <code>inheritableRequestAttributesHolder</code> 中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setRequestAttributes</span><span class="params">(<span class="meta">@Nullable</span> RequestAttributes attributes, <span class="type">boolean</span> inheritable)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (attributes == <span class="literal">null</span>) &#123;</span><br><span class="line">      resetRequestAttributes();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (inheritable) &#123;</span><br><span class="line">         inheritableRequestAttributesHolder.set(attributes);</span><br><span class="line">         requestAttributesHolder.remove();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         requestAttributesHolder.set(attributes);</span><br><span class="line">         inheritableRequestAttributesHolder.remove();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取出 <code>RequestAttributes</code> 时会先从 <code>requestAttributes</code> 中取，取不到再到 <code>inheritableRequestAttributesHolder</code> 中取。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestAttributes <span class="title function_">getRequestAttributes</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">RequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> requestAttributesHolder.get();</span><br><span class="line">   <span class="keyword">if</span> (attributes == <span class="literal">null</span>) &#123;</span><br><span class="line">      attributes = inheritableRequestAttributesHolder.get();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> attributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="inheritableRequestAttributesHolder-与-requestAttributesHolder"><a href="#inheritableRequestAttributesHolder-与-requestAttributesHolder" class="headerlink" title="inheritableRequestAttributesHolder 与 requestAttributesHolder"></a><code>inheritableRequestAttributesHolder</code> 与 <code>requestAttributesHolder</code></h2><p><code>RequestContextHolder</code> 底层由 <code>ThreadLocal</code> 实现。</p><p>通过源码剖析我们可以看到，在 <code>RequestContextHolder</code> 中有两个 <code>ThreadLocal</code> 变量，分别为 <code>inheritableRequestAttributesHolder</code> 与 <code>requestAttributesHolder</code> 。这两个变量有什么区别吗？</p><p><code>RequestContextHolder</code> 默认从 <code>requestAttributesHolder</code> 存取，但是在<strong>多线程的情况下，子线程无法访问父线程中的数据</strong>，即 <code>RequestContextHolder#getRequestAttributes</code> 返回 null，此时就需要用到 <code>inheritableRequestAttributesHolder</code>。<code>inheritableRequestAttributesHolder</code> 是 <code>NamedInheritableThreadLocal</code> 类型，<code>NamedInheritableThreadLocal</code> 继承于 <code>InheritableThreadLocal</code>，<code>InheritableThreadLocal</code> <strong>实现了子线程从父线程继承数据</strong>，这样在<strong>子线程也可以访问父线程中 <code>InheritableThreadLocal</code> 的数据。</strong></p><blockquote><p><a href="https://devildyw.github.io/2022/02/28/ThreadLocal/">ThreadLocal | Devil的个人博客 (devildyw.github.io)</a></p></blockquote><p>要使用 <code>inheritableRequestAttributesHolder</code> 替代 <code>requestAttributesHolder</code> ，关键在于 <code>FrameworkServlet</code> 中的 <code>threadContextInheritable</code>，该值为 false，即默认使用 <code>requestAttributesHolder</code>，将其设置为 true，则会使用 <code>inheritableRequestAttributesHolder</code>。通常 <code>requestAttributesHolder</code> 已经够用了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">threadContextInheritable</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">RequestContextHolder.setRequestAttributes(requestAttributes, <span class="built_in">this</span>.threadContextInheritable);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setRequestAttributes</span><span class="params">(<span class="meta">@Nullable</span> RequestAttributes attributes, <span class="type">boolean</span> inheritable)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (attributes == <span class="literal">null</span>) &#123;</span><br><span class="line">resetRequestAttributes();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (inheritable) &#123;</span><br><span class="line">inheritableRequestAttributesHolder.set(attributes);</span><br><span class="line">requestAttributesHolder.remove();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">requestAttributesHolder.set(attributes);</span><br><span class="line">inheritableRequestAttributesHolder.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InheritableThreadLocal</code> 解决了父线程向子线程传递数据的问题，但<strong>传递数据发生在创建 Thread 阶段</strong>，如果<strong>使用了线程池，线程被复用，子线程的数据仍然是创建时传递的数据，而不是执行任务时父线程的数据</strong>。这种情况下，就需要重写 <code>RequestContextHolder</code>，使用 <code>TransmittableThreadLocal</code> 代替 <code>ThreadLocal</code>。<code>TransmittableThreadLocal</code> 用于解决使用线程池时，父线程向子线程传递数据的问题，详见 <a href="https://blog.csdn.net/qq_26012495/article/details/104379137">解决ThreadLocal在开启子线程时，父线程向子线程值传递问题，源码分析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SpringMVC-之-RequestContextHolder&quot;&gt;&lt;a href=&quot;#SpringMVC-之-RequestContextHolder&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC 之 RequestContextHo</summary>
      
    
    
    
    <category term="Spring框架" scheme="https://devildyw.github.io/categories/Spring%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="并发编程" scheme="https://devildyw.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ARP</title>
    <link href="https://devildyw.github.io/2022/10/18/ARP/"/>
    <id>https://devildyw.github.io/2022/10/18/ARP/</id>
    <published>2022-10-18T13:27:16.000Z</published>
    <updated>2022-10-18T13:51:11.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARP（地址解析协议）"><a href="#ARP（地址解析协议）" class="headerlink" title="ARP（地址解析协议）"></a>ARP（地址解析协议）</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>计算机通信方式通过广播的方式。所有上层的数据包到最后都要封装到以太网头，然后通过以太网协议发送。在谈及以太网协议的时候，我们已经了解到，通信基于 MAC 地址的广播方式实现的，计算机在发送数据包时，获取自身的 <code>MAC</code> 地址是 容 易 的 ， 获 取 目 标 主 机 的 <code>MAC</code> 地 址 ， 需 要 通 过 <code>ARP</code>（ Address Resolution Protocol，地址解析协议）来实现。</p><h2 id="协议原理"><a href="#协议原理" class="headerlink" title="协议原理"></a>协议原理</h2><p><code>ARP</code> 用于实现从 <code>IP</code> 地址到MAC地址的映射，即询问目标<code>IP</code> 地址对应的MAC地址，以广播的方式发送数据包，获取目标主机的MAC地址。我们通过一个案例来说明其具体通信原理，假设主机 <code>IP</code> 地址都已知。</p><ul><li>主机A的 <code>IP</code> 地址为 <code>10.1.20.64</code>，MAC地址为 <code>00：08：ca：xx：xx：xx</code>；</li><li>主机B的 <code>IP</code> 地址为 <code>10.1.20.109</code> ，MAC地址为 <code>44：6d：57：xx：xx：xx</code>。</li></ul><p>当 主 机 A 要 与 主 机 B 通 信 时 ， <code>ARP</code> 可 以 将 主 机 B 的 <code>IP</code> 地 址（<code>10.1.20.109</code>）解析成主机B的MAC地址，以下为工作流程。</p><p>第一步：通过 <strong><code>IP</code> 地址和子网掩码计算出自己所处的子网</strong>，得出如下表所示的结果。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210182132568.png" alt="image-20221018213209515"></p><p>第二步：分析主机A和B是否处于同一网络，<strong>如果不是同一网络</strong>，那么下表中目标 <code>IP</code> 地址为<code>10.1.20.109</code>（访问路由器的路由表），<strong>通过 <code>ARP</code> 获取的是网关的 <code>MAC</code> 地址</strong>。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210182132043.png" alt="image-20221018213236999"></p><p>第三步：根据主机A上的路由表内容，确定用于访问主机B的转发 <code>IP</code> 地址是 <code>10.1.20.109</code>。然后主机A在自己的本地 <code>ARP</code> <strong>缓存中</strong>检查主机B的匹配 <code>MAC</code> 地址。</p><p>第四步：如果主机A在 <code>ARP</code> 缓存中没有找到映射，它将询问 <code>10.1.20.64</code> 的硬件地址，从而将 <code>ARP</code> 请求帧广播到本地网络上的所有主机。源主机A的 <code>IP</code> 地址和 <code>MAC</code> 地址都包括在 <code>ARP</code> 请求中。本地网络上的每台主机都接收到 <code>ARP</code> 请求并且检查是否与自己的 <code>IP</code> 地址匹配。<strong>如果主机发现请求的 <code>IP</code> 地址与自己的 <code>IP</code> 地址不匹配，它将丢弃 <code>ARP</code> 请求。</strong></p><p>第五步：主机B确定 <code>ARP</code> 请求中的 <code>IP</code> 地址与自己的 <code>IP</code> 地址<strong>匹配</strong>，<strong>将主机A的 <code>IP</code> 地址和 <code>MAC</code> 地址映射添加到本地 <code>ARP</code> 缓存中。</strong></p><p>第六步：<strong>主机 B 将包含其 <code>MAC</code> 地址的 <code>ARP</code> 回复消息直接发送回主机 A。</strong></p><p>第七步：当主机 A 接收到从主机 B 发来的 <code>ARP</code> 回复消息时，会用主机 B 的 <code>IP</code> 地址和 <code>MAC</code> 地址映射<strong>更新 <code>ARP</code> 缓存</strong>。本机缓存是有<strong>生存期</strong>的，生存期结束后，将再次<strong>重复</strong>上面的过程。主机 B 的 <code>MAC</code> 地址一旦确定，主机 A 就能向主机 B 发送 <code>IP</code> 地址了。</p><hr><p>​                                                                                                                                                                        ——— 摘自《Netty 4 核心原理与手写 RPC 框架实战》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ARP（地址解析协议）&quot;&gt;&lt;a href=&quot;#ARP（地址解析协议）&quot; class=&quot;headerlink&quot; title=&quot;ARP（地址解析协议）&quot;&gt;&lt;/a&gt;ARP（地址解析协议）&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;head</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://devildyw.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机网络" scheme="https://devildyw.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://devildyw.github.io/2022/10/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://devildyw.github.io/2022/10/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2022-10-18T11:01:50.000Z</published>
    <updated>2022-11-08T13:13:09.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="TCP-x2F-IP-网络模型"><a href="#TCP-x2F-IP-网络模型" class="headerlink" title="TCP&#x2F;IP 网络模型"></a>TCP&#x2F;IP 网络模型</h3><p>计算机与计算机之间要有统一的连接标准才能够完成相互通信，这个标准被称为互联网协议，而网络就是物理链接介质+互联网协议。按照功能不同，人们将互联网协议从不同维度分为 <code>OSI</code> 七层、<code>TCP/IP</code> 五层或 <code>TCP/IP</code> 四层，如下图所示</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210182110569.png" alt="image-20221018211041494"></p><p>这个网络协议是分层的，每一层都有各自的作用和职责。</p><p>在 <code>TCP/IP</code> 五层模型中每层运行的常见设备如下图所示。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210182111820.png" alt="image-20221018211134767"></p><p>在 <code>TCP/IP</code> 四层模型中数据传输过程中每一层的封装格式：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210182029355.png" alt="img"></p><blockquote><p>网络接口层的传输单位是帧（frame），<code>IP</code> 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区别，可以统称位<strong>数据包</strong>。</p></blockquote><p>我们主要学习前三层，所以这里以 <code>TCP/IP</code> <strong>四层模型</strong>来介绍。</p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层位于 <code>TCP/IP</code> 模型的最上层，也是用户能直接接触到的，如电脑或手机上使用的应用软件都是在应用层上实现。</p><p>当两个不同设备的应用需要进行通信的时候，应用就把应用数据传输给下一层，也就是<strong>传输层</strong>。</p><p>所以，<strong>应用层只需要专注于为用户提供应用功能，而不用去关心数据是怎么传输的，数据传输是由下层次的协议负责。</strong>就类似于我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快递是如何被运输的。</p><p><strong>应用层是工作在操作系统中的用户态，传输层以及下则工作在内核态。</strong></p><p>常见的应用层协议：<code>HTTP</code>、<code>FTP</code>、<code>Telnet</code>、<code>DNS</code>、<code>SMTP</code>等。</p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>应用层的数据包会传给传输层，<strong>传输层（<em>Transport Layer</em>）</strong>是为应用层提供网络支持的。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210181922823.png" alt="img"></p><p>在传输层中有两个传输协议，分别是 <code>TCP</code> 和 <code>UDP</code></p><p><code>TCP</code> 全称叫传输控制协议（<em>Transmission Control Protocol</em>），大部分应用使用的正是 TCP 传输协议，比如 HTTP 应用层协议。<code>TCP</code> 相较于 <code>UDP</code> 多了很多特性，比如<strong>流量控制、超时重传、拥塞控制</strong>等，这些特性的目的都是为了保证数据传输时的<strong>可靠性</strong>。</p><p><code>UDP</code> 相对来说就很简单，<code>UDP</code> 只负责发送数据包，<strong>不保证数据包是否能抵达对方</strong>，但它<strong>实时性</strong>相对更好，<strong>传输效率也更高</strong>（不用花费额外的时间去建立连接）。<code>UDP</code> 也可以实现可靠传输，把 <code>TCP</code> 的特性在应用层上实现就可以，但要是实现一个可以商用的可靠 <code>UDP </code> 传输协议，并不是一件简单的事。</p><p>应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的<strong>数据包大小超过 <code>MSS</code><strong>（TCP 最大报文段长度），就</strong>需要将数据包分块</strong>，这样即使中途有一个分块丢失或损坏了，只需要重新发送这个分块，而不用发送整个数据包。在 TCP 协议中，我们把每个数据分块称为一个 <strong><code>TCP</code> 报文段</strong>（<em>TCP Segment</em>）</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210181932485.png" alt="img"></p><p>当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用进程在接收或者传输数据，因此需要用一个标识来区分不同的应用进程，这个标识就是<strong>端口号</strong>（0~65535）</p><blockquote><p>80 端口通常是 Web 服务器用的，22端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签页都是一个独立的进程，操作系统会为这些进程分配临时的端口号。</p></blockquote><p><strong>由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用进程的。</strong></p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>传输层事实上也不负责将数据从一个设备传输到另一个设备。</p><p>实际场景中的网络环节是错综复杂的，中间有着各种各样的线路和分岔路口，如果一个设备的数据传输给另一个设备，就需要在各种各样的路径和节点之间进行选择，而传输层的设计理念是简单、高效、专注，如果传输层还负责这一块功能就有点违背设计原则了。</p><p>也就是说，传输层专注于为应用层服务，让其作为应用间数据传输的媒介，帮助实现应用到应用之间的通信，而实际的传输功能功能就交给了下层，也就是<strong>网络层</strong>（<em>Internet Layer</em>）。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210181950303.png" alt="img"></p><p>网络层中最常（但不只有）使用的是 <code>IP</code> 协议（<em>Internet Protocol</em>），<code>IP</code> 协议会将传输层的报文做为数据部分，再加上 <code>IP</code> 包头组装成 <code>IP</code> 报文，如果 <code>IP</code> 报文大小超过了 <code>MTU</code>（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 <code>IP</code> 报文。 </p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210181954507.png" alt="img"></p><p>网络层负责将数据从一个设备传输到另一个设备，世界上有这么多的设备，网络层是如何找到目标设备的呢？因此，<strong>网络层需要有区分设备的标识</strong>。</p><p>我们通常<strong>使用 <code>IP</code> 地址作为设备的标识</strong>，对于 <code>IPv4</code> 协议，<code>IP</code> 地址供 32 位，分成了四段（如：192.168.100.1），每段是 8 位。只有一个单纯的 <code>IP</code> 地址虽然做到了区分设备，但是寻址起来就特别麻烦了，那么多的设备，一个一个去匹配显然不科学。</p><p>实际上 <code>IP</code> 地址由两部分组成：<strong>网络部分（用来标识子网）和主机部分（用来标识主机）</strong>。</p><ul><li><strong>一个是网络号，负责标识该 <code>IP</code> 是属于那个 「子网」的；</strong></li><li><strong>一个是主机号，负责标识同一 「子网」下的不同主机；</strong></li></ul><blockquote><p>注意：单纯的 <code>IP</code> 地址段只是标识了 <code>IP</code> 地址的种类，从网络部分或主机部分都无法辨识一个 <code>IP</code> 地址所处的子网。例如，并不能确定172.16.10.1与172.16.10.2处于同一子网。因此，就需要子网掩码</p></blockquote><blockquote><p>什么是子网？</p><p>为了确定网络区域，分开主机和路由器的每个接口，从而产生了若干个分离的网络岛，接口端连接了这些独立网络的端点。这些独立的网络岛叫做<strong>子网(subnet)。子网之间用路由器互联。</strong></p><p>什么是子网掩码？</p><p>所谓“子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于<code>IP</code>地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。</p></blockquote><p>配合子网掩码可以计算出 <code>IP</code> 地址的网络号和主机号。</p><blockquote><p>举例：</p><p>比如 10.100.122.0&#x2F;24，后面的 <code>/24</code>标识就是 <code>255.255.255.0</code> 子网掩码，255.255.255.0 二进制是「11111111-11111111-11111111-00000000」，可以看出有 24 个 1，为了简化子网掩码的表示，用 <code>/24</code> 代替 <code>255.255.255.0</code>。</p></blockquote><p>使用子网掩码和 <code>IP</code> 地址计算出网络地址和主机地址。</p><p>网络号 &#x3D; <code>IP</code> 地址和子网掩码进行<strong>按位与运算</strong>。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210182009553.jpeg"></p><p>主机号 &#x3D; 子网掩码取反后与 <code>IP</code> 地址进行<strong>按位与运算</strong>。</p><hr><p>寻址过程：先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。</p><blockquote><p>上述寻址过程可以理解为我们要找到一个人，我们首先要找到这个人所在的小区（网络号），找到这个小区后，我们才去找对应的人。</p></blockquote><p>除了寻址能力，<code>IP</code> 协议还有另一个重要的能力就是<strong>路由</strong>。实际场景中，两台设备并不是用同一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走那条路径。</p><p>路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210182017678.jpeg" alt="IP地址的网络号"></p><p>所以，**<code>IP</code> 协议的寻址作用是告诉我们去往下一个目的地该朝那个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘。**</p><h4 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h4><p>生成了 <code>IP</code> 报文后，接下来要交给<strong>网络接口层</strong>（<em>Link Layer</em>）在 <code>IP</code> 头部前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210182023613.png" alt="img"></p><p><code>IP</code> 头部中的接收方 <code>IP</code> 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。</p><blockquote><p>什么是以太网呢？</p><p>电脑上的以太网接口，<code>Wi-Fi</code>接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。</p><p>使用以太网进行数据传输，基于 MAC 地址的广播方式实现数据传输，只能在局域网内广播。</p></blockquote><p>以太网在判断网络包目的地时和 <code>IP</code> 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。</p><blockquote><p>MAC 头部中包含的源地址和目标地址的由来： Ethernet（以太网协议） 规定接入Internet的设备必须配有网卡，发送端和接收端的地址便是指网卡的地址，即MAC地址。</p><p>MAC 地址：每块网卡出厂时都被印上一个世界<strong>唯一的</strong> MAC 地址，它是一个长度为48位的二进制数，通常用12位十六进制数表示（前6位是厂商编号，后6位是流水线号）。</p></blockquote><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 <code>ARP</code> 协议获取对方的 MAC 地址。<a href="https://devildyw.github.io/2022/10/18/ARP/">ARP | Devil的个人博客 (devildyw.github.io)</a></p><p>所以说，网络接口层主要为网络层提供<strong>「链路级别」</strong>传输的服务，负责在以太网、<code>WiFi</code> 这样的底层网络上发送原始数据包，<strong>工作在网卡这个层次，使用 MAC 地址来标识网络上的设备</strong>。</p><h3 id="输入网址到网页显示，期间的过程"><a href="#输入网址到网页显示，期间的过程" class="headerlink" title="输入网址到网页显示，期间的过程"></a>输入网址到网页显示，期间的过程</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210221845503.jpeg" alt="简单的网络模型"></p><h4 id="1-HTTP"><a href="#1-HTTP" class="headerlink" title="1. HTTP"></a>1. HTTP</h4><blockquote><p>浏览器做的第一步工作是解析 URL</p></blockquote><p>浏览器首先对 <code>URL</code> 进行解析，从而生成发送给 <code>Web</code> 服务器的请求</p><p>一条 <code>URL</code> 中各个元素代表什么</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210221847708.jpeg" alt="URL 解析"></p><p>由上可知，<code>URL</code> 实际上是请求服务器里面的文件资源（前后端分离过后，这里的服务器指的是前端服务器）。</p><p>对 <code>URL</code> 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求报文了。</p><p>HTTP 报文分为请求报文和响应报文。（下图很详细的展示了 HTTP 报文的结构）</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210221851674.png" alt="HTTP 的消息格式"></p><h4 id="2-真实地址查询-–-DNS"><a href="#2-真实地址查询-–-DNS" class="headerlink" title="2. 真实地址查询 – DNS"></a>2. 真实地址查询 – DNS</h4><p>通过浏览器对于 <code>URL</code> 的解析并生成 HTTP 请求报文后，需要委托下层协议将报文发送给 <code>Web</code> 服务器。</p><p>但是往往解析出来的服务器地址是一个<strong>域名地址</strong>，我们必须借助 DNS 服务器查询出域名对应的真实 IP 地址这样操作系统才能在发送报文时，知道目的地。</p><p>DNS（域名解析协议）服务器：记录了域名与 IP 之间的映射关系。</p><p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com</code> ，这里的句点代表了不同层次之间的<strong>界限</strong>。</p><blockquote><p><strong>在域名中，越靠右的位置表示其层次越高。</strong></p><p>实际上域名最后还有一个点，比如 <code>www.server.com.</code>，这个最后的一个点代表根域名。</p><p>也就是，<code>.</code> 根域是在最顶层，它的下一层就是 <code>.com</code> 顶级域，再下面是 <code>server.com</code>。</p></blockquote><p>域名的层次关系类似一个树状结构：</p><ul><li>根 DNS 服务器（.）</li><li>顶级域 DNS 服务器（.com）</li><li>权威 DNS 服务器 (server.com)</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210221904760.png" alt="DNS 树状结构"></p><p>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。</p><p>所以，任何 DNS 服务器都可以找到并访问根域 DNS 服务器了。</p><p>因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</p><blockquote><p>域名解析的工作流程</p><ol><li>客户端首先会发出一个 DNS 请求，问 <a href="http://www.server.com/">www.server.com</a> 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP&#x2F;IP 设置中填写的 DNS 服务器地址）。</li><li>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 <a href="http://www.server.com,则它直接返回/">www.server.com，则它直接返回</a> IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 <a href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</li><li>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“<a href="http://www.server.com/">www.server.com</a> 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</li><li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 <a href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？”</li><li>顶级域名服务器说：“我给你负责 <a href="http://www.server.com/">www.server.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</li><li>本地 DNS 于是转向问权威 DNS 服务器：“老三，<a href="http://www.server.com对应的IP是啥呀？”">www.server.com对应的IP是啥呀？”</a> server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li><li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li></ol><p>至此，我们完成了 DNS 的解析过程。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210221913505.png" alt="域名解析的工作流程"></p></blockquote><p>实际上并不是每次解析域名都需要这么多的步骤，由于缓存的存在，能够帮助我们省去一大部分的解析花费的时间。</p><blockquote><p>实际情况是：浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。</p></blockquote><h4 id="3-协议栈"><a href="#3-协议栈" class="headerlink" title="3. 协议栈"></a>3. 协议栈</h4><p>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的<strong>协议栈</strong>。</p><p><strong>协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210221917105.jpeg" alt="img"></p><p><strong>应用程序</strong>通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 <strong>TCP</strong> 和 <strong>UDP</strong> 协议，这两个传输协议会接受来自应用层的委托执行收发数据的操作。</p><p>协议栈的下半部分是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是 IP 负责的。</p><p>此外 IP 中还包括 <code>ICMP</code> 协议和 <code>ARP</code> 协议。</p><ul><li><code>ICMP</code> ：<strong>用于告知网络包传送过程中产生的错误以及各种控制信息。</strong></li><li><code>ARP</code> ：<strong>用于根据 IP 地址查询相应的以太网 MAC 地址。</strong></li></ul><p><strong>IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</strong></p><h4 id="4-可靠传输-–-TCP"><a href="#4-可靠传输-–-TCP" class="headerlink" title="4. 可靠传输 – TCP"></a>4. 可靠传输 – TCP</h4><p>HTTP 是居于 TCP 协议传输的。</p><p>TCP 报文头部格式：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210221925401.jpeg" alt="TCP 包头格式"></p><p><strong>源端口号和目标端口号</strong>：用于指定发送的目的端口和用于接收方回传时指定端口。</p><p><strong>序号</strong>：为了解决包乱序的问题。</p><p><strong>确认号</strong>：确认发出去的包对方是否收到。为了解决丢包问题。</p><p><strong>状态位</strong>：例如 <code>SYN</code> 是发起一个连接，<code>ACK</code> 是回复，<code>RST</code> 是重新连接，<code>FIN</code> 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</p><p><strong>窗口大小</strong>：TCP 要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前的处理能力。</p><p><strong>拥塞控制</strong>：控制发送包的速度（TCP 独有）。</p><hr><h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><p>在使用 TCP 传输数据之前，首先需要建立 TCP 连接，TCP 连接的建立，通常称为<strong>三次握手</strong>。</p><p><strong>这个所谓的「连接」，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210221939191.png" alt="TCP 三次握手"></p><blockquote><ul><li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。</li><li>然后客户端主动发起连接 <code>SYN</code>，之后处于 <code>SYN-SENT</code> 状态。</li><li>服务端收到发起的连接，返回 <code>SYN</code>，并且 <code>ACK</code> 客户端的 <code>SYN</code>，之后处于 <code>SYN-RCVD</code> 状态。</li><li>客户端收到服务端发送的 <code>SYN</code> 和 <code>ACK</code> 之后，发送对 <code>SYN</code> 确认的 <code>ACK</code>，之后处于 <code>ESTABLISHED</code> 状态，因为它一发一收成功了。</li><li>服务端收到 <code>ACK</code> 的 <code>ACK</code> 之后，处于 <code>ESTABLISHED</code> 状态，因为它也一发一收了。</li></ul><p>所以三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p></blockquote><hr><h5 id="TCP-分割数据"><a href="#TCP-分割数据" class="headerlink" title="TCP 分割数据"></a>TCP 分割数据</h5><p>如果 HTTP 请求消息比较长，超过了 <code>MSS</code> 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210221945380.png" alt="MTU 与 MSS"></p><ul><li><code>MTU</code>：<strong>一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</strong></li><li><code>MSS</code>：<strong>除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</strong></li></ul><p><strong>数据会被以 <code>MSS</code> 的长度为单位进行拆分</strong>，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210221948354.jpeg" alt="数据包分割"></p><hr><h4 id="TCP-报文生成"><a href="#TCP-报文生成" class="headerlink" title="TCP 报文生成"></a>TCP 报文生成</h4><p>TCP 协议里面会有两个端口，一个是客户端（浏览器）监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 <code>80</code>， HTTPS 默认端口号是 <code>443</code>）。</p><p>在双方建立了连接后，TCP 报文中的<strong>数据部分就是存放 HTTP 头部 + 数据</strong>，组装好 TCP 报文之后，就需交给下面的网络层处理。</p><p>报文段的报文如下图所示：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210221951430.png" alt="TCP 层报文"></p><h4 id="5-远程定位-–-IP"><a href="#5-远程定位-–-IP" class="headerlink" title="5. 远程定位 – IP"></a>5. 远程定位 – IP</h4><h4 id="6-两点传输-–-MAC"><a href="#6-两点传输-–-MAC" class="headerlink" title="6. 两点传输 – MAC"></a>6. 两点传输 – MAC</h4><p>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 <strong>MAC 头部</strong>。</p><blockquote><p>MAC 包头格式</p></blockquote><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210221954427.jpeg" alt="MAC 包头格式"></p><p>在 MAC 包头里需要<strong>发送方 MAC 地址</strong>和<strong>接收方目标 MAC 地址</strong>，用于<strong>两点之间的传输</strong>。</p><p>一般在 TCP&#x2F;IP 通信里，MAC 包头的<strong>协议类型</strong>只使用：</p><ul><li><code>0800</code> ： IP 协议</li><li><code>0806</code> ： ARP 协议</li></ul><blockquote><p>MAC 发送方和接收方如何确认?</p></blockquote><p><strong>发送方</strong>的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。</p><p><strong>接收方</strong>的 MAC 地址就有点复杂了，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。</p><p>所以先得搞清楚应该把包发给谁，这个只要查一下<strong>路由表</strong>就知道了。在路由表中找到相匹配的条目，然后把包发给 <code>Gateway</code> 列中的 IP 地址就可以了。</p><blockquote><p>既然知道要发给谁，按如何获取对方的 MAC 地址呢？</p></blockquote><p>不知道对方 MAC 地址？不知道就喊呗。</p><p>此时就需要 <code>ARP</code> 协议帮我们找到路由器的 MAC 地址。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210221954425.png" alt="ARP 广播"></p><p>ARP 协议会在以太网中以<strong>广播</strong>的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。</p><p>然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。</p><p>如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。</p><blockquote><p>好像每次都要广播获取，这不是很麻烦吗？</p></blockquote><p>放心，在后续操作系统会把本次查询结果放到一块叫做 <strong>ARP 缓存</strong>的内存空间留着以后用，不过缓存的时间就几分钟。</p><p>也就是说，在发包时：</p><ul><li>先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。</li><li>而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。</li></ul><blockquote><p>查看 ARP 缓存内容</p></blockquote><p>在 Linux 系统中，我们可以使用 <code>arp -a</code> 命令来查看 ARP 缓存的内容。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210221954422.png" alt="ARP 缓存内容"></p><blockquote><p>MAC 报文生成</p></blockquote><p>至此，网络包的报文如下图。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210221954539.jpeg" alt="MAC 层报文"></p><h4 id="7-出口-–-网卡"><a href="#7-出口-–-网卡" class="headerlink" title="7. 出口 – 网卡"></a>7. 出口 – 网卡</h4><p>网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将<strong>数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。</p><p>负责执行这一操作的是<strong>网卡</strong>，要控制网卡还需要靠<strong>网卡驱动程序</strong>。</p><p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210221954016.png" alt="数据包"></p><ul><li>起始帧分界符是一个用来表示包起始位置的标记</li><li>末尾的 <code>FCS</code>（帧校验序列）用来检查包传输过程是否有损坏</li></ul><p>最后网卡会将包转为电信号，通过网线发送出去。</p><h4 id="8-交换机"><a href="#8-交换机" class="headerlink" title="8. 交换机"></a>8. 交换机</h4><p>下面来看一下包是如何通过交换机的。交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。</p><blockquote><p>交换机的包接收操作</p></blockquote><p>首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。</p><p>然后通过包末尾的 <code>FCS</code> 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p><p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p><p>将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。</p><p>交换机的 MAC 地址表主要包含两个信息：</p><ul><li>一个是设备的 MAC 地址，</li><li>另一个是该设备连接在交换机的哪个端口上。</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210221955195.jpeg" alt="交换机的 MAC 地址表"></p><p>举个例子，如果收到的包的接收方 MAC 地址为 <code>00-02-B3-1C-9C-F9</code>，则与图中表中的第 3 行匹配，根据端口列的信息，可知这个地址位于 <code>3</code> 号端口上，然后就可以通过交换电路将包发送到相应的端口了。</p><p>所以，<strong>交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</strong>。</p><blockquote><p>当 MAC 地址表找不到指定的 MAC 地址会怎么样？</p></blockquote><p>地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。</p><p>这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。</p><p>这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后<strong>只有相应的接收者才接收包，而其他设备则会忽略这个包</strong>。</p><p>有人会说：“这样做会发送多余的包，会不会造成网络拥塞呢？”</p><p>其实完全不用过于担心，因为发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入 MAC 地址表，下次也就不需要把包发到所有端口了。</p><p>局域网中每秒可以传输上千个包，多出一两个包并无大碍。</p><p>此外，如果接收方 MAC 地址是一个<strong>广播地址</strong>，那么交换机会将包发送到除源端口之外的所有端口。</p><p>以下两个属于广播地址：</p><ul><li>MAC 地址中的 <code>FF:FF:FF:FF:FF:FF</code></li><li>IP 地址中的 <code>255.255.255.255</code></li></ul><h4 id="9-路由器"><a href="#9-路由器" class="headerlink" title="9. 路由器"></a>9. 路由器</h4><blockquote><p>路由器与交换机的区别</p></blockquote><p>网络包经过交换机之后，现在到达了<strong>路由器</strong>，并在此被转发到下一个路由器或目标设备。</p><p>这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。</p><p>不过在具体的操作过程上，路由器和交换机是有区别的。</p><ul><li>因为<strong>路由器</strong>是基于 IP 设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；</li><li>而<strong>交换机</strong>是基于以太网设计的，俗称<strong>二层</strong>网络设备，交换机的端口不具有 MAC 地址。</li></ul><blockquote><p>路由器基本原理</p></blockquote><p>路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。</p><p>当转发包时，首先路由器端口会接收发给自己的以太网包，然后<strong>路由表</strong>查询转发目标，再由相应的端口作为发送方将以太网包发送出去。</p><blockquote><p>路由器的包接收操作</p></blockquote><p>首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <code>FCS</code> 进行错误校验。</p><p>如果没问题则检查 MAC 头部中的<strong>接收方 MAC 地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</p><p>总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。</p><blockquote><p>查询路由表确定输出端口</p></blockquote><p>完成包接收操作之后，路由器就会<strong>去掉</strong>包开头的 MAC 头部。</p><p><strong>MAC 头部的作用就是将包送达路由器</strong>，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会<strong>被丢弃</strong>。</p><p>接下来，路由器会根据 MAC 头部后方的 <code>IP</code> 头部中的内容进行包的转发操作。</p><p>转发操作分为几个阶段，首先是查询<strong>路由表</strong>判断转发目标。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210221955952.png" alt="路由器转发"></p><p>具体的工作流程根据上图，举个例子。</p><p>假设地址为 <code>10.10.1.101</code> 的计算机要向地址为 <code>192.168.1.100</code> 的服务器发送一个包，这个包先到达图中的路由器。</p><p>判断转发目标的第一步，就是根据包的接收方 IP 地址查询路由表中的目标地址栏，以找到相匹配的记录。</p><p>路由匹配和前面讲的一样，每个条目的子网掩码和 <code>192.168.1.100</code> IP 做 <strong>&amp; 与运算</strong>后，得到的结果与对应条目的目标地址进行匹配，如果匹配就会作为候选转发目标，如果不匹配就继续与下个条目进行路由匹配。</p><p>如第二条目的子网掩码 <code>255.255.255.0</code> 与 <code>192.168.1.100</code> IP 做 <strong>&amp; 与运算</strong>后，得到结果是 <code>192.168.1.0</code> ，这与第二条目的目标地址 <code>192.168.1.0</code> 匹配，该第二条目记录就会被作为转发目标。</p><p>实在找不到匹配路由时，就会选择<strong>默认路由</strong>，路由表中子网掩码为 <code>0.0.0.0</code> 的记录表示「默认路由」。</p><blockquote><p>路由器的发送操作</p></blockquote><p>接下来就会进入包的<strong>发送操作</strong>。</p><p>首先，我们需要根据<strong>路由表的网关列</strong>判断对方的地址。</p><ul><li>如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还需继续需要路由器转发。</li><li>如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明<strong>已抵达终点</strong>。</li></ul><p>知道对方的 IP 地址之后，接下来需要通过 <code>ARP</code> 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。</p><p>路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。</p><p>接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 <code>0800</code> （十六进制）表示 IP 协议。</p><p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。</p><p>发送出去的网络包会通过<strong>交换机</strong>到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。</p><p>接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。</p><p>不知你发现了没有，在网络包传输的过程中，<strong>源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址</strong>，因为需要 MAC 地址在以太网内进行<strong>两个设备</strong>之间的包传输。</p><hr><p>至此我们的请求就顺利传输到 <code>Web</code> 服务器了，服务器响应请求按相同的步骤将资源传输到客户端（HTTP 响应报文）。</p><h2 id="HTTP-篇"><a href="#HTTP-篇" class="headerlink" title="HTTP 篇"></a>HTTP 篇</h2><h3 id="HTTP-常识"><a href="#HTTP-常识" class="headerlink" title="HTTP 常识"></a>HTTP 常识</h3><p><img src="https://img-blog.csdnimg.cn/6b9bfd38d2684b3f9843ebabf8771212.png" alt="提纲"></p><h4 id="HTTP-基本概念"><a href="#HTTP-基本概念" class="headerlink" title="HTTP 基本概念"></a>HTTP 基本概念</h4><p>HTTP 是一个应用层的<strong>超文本传输协议</strong>（HyperText Transfer Protocol）</p><p>HTTP的名字「超文本协议传输」，可以拆成三个部分。</p><blockquote><ul><li>超文本</li><li>传输</li><li>协议</li></ul></blockquote><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/3-HTTP%E4%B8%89%E9%83%A8%E5%88%86.png" alt="三个部分"></p><p><em>1. 「协议」</em> </p><p>在生活中随处可见协议。例如：</p><ul><li>保密协议</li><li>三方协议</li></ul><p>生活中的协议本质上与计算机网络中的协议是相同的，协议的特点：</p><ul><li>「<strong>协</strong>」字，代表的意思是必须有<strong>两个以上的参与者</strong>。</li><li>「<strong>议</strong>」字，代表的意思是对参与者的一种<strong>行为约定和规范</strong>。</li></ul><p>因此针对 HTTP <strong>协议</strong>，我们可以这么理解。</p><p>HTTP 是一个用在计算机世界里的<strong>协议</strong>，它使用计算能够理解的语言确立了一种计算机之间交流通信的规范（<strong>两个以上的参与者</strong>），以及相关的各种控制和错误处理方式（<strong>行为规定和规范</strong>）。</p><blockquote><p>协议：就是两个以上的参与者能够理解，能够达成共识，能够相互遵守的一套行为规范。</p></blockquote><ol start="2"><li><em>「传输」</em></li></ol><p>HTTP 是一个双向协议</p><p>HTTP 是一个在计算机世界里面专门用来在两点之间传输数据的约定和规范。</p><ol start="3"><li><em>「超文本」</em></li></ol><p>HTTP 传输的内容是「超文本」。</p><blockquote><p>我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。</p><p>再来理解「超文本」，它就是<strong>超越了普通文本的文本</strong>，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。例如：HTML</p></blockquote><hr><p>综上得出答案：<strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><hr><h5 id="HTTP-常见状态码"><a href="#HTTP-常见状态码" class="headerlink" title="HTTP 常见状态码"></a>HTTP 常见状态码</h5><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png" alt=" 五大类 HTTP 状态码 "></p><ul><li><p><strong>2XX</strong>：是我们最常看见的状态码，表示服务器成功处理了客户端的请求。</p><ul><li><p>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的<strong>响应头都会有 body 数据</strong>。</p></li><li><p>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，<strong>但响应头没有 body 数据</strong>。</p></li><li><p>「<strong>206 Partial Content</strong>」是应用于 <strong>HTTP 分块下载或断点续传</strong>，表示响应返回的 <strong>body 数据并不是资源的全部，而是其中的一部分</strong>，也是服务器处理成功的状态。</p></li></ul></li><li><p><strong>3XX</strong>：表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，即<strong>重定向</strong>。</p><ul><li><p>「<strong>301 Moved Permanently</strong>」表示<strong>永久重定向</strong>，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</p></li><li><p>「<strong>302 Found</strong>」表示<strong>临时重定向</strong>，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</p><p>301 和 302 都会在<strong>响应头</strong>里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会<strong>自动</strong>重定向新的URL</p></li><li><p>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称<strong>缓存重定向</strong>，也就是<strong>告诉客户端可以继续使用缓存资源，用于缓存控制</strong>。</p></li></ul></li><li><p><strong>4XX</strong>：表示客户端发送的<strong>报文有误</strong>，服务器无法理解，也就是<strong>错误码</strong>的含义。</p><ul><li><p>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个<strong>笼统的错误</strong>。</p></li><li><p>「<strong>403 Forbidden</strong>」表示<strong>服务器禁止访问资源</strong>，并不是客户端的请求出错。</p></li><li><p>「<strong>404 Not Found</strong>」表示请求的资源在服务器上<strong>不存在或未找到</strong>，所以无法提供给客户端。</p></li></ul></li><li><p><strong>5XX</strong>：表示客户端的请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务端的错误码。</p><ul><li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为<strong>网关或代理</strong>时返回的错误码，表示<strong>服务器自身工作正常</strong>，<strong>访问后端服务器发生了错误</strong>。</li><li>「<strong>503 Service Unavailable</strong>」表示<strong>服务器当前很忙，暂时无法响应客户端</strong>，类似“网络服务正忙，请稍后重试”的意思。</li></ul></li></ul><hr><h4 id="HTTP-报文常见字段"><a href="#HTTP-报文常见字段" class="headerlink" title="HTTP 报文常见字段"></a>HTTP 报文常见字段</h4><ol><li><p><strong>Host</strong> 字段</p><p>客户端发送请求时，用来指定服务器的域名。</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.A.com</span><br></pre></td></tr></table></figure></li><li><p><strong>Content-Length</strong> 字段</p><p>响应报文中，表明此次响应的数据长度。</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1000</span><br></pre></td></tr></table></figure><p>该字段告诉浏览器，本次数据长度是1000，超过这个长度后面的字节就属于下一个响应了。</p><blockquote><p>HTTP 协议是基于 TCP 传输协议通信的，而使用了 TCP 传输协议，就会存在一个”粘包”的问题</p><p>解决方案：</p><ul><li>通过 Content-Length 字段作为 HTTP body 的边界。</li><li>通过设置回车符、换行符作为 HTTP header 的边界。</li></ul></blockquote></li><li><p>Connection 字段</p><p><code>Connection</code> 字段常用于客户端要求服务器使用<strong>「 HTTP 长连接」</strong>机制，以便其他请求复用。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/9-connection%E5%AD%97%E6%AE%B5.png" alt="img"></p><p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><p>开启了 <strong>HTTP Keep-Alive</strong> 机制后， 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用<strong>同一个连接</strong>，一直持续到客户端或服务器端提出断开连接。</p><blockquote><p><code>HTTP/1.1</code> 版本的默认链接都是长连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。</p></blockquote></li><li><p><em>Content-Type 字段</em></p><p><code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p>上述类型表明，发送的是网页，编码是 UTF-8。</p><p>客户端请求的时候可以使用 <code>Accept</code> 字段声明自己可以接受那些数据格式。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Accept: */*  表示自己可以接受任何格式的数据。</span><br></pre></td></tr></table></figure></li><li><p>Content-Encoding 字段</p><p><code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用的是上面压缩格式。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Content-Encoding: gzip  表示服务器返回的数据采用了 gzip 方式压缩，告知客户端采用该方式解压</span><br></pre></td></tr></table></figure><p>客户端在请求时，用 <code>Accept-Encoding</code> 字段说明自己可以接受那些压缩方法。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure></li></ol><h4 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a>GET 与 POST</h4><h5 id="GET-与-POST-之间的区别"><a href="#GET-与-POST-之间的区别" class="headerlink" title="GET 与 POST 之间的区别"></a>GET 与 POST 之间的区别</h5><p> 根据 RFC 文档中的规范，<strong>GET 的语义是从服务器获取指定的资源</strong>，这个资源可以是静态的文本、页面、图片视频等。GET 请求的<strong>请求参数一般是写在 URL 中的</strong>，URL 规定只能支持 ACSII 编码，并且浏览器会对 URL 的长度有限制（HTTP 协议本身对于 URL 长度不做任何规定）。</p><p>而 <strong>POST 请求的语义是根据请求负荷（报文 body）对指定的资源做出处理</strong>，具体方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中，<strong>body 中的数据可以是任意格式的数据</strong>（json，表单，文件，xml等），<strong>只要客户端与服务端协商好即可</strong>，并且浏览器<strong>不会</strong>对 body 大小做限制。</p><hr><h5 id="GET-和-POST-方法都是安全和幂等的吗？"><a href="#GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="GET 和 POST 方法都是安全和幂等的吗？"></a>GET 和 POST 方法都是安全和幂等的吗？</h5><ul><li>在 HTTP 协议里，所谓的<strong>「安全」</strong>是指请求方法不会<strong>「破坏」</strong>服务器上的资源。</li><li>所谓的<strong>「幂等」</strong>，意思是多次执行相同的操作，结果都是<strong>「相同」</strong>的。</li></ul><p>从 RFC 规范定义的语义来看：</p><ul><li><p><strong>GET 方法是安全且幂等的</strong>，因为它是<strong>「只读」</strong>操作，无论多少次，服务器上的数据都是安全的，且每次结果都是相同的。<strong>所以可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发送请求），也可以做到代理上（如：nginx），而且在浏览器中 GET 请求可以保存为书签。</strong></p></li><li><p>POST 因为是<strong>「新增或提交数据」</strong>的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以也<strong>不是幂等</strong>的。因此浏览器一般不会缓存 POST 请求，也不能将其保存作为书签。</p></li></ul><blockquote><p>但实际上，开发者不一定会遵守 RFC 文档上规定的语音来实现 GET 和 POST 方法。如：</p><ul><li>用 GET 方法实现新增或删除数据的请求，这样 GET 请求就不再幂等和安全了。</li><li>用 POST 方法实现查询数据的请求，这样 POST 请求自然就是幂等和安全的了。</li></ul></blockquote><blockquote><p>HTTP 传输的内容都是明文的，虽然在浏览器地址栏上看不到 POST 请求的 body 数据，但是只要抓包就都能看到了，所以要避免传输过程中的数据被窃取，就要使用 HTTPS 协议，这样所有 HTTP 的数据都会被加密。</p></blockquote><p>GET 请求可以带 body 吗？</p><p>RFC 文档中并没有规定 GET 请求不能携带 body，理论上任何请求都可以携带 body。只是 RFC 规定 GET 语义是获取资源，根据这个语义不需要用到 body。</p><blockquote><p>但实际开发，GET 还是不要带 body 了。按照 RFC 语义规范来，否则会被前端骂的。</p></blockquote><hr><h4 id="HTTP-缓存技术"><a href="#HTTP-缓存技术" class="headerlink" title="HTTP 缓存技术"></a>HTTP 缓存技术</h4><p>对于一些重复性 HTTP 请求，比如在每次或一段事件内相同的请求得到的数据都是一样的，我们可以把这对<strong>「请求-响应」</strong>的数据都缓存在本地。</p><p>HTTP 设计者考虑到这一点，因此 <strong>HTTP 协议头部有不少的是针对缓存的字段</strong>。</p><p>HTTP 缓存有两种实现方式，分别是<strong>强制缓存和协商缓存</strong>。</p><h5 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h5><p>强制缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的<strong>主动性在于浏览器这边</strong>。</p><p>如下图中，返回的是 200 状态码，但在 size 项中标识的是 <em><strong>from disk cache</strong></em>，就是使用了<strong>强制缓存</strong>。</p><p><img src="https://img-blog.csdnimg.cn/1cb6bc37597e4af8adfef412bfc57a42.png" alt="img"></p><p>强制缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：</p><ul><li><code>Cache-Control</code>， 是一个相对时间；</li><li><code>Expires</code>，是一个绝对时间；</li></ul><p>如果 HTTP 响应头部<strong>同时</strong>有 Cache-Control 和 Expires 字段的话，<strong>Cache-Control的优先级高于 Expires</strong> 。</p><p>Cache-control <strong>选项更多</strong>一些，设置更加精细，所以建议使用 <em><strong>Cache-Control</strong></em> 来实现强缓存。具体的实现流程如下：</p><ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 <strong>Response 头部</strong>加上 Cache-Control，Cache-Control 中设置了过期时间的大小。</li><li>浏览器再次访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用缓存，否则重新请求服务器；</li><li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li></ul><hr><h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5><p>当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 <code>304</code>，这个是告诉浏览器可以使用本地缓存的资源，通常这种<strong>通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98etag.png" alt="img"></p><p>从上图中可以看到一个<strong>协商缓存</strong>的过程，所以<strong>协商缓存就是与服务端协商过后，通过协商结果来判断是否使用本地缓存。</strong></p><p>协商缓存可以基于两种头部来实现。</p><p><strong>第一种</strong>：请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现，这两个字段的意思是：</p><ul><li>响应头部中的 <code>Last-Modified</code>：标示这个响应资源的最后修改时间；</li><li>请求头部中的 <code>If-Modified-Since</code>：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li></ul><p><strong>第二种</strong>：请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段，这两个字段的意思是：</p><ul><li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li><li>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li></ul><p>第一种实现方式是<strong>基于时间</strong>实现的，第二种实现方式是<strong>基于一个唯一标识</strong>实现的，相对来说<strong>后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</strong></p><p>如果在第一次请求资源的时候，服务端返回的 HTTP 响应头部同时有 Etag 和 Last-Modified 字段，那么客户端再下一次请求的时候，如果带上了 ETag 和 Last-Modified 字段信息给服务端，<strong>这时 Etag 的优先级更高</strong>，也就是服务端先会判断 Etag 是否变化了，如果 Etag 有变化就不用在判断 Last-Modified 了，如果 Etag 没有变化，然后再看 Last-Modified。</p><p><strong>为什么 ETag 的优先级更高？</strong>这是因为 ETag 主要能解决 Last-Modified 几个比较难以解决的问题：</p><ol><li>在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；</li><li>可能有些文件是在秒级以内修改的，<code>If-Modified-Since</code> 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；</li><li>有些服务器不能精确获取文件的最后修改时间。</li></ol><hr><p>注意，<strong>协商缓存这两个字段都需要配合强制缓存中 Cache-control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p><p>下图是强制缓存和协商缓存的工作流程：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http%E7%BC%93%E5%AD%98.png" alt="img"></p><p>当使用 ETag 字段实现的协商缓存的过程：</p><ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 <strong>ETag 唯一标识</strong>，这个唯一标识的值是根据当前请求的资源生成的；</li><li>当浏览器再次请求访问服务器中的该资源时，<strong>首先会先检查强制缓存是否过期</strong>：<ul><li>如果没有过期，则直接使用本地缓存；</li><li>如果缓存过期了，会在 Request 头部加上 <strong>If-None-Match</strong> 字段，该字段的值就是 <strong>ETag</strong> 唯一标识；</li></ul></li><li>服务器再次收到请求后，<strong>会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较：</strong><ul><li><strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；</li><li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上<strong>新的 ETag 唯一标识</strong>；</li></ul></li><li>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</li></ul><h4 id="HTTP-特性"><a href="#HTTP-特性" class="headerlink" title="HTTP 特性"></a>HTTP 特性</h4><p>到目前为止，HTTP 常见的版本有 HTTP&#x2F;1.1，HTTP&#x2F;2.0，HTTP&#x2F;3.0，不同版本的 HTTP 特性是不一样的。这里先介绍 HTTP 1.1 版本介绍。</p><h5 id="HTTP-x2F-1-1-的优点"><a href="#HTTP-x2F-1-1-的优点" class="headerlink" title="HTTP&#x2F;1.1 的优点"></a>HTTP&#x2F;1.1 的优点</h5><p>HTTP 最突出的优点就是<strong>「简单、灵活和易于扩展、应用广泛和跨平台」</strong>。</p><ol><li><p><strong>简单</strong></p><p>HTTP 基本的报文哥特式就是 <code>header + body</code> ，头部信息也是 <code>key-value</code> 简单文本的形式，易于理解，降低了学习和使用的门槛。</p></li><li><p><strong>灵活和易于扩展</strong>  </p><p>HTTP 协议里的各类请求方法、URI&#x2F;URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。</p><p>同时 HTTP 由于是工作在应用层（<code>OSI</code> 第七层），则它的<code>下层可以随意变化</code>，比如：</p><ul><li>HTTPS 就是 HTTP 与 TCP 层之间增加了 SSL&#x2F;TLS 安全传输层；</li><li>HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 传输协议使用的是 TCP 协议，而到了 HTTP&#x2F;3.0 传输协议改用成了 UDP 协议。</li></ul></li><li><p><strong>应用广泛和跨平台</strong></p><p>HTTP 的应用非常广泛，从电脑的浏览器到手机上的各种 APP，各种各样的应用程序，HTTP 应用遍地开花，同时天然具有<strong>跨平台</strong>的优越性。</p></li></ol><hr><h5 id="HTTP-x2F-1-1-缺点"><a href="#HTTP-x2F-1-1-缺点" class="headerlink" title="HTTP&#x2F;1.1 缺点"></a>HTTP&#x2F;1.1 缺点</h5><p>HTTP 优缺点：<strong>「不安全」</strong>这一个大缺点，除此之外还有<strong>「无状态、明文传输」</strong>。</p><ol><li><p><strong>无状态</strong></p><p>无状态是一把<strong>双刃剑</strong>既有好处也有坏处。</p><p><strong>好处</strong>：因为服务器不会去记忆 HTTP 的状态，所以<strong>不需要额外的资源来记录状态信息</strong>，这能减轻服务器的负担，把更多的资源用来对完提供服务。（CPU 和 内存）</p><p><strong>坏处</strong>：服务器没有记忆能力，他在完成有关联性的操作时会非常麻烦。即一些用户的登录状态 HTTP 是没有办法保存的，如果不做任何处理，需要用户每次执行操作时都要进行登录，这大大的折扣了用户的体验。</p><p>对于无状态的问题，解决方案很多，其中比较简单的方式就是使用 <strong>Cookie</strong> 技术。</p><p><strong>Cookie 相当于，在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，这样服务器就能认得你了。</strong></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/14-cookie%E6%8A%80%E6%9C%AF.png" alt="Cookie 技术"></p></li><li><p><strong>明文传输</strong></p><p>明文传输同样也是一把双刃剑，明文传输意味着在传输过程中的信息，是可方便读的，比如被抓包工具，抓到请求包后都可以之间肉眼查看，为我们调试工作带来了极大的便利性。</p><p>但正是因为这样，HTTP 所有信息都暴露在光天化日之下，相当于<strong>信息裸奔</strong>。在传输的漫长过程中，所有的信息都毫无隐私可言，很容易被窃取，如果有隐私信息，被不法之人获取到了，那将是灾难级的。</p></li><li><p><strong>不安全</strong></p><p>HTTP 最为严重的缺点就是不安全：</p><ul><li>通信使用明文（不加密），内容可能会被窃听。比如<strong>账号信息容易泄露，那对于用户而言将是灾难。</strong></li><li>不验证通信方的身份，因此有可能遭遇伪装。比如，<strong>访问假的淘宝、pdd、那对于用户也是灾难。</strong></li><li>无法证明报文的完整性，所以有可能已遭篡改。比如，<strong>网页上植入垃圾广告，对用户的体验也是不利的。</strong></li></ul></li></ol><h5 id="HTTP-x2F-1-1-性能"><a href="#HTTP-x2F-1-1-性能" class="headerlink" title="HTTP&#x2F;1.1 性能"></a>HTTP&#x2F;1.1 性能</h5><p>HTTP&#x2F;1.1 是基于 <strong>TCP&#x2F;IP</strong>，并且使用了「<strong>请求 - 应答</strong>」的通信模式，所以性能的关键就在这两点上。</p><ol><li><p><strong>TCP 长连接</strong></p><p>早期 HTTP&#x2F;1.0 性能上有一个很大的问题，那就是<strong>每发起一个请求，都要新建一次 TCP 链接（三次握手），而且是串行请求</strong>，做了无谓的 TCP 请求建立和连接断开，增加了通信开销。</p><p>为了解决上述 TCP 连接问题，HTTP&#x2F;1.1 提出了<strong>长连接（持久连接）</strong>的通信方式，这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p><p>持久连接的特点是：<strong>只要任意一端没有明确提出断开连接，则保持 TCP 保持状态。</strong></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/16-%E7%9F%AD%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%95%BF%E8%BF%9E%E6%8E%A5.png" alt="短连接与长连接"></p><p><strong>当然，如果某个 HTTP 连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接。</strong></p></li><li><p><strong>管道网络传输</strong></p><p>HTTP&#x2F;1.1 采用了<strong>长连接</strong>的方式，这使得管道（pipeline）网络传输成为了可能。</p><p>即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求除去，可以<strong>减少整体的响应时间</strong>。</p><blockquote><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。那么，管道机制则是允许浏览器同时发出 A 请求和 B 请求。如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/17-%E7%AE%A1%E9%81%93%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93.png" alt="管道网络传输"></p></blockquote><p>但是<strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>。</p><p>如果服务器在处理 A 请求时的耗时比较长，那么后续的请求都会被阻塞住，这被称为<strong>「队头堵塞」</strong>。</p><p>所以，<strong>HTTP&#x2F;1.1 管道解决了请求的对头阻塞，但是没有解决响应的对头阻塞。</strong></p><blockquote><p>TIP</p><p>注意！！！</p><p>实际上 HTTP&#x2F;1.1 管道化技术不是默认开启，而且浏览器基本都没有支持，所以<strong>后面所有文章讨论HTTP&#x2F;1.1 都是建立在没有使用管道化的前提</strong>。大家知道有这个功能，但是没有被使用就行了。</p></blockquote></li><li><p><strong>队头阻塞</strong></p><p>「请求 - 应答」的模式加剧了 HTTP 的性能问题。</p><p>因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「<strong>队头阻塞</strong>」，好比上班的路上塞车。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/18-%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E.png" alt="队头阻塞"></p><p>总结：<strong>HTTP&#x2F;1.1 的性能还是较差，虽然较与 HTTP&#x2F;1.0 有了提升，但还是一般般，后续的 HTTP&#x2F;2 和 HTTP&#x2F;3 就是在优化 HTTP 的性能。（主要是提升性能）</strong></p></li></ol><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><h5 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h5><ul><li>HTTPS 解决了 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 较与 HTTP 在 TCP 三次握手之后，还需要进行 SSL&#x2F;TLS 的握手过程，才可以进入加密报文传输。</li><li>HTTPS 与 HTTP 默认端口号不同，HTTP 是 80，而 HTTPS 是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/19-HTTPS%E4%B8%8EHTTP.png" alt="HTTP 与 HTTPS 网络层"></p><h5 id="HTTPS-解决了-HTTP-的那些问题？"><a href="#HTTPS-解决了-HTTP-的那些问题？" class="headerlink" title="HTTPS 解决了 HTTP 的那些问题？"></a>HTTPS 解决了 HTTP 的那些问题？</h5><p>HTTP 由于是明文传输，所以安全上存在以下风险：</p><ul><li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容。</li><li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染。</li><li><strong>冒充风险</strong>，比如冒充别的网站。</li></ul><p>HTTPS 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议，可以很好地解决上述的风险：</p><ul><li><strong>信息加密</strong>：交互信息无法被窃取。</li><li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示了。</li><li><strong>身份证书</strong>：证明网站是我们要访问的网站。</li></ul><blockquote><p>可见，只要我们自己不作，SSL&#x2F;TLS 协议是能够保证通信是安全的。</p></blockquote><blockquote><p>HTTPS 是如何解决上面三个风险的？</p></blockquote><ul><li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li><li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够生成独一无二的「指纹」，指纹用于校验数据的完整性 ，解决了篡改的风险。</li><li>将服务器公钥放到<strong>数字证书</strong>中，解决了冒充的风险。</li></ul><ol><li><em><strong>混合加密</strong></em></li></ol><p>通过混合加密的方式可以保证信息的<strong>机密性</strong>，解决了窃听的而风险。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/20-%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86.png" alt="混合加密"></p><p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的<strong>「混合加密」</strong>方式：</p><ul><li>在通信建立前采用非对称加密的方式交换<strong>「会话秘钥」</strong>，后续就不再使用非对称加密。</li><li>在通信过程中全部使用对称加密的<strong>「会话秘钥」</strong>的方式加密明文数据。</li></ul><p>采用「混合加密」的方式的原因：</p><ul><li><strong>对称加密</strong>只是用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li><li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li></ul><ol start="2"><li><em><strong>摘要算法 + 数字签名</strong></em></li></ol><p>为了保证传输的内容不被篡改，我们需要对内容计算出一个<strong>「指纹」</strong>，然后同内容一起传输给对方。</p><p>对方收到后，显示对内容也计算出一个<strong>「指纹」</strong>，然后跟发送方发送的<strong>「指纹」</strong>做一个比较，如果<strong>「指纹」</strong>相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。</p><p>那么，在计算机里会<strong>用摘要算法（哈希函数）来计算出内容里的哈希值</strong>，也就是内容的<strong>「指纹」</strong>，这个<strong>哈希值是唯一的，且无法通过哈希值推导出内容</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.png" alt="img"></p><p>通过哈希算法可以确保内容不会被篡改，<strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。</p><blockquote><p>你想向老师请假，一般来说是要求由家长写一份请假理由并签名，老师才能允许你请假。</p><p>但是你有模仿你爸爸字迹的能力，你用你爸爸的字迹写了一份请假理由然后签上你爸爸的名字，老师一看到这个请假条，查看字迹和签名，就误以为是你爸爸写的，就会允许你请假。</p><p>那作为老师，要如何避免这种情况发生呢？现实生活中的，可以通过电话或视频来确认是否是由父母发出的请假，但是计算机里可没有这种操作。</p></blockquote><p>为了避免这种情况，计算机里会用<strong>非对称加密算法</strong>来解决，共有两个密钥：</p><ul><li>一个是公钥，这个是可以公开给所有人的；</li><li>一个是私钥，这个必须由本人管理，不可以泄露。</li></ul><p>这两个密钥是可以<strong>双向加解密</strong>的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。</p><p>流程的不同，意味着目的也不相同：</p><ul><li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容， 其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li><li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄漏的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息的来源于持有私钥身份的人发送的。</li></ul><p>一般不会使用 非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能。</p><p>所以非对称加密的用途主要在于<strong>通过「私钥加密，公钥解密」的方式，来确认消息的身份</strong>，我们常说的<strong>数字签名算法</strong>，就是用这种方式，不过密钥加密内容不是内容本身，而是<strong>对内容的哈希值加密</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png" alt="img"></p><p>私钥是由服务器保管，然后服务端会向客户端颁发对应的公钥。如果客户端接收到的信息，能被公钥解密，就说明该消息是由服务器发送的。</p><ol start="3"><li><em><strong>数字证书</strong></em></li></ol><p>前面我们知道：</p><ul><li><strong>可以通过哈希算法来保证消息的完整性；</strong>（通过哈希运算内容得到的哈希值来比较是否值相同，防止发送过来的内容被篡改）；</li><li><strong>可以通过数字签名来保证消息的来源可靠性</strong>（能确认消息是由持有私钥的一方发送的）；</li></ul><p>但是这还远远不够，还缺少了身份验证的环节，万一公钥是被伪造的呢？</p><blockquote><p>为了防止公钥伪造，我们需要委托一个<strong>权威机构</strong>，他们会用他们自己的私钥对公钥做了个数字前面，然后把<strong>「个人信息 + 公钥 + 数字签名」</strong>打包成一个<strong>数字证书，也就是说这个数字证书包含你的公钥。</strong></p><p>接收方拿到数字证书后，<strong>首先会去这个权威机构哪里验证这个数字证书是否合法</strong>，权威机构接收到数字证书后，使用自己的公钥对数字证书进行解密，如果解密成功，就说明这个数字证书是合法的，然后权威机构就会把数字证书内的公钥发送给刚刚的接收方。</p><p><strong>由于通过权威机构的验证了数字证书是合法的，那么就能证明这个公钥不是被伪造的了。</strong></p></blockquote><p>在计算机里，这个权威机构就是 CA（数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</p><p>流程如下：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="数子证书工作流程"></p><p><strong>通过数字证书的方式保证了服务器公钥的身份，解决冒充的风险。</strong></p><h2 id="TCP-篇"><a href="#TCP-篇" class="headerlink" title="TCP 篇"></a>TCP 篇</h2><h2 id="IP-篇"><a href="#IP-篇" class="headerlink" title="IP 篇"></a>IP 篇</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络&quot;&gt;&lt;a href=&quot;#计算机网络&quot; class=&quot;headerlink&quot; title=&quot;计算机网络&quot;&gt;&lt;/a&gt;计算机网络&lt;/h1&gt;&lt;h2 id=&quot;基础篇&quot;&gt;&lt;a href=&quot;#基础篇&quot; class=&quot;headerlink&quot; title=&quot;基础篇&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://devildyw.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机网络" scheme="https://devildyw.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://devildyw.github.io/2022/10/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://devildyw.github.io/2022/10/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-10-18T11:01:33.000Z</published>
    <updated>2022-11-06T10:53:20.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="硬件结构"><a href="#硬件结构" class="headerlink" title="硬件结构"></a>硬件结构</h2><p>该部分主要接收一些计算机中的硬件知识。</p><h3 id="CPU-是如何执行程序的？"><a href="#CPU-是如何执行程序的？" class="headerlink" title="CPU 是如何执行程序的？"></a>CPU 是如何执行程序的？</h3><h4 id="冯诺依曼模型"><a href="#冯诺依曼模型" class="headerlink" title="冯诺依曼模型"></a>冯诺依曼模型</h4><p>冯诺依曼模型定义了计算机基本结构的 5 个部分，分别是<strong>运算器、控制器、存储器、输入设备、输出设备</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Von_Neumann_architecture.svg" alt="img"></p><p>运算器、控制器是在中央处理器里的，存储器就是我们常见的内存，输入输出设备则是计算机外接的设备，比如键盘、鼠标就是常见的输入设备，显示器、音响就是常见的输出设备。</p><p>存储单元和输入&#x2F;输出设备要与中央处理器打交道的话，离不开<strong>总线</strong>。它们的关系如下。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210202022116.png"></p><p>下面，我们分别介绍内存、中央处理器、总线、输入输出设备。</p><hr><h5 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h5><p>我们程序在<strong>运行时</strong>的程序和数据都是存储在内存，存储的区域是<strong>线性</strong>的。</p><p>在计算机数据存储中，存储数据的基本单位是<strong>字节（byte）</strong>，1 字节等于 8 位（bit）。每一个字节都对应一个内存地址</p><blockquote><p>内存的地址都是从 0 开始编号的，然后自增排列，最后一个地址为内存总字节数 -1，这种结构好似我们程序里的数组，所以<strong>内存里读写任何一个数据的速度都是一样的</strong>。</p></blockquote><h5 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h5><p>中央处理就是我们常说的 CPU，32 位和 64 位 CPU 最主要的区别在于一次能计算出多少字节数据：</p><ul><li>32 位 CPU 一次可以计算 4 个字节（32 位）；</li><li>64 位 CPU 一次可以计算 8 个字节（64 位）；</li></ul><blockquote><p>这里的 32 位和 64 位，通常称为 CPU 的位宽。</p><p>之所以 CPU 要这样设计，是为了能计算更大的数组，如果是 8 位的 CPU，那么一次只能计算 1 个字节 <code>0~255</code> 范围内的数值，这样就无法一次完成计算 <code>1000*500</code>，于是为了能一次计算大数的运算，CPU 需要支持多个 byte 一起计算，所以 CPU 位宽越大，可以计算的数值就越大，比如说 32 位 CPU 能计算的最大整数是 <code>4294967295</code></p></blockquote><p>CPU 内部还有一些组件，常见的有<strong>寄存器</strong>、<strong>控制单元和逻辑运算单元</strong>等。其中<strong>控制单元负责控制 CPU 工作</strong>，逻辑运算单元<strong>负责计算</strong>，而寄存器可以分为多种类，每种寄存器的功能又不尽相同。</p><p>CPU 中的寄存器主要作用是存储计算时的数据，因为内存离 CPU 太远了，而寄存器就在 CPU 里，还紧挨着控制单元和逻辑运算单元，自然计算时速度会比内存快很多。</p><blockquote><p>常见的寄存器种类：</p><ul><li><strong>通用寄存器</strong>：用来存储需要进行运算的数据，比如需要进行加和运算的两个数据。</li><li><strong>程序计数器</strong>：用来存储 CPU 要执行的下一条指令「所在的内存地址」，注意不是存储了下一条要执行的指令，此时指令还在存储中，<strong>程序计数器只是存储了下一条执行的地址</strong>。</li><li><strong>指令寄存器</strong>：用来存放程序计数器指向的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。</li></ul></blockquote><h5 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h5><p>总线用于 CPU 和内存以及其他设备之间的通信，总线分为 3 中：</p><ul><li><strong>地址总线</strong>：用于指定 CPU 将要操作的内存地址；</li><li><strong>数据总线</strong>：用于读写内存的数据；</li><li><strong>控制总线</strong>：用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线；</li></ul><p>CPU 要读写内存数据时，需要经过下面三个总线：</p><ol><li>通过「地址总线」来指定内存的地址；</li><li>通过「控制总线」控制是读或写命令；</li><li>通过「数据总线」来传输数据；</li></ol><h5 id="输入-x2F-输出设备"><a href="#输入-x2F-输出设备" class="headerlink" title="输入&#x2F;输出设备"></a>输入&#x2F;输出设备</h5><p>输出设备向计算机输入数据，计算机经过处理计算后，把数据输出给输出设备。期间如果输入设备是键盘，按下按键时是需要和 CPU 进行交互的，这时就需要用到控制总线了。</p><hr><h3 id="线路位宽与-CPU-位宽"><a href="#线路位宽与-CPU-位宽" class="headerlink" title="线路位宽与 CPU 位宽"></a>线路位宽与 CPU 位宽</h3><p><strong>线路位宽</strong></p><p><strong>操作系统位宽一般就是指线路位宽。程序在执行时，需要通过地址总线去内存中找到对应数据或指令的地址。线路位宽就是指地址总线有多少根。</strong></p><p>数据是如何通过线路传输的呢？其实是通过操作电压，低电压表示 0，高压电压则表示 1。</p><p>如果构造了高低高这样的信号，其实就是 101 二进制数据，十进制则表示 5，如果只有一条线路，就意味着每次只能传递 1 bit 的数据，即 0 或 1，那么传输 101 这个数据，就需要 3 次才能传输完成，这样的效率非常低。</p><p>这样一位一位传输的方式，称为串行，下一个 bit 必须等待上一个 bit 传输完成才能进行传输。当然，想一次多传一些数据，增加线路即可，这时数据就可以并行传输。</p><p>为了避免低效率的串行传输的方式，线路的位宽最好一次就能访问到所有的内存地址。</p><p>CPU 要想操作的内存地址就需要地址总线：</p><ul><li>如果地址总线只有 1 条，那每次只能表示 「0 或 1」这两种地址，所以 CPU 能操作的内存地址最大数量为 2（2^1）个（注意，不要理解成同时能操作 2 个内存地址）；</li><li>如果地址总线有 2 条，那么能表示 00、01、10、11 这四种地址，所以 CPU 能操作的内存地址最大数量为 4（2^2）个。</li></ul><p>那么，想要 CPU 操作 <code>4G</code> 大的内存，那么就需要 32 条地址总线，因为 <code>2 ^ 32 = 4G</code>。</p><p><strong>CPU 位宽</strong></p><p>CPU 的位宽最好不要小于线路位宽，比如 32 位 CPU 控制 40 位宽的地址总线和数据总线的话，工作起来就会非常复杂且麻烦，所以 32 位的 CPU 最好和 32 位宽的线路搭配，因为 32 位 CPU 一次最多只能操作 32 位宽的地址总线和数据总线。</p><p>如果用 32 位 CPU 去加和两个 64 位大小的数字，就需要把这 2 个 64 位的数字分成 2 个低位 32 位数字和 2 个高位 32 位数字来计算，先加个两个低位的 32 位数字，算出进位，然后加和两个高位的 32 位数字，最后再加上进位，就能算出结果了，可以发现 32 位 CPU 并不能一次性计算出加和两个 64 位数字的结果。</p><p>对于 64 位 CPU 就可以一次性算出加和两个 64 位数字的结果，因为 64 位 CPU 可以一次读入 64 位的数字，并且 64 位 CPU 内部的逻辑运算单元也支持 64 位数字的计算。</p><p>但是并不代表 64 位 CPU 性能比 32 位 CPU 高很多，很少应用需要算超过 32 位的数字，所以<strong>如果计算的数额不超过 32 位数字的情况下，32 位和 64 位 CPU 之间没什么区别的，只有当计算超过 32 位数字的情况下，64 位的优势才能体现出来</strong>。</p><p>另外，32 位 CPU 最大只能操作 <code>4GB</code> 内存，就算你装了 8 GB 内存条，也没用。而 64 位 CPU 寻址范围则很大，理论最大的寻址空间为 <code>2^64</code>。</p><h4 id="程序执行的基本过程"><a href="#程序执行的基本过程" class="headerlink" title="程序执行的基本过程"></a>程序执行的基本过程</h4><p>下面我们看看程序是如何在冯诺依曼模型上执行的。</p><p><strong>程序实际上就是一条一条的指令的集合</strong>，所以程序的执行过程其实就是把每一条指令一步一步地执行起来，负责执行指令的就是 CPU 了。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210202149351.png" alt="img"></p><p>CPU 执行程序的过程如下：</p><ul><li>第一步：CPU 读取「程序计数器」的值，这个值是指令的<strong>内存地址</strong>，然后 CPU 的<strong>「控制单元」</strong>操作<strong>「地址总线」</strong>指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过<strong>「数据总线」</strong>将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到<strong>「指令寄存器」</strong>。</li><li>第二步，CPU 分析<strong>「指令寄存器」</strong>中的指令，确定指令的类型和参数，如果是计算类型的指令，就把指令交给<strong>「逻辑运算单元」</strong>运算；如果是存储类型的指令，则交由<strong>「控制单元」</strong>执行；</li><li>第三步，CPU 执行完指令后，<strong>「程序计数器」</strong>的值<strong>自增</strong>，表示<strong>指向下一条指令</strong>。这个自增的大小，由 <strong>CPU 的位宽</strong>决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此<strong>「程序计数器」</strong>的值会自增 4；</li></ul><blockquote><p>流程可以简单地描述为：一个程序执行的时候，CPU 会根据程序计数器里面的内存地址，把内存里面需要执行的指令读取到指令寄存器里面执行，然后根据指令长度增长，程序计数器自增指向下一条执行的指令的内存地址，开始顺序读取下一条指令。</p></blockquote><p>CPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为 <strong>CPU 的指令周期</strong>。</p><h4 id="a-x3D-1-2-执行具体过程"><a href="#a-x3D-1-2-执行具体过程" class="headerlink" title="a &#x3D; 1 + 2 执行具体过程"></a>a &#x3D; 1 + 2 执行具体过程</h4><p>知道了基本的程序执行过程后，接下来用 <code>a = 1 + 2</code> 的作为例子，进一步分析该程序在冯诺伊曼模型的执行过程。</p><p>CPU 是不认识 <code>a = 1 + 2</code> 这个字符串，这些字符串只是方便我们程序员认识，要想这段程序能跑起来，还需要把整个程序翻译成<strong>汇编语言</strong>的程序，这个过程称为编译成汇编代码。</p><p><strong>针对汇编代码，我们还需要用汇编器翻译成机器码</strong>，这些机器码由 0 和 1 组成的机器语言，这一条条机器码，就是一条条的<strong>计算机指令</strong>，这个才是 CPU 能够真正认识的东西。</p><p>下面来看看 <code>a = 1 + 2</code> 在 32 位 CPU 的执行过程。</p><p>程序编译过程中，编译器通过分析代码，发现 1 和 2 是数据，于是程序运行时，内存会有个专门的区域来存放这些数据，这个区域就是<strong>「数据段」</strong>。如下图，数据 1 和 2 的区域位置：</p><ul><li>数据 1 被存放到 <code>0x100</code> 位置；</li><li>数据 2 被存放到 <code>0x104</code> 位置；</li></ul><p>注意，<strong>数据和指令是分开区域存放的，存放指令区域的地方称为「正文段」。</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210202207577.png" alt="img"></p><p>编译器会把 <code>a = 1 + 2</code> 翻译成 4 条指令，存放到正文段中。如图，这 4 条指令被存放到了 <code>0x200</code> ~ <code>0x20c</code> 的区域中：</p><ul><li><code>0x200</code> 的内容是 <code>load</code> 指令将 <code>0x100</code> 地址中的数据 1 装入到寄存器 <code>R0</code>；</li><li><code>0x204</code> 的内容是 <code>load</code> 指令将 <code>0x104</code> 地址中的数据 2 装入到寄存器 <code>R1</code>；</li><li><code>0x208</code> 的内容是 <code>add</code> 指令将寄存器 <code>R0</code> 和 <code>R1</code> 的数据相加，并把结果存放到寄存器 <code>R2</code>；</li><li><code>0x20c</code> 的内容是 <code>store</code> 指令将寄存器 <code>R2</code> 中的数据存回数据段中的 <code>0x108</code> 地址中，这个地址也就是变量 <code>a</code> 内存中的地址；</li></ul><p>编译完成后，具体执行程序的时候，程序计数器会被设置为 <code>0x200</code> 地址，然后依次执行这 4 条指令。</p><p>上面的例子中，由于是在 32 位 CPU 执行的，因此一条指令是占 32 位大小，所以你会发现每条指令间隔 4 个字节。（单字长指令 &#x3D; 机器字长 &#x3D; <strong>计算机能直接处理的二进制数据的位数。机器字长通常与主存单元的位数一致</strong>。）</p><p>而数据的大小是根据你在程序中指定的变量类型，比如 <code>int</code> 类型的数据则占 4 个字节，<code>char</code> 类型的数据则占 1 个字节。</p><h2 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><p>计算机是由这种外部硬件设备组成的，比如内存、CPU、硬盘等，如果每个应用都要和这些硬件对接通信协议，那这样太累了，所以这个中间人就由内核来充当，<strong>让内核作为应用连接硬件设备的桥梁</strong>，应用程序只需要关心与内核的交互，不用关心硬件的细节。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210250021743.png" alt="内核"></p><h4 id="内核的能力"><a href="#内核的能力" class="headerlink" title="内核的能力"></a>内核的能力</h4><p>现代的操作系统，内核一般会提供 4 个基本能力：</p><ul><li>管理进程、线程，决定那个进程、线程使用 CPU，也就是<strong>进程调度</strong>的能力；</li><li>内存管理，决定内存的分配与回收，也就是<strong>内存管理</strong>的能力；</li><li>管理硬件设备，为进程与硬件设备之间提供通信能力，也就是<strong>硬件通信</strong>能力。</li><li><strong>提供系统调用</strong>，如果应用程序要运行更高权限的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。</li></ul><h4 id="内核怎样工作"><a href="#内核怎样工作" class="headerlink" title="内核怎样工作"></a>内核怎样工作</h4><p>内核具有很高的权限，可以控制 CPU、内存等硬件，而用户层面的应用程序具有操作系统的权限很小，因此多少操作系统，会把内存分为<strong>内核空间和用户空间</strong></p><ul><li>内核空间：这个内存空间<strong>只有</strong>内核程序可以访问；</li><li>用户空间：这个内存空间<strong>专门</strong>给应用程序使用；</li></ul><blockquote><p>用户空间的代码只能访问一个局部的内存空间，而内核空间的代码可以访问<strong>所有内存空间</strong>。因此当程序使用用户空间时，常指该程序在<strong>用户态</strong>执行，而当程序使用内核空间时，程序则在<strong>内核态</strong>执行。</p></blockquote><p>应用程序需要进入内核空间，就需要通过系统调用，下面来看看系统调用的过程：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210250035284.png" alt="img"></p><blockquote><p>内核程序执行在内核态，用户程序执行在内核态。<strong>当应用程序使用系统调用，会产生一个中断</strong>。发生中断后，CPU 会中断当前在执行的应用程序，转而跳转到中断处理程序，也就是开始执行内核程序。<strong>内核处理完后，主动触发中断</strong>，把 CPU 执行权限交回给应用程序，回到用户态继续工作。</p></blockquote><h3 id="Linux-的设计"><a href="#Linux-的设计" class="headerlink" title="Linux 的设计"></a>Linux 的设计</h3><p>Linux 内核设计的理念主要有这么几点：</p><ul><li><em><strong>MultiTask</strong></em>：多任务</li><li><em><strong>SMP</strong></em>：对称多处理</li><li><em><strong>ELF</strong></em>：可执行文件链接格式</li><li><em><strong>Monolithic Kernel</strong></em>：宏内核</li></ul><h4 id="MultiTask-多任务"><a href="#MultiTask-多任务" class="headerlink" title="MultiTask 多任务"></a>MultiTask <strong>多任务</strong></h4><p>代表着 Linux 是一个多任务的操作系统。</p><p>多任务意味着可以同时有多个任务同时执行，这里的「同时」可以是并发或并行：</p><ul><li>对于单核 CPU 时，可以让每个任务执行一小段时间，时间到就切换到另外一个任务，从<strong>宏观</strong>角度看，<strong>一段时间</strong>内执行了多个任务，这被称为<strong>并发</strong>。</li><li>对于多核 CPU 时，多个任务可以<strong>同一时刻</strong>被不同核心的 CPU 同时执行，这被称为<strong>并行</strong>。</li></ul><h4 id="SMP-对称多处理"><a href="#SMP-对称多处理" class="headerlink" title="SMP 对称多处理"></a>SMP 对称多处理</h4><p>对称多处理，代表着每个 CPU 的地位是<strong>相等</strong>的，对资源的<strong>使用权限</strong>也是<strong>相同</strong>的，多个 CPU 共享一个内存，每个 CPU 都可以访问完整的内存和硬件资源。</p><p>这个特点决定了 Linux 操作系统<strong>不会</strong>有某个 CPU 单独服务应用程序或内核程序，而是每个程序都可以被分配到任意一个 CPU 上被执行。</p><h4 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h4><p>ELF 意思是可执行文件链接格式，它是 Linux 操作系统中可执行文件的存储格式。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8/Elf.png" alt="ELF 文件格式"></p><p>ELF 把文件分成了一个个分段，每一个段都有自己的作用。</p><p>另外，ELF 文件有两种索引，Program header table 中记录了「运行时」所需的段，而 Section header table 记录了二进制文件中各个「段的首地址」。</p><p>那 ELF 文件怎么生成的呢？</p><p>我们编写的代码，首先通过「编译器」编译成汇编代码，接着通过「汇编器」变成目标代码，也就是目标文件，最后通过「链接器」把多个目标文件以及调用的各种函数库链接起来，形成一个可执行文件，也就是 ELF 文件。</p><p>那 ELF 文件是怎么被执行的呢？</p><p><strong>执行 ELF 文件的时候，会通过「装载器」把 ELF 文件装载到内存里，CPU 读取内存中的指令和数据，于是程序就被执行起来了。</strong></p><h4 id="Monolithic-Kernel"><a href="#Monolithic-Kernel" class="headerlink" title="Monolithic Kernel"></a>Monolithic Kernel</h4><p><strong>宏内核</strong> ，Linux 内核架构就是宏内核，意味着 Linux 内核是一个<strong>完整的可执行程序</strong>，且拥有<strong>最高权限</strong>。</p><p>宏内核的特征是系统内核的所有模块，比如进程调度、内存管理、文件系统、设备驱动等，都运行在内核态。</p><p>Linux 也实现了动态加载内核模块的功能，例如大部分设备是以可加载模块的形式存在的，与内和其他模块解耦，让驱动开发和驱动加载更为方便、灵活。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/OS-structure2.png" alt="分别为宏内核、微内核、混合内核的操作系统结构"></p><p>与宏内核相反的是<strong>微内核</strong>，微内核架构的内核<strong>只保留最基本的能力，比如进程调度、虚拟机内存、中断等</strong>，把一些应用<strong>放到了用户空间，比如驱动程序、文件系统等</strong>。这样服务与服务之间是<strong>隔离</strong>的，单个服务出现故障或者完全攻击，也不会导致整个操作系统挂掉，提高了操作系统的稳定性和可靠性。</p><p>微内核内核功能少，可移植性高，相比宏内核有一点不好的地方在于，由于驱动程序不在内核中，而且驱动程序一般会频繁调用底层能力的，于是驱动和硬件设备交互就需要频繁切换到内核态，这样会带来<strong>性能损耗</strong>。华为的鸿蒙操作系统的内核架构就是微内核。</p><p>还有一种内核叫<strong>混合类型内核</strong>，它的架构有点像微内核，<strong>内核里面会有一个最小版本的内核</strong>，然后其他模块会在这个基础上搭建，然后实现的时候会跟宏内核类似，也就是把整个内核做成一个完整的程序，大部分服务都在内核中，这就像是宏内核的方式包裹着一个微内核。</p><h3 id="Windows-设计"><a href="#Windows-设计" class="headerlink" title="Windows 设计"></a>Windows 设计</h3><p>当今 Windows 7、Windows 10 使用的内核叫 Windows NT，NT 全称叫 New Technology。</p><p>结构图：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/windowNT.png" alt="Windows NT 的结构"></p><p>与 Linux 一样支持 <strong>MultiTask（多任务）</strong> 和 <strong>SMP（对称多处理）</strong>，但不同的是，<strong>Windows 的内核设计是混合型内核</strong>，上图中的 <em><strong>MicroKernel</strong></em> 模块，就是这个最小版本的内核，而整个内核实现是一个完成的可执行程序，含有非常多的模块。</p><p>Windows 的可执行文件的格式与 Linux 也不同，所以两个系统的可执行文件不能在对方的系统上运行。</p><p>Windows 的可执行文件格式叫 PE，称为<strong>可移植执行文件</strong>，拓展名如：<code>.exe</code>、<code>.dll</code>、<code>.sys</code> 等。</p><p>PE 结构：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/pe.png" alt="PE 文件结构"></p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="为什么要有虚拟内存？"><a href="#为什么要有虚拟内存？" class="headerlink" title="为什么要有虚拟内存？"></a>为什么要有虚拟内存？</h3><h4 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h4><p>对于单片机这样没有操作系统的，每次写完代码，都需要借助工具将程序烧录进去，这样程序才能跑起来。单片机的 CPU 是直接操作内存的<strong>「物理地址」</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/019f1f0d2d30469cbda2b8fe2cf5e622.png" alt="img"></p><p>这种情况下，如果程序占用的内存有叠加，要想同时运行两个程序是不可能的。</p><blockquote><p>例如：如果第一个程序在 2000 的位置写入一个新的值，将会擦除掉第二个程序存放在相同位置上的所有内容。</p></blockquote><p>所以同时运行两个程序根本行不通，这两个程序会立刻崩溃。</p><p>因此有了<strong>虚拟内存</strong>。每个进程分配独立的一套虚拟地址，互不干涉。（虚拟地址由操作系统负责映射到物理内存）</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/298fb68e3da94d767b02f2ed81ebf2c4.png" alt="进程的中间层"></p><p><strong>操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</strong></p><p>如果程序要访问虚拟地址的时候，由于操作系统会将虚拟地址映射到不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。</p><p>两种地址的概念：</p><ul><li>我们程序所使用的内存地址叫做<strong>虚拟内存地址</strong>（Virtual Memory Address）</li><li>实际存在硬件里面的空间地址叫做<strong>物理内存地址</strong>（Physical Memory Address）</li></ul><p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转变为物理地址，然后<strong>再通过物理地址访问内存</strong>。</p><blockquote><p>CPU 执行程序命令时：虚拟地址先通过 MMU 转变为实际的物理内存地址，然后再通过物理地址访问。</p></blockquote><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/72ab76ba697e470b8ceb14d5fc5688d9.png" alt="img"></p><p>操作系统通过<strong>内存分段</strong>和<strong>内存分页</strong>来管理虚拟地址和物理地址之间的映射关系。</p><h4 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h4><p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。<strong>不同的段是有不同的属性的，所以就用分段（<em>Segmentation</em>）的形式把这些段分离出来。</strong></p><p>分段机制下的虚拟地址由两部分组成，<strong>段选择因子</strong>和<strong>段内偏移量</strong>。</p><p>映射关系如图：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/a9ed979e2ed8414f9828767592aadc21.png" alt="img"></p><p>段选择因子和段内偏移量：</p><ul><li><strong>段选择因子</strong>保存在段寄存器里面。段选择子里面最重要的就是<strong>段号</strong>，用作段的索引。段表里面保存的是这个段的<strong>基地址、段的界限和特权等级</strong>等。段号用于再段表中查出段内标识符，标识符中就包含了这个段的信息。</li><li>虚拟地址中的段内偏移量应该位于 0 和 段界限之间，如果段内偏移量是合法的话，就将<strong>段基地址加上段内偏移量得到物理内存地址</strong>。</li></ul><blockquote><p>物理地址 &#x3D; 虚拟地址段选择因子-&gt;段内描述符-&gt;段基地址 + 段内偏移量</p></blockquote><p>虚拟地址通过段表与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个 段（分别为 栈、堆、数据、代码 四个段），每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址，如下图。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/c5e2ab63e6ee4c8db575f3c7c9c85962.png" alt="img"></p><blockquote><p>如果要访问段 3 中偏移量 500 的虚拟地址，我们可以计算出物理地址为，段 3 基地址 7000 + 偏移量 500 &#x3D; 7500。</p></blockquote><p>分段虽然解决了程序本身不需要关系具体的物理内存地址的问题，但它也有一些不足之处：</p><ul><li>第一个就是<strong>内存碎片</strong>的问题。</li><li>第二个就是<strong>内存交换效率低</strong>的问题。</li></ul><p>接下来，说说为什么会有这两个问题。</p><blockquote><p>我们先来看看，分段为什么会产生内存碎片的问题？</p></blockquote><p>我们来看看这样一个例子。假设有 1G 的物理内存，用户执行了多个程序，其中：</p><ul><li>游戏占用了 512MB 内存</li><li>浏览器占用了 128MB 内存</li><li>音乐占用了 256 MB 内存。</li></ul><p>这个时候，如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 &#x3D; 256MB。</p><p>如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/6142bc3c917e4a6298bdb62936e0d332.png" alt="img"></p><blockquote><p>内存分段会出现内存碎片吗？</p></blockquote><p>内存碎片主要分为，<strong>内部内存碎片</strong>和<strong>外部内存碎片</strong>。</p><p>内存分段管理可以做到段根据实际需求分配内存，所以有多少需求就分配多大的段，所以<strong>不会出现内部内存碎片</strong>。</p><p>但是由于每个段的长度不固定，所以多个段未必能恰好使用所有的内存空间，会产生了多个不连续的小物理内存，导致新的程序无法被装载，所以<strong>会出现外部内存碎片</strong>的问题。（如上图类似）</p><p>解决「外部内存碎片」的问题就是<strong>内存交换</strong>。</p><blockquote><p>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</p></blockquote><p>这个内存交换空间，在 Linux 系统里，也就是我们常看到的 <strong>Swap</strong> 空间，这块空间是从硬盘划分出来的，<strong>用于内存与硬盘的空间交换</strong>。</p><blockquote><p>再来看看，分段为什么会导致内存交换效率低的问题？</p></blockquote><p>对于多进程的系统来说，用分段的方式，外部内存碎片是很容易产生的，产生了外部内存碎片，那不得不重新 <code>Swap</code> 内存区域，这个过程会产生性能瓶颈。</p><p><strong>因为硬盘的访问速度要比内存慢太多了</strong>，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。</p><p>所以，<strong>如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</strong></p><p>为了解决内存分段的<strong>「外部内存碎片和内存交换效率低」</strong>的问题，就出现了<strong>内存分页</strong>。</p><h4 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h4><p>上述我们已经讨论了分段的好处是能够产生连续的空间，但是会出现<strong>「外部内存碎片和内存交换的空间太大」</strong>的问题。</p><p><strong>内存分页</strong>可以使内存碎片出现的更少，另外，当需要进行内存交换的时候，让需要交换写入或者从磁盘预装的数据更少一点。</p><p><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（<em>Page</em>）。在 Linux 下，每一页的大小为 <code>4KB</code>。</p><p>虚拟地址与物理地址之间通过页表来映射，如图：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/08a8e315fedc4a858060db5cb4a654af.png" alt="img"></p><p>页表是存储在<strong>内存</strong>里的，<strong>内存管理单元</strong>（<em>MMU</em>）就做将虚拟内存地址转换为物理地址的工作。</p><blockquote><p>当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>，进入系统<strong>内核空间</strong>分配物理内存、更新页表，最后再返回用户空间，恢复进程的运行。</p></blockquote><hr><h5 id="分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？"><a href="#分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？" class="headerlink" title="分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？"></a>分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？</h5><p>内存分页由于内存空间都是预先分配好的，也就不会像内存分段一样，在段与段之间产生间隙非常小的内存，这正是分段会产生外部碎片的原因，而<strong>采用了分页，页与页之间是紧密排列的，所以不会有外部碎片。</strong></p><p>但，由于内存分页机制分配内存的最小单位是一页，即使程序不足一页大小，我们还是最少只能分配一页所以会出现内存浪费的情况，所以<strong>内存分页会有内部内存碎片</strong>的情况。</p><blockquote><p>内存交换：如果内存空间不够，操作系统会把其他正在运行的进程中<strong>「最近没被使用」</strong>的内存页面给释放掉，将其暂时写入硬盘，称之为<strong>换出（Swap Out）</strong>。一旦需要的时候，再加载进来，成为<strong>换入（Swap In）</strong>。</p></blockquote><p>针对内存分页的内存交换，一次性写入磁盘的也只有少数的一个页或者几个页，<strong>相较于分段内存每次交换都是交换内存较大的段而言效率很高。</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/388a29f45fe947e5a49240e4eff13538.png" alt="img"></p><blockquote><p>更进一步的，分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页都加载到物理内存里，而是<strong>只在有程序运行中，需要用到对应的内存页里面的指令和数据时，再加载到物理内存里面去。</strong></p></blockquote><hr><h5 id="分页机制下，虚拟地址和物理地址如何映射的？"><a href="#分页机制下，虚拟地址和物理地址如何映射的？" class="headerlink" title="分页机制下，虚拟地址和物理地址如何映射的？"></a>分页机制下，虚拟地址和物理地址如何映射的？</h5><p>先看下面的图：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/7884f4d8db4949f7a5bb4bbd0f452609.png" alt="img"></p><p>在分页机制下，虚拟地址可以分为两个部分，<strong>页号和页内偏移</strong>。也好作为页表的索引，页表包含物理页每页所在物理内存的基地址，<strong>这个基地址与页内偏移组成就形成了物理内存地址。</strong></p><blockquote><p>内存地址转换三大步：</p><ul><li>把虚拟内存地址，切分为页号和偏移量；</li><li>根据页号，从页表里面，查询对应的物理页号；</li><li>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/8f187878c809414ca2486b0b71e8880e.png" alt="img"></p></blockquote><hr><h5 id="简单分页的缺陷"><a href="#简单分页的缺陷" class="headerlink" title="简单分页的缺陷"></a>简单分页的缺陷</h5><p>上述这种分页是简单的分页，有空间上的缺陷。</p><blockquote><p>每个进程都有自己的页表，存放在内存里。</p></blockquote><p>因为操作系统是可以同时运行非常多的进程的，那这不就意味着页表会非常的庞大。</p><blockquote><p>例如：在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 <code>4MB</code> 的内存来存储页表。</p><p>这 4MB 大小的页表，看起来也不是很大。<strong>但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。</strong></p><p>那么，<code>100</code> 个进程的话，就需要 <code>400MB</code> 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。</p></blockquote><h4 id="多级分页"><a href="#多级分页" class="headerlink" title="多级分页"></a>多级分页</h4><p>为了解决简单分页上空间上的缺陷，就需要采用一种叫做<strong>多级页表（Multi-Level Page Table）</strong>的解决方案了。</p><p>根据前面对于简单页表的缺陷分析，我们知道如果运行100个进程，那么一个进程的页表需要装下 100 多万个「页表项」，并且每个页表项是占用 4 字节大小的，于是相当于每个页表需占用 4MB 大小的空间。</p><p>我们把这个 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 <code>1024</code> 个页表（二级页表），每个表（二级页表）中包含 <code>1024</code> 个「页表项」，形成<strong>二级分页</strong>。如下图所示：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/19296e249b2240c29f9c52be70f611d5.png"></p><blockquote><p>你可能会问，分了二级表，映射 4GB 地址空间就需要 4KB（一级页表）+ 4MB（二级页表）的内存，这样占用空间不是更大了吗？</p></blockquote><p>当然如果 4GB 的虚拟地址全部都映射到了物理内存上的话，二级分页占用空间确实是更大了，但是，我们往往不会为一个进程分配那么多内存。</p><p>其实我们应该换个角度来看问题，还记得计算机组成原理里面无处不在的<strong>局部性原理</strong>么？</p><p>每个进程都有 4GB 的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到 4GB，因为会存在部分对应的页表项都是空的，根本没有分配，对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存。</p><p>如果使用了二级分页，一级页表就可以覆盖整个 4GB 虚拟地址空间，但<strong>如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表</strong>。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）&#x3D; <code>0.804MB</code>，这对比单级页表的 <code>4MB</code> 是不是一个巨大的节约？</p><p>那么为什么不分级的页表就做不到这样节约内存呢？</p><p>我们从页表的性质来看，保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址。假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。所以<strong>页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项</strong>（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。</p><p>我们把二级分页再推广到多级页表，就会发现页表占用的内存空间更少了，这一切都要归功于对局部性原理的充分应用。</p><blockquote><p>在一级页表中只有20%被用到了，在二级页表中也只有20%被用到了，在三级页表中。。。。。这样依次类推就是多级页表内存空间占用更少的原因。</p></blockquote><p>对于 64 位的系统，两级分页肯定不够了，就变成了四级目录，分别是：</p><ul><li>全局页目录项 PGD（<em>Page Global Directory</em>）；</li><li>上层页目录项 PUD（<em>Page Upper Directory</em>）；</li><li>中间页目录项 PMD（<em>Page Middle Directory</em>）；</li><li>页表项 PTE（<em>Page Table Entry</em>）；</li><li><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9B%9B%E7%BA%A7%E5%88%86%E9%A1%B5.png" alt="img"></li></ul><h4 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h4><p>多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销。</p><p><strong>程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/edce58534d9342ff89f5261b1929c754.png"></p><p>我们就可以利用这一特性，把<strong>最常访问的几个页表项存储到访问速度更快的硬件</strong>，于是计算机科学家们，就在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 <strong>TLB（<em>Translation Lookaside Buffer</em>）</strong> ，通常称为页表缓存、转址旁路缓存、快表等。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/a3cdf27646b24614a64cfc5d7ccffa35.png" alt="img"></p><p>在 CPU 芯片里面，封装了内存管理单元（<em>Memory Management Unit</em>）芯片，它用来完成地址转换和 TLB 的访问与交互。</p><p><strong>有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。</strong></p><p><strong>TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个。</strong></p><hr><h4 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h4><p>内存分段和内存分页是可以组合在一起使用的，通常称这种组合为<strong>段页式内存管理</strong>。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/f19ebd6f70f84083b0d87cc5e9dea8e3.png" alt="img"></p><p>段页式内存管理实现的方式：</p><ul><li><strong>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；</strong></li><li><strong>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；</strong></li></ul><p>这样，地址结构就由<strong>段号、段内页号和页内位移</strong>三部分组成。</p><p>用于段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号，如图所示：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/8904fb89ae0c49c4b0f2f7b5a0a7b099.png" alt="img"></p><blockquote><p>段页式地址变换中要得到物理地址需要经过三次内存访问：</p><ul><li>第一次访问段表，得到页表其实位置</li><li>第二次访问页表，得到物理页号</li><li>第三次将物理页号与页内位移组合，得到物理地址。</li></ul><p><strong>可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但提高了内存的利用率。</strong></p></blockquote><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>虚拟内存的作用：</p><ul><li>第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。</li><li>第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。</li><li>第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。</li></ul><hr><h3 id="系统内存紧张时，会发生什么？"><a href="#系统内存紧张时，会发生什么？" class="headerlink" title="系统内存紧张时，会发生什么？"></a><strong>系统内存紧张时，会发生什么？</strong></h3><blockquote><p>当应用程序通过 <code>malloc</code> 函数申请内存时，实际上申请的是虚拟内存，此时并不会分配物理内存。</p></blockquote><p>当应用程序读写了这块虚拟内存，CPU 就会去访问这个虚拟内存，这时会发现这个虚拟内存没有映射到物理内存，CPU 就会产生<strong>缺页中断</strong>，进程会从用户态切换到内核态，并将缺页交给内核的 <strong>Page Fault Handler （缺页中断函数）</strong>处理。</p><p>缺页中断函数，会判断当前是否还有空闲的物理内存，如果有，直接分配，并建立与虚拟内存与物理内存之间的关系。</p><p>如果没有，那么内核就会开始进行内存回收的工作，回收的方式主要有两种：<strong>直接内存回收和后台内存回收。</strong></p><ul><li><strong>后台内存回收</strong>（<code>kswapd</code>）：在物理内存紧张的时候，会唤醒 <code>kswapd</code> 内核线程来回收内存，这个回收内存的过程<strong>异步</strong>的，不会阻塞进程的执行。</li><li><strong>直接内存回收</strong>（<code>direct reclaim</code>）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是<strong>同步</strong>的，会阻塞进程的执行。</li></ul><blockquote><p>这里的阻塞是针对申请内存的进程</p></blockquote><p>如果<strong>直接内存回收后</strong>，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了 ——<strong>触发 OOM （Out of Memory）机制</strong>。</p><p><strong>机制讲解</strong>：OOM Killer 机制会根据算法选择一个<strong>占用物理内存较高</strong>的进程，然后将其杀死，以便释放内存资源，<strong>如果物理内存依然不足</strong>，OOM Killer 会<strong>继续</strong>杀死占用物理内存较高的进程，直到释放足够的内存位置。</p><blockquote><p>优先级：后台内存回收 &gt; 直接内存回收 &gt; OOM 机制</p></blockquote><p>申请物理内存的过程如下图：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/2f61b0822b3c4a359f99770231981b07.png" alt="img"></p><h4 id="那些内存可以被回收？"><a href="#那些内存可以被回收？" class="headerlink" title="那些内存可以被回收？"></a>那些内存可以被回收？</h4><p>主要有两类可以被回收，它们的回收方式也不同。</p><ul><li><strong>文件页</strong>（File-backed Page）：<strong>内核缓存的磁盘数据（Buffer）和内核缓存的文件数据（Cache）都叫作文件页</strong>。大部分文件页，都可以直接释放内存，以后有需要时，再从磁盘重新读取就可以了。而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放。所以，<strong>回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存</strong>。</li><li><strong>匿名页</strong>（Anonymous Page）：这部分内存没有实际载体，不像文件缓存有硬盘文件这样一个载体，比如<strong>堆、栈数据</strong>等。这部分内存很可能还要再次被访问，所以不能直接释放内存，它们<strong>回收的方式是通过 Linux 的 Swap 机制</strong>，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。</li></ul><p>文件页和匿名页的回收都是基于 LRU 算法，也就是<strong>优先回收不常访问的内存</strong>。LRU 回收算法，实际上维护着 active 和 inactive 两个双向链表，其中：</p><ul><li><strong>active_list</strong> 活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页；</li><li><strong>inactive_list</strong> 不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页；</li></ul><p><strong>越接近链表尾部，就表示内存页越不常访问</strong>。这样，在回收内存时，系统就可以根据活跃程度，优先回收不活跃的内存。</p><p><strong>活跃和非活跃的内存页，按照类型的不同，又分别分为文件页和匿名页。</strong>可以从 &#x2F;proc&#x2F;meminfo 中，查询它们的大小，比如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">grep表示只保留包含active的指标（忽略大小写）</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">sort</span>表示按照字母顺序排序</span></span><br><span class="line">[root@xiaolin ~]# cat /proc/meminfo | grep -i active | sort</span><br><span class="line">Active:           901456 kB</span><br><span class="line">Active(anon):     227252 kB</span><br><span class="line">Active(file):     674204 kB</span><br><span class="line">Inactive:         226232 kB</span><br><span class="line">Inactive(anon):    41948 kB</span><br><span class="line">Inactive(file):   184284 kB</span><br></pre></td></tr></table></figure><h4 id="回收带来的性能影响"><a href="#回收带来的性能影响" class="headerlink" title="回收带来的性能影响"></a>回收带来的性能影响</h4><p>根据回收机制来说：</p><ul><li>后台内存回收，唤醒 kswaped 内核线程，这种方式是异步回收，不会阻塞进程，性能较好。</li><li>直接内存回收，这种方式是同步回收的，会阻塞进程，这样就会造成很长时间的延迟，以及系统 CPU 利用率会升高，最终引起系统负荷飙高。</li></ul><p>根据可被回收的内存类型来说：</p><ul><li>文件页的回收：对于干净页是直接释放内存，这个操作不会影响性能，而对于脏页会先写到磁盘再释放内存，这个操作会发生磁盘 I&#x2F;O 的，所以脏页的回收是会影响系统性能的。</li><li>匿名页的回收：如果开启了 Swap 机制，那么 Swap 机制会将不常访问的匿名页换出到磁盘中，下次访问时，再从磁盘换出到内存中，这个操作是会影响系统性能的（磁盘 I&#x2F;O）。</li></ul><p>可以看到，回收内存的操作基本都会发生磁盘 I&#x2F;O 的，如果回收内存的操作很频繁，意味着磁盘 I&#x2F;O 次数会很多，这个过程势必会影响系统的性能。</p><p>既然频繁的内存回收会影响性能，那下面介绍几个常见的解决方式。</p><h5 id="调整文件页和匿名页的回收倾向"><a href="#调整文件页和匿名页的回收倾向" class="headerlink" title="调整文件页和匿名页的回收倾向"></a>调整文件页和匿名页的回收倾向</h5><p>从上述性能分析来看，文件页的回收操作对系统的影响相比匿名页的回收操作会少一点，因为文件页对于干净页来看是不会发生磁盘 I&#x2F;O，而匿名页的 Swap 换入换出这两个操作都会发生磁盘 I&#x2F;O。</p><p>Linux 提供了一个 <code>/proc/sys/vm/swappiness</code> 选项，用来调整文件页和匿名页的回收倾向。</p><p>swappiness 的范围是 0-100，数值越大，越积极使用 Swap，也就是更倾向于回收匿名页；数值越小，越消极使用 Swap，也就是更倾向于回收文件页。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@xiaolin ~]# cat /proc/sys/vm/swappiness</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>一般建议 swappiness 设置为 0（默认值是 60），这样在回收内存的时候，<strong>会更倾向于文件页的回收，但是并不代表不会回收匿名页。</strong></p><hr><h5 id="尽早触发-kswapd-内核线程异步回收内存"><a href="#尽早触发-kswapd-内核线程异步回收内存" class="headerlink" title="尽早触发 kswapd 内核线程异步回收内存"></a>尽早触发 kswapd 内核线程异步回收内存</h5><blockquote><p>如何查看系统的直接内存回收和后台内存回收的指标？</p></blockquote><p>我们可以使用 <code>sar -B 1</code> 来观察：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20221105174012664.png" alt="image-20221105174012664"></p><blockquote><p>如果输入命令后 <code>not found commnd!</code> , 可能是系统没有安装这个工具，centOS 下 sar 工具命令为 :</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">CentOS</span></span><br><span class="line">yum install sysstat</span><br></pre></td></tr></table></figure></blockquote><p>图中红色框住的就是后台内存回收和直接内存回收的指标，它们分别表示：</p><ul><li><strong>pgscank&#x2F;s : kswapd(后台回收线程) 每秒扫描的 page 个数。</strong></li><li><strong>pgscand&#x2F;s: 应用程序在内存申请过程中每秒直接扫描的 page 个数。</strong></li><li><strong>pgsteal&#x2F;s: 扫描的 page 中每秒被回收的个数（pgscank+pgscand）。</strong></li></ul><blockquote><p>如果系统时不时发生抖动，并且在抖动的时间段里如果通过 sar -B 观察到 pgscand 数值很大，那大概率是因为「直接内存回收」导致的。</p><p>针对这个问题，解决的办法就是，<strong>可以通过尽早的触发「后台内存回收」来避免应用程序进行直接内存回收。</strong></p></blockquote><blockquote><p>什么条件下才能触发 kswapd 内核线程回收内存呢？</p></blockquote><p>内核定义了三个内存阈值（watermark，也称为水位），用来衡量当前剩余内存（pages_free）是否充裕或者紧张，分别是：</p><ul><li><strong>页最小阈值（pages_min）；</strong></li><li><strong>页低阈值（pages_low）；</strong></li><li><strong>页高阈值（pages_high）；</strong></li></ul><p>这三个内存阈值会划分为四种内存使用情况，如下图：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/166bc9f5b7c545d89f1e36ab8dd772cf.png" alt="img"></p><p>kswapd 会定期扫描内存的使用情况，根据剩余内存（pages_free）的情况来进行内存回收的工作。</p><ul><li>图中绿色部分：如果剩余内存（pages_free）大于 页高阈值（pages_high），说明剩余内存是充足的；</li><li>图中蓝色部分：如果剩余内存（pages_free）在页高阈值（pages_high）和页低阈值（pages_low）之间，说明内存有一定压力，但还可以满足应用程序申请内存的请求；</li><li>图中橙色部分：如果剩余内存（pages_free）在页低阈值（pages_low）和页最小阈值（pages_min）之间，说明内存压力比较大，剩余内存不多了。<strong>这时 kswapd0 会执行内存回收，直到剩余内存大于高阈值（pages_high）为止</strong>。虽然会触发内存回收，但是不会阻塞应用程序，因为两者关系是异步的。</li><li>图中红色部分：如果剩余内存（pages_free）小于页最小阈值（pages_min），说明用户可用内存都耗尽了，此时就会<strong>触发直接内存回收</strong>，这时应用程序就会被阻塞，因为两者关系是同步的。</li></ul><p>可以看到，当<strong>剩余内存页（pages_free） 小于页低阈值（pages_lows）</strong>，就会触发 kswapd 进行后台回收，然后 kswapd 会<strong>一直回收到剩余内存页（pages_free）大于页高阈值（pages_high）</strong>。</p><p>也就是说 kswapd 的活动空间只有 pages_low 与 pages_min 之间的这段区域，如果剩余内存低于了 pages_min 会触发直接内存回收，高于了 pages_high 又不会唤醒 kswapd。</p><p>页低阈值（pages_low）可以通过内核选项 <code>/proc/sys/vm/min_free_kbytes</code> （该参数代表系统所保留空闲内存的最低限）来间接设置。</p><p>min_free_kbytes 虽然设置的是页最小阈值（pages_min），但是页高阈值（pages_high）和页低阈值（pages_low）都是根据页最小阈值（pages_min）计算生成的，它们之间的计算关系如下：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pages_min = min_free_kbytes</span><br><span class="line">pages_low = pages_min*5/4</span><br><span class="line">pages_high = pages_min*3/2</span><br></pre></td></tr></table></figure><p>如果系统时不时发生抖动，并且通过 sar -B 观察到 pgscand 数值很大，那大概率是因为直接内存回收导致的，这时可以<strong>增大 min_free_kbytes 这个配置选项来及早地触发后台回收</strong>，然后继续观察 pgscand 是否会降为 0。</p><p><strong>增大了 min_free_kbytes 配置后</strong>，这会使得系统预留过多的空闲内存，从而在一定程度上降低了应用程序可使用的内存量，这在<strong>一定程度上浪费了内存</strong>。<strong>极端情况下设置 min_free_kbytes 接近实际物理内存大小时</strong>，留给应用程序的内存就会太少而<strong>可能会频繁地导致 OOM 的发生</strong>。</p><p><strong>所以在调整 min_free_kbytes 之前，需要先思考一下，应用程序更加关注什么，如果关注延迟那就适当地增大 min_free_kbytes，如果关注内存的使用量那就适当地调小 min_free_kbytes。</strong></p><hr><h5 id="NUMA-架构下的内存回收策略"><a href="#NUMA-架构下的内存回收策略" class="headerlink" title="NUMA 架构下的内存回收策略"></a>NUMA 架构下的内存回收策略</h5><blockquote><p>什么是 NUMA 架构？</p><p>SMP 指的是一种<strong>多个 CPU 处理器共享资源的电脑硬件架构</strong>，也就是说每个 CPU 地位平等，它们共享相同的物理资源，包括总线、内存、IO、操作系统等。每个 CPU 访问内存所用时间都是相同的，因此，这种系统也被称为一致存储访问结构（UMA，Uniform Memory Access）。</p><p>随着 CPU 处理器核数的增多，多个 CPU 都通过一个总线访问内存，这样总线的带宽压力会越来越大，同时每个 CPU 可用带宽会减少，这也就是 SMP 架构的问题。</p></blockquote><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/feec409868070d8cd79aecad2895b531.png" alt="SMP 与 NUMA 架构"></p><p>为了解决 SMP 架构的问题，就研制出了 NUMA 结构，即<strong>非一致存储访问结构（Non-uniform memory access，NUMA）。</strong></p><p>NUMA 架构将每个 CPU 进行了分组，每一组 CPU 用 Node 来表示，一个 Node 可能包含多个 CPU 。</p><p><strong>每个 Node 有自己独立的资源，包括内存、IO 等</strong>，每个 Node 之间可以通过互联模块总线（QPI）进行通信，所以，也就意味着每个 Node 上的 CPU 都可以访问到整个系统中的所有内存。但是，访问远端 Node 的内存比访问本地内存要耗时很多。</p><blockquote><p>NUMA 架构跟回收内存有什么关系？</p></blockquote><p>在 NUMA 架构下，当某个 Node 内存不足时，系统可以从其他 Node 寻找空闲内存，也可以从本地内存中回收内存。</p><p>具体选哪种模式，可以通过 &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;zone_reclaim_mode 来控制。它支持以下几个选项：</p><ul><li>0 （默认值）：在回收本地内存之前，在其他 Node 寻找空闲内存；</li><li>1：只回收本地内存；</li><li>2：只回收本地内存，在本地回收内存时，可以将文件页中的脏页写回硬盘，以回收内存。</li><li>4：只回收本地内存，在本地回收内存时，可以用 swap 方式回收内存。</li></ul><p>在使用 NUMA 架构的服务器，如果系统出现还有一半内存的时候，却发现系统频繁触发「直接内存回收」，导致了影响了系统性能，那么大概率是因为 zone_reclaim_mode 没有设置为 0 ，导致当本地内存不足的时候，只选择回收本地内存的方式，而不去使用其他 Node 的空闲内存。</p><p>虽然说访问远端 Node 的内存比访问本地内存要耗时很多，但是相比内存回收的危害而言，访问远端 Node 的内存带来的性能影响还是比较小的。因此，<strong>zone_reclaim_mode 一般建议设置为 0。</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20221105181039326.png" alt="image-20221105181039326"></p><h4 id="如何保护一个进程不被-OOM-杀掉呢"><a href="#如何保护一个进程不被-OOM-杀掉呢" class="headerlink" title="如何保护一个进程不被 OOM 杀掉呢"></a>如何保护一个进程不被 OOM 杀掉呢</h4><p>在系统空闲内存不足的情况，进程申请了 一个很大的内存，如果直接回收都无法回收出足够大的内存，那么就会会触发 <code>OOM</code> 机制，内核就会根据算法选择一个进程杀掉（可能和手机系统的杀后台差不多）。</p><p>这就要提到一个在 Linux 内核里有一个 <code>oom_badness()</code> 函数，它会把系统中可以被杀掉的进程扫描一遍，并对每个进程打分，得分最高的进程就会被首先杀掉。</p><p>进程得分的结果受下面这两个方面影响：</p><ul><li>第一，进程已经使用的物理内存页面数。</li><li>第二，每个进程的 <code>OOM</code> 校准值 <code>oom_score_adj</code>。它是可以通过 <code>/proc/[pid]/oom_score_adj</code> 来配置的。我们可以在设置 -1000 到 1000 之间的任意一个数值，调整进程被 <code>OOM</code> Kill 的几率。</li></ul><p>函数 <code>oom_badness()</code> 里的最终计算方法是这样的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// points 代表打分的结果</span></span><br><span class="line"><span class="comment">// process_pages 代表进程已经使用的物理内存页面数</span></span><br><span class="line"><span class="comment">// oom_score_adj 代表 OOM 校准值</span></span><br><span class="line"><span class="comment">// totalpages 代表系统总的可用页面数</span></span><br><span class="line">points = process_pages + oom_score_adj*totalpages/<span class="number">1000</span></span><br></pre></td></tr></table></figure><p><strong>用「系统总的可用页面数」乘以 「<code>OOM</code> 校准值 <code>oom_score_adj</code>」再除以 1000，最后再加上进程已经使用的物理页面数，计算出来的值越大，那么这个进程被 <code>OOM</code> Kill 的几率也就越大</strong>。</p><p>每个进程的 <code>oom_score_adj</code> 默认值都为 0，所以最终得分跟进程自身消耗的内存有关，消耗的内存越大越容易被杀掉。我们可以通过调整 <code>oom_score_adj</code> 的数值，来改成进程的得分结果：</p><ul><li>如果你不想某个进程被首先杀掉，那你可以调整该进程的 <code>oom_score_adj</code>，从而改变这个进程的得分结果，降低该进程被 <code>OOM</code> 杀死的概率。</li><li><strong>如果你想某个进程无论如何都不能被杀掉，那你可以将 <code>oom_score_adj</code> 配置为 -1000。</strong></li></ul><p>我们最好将一些很重要的系统服务的 <code>oom_score_adj</code> 配置为 -1000，比如 <code>sshd</code>，因为这些系统服务一旦被杀掉，我们就很难再登陆进系统了。</p><p><strong>注意</strong>：但是，不建议将我们自己的业务程序的 <code>oom_score_adj</code> 设置为 -1000，因为业务程序一旦发生了内存泄漏，而它又不能被杀掉，这就会导致随着它的内存开销变大，<code>OOM</code> killer 不停地被唤醒，从而把其他进程一个个给杀掉。</p><h3 id="在-4GB-物理内存的机器上，申请-8GB-内存会怎么样？"><a href="#在-4GB-物理内存的机器上，申请-8GB-内存会怎么样？" class="headerlink" title="在 4GB 物理内存的机器上，申请 8GB 内存会怎么样？"></a>在 4GB 物理内存的机器上，申请 8GB 内存会怎么样？</h3><p>讨论这个问题，需要在有前置条件下，不然说出答案是经不起推敲的。</p><p>这个问题需要讨论三个前置条件：</p><ul><li>操作系统是 32 位的，还是 64 位的？</li><li>申请完 8G 内存后会不会被使用？</li><li>操作系统有没有使用 Swap 机制？</li></ul><h4 id="操作系统虚拟内存大小"><a href="#操作系统虚拟内存大小" class="headerlink" title="操作系统虚拟内存大小"></a>操作系统虚拟内存大小</h4><p>32 位操作系统和 64 位操作系统的虚拟地址空间大小是不同的，在 Linux 操作系统中，虚拟地址空间的内部又被分为<strong>内核空间和用户空间</strong>两部分，如下所示：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/3a6cb4e3f27241d3b09b4766bb0b1124.png" alt="img"></p><p>通过这里可以看出：</p><ul><li><code>32</code> 位系统的内核空间占用 <code>1G</code>，位于最高处，剩下的 <code>3G</code> 是用户空间；</li><li><code>64</code> 位系统的内核空间和用户空间都是 <code>128T</code>，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。</li></ul><blockquote><p>在 32 位的操作系统上，进程最多只能分配 3 G 大小的虚拟内存空间，所以进程申请 8 GB 内存的话，在申请虚拟内存阶段就会失败。</p></blockquote><blockquote><p>对于 64 位操作系统，进程可以使用 128 TB 大小的虚拟内存空间，所以进程申请 8 GB 是没有问题的，因为进程申请内存是虚拟内存，只要不适用这个虚拟内存，操作系统就不会分配物理内存。</p></blockquote><h4 id="Swap-机制的作用"><a href="#Swap-机制的作用" class="headerlink" title="Swap 机制的作用"></a>Swap 机制的作用</h4><p>如果申请物理内存大小超过了空闲物理内存大小，就要看操作系统有没有开启 Swap 机制：</p><ul><li>如果没有开启 Swap 机制，程序就会直接 OOM；</li><li>如果有开启 Swap 机制，程序可以正常运行。</li></ul><blockquote><p>Swap 机制讲解：</p></blockquote><p><strong>当系统的物理内存不够用的时候</strong>，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，<strong>这些被释放的空间会被临时保存到磁盘，等到那些程序要运行时，再从磁盘中恢复保存的数据到内存中</strong>。</p><p>另外，<strong>当内存使用存在压力的时候</strong>，会开始触发内存回收行为，会<strong>把这些不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了</strong>。</p><p>这种。将内存数据换出到磁盘，又从磁盘中恢复数据到内存的过程，就是 Swap 机制负责的。</p><p>Swap 就是把一块磁盘空间或者本地文件，当成内存来使用，它包含<strong>换出</strong>和<strong>换入</strong>两个过程。</p><ul><li><strong>换出（Swap Out）</strong> ，是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存；</li><li><strong>换入（Swap In）</strong>，是在进程再次访问这些内存的时候，把它们从磁盘读到内存中来；</li></ul><p>如图：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/388a29f45fe947e5a49240e4eff13538.png" alt="img"></p><blockquote><p>使用 Swap 机制优点是，应用程序实际可用使用的内存空间将远远超过系统的物理内存。由于硬盘空间的价格远比内存低，这种方式无疑是经济实惠的。但频繁地读写磁盘会显著减低操作系统的运行速度，这也是 Swap 的弊端。</p></blockquote><p>Linux 中的 Swap 会在内存不足和内存闲置两种场景下触发：</p><ul><li><strong>内存不足：</strong>当系统需要的内存超过了可用的物理内存时，内核就会将内存中不常用的内存页<strong>换出</strong>到磁盘上为当前进程让出内存，保证了正在执行的进程的可用性，这个内存回收的过程是强制的<strong>直接内存回收（Direct Page Reclaim）</strong>。<strong>直接内存回收时同步的过程，会阻塞当前申请内存的进程。</strong></li><li><strong>内存闲置：</strong>应用程序在启动阶段使用的大量内存在启动后往往都不会使用，通过后台运行的守护进程（<code>kSwapd</code>），我们可以将这部分只使用一次的内存交换到磁盘上为其他内存的申请预留空间。<code>kSwapd</code> 是 Linux 负责页面置换（Page replacement）的守护进程，它也是负责交换闲置内存的主要进程，它会在<strong>空闲内存低于一定水位</strong> (opens new window)时，回收内存页中的空闲内存保证系统中的其他进程可以尽快获得申请的内存。**<code>kSwapd</code> 是后台进程，所以回收内存的过程是异步的，不会阻塞当前申请内存的进程。**</li></ul><p>Linux 提供了两种不同的方法启用 Swap，分别是 Swap 分区（Swap）和 Swap 文件（Swapfile），开启方法可以看<a href="https://support.huaweicloud.com/trouble-ecs/ecs_trouble_0322.html">这个资料</a>：</p><ul><li>Swap 分区是硬盘上的独立区域，该区域只会用于交换分区，其他的文件不能存储在该区域上，我们可以使用 <code>swapon -s</code> 命令查看当前系统上的交换分区；</li><li>Swap 文件是文件系统中的特殊文件，它与文件系统中的其他文件也没有太多的区别；</li></ul><blockquote><p>Swap 换入换出的是什么类型的内存？</p><p>内核缓存的文件数据， 因为都有对应的磁盘文件，所以在回收文件数据的时候，直接写回到对应文件就可以了。</p><p>但是像进程的堆，栈数据等，它们是没有实际载体的，这部分内存称为匿名页。而且这部分内存很可能还要再次被访问，所以不能直接释放内存，于是就需要有一个能保存匿名页的磁盘载体，这个载体就是 Swap 分区。</p><p>匿名页回收的方式是通过 Linux 的 Swap 机制，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。</p></blockquote><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li><p>在 32 位操作系统中，因为进程最大只能申请 3 GB 大小的虚拟内存，所以直接申请 8 GB 内存，会申请失败。</p></li><li><p>在 64 位操作系统中，因为进程最大能申请 128 TB 大小的虚拟内存，即使物理内存只有 4 GB，直接申请 8 GB 内存也是没有问题的，因为申请的内存是虚拟内存（如果没有被使用是不会为其真正分配物理内存的）。如果这块虚拟内存被访问了，要看系统有没有 Swap 分区：</p><ul><li>如果没有 Swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 <code>OOM</code>（内存溢出）。</li><li>如果由 Swap 分区，即使物理内存只有 4 GB，程序也能正常使用 8 GB 的内存，进程可以正常运行。</li></ul></li></ul><blockquote><p>什么是 <code>OOM</code>?</p></blockquote><p>内存溢出(Out Of Memory，简称<code>OOM</code>)是指<strong>应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存。此时程序就运行不了，系统会提示内存溢出。</strong></p><p>–</p><h3 id="如何避免预读失效和缓存污染问题？"><a href="#如何避免预读失效和缓存污染问题？" class="headerlink" title="如何避免预读失效和缓存污染问题？"></a>如何避免预读失效和缓存污染问题？</h3><blockquote><p><code>Redis</code> 的缓存淘汰算法则是通过<strong>实现 <code>LFU</code> 算法</strong>来避免<strong>「缓存污染」</strong>而导致缓存命中率下降的问题（<code>Redis</code> 没有预读机制）。</p><p><code>MySQL</code> 和 Linux 操作系统是通过<strong>改进 <code>LRU</code> 算法</strong>来避免<strong>「预读失效和缓存污染」</strong>而导致缓存命中率下降的问题。</p></blockquote><p>该模块主要说说 Linux 和 <code>Mysql</code> 是如何改进 <code>LRU</code> 算法的。</p><h4 id="Linux-和-Mysql-的缓存"><a href="#Linux-和-Mysql-的缓存" class="headerlink" title="Linux 和 Mysql 的缓存"></a>Linux 和 <code>Mysql</code> 的缓存</h4><p><strong>Linux 操作系统的缓存</strong></p><p>在应用程序读取文件的数据的时候，Linux 操作系统会对读取的文件进行缓存，会缓存在文件系统中的 <strong>Page Chche</strong>（如下图中的页缓存）：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png" alt="img"></p><p><strong>Page Cache</strong> 属于内存空间里的数据，由于内存访问比磁盘访问快很多，在下一次访问相同的数据就不需要磁盘 I&#x2F;O了，命中缓存直接返回数据即可。</p><p>因此，<strong>Page Cache（缓存）</strong> 起到了加速访问数据的作用。</p><p><strong><code>MySql</code> 的缓存</strong></p><p><code>MySql</code> 的数据是存储在磁盘里的，为了提升数据库的读写性能，<code>Innodb</code> 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，<strong>Buffer Pool 属于内存空间里的数据</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/%E7%BC%93%E5%86%B2%E6%B1%A0.drawio.png" alt="img"></p><p>有了缓冲池之后：</p><ul><li>当<strong>读取数据</strong>时，如果数据存储在 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li><li>当<strong>修改数据</strong>时，首先是修改 Buffer Pool 中的数据所在的页，然后将其设置为脏页，最后由后台线程将脏页写入到磁盘。</li></ul><hr><h4 id="传统-LRU-是如何管理内存数据的？"><a href="#传统-LRU-是如何管理内存数据的？" class="headerlink" title="传统 LRU 是如何管理内存数据的？"></a>传统 <code>LRU</code> 是如何管理内存数据的？</h4><p>无论是 Linux 的 <strong>Page Cache （缓存页）</strong>还是 <code>MySql</code> 的 <strong>Buffer Pool（缓冲池）</strong>，容量都是有限的，并不能无限地存放缓存数据，对于一些频繁访问的数据我们希望可以长时间（或一直）留在内存中，而一些很少访问的数据我们希望在某些时机可以淘汰掉，从而保证内存不会因为满了而导致无法再缓存新的数据，同时还能保证常用数据留在内存中。</p><p><strong><code>LRU</code>（Least recently used）算法</strong>，就可以实现上述机制。</p><p><code>LRU</code> 算法一般是用「链表」作为数据结构来实现的，<strong>链表头部的数据是最近使用的</strong>，而<strong>链表末尾的数据是最久没被使用的</strong>。那么，当空间不够了，就<strong>淘汰最久没被使用的节点</strong>，也就是链表末尾的数据，从而腾出内存空间。</p><p>因为 Linux 的 Page Cache 和 <code>MySQL</code> 的 Buffer Pool 缓存的<strong>基本数据单位都是页（Page）单位，所以后续以「页」名称代替「数据」</strong>。</p><blockquote><p><code>LRU</code> 算法原理</p><p>可以用一个特殊的栈来保存当前正在使用的各个页面的页面号。当一个新的进程访问某页面时，便将该页面号压入栈顶，其他的页面号往栈底移，如果内存不够，则将栈底的页面号移除。这样，栈顶始终是最新被访问的页面的编号，而栈底则是最近最久未访问的页面的页面号。</p><p>在一般标准的操作系统教材里，会用下面的方式来演示 <code>LRU</code> 原理，假设内存只能容纳3个页大小，按照 7 0 1 2 0 3 0 4 的次序访问页。假设内存按照栈的方式来描述访问时间，在上面的，是最近访问的，在下面的是，最远时间访问的，<code>LRU</code>就是这样工作的。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/20191109174241708.png" alt="在这里插入图片描述"></p></blockquote><p>传统的 <code>LRU</code> 算法的实现思路是这样的：</p><ul><li>当访问的页在内存里，就直接把该页对应的 <code>LRU</code> 链表节点移动到链表的头部。</li><li>当访问的页不在内存里，除了要把该页放入到 <code>LRU</code> 链表的头部，还要淘汰 <code>LRU</code> 链表末尾的页（如果满了的情况）。</li></ul><p>比如下图，假设 <code>LRU</code> 链表长度为 5，<code>LRU</code> 链表从左到右有编号为 1，2，3，4，5 的页。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/lru.png" alt="img"></p><p>如果访问了 3 号页，因为 3 号页已经在内存了，所以把 3 号页移动到链表头部即可，表示最近被访问了。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/lru2.png" alt="img"></p><p>而如果接下来，访问了 8 号页，因为 8 号页不在内存里，且 <code>LRU</code> 链表长度为 5，所以必须要淘汰数据，以腾出内存空间来缓存 8 号页，于是就会淘汰末尾的 5 号页，然后再将 8 号页加入到头部。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/lru3.png" alt="img"></p><p>传统的 <code>LRU</code> 算法并没有被 Linux 和 <code>MySQL</code> 使用，因为传统的 <code>LRU</code> 算法无法避免下面这两个问题：</p><ul><li>预读失效导致缓存命中率下降；</li><li>缓存污染导致缓存命中率下降；</li></ul><hr><h4 id="预读机制"><a href="#预读机制" class="headerlink" title="预读机制"></a>预读机制</h4><p>Linux 操作系统为基于 Page Cache 的读缓存机制提供<strong>预读机制</strong>，一个例子是：</p><ul><li>应用程序只想读取磁盘上文件 A 的 offset 为 0-3 KB 范围内的数据，由于磁盘的基本读写单位为 block（4 KB），于是操作系统至少会读 0-4 KB 的内容，这恰好可以在一个 page 中装下。</li><li>但是操作系统出于空间局部性原理（<strong>靠近当前被访问数据的数据，在未来很大概率会被访问到</strong>），会选择将磁盘块 offset [4 KB,8 KB)、[8 KB,12 KB) 以及 [12 KB,16 KB) 都加载到内存，于是额外在内存中申请了 3 个 page；</li></ul><p>下图代表了操作系统的预读机制：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/ae8252378169c8c14b8b9907983f7d8b.png" alt="img"></p><p>上图中，应用程序利用 read 系统调动读取 4 KB 数据，实际上内核使用预读机制（<code>ReadaHead</code>） 机制完成了 16 KB 数据的读取，也就是<strong>通过一次磁盘顺序读将多个 Page 数据装入 Page Cache</strong>。</p><p>这样下次读取 4 KB 数据后面的数据的时候，就不用从磁盘读取了，直接在 Page Cache 即可命中数据。因此，预读机制带来的好处就是<strong>减少了 磁盘 I&#x2F;O 次数，提高系统磁盘 I&#x2F;O 吞吐量</strong>。</p><p><strong><code>MySQL</code>  <code>Innodb</code> 存储引擎的 Buffer Pool 也有类似的预读机制，<code>MySQL</code> 从磁盘加载页时，会提前把它相邻的页一并加载进来，目的是为了减少磁盘 IO。</strong></p><hr><h5 id="预读失败的后果"><a href="#预读失败的后果" class="headerlink" title="预读失败的后果"></a>预读失败的后果</h5><blockquote><p><strong>预读失败</strong>：如果这些<strong>被提前加载进来的页，并没有被访问</strong>，相当于这个预读工作是白做了，这就是预读失败。</p></blockquote><p>问题分析：如果使用传统的 <code>LRU</code> 算法，就会把「预读页」放到 <code>LRU</code> 链表头部，而当内存空间不够的时候，还需要把末尾的页淘汰掉。</p><p>后果：如果这些「预读页」如果一直不会被访问到，就会出现一个很奇怪的问题，<strong>不会被访问的预读页却占用了 <code>LRU</code> 链表前排的位置，而末尾淘汰的页，可能是热点数据，这样就大大降低了缓存命中率</strong> 。</p><hr><h5 id="如何避免预读失败造成的影响？"><a href="#如何避免预读失败造成的影响？" class="headerlink" title="如何避免预读失败造成的影响？"></a>如何避免预读失败造成的影响？</h5><p>虽然存在预读失败的情况，而这种情况也确实对系统存在影响，但是凡事都有利弊，我们不能因为害怕出现预读失败的情况，而将预读机制去掉，大部分情况下，空间局部性原理还是成立的。</p><p>要避免预读失效带来的影响，最好的办法就是<strong>让预读页停留在内存里的时间尽可能的短，让真正被访问的页才移动到 <code>LRU</code> 链表的头部，从而保证真正被读取的热数据留在内存中里的时间尽可能长。</strong></p><p>那到底怎么才能避免呢？</p><p>Linux 操作系统和 <code>MySQL</code> <code>Innodb</code> 通过改进传统 <code>LRU</code> 链表来避免预读失效带来的影响，具体的改进分别如下：</p><ul><li>Linux 操作系统实现两个了 <code>LRU</code> 链表：<strong>活跃 <code>LRU</code> 链表（active_list）和非活跃 <code>LRU</code> 链表（inactive_list）</strong>；</li><li><code>MySQL</code> 的 <code>Innodb</code> 存储引擎是在一个 <code>LRU</code> 链表上划分来 2 个区域：<strong>young 区域 和 old 区域</strong>。</li></ul><p>这两个改进方式，设计思想都是类似的，<strong>都是将数据分为了冷数据和热数据，然后分别进行 <code>LRU</code> 算法</strong>。不再像传统的 <code>LRU</code> 算法那样，所有数据都只用一个 <code>LRU</code> 算法管理。</p><blockquote><p>Linux 是如何避免预读失效带来的影响？</p></blockquote><p>Linux 操作系统实现两个了 <code>LRU</code> 链表：<strong>活跃 <code>LRU</code> 链表（active_list）和非活跃 <code>LRU</code> 链表（inactive_list）</strong>。</p><ul><li><strong>active list</strong> 活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页；</li><li><strong>inactive list</strong> 不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页；</li></ul><p>有了这两个 <code>LRU</code> 链表后，<strong>预读页就只需要加入到 inactive list 区域的头部，当页被真正访问的时候，才将页插入 active list 的头部</strong>。如果预读的页一直没有被访问，就会从 inactive list 移除，这样就不会影响 active list 中的热点数据。</p><p>接下来，给大家举个例子。</p><p>假设 active list 和 inactive list 的长度为 5，目前内存中已经有如下 10 个页：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/active_inactive_list.drawio.png" alt="img"></p><p>现在有个编号为 20 的页被预读了，这个页只会被插入到 inactive list 的头部，而 inactive list 末尾的页（10号）会被淘汰掉。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/active_inactive_list1.drawio.png" alt="img"></p><p><strong>即使编号为 20 的预读页一直不会被访问，它也没有占用到 active list 的位置</strong>，而且还会比 active list 中的页更早被淘汰出去。</p><p>如果 20 号页被预读后，立刻被访问了，那么就会将它插入到 active list 的头部， active list 末尾的页（5号），会被<strong>降级</strong>到 inactive list ，作为 inactive list 的头部，<strong>这个过程并不会有数据被淘汰</strong>。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/active_inactive_list2.drawio.png" alt="img"></p><blockquote><p><code>MySQL</code> 是如何避免预读失效带来的影响？</p></blockquote><p><code>MySQL</code> 的 <code>Innodb</code> 存储引擎是在一个 <code>LRU</code> 链表上划分来 2 个区域，<strong>young 区域 和 old 区域</strong>。</p><p>young 区域在 <code>LRU</code> 链表的前半部分，old 区域则是在后半部分，这两个区域都有各自的头和尾节点，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/young%2Bold.png" alt="img"></p><p>young 区域与 old 区域在 <code>LRU</code> 链表中的占比关系并不是一比一的关系，而是 <code>63:37</code>（<strong>默认比例</strong>）的关系。</p><p><strong>划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部</strong>。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。</p><p>接下来，给大家举个例子。</p><p>假设有一个长度为 10 的 <code>LRU</code> 链表，其中 young 区域占比 70 %，old 区域占比 30 %。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/lrutwo.drawio.png" alt="img"></p><p>现在有个编号为 20 的页被预读了，这个页只会被插入到 old 区域头部，而 old 区域末尾的页（10号）会被淘汰掉。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/lrutwo2.png" alt="img"></p><p>如果 20 号页一直不会被访问，它也没有占用到 young 区域的位置，而且还会<strong>比 young 区域的数据更早被淘汰出去</strong>。</p><p>如果 20 号页被预读后，立刻被访问了，那么就会将它插入到 young 区域的头部，young 区域末尾的页（7号），会被挤到 old 区域，作为 old 区域的头部，<strong>这个过程并不会有页被淘汰。</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/lrutwo3.png" alt="img"></p><hr><h4 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h4><p>虽然上述办法避免了去读失效带来的影响。但是如果还是使用<strong>「只要数据被访问一次，就将数据加入到活跃 <code>LRU</code> 链表头部（或者 young 区域）」</strong> 这种方式的话，那么还存在缓存污染的问题。</p><hr><p><strong>缓存污染</strong>：当我们在批量读取数据的时候，由于数据被访问了一次，这些大量数据都会被加入到「活跃 <code>LRU</code> 链表」里，然后之前缓存在活跃 <code>LRU</code> 链表（或者 young 区域）里的热点数据全部都被淘汰了，<strong>如果这些大量的数据在很长一段时间都不会被访问的话，那么整个活跃 <code>LRU</code> 链表（或者 young 区域）就被污染了</strong>。</p><hr><h5 id="缓存污染会带来什么问题？"><a href="#缓存污染会带来什么问题？" class="headerlink" title="缓存污染会带来什么问题？"></a>缓存污染会带来什么问题？</h5><p>缓存污染带来的影响就是很致命的，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 I&#x2F;O，系统性能就会急剧下降。</p><p>我以 <code>MySQL</code> 举例子，Linux 发生缓存污染的现象也是类似。</p><p>当某一个 <code>SQL</code> 语句<strong>扫描了大量的数据</strong>时，在 Buffer Pool 空间比较有限的情况下，可能会将 <strong>Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了</strong>，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 I&#x2F;O，<code>MySQL</code> 性能就会急剧下降。</p><p>注意， 缓存污染并不只是查询语句查询出了大量的数据才出现的问题，即使查询出来的结果集很小，也会造成缓存污染。</p><p>比如，在一个数据量非常大的表，执行了这条语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> name <span class="keyword">like</span> &quot;%xiaolin%&quot;;</span><br></pre></td></tr></table></figure><p>可能这个查询出来的结果就几条记录，但是由于这条语句会发生索引失效，所以这个查询过程是全表扫描的，接着会发生如下的过程：</p><ul><li>从磁盘读到的页加入到 <code>LRU</code> 链表的 old 区域头部；</li><li>当从页里读取行记录时，也就是<strong>页被访问的时候，就要将该页放到 young 区域头部</strong>；</li><li>接下来拿行记录的 name 字段和字符串 <code>xiaolin</code> 进行模糊匹配，如果符合条件，就加入到结果集里；</li><li>如此往复，直到扫描完表中的所有记录。</li></ul><p>经过这一番折腾，由于这条 <code>SQL</code> 语句访问的页非常多，每访问一个页，都会将其加入 young 区域头部，那么<strong>原本 young 区域的热点数据都会被替换掉，导致缓存命中率下降</strong>。那些在批量扫描时，而被加入到 young 区域的页，如果在很长一段时间都不会再被访问的话，那么就污染了 young 区域。</p><p>举个例子，假设需要批量扫描：21，22，23，24，25 这五个页，这些页都会被逐一访问（读取页里的记录）。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/lruthree.drawio.png" alt="img"></p><p>在批量访问这些页的时候，会被逐一插入到 young 区域头部。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/lruthree1.png" alt="img"></p><p>可以看到，原本在 young 区域的 6 和 7 号页都被淘汰了，而批量扫描的页基本占满了 young 区域，如果这些页在很长一段时间都不会被访问，那么就对 young 区域造成了污染。</p><p>如果 6 和 7 号页是热点数据，那么在被淘汰后，后续有 <code>SQL</code> 再次读取 6 和 7 号页时，由于缓存未命中，就要从磁盘中读取了，降低了 <code>MySQL</code> 的性能，这就是缓存污染带来的影响。</p><hr><h5 id="怎么避免缓存污染造成的影响？"><a href="#怎么避免缓存污染造成的影响？" class="headerlink" title="怎么避免缓存污染造成的影响？"></a>怎么避免缓存污染造成的影响？</h5><p>前面的 <code>LRU</code> 算法只要数据被访问一次，就将数据加入活跃 <code>LRU</code> 链表（或者 young 区域），<strong>这种 <code>LRU</code> 算法进入活跃 <code>LRU</code> 链表的门槛太低了</strong>！正式因为门槛太低，才导致在发生缓存污染的时候，很容就将原本在活跃 <code>LRU</code> 链表里的热点数据淘汰了。</p><p>所以，<strong>只要我们提高进入到活跃 <code>LRU</code> 链表（或者 young 区域）的门槛，就能有效地保证活跃 LRU 链表（或者 young 区域）里的热点数据不会被轻易替换掉</strong>。</p><p>Linux 操作系统和 <code>MySQL</code>  <code>Innodb</code> 存储引擎分别是这样提高门槛的：</p><ul><li><strong>Linux 操作系统</strong>：在内存页被访问<strong>第二次</strong>的时候，才将页从 inactive list 升级到 active list 里。</li><li><code>MySQL</code>  <code>Innodb</code>：在内存页被访问第二次的时候，并不会马上将该页从 old 区域升级到 young 区域，因为还要进行停留在 old 区域的时间判断：<ul><li>如果第二次的访问时间与第一次访问的时间<strong>在 1 秒内</strong>（默认值），那么该页就<strong>不会</strong>被从 old 区域升级到 young 区域；</li><li>如果第二次的访问时间与第一次访问的时间<strong>超过 1 秒</strong>，那么该页就<strong>会</strong>从 old 区域升级到 young 区域；</li></ul></li></ul><p>提高了进入活跃 <code>LRU</code> 链表（或者 young 区域）的门槛后，就很好了避免缓存污染带来的影响。</p><p>在批量读取数据时候，<strong>如果这些大量数据只会被访问一次，那么它们就不会进入到活跃 <code>LRU</code> 链表（或者 young 区域）</strong>，也就不会把热点数据淘汰，只会待在非活跃 <code>LRU</code> 链表（或者 old 区域）中，后续很快也会被淘汰。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h1&gt;&lt;h2 id=&quot;硬件结构&quot;&gt;&lt;a href=&quot;#硬件结构&quot; class=&quot;headerlink&quot; title=&quot;硬件结构&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://devildyw.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="操作系统" scheme="https://devildyw.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>《Netty4核心原理与手写RPC框架实战》</title>
    <link href="https://devildyw.github.io/2022/10/06/%E3%80%8ANetty4%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    <id>https://devildyw.github.io/2022/10/06/%E3%80%8ANetty4%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%88%98%E3%80%8B/</id>
    <published>2022-10-06T11:30:52.000Z</published>
    <updated>2022-10-25T09:13:49.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《Netty4核心原理与手写RPC框架实战》读书笔记"><a href="#《Netty4核心原理与手写RPC框架实战》读书笔记" class="headerlink" title="《Netty4核心原理与手写RPC框架实战》读书笔记"></a>《Netty4核心原理与手写RPC框架实战》读书笔记</h1><h2 id="Java-I-x2F-O-演进之路"><a href="#Java-I-x2F-O-演进之路" class="headerlink" title="Java I&#x2F;O 演进之路"></a>Java I&#x2F;O 演进之路</h2><h3 id="什么是-I-x2F-O"><a href="#什么是-I-x2F-O" class="headerlink" title="什么是 I&#x2F;O"></a>什么是 I&#x2F;O</h3><p>在操作系统之中我们都知道在 UNIX 世界里一切皆文件，而文件呢就是一串二进制流而已，其实不管是 Socket，还是 FIFO、管道、终端。对计算机来说一切都是文件，一切都是流。<strong>在信息交换的过程中，计算机都是对这些流进行数据的收发操作，简称 I&#x2F;O 操作（Input and Output）。</strong> </p><h3 id="I-x2F-O-交互流程"><a href="#I-x2F-O-交互流程" class="headerlink" title="I&#x2F;O 交互流程"></a>I&#x2F;O 交互流程</h3><p>通过用户进程中的一次完整的 I&#x2F;O 交互流程分为两阶段，首先是经过内核空间，也就是由操作系统处理；紧接着就是到用户空间，也就是交由应用程序。具体流程如下图所示。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210061940952.png" alt="image-20221006194022868"></p><p>I&#x2F;O 有内存 I&#x2F;O、网络 I&#x2F;O 和磁盘 I&#x2F;O 三种，通常我们说的 I&#x2F;O 指的是后两者。如下图所示是 I&#x2F;O 通信过程的调度示意。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210061943276.png" alt="image-20221006194305227"></p><h2 id="五种-I-x2F-O-通信模型"><a href="#五种-I-x2F-O-通信模型" class="headerlink" title="五种 I&#x2F;O 通信模型"></a>五种 I&#x2F;O 通信模型</h2><p>在网络环境下，通俗地讲，将 I&#x2F;O 分为两步：<strong>第一步是等待；第二步是数据搬迁。</strong></p><p>如果想要提高 I&#x2F;O 效率，需要将<strong>等待时间降低</strong>。因此发展出来五种 I&#x2F;O 模型，分别是：<strong>阻塞 I&#x2F;O 模型、非阻塞 I&#x2F;O 模型、多路复用 I&#x2F;O 模型、信号驱动 I&#x2F;O 模型、异步 I&#x2F;O 模型。其中前四种被称为同步 I&#x2F;O</strong>，下面对每一种 I&#x2F;O 模型进行详细分析。</p><h3 id="阻塞-I-x2F-O-模型"><a href="#阻塞-I-x2F-O-模型" class="headerlink" title="阻塞 I&#x2F;O 模型"></a>阻塞 I&#x2F;O 模型</h3><p>阻塞 I&#x2F;O 模型的通信过程示意如下图所示。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210062050240.png" alt="image-20221006205039163"></p><p>我们第一次接触的到的网络编程都是从 <code>listen()</code>、<code>send()</code>、<code>recv()</code> 等接口开始的，这些接口都是阻塞型的。都属于阻塞 I&#x2F;O 模型</p><p><strong>在调用函数到数据返回的期间阻塞的。</strong>在服务器实现模式为<strong>一个连接对应一个线程</strong>，即客户端有连接请求时服务器就需要启动一个线程进行处理，如果这个连接不做任何事情就会造成不必要的线程开销，可以通过<strong>线程池机制改善（只能改善减少创建关闭线程的开销，但不能改善 BIO 本身的缺点）</strong>。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210062051489.png" alt="image-20221006205154439"></p><h3 id="非阻塞-I-x2F-O-模型"><a href="#非阻塞-I-x2F-O-模型" class="headerlink" title="非阻塞 I&#x2F;O 模型"></a>非阻塞 I&#x2F;O 模型</h3><p>示意图如下。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210062052703.png" alt="image-20221006205243625"></p><p>当用户进程发出 read 操作时，如果内核中的数据还没有准备好，那么它并不会阻塞用户进程，而是立刻返回一个 error。从用户进程的角度讲，他发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果，用户进程判断结果是一个 error 时，他就知道数据还没有准备好。于是它可以再次发送 read 操作，一旦内核中的数据准备好了，并且再次收到了用户进程的系统调用，那么它会马上将数据拷贝到用户内存，然后返回，非阻塞接口相比于阻塞接口的显著差异在于，在被调用之后立即返回。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210062059124.png" alt="image-20221006205945061"></p><blockquote><p>非阻塞模式套接字与阻塞模式相比，不容易使用，使用非阻塞模式套接字，要编写更多的代码，但是，非阻塞模式套接字在控制建立多个链接、时间不定时，具有明显优势。</p></blockquote><h3 id="多路复用-I-x2F-O-模型"><a href="#多路复用-I-x2F-O-模型" class="headerlink" title="多路复用 I&#x2F;O 模型"></a>多路复用 I&#x2F;O 模型</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210081837376.png" alt="image-20221008183741246"></p><p>多个进程的 I&#x2F;O 可以注册到一个复用器（Selector）上，当用户进程调用该 Selector，Selector 会监听注册进来的所有 I&#x2F;O，如果Selector 监听的所有 I&#x2F;O 在内核缓冲区都没有可读数据，select 调用进程会被阻塞，而当任一 I&#x2F;O 在内核缓冲区中有可读数据时，select 调用进程就会返回，而后 select 调用进程可以自己或通知另外的进程（注册进程）再次发起读取 I&#x2F;O，读取内核中准备好的数据，多个进程注册 I&#x2F;O 后，只有一个 select 调用进程被阻塞。</p><blockquote><p>其实多路复用 I&#x2F;O 模型和阻塞 I&#x2F;O 模型并没有太大的不同，事实上由于这里要使用两个系统调用而比阻塞 I&#x2F;O 模型的性能还要差些。</p><p>多路复用 I&#x2F;O 不一定比使用多线程加阻塞 I&#x2F;O 的模式更优，甚至性能更佳，多路复用的优势在于可以处理更多的连接，而不是单个连接处理更快。</p></blockquote><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210081847520.png" alt="image-20221008184759480"></p><h3 id="信号驱动-I-x2F-O-模型"><a href="#信号驱动-I-x2F-O-模型" class="headerlink" title="信号驱动 I&#x2F;O 模型"></a>信号驱动 I&#x2F;O 模型</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210081848507.png" alt="image-20221008184819467"></p><p>信号驱动 I&#x2F;O 是指进程预先告知内核，向内核注册一个信号处理函数，然后用户进程返回<strong>不阻塞</strong>，当内核<strong>数据就绪时会发送一个信号给进程</strong>，用户进程便在信号处理函数中调用 I&#x2F;O 读取数据，从上图可以看出，<strong>实际上 I&#x2F;O 内核拷贝到用户进程的过程还是阻塞的，信号驱动 I&#x2F;O 并没有实现真正的异步，因为通知到进程后，依然由进程来完成 I&#x2F;O 操作。</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210081853074.png" alt="image-20221008185312018"></p><h3 id="异步-I-x2F-O-模型"><a href="#异步-I-x2F-O-模型" class="headerlink" title="异步 I&#x2F;O 模型"></a>异步 I&#x2F;O 模型</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210081853986.png" alt="image-20221008185359939"></p><p>用户进程发起 aio_read 操作后，给内核传递与 read 相同的描述符、缓冲区指针、缓冲区大小三个参数及文件偏移，告诉内核当整个操作完成时，如何通知我们立刻就可以开始去做其他的事；而另一方面，从内核的角度，当他收到一个 aio_read 之后，首先他会立刻返回，所以不会对用户进程产生任何阻塞，内核会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，内核会给用户进程发送一个信号，告诉它 aio_read 操作完成。</p><blockquote><p>异步 I&#x2F;O 的工作机制是：告知内核启动某个操作，并让内核在整个操作完成后通知我们，这种模型与信号驱动 I&#x2F;O 模型的区别在于，<strong>信号驱动 I&#x2F;O 模型是由内核通知我们何时可以启动一个 I&#x2F;O 操作，这个 I&#x2F;O 操作由用户自定义的信号函数来实现，而异步 I&#x2F;O 模型由内核告知我们 I&#x2F;O 操作何时完成。</strong></p></blockquote><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210081924965.png" alt="image-20221008192424929"></p><h3 id="各-I-x2F-O-模型的对比与总结"><a href="#各-I-x2F-O-模型的对比与总结" class="headerlink" title="各 I&#x2F;O 模型的对比与总结"></a>各 I&#x2F;O 模型的对比与总结</h3><p>前四种 I&#x2F;O 模型都是同步 I&#x2F;O 操作，它们的区别在于第一阶段，而第二阶段是一样的：数据（准备好后）从内核拷贝到应用缓冲区期间（用户空间），进程阻塞于 <code>recvfrom</code> 调用。</p><blockquote><p>recvfrom 会将数据从内核（Kernel）拷贝到用户内存中，这个时候进程就被阻塞了。在这段时间内，进程是被阻塞的。</p></blockquote><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210081929728.png" alt="image.png"></p><p>由上图可以看出，阻塞程度：阻塞 I&#x2F;O &gt; 非阻塞 I&#x2F;O &gt; 多路复用 I&#x2F;O &gt; 信号驱动 I&#x2F;O &gt; 异步 I&#x2F;O，效率是由低到高的。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210081930764.png" alt="image-20221008193056732"></p><p>Java BIO 和 NIO 之间的主要差异。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210081952389.png" alt="image-20221008195234349"></p><h2 id="易混淆概念解释"><a href="#易混淆概念解释" class="headerlink" title="易混淆概念解释"></a>易混淆概念解释</h2><ul><li>同步与异步：主要看请求发起方对消息结果的获取是主动发起还是被动通知的。</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210081934838.png" alt="image-20221008193426801"></p><ul><li>阻塞与非阻塞：调用一个函数后，在等待这个函数返回结果之前，当前的线程是处于挂起状态还是运行状态。</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210081936694.png" alt="image-20221008193611650"></p><ul><li>同步阻塞：请求方主动发起的，一直等待应答结果（用户线程阻塞挂起）；</li><li>异步非阻塞：请求方主动发起，但是可以去做其他的事情，但是需要不断轮询查看发起的请求是否有结果；</li><li>异步阻塞：请求方发起请求，一直阻塞等待答应结果（实际不应用）；</li><li>异步非阻塞：请求方发起请求，可以去干自己的事，服务会主动通知该请求已完成。</li></ul><h2 id="NIO-介绍"><a href="#NIO-介绍" class="headerlink" title="NIO 介绍"></a>NIO 介绍</h2><h3 id="缓冲区（Buffer）"><a href="#缓冲区（Buffer）" class="headerlink" title="缓冲区（Buffer）"></a>缓冲区（Buffer）</h3><p>在谈到缓冲区，<strong>我们说缓冲区对象本质上是一个数组，但它其实是一个特殊的数组，缓冲区对象内置了一些机制，能够追踪和记录缓冲区的状态变化情况</strong>，如果我们使用 <code>get()</code> 方法从缓冲区获取数据或者使用 <code>put()</code> 方法把数据写入缓冲区，都会引起缓冲区状态的变化。</p><blockquote><p>缓冲区三个重要属性：</p><ul><li>position：指定下一个将要被写入或者读取的元素索引，它的值由 get()&#x2F;put() 方法自动更新，在新创建一个 Buffer 对象时，position 被初始化为 0。</li><li>limit：指定还有多少数据需要取出（在从缓冲区写入通道时），或者还有多少空间可以放入数据（在从通道读入缓冲区时）。</li><li>capacity：指定了可以存储在缓冲区的最大数据容量，实际上，它指定了底层数据的大小，或者至少时指定了准许我们使用的底层数组的容量。‘</li></ul><p>注：0&lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity</p></blockquote><p>在 NIO 中，所有的缓冲区类型都继承与抽象类 Buffer，最常用的就是 ByteBuffer，对于 Java 中的基本类型，基本都有一个具体 Buffer 类型与之相对应。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210082019274.png" alt="image-20221008201920235"></p><ul><li><p><strong>缓存区的分配</strong>：可以通过调用静态方法 <code>allocate()</code> 来指定缓冲区的容量，其实调用 allocate 方法相当于<strong>创建了一个指定大小的数组，并把它包装为缓冲区对象</strong>。我们也可以<strong>自己创建一个数组通过调用静态方法 <code>wrap()</code> 来将其包装为缓冲区对象。</strong> </p></li><li><p><strong>缓冲区分片</strong>：根据现有的缓冲区对象创建一个子缓冲区，<strong>即在现有缓冲区上切出一片作为一个新的缓冲区，但现有的缓冲区与创建的子缓冲区在底层数面上是数据共享的（子缓冲区相当于现有缓冲区的一个视图窗口）。</strong>可以通过调用缓冲区对象的 <code>slice()</code> 创建。</p></li><li><p><strong>只读缓冲区</strong>：通过调用缓冲区对象的 <code>asReadOnlyBuffer()</code> 方法，将任何<strong>常规缓冲区转换为只读缓冲区</strong>，这个方法返回一个与原缓冲区<strong>完全相同</strong>的缓冲区，并与原缓冲区<strong>共享数据</strong>，只不过它是只读的。如果<strong>原缓冲区的内容发生了变化，只读缓冲区的内容也随之发生变化</strong>。<strong>注意：尝试修改只读缓冲区的内容，则会报 ReadOnlyBufferException 异常；只可以 常规–&gt; 只读 不可以 只读 –&gt; 可写</strong></p></li><li><p><strong>直接缓冲区</strong>：直接缓冲区是为了加快 I&#x2F;O 速度，使用一种特殊方式为其分配内存的缓冲区。<strong>该缓冲区会在每一次调用底层操作系统的本机 I&#x2F;O 操作之前（或之后），尝试避免将缓冲区内容拷贝到一个中间缓冲区拷贝数据。</strong>通过调用静态方法 <code>allocateDirect()</code> 方法</p></li><li><p><strong>内存映射</strong>：比常规的基于流或者基于通道的 I&#x2F;O 快得多。 <strong>内存映射文件 I&#x2F;O 通过使文件的数据表现为内存数组的内容来完成</strong>。一般来说，<strong>只有文件中实际读取或写入的部分才会映射到内存中</strong>。</p></li></ul><h3 id="选择器（Selector）"><a href="#选择器（Selector）" class="headerlink" title="选择器（Selector）"></a>选择器（Selector）</h3><p>NIO 中非阻塞 I&#x2F;O 采用了基于 Reactor 模式的工作方式， I&#x2F;O 调用不会被阻塞，而是注册感兴趣的特定 I&#x2F;O 事件，如可读数据到达、新的套接字连接等，在发生特定事件时，系统再通知我们。NIO 中实现非阻塞 I&#x2F;O 的核心对象是 Selector，Selector 是注册各种 I&#x2F;O 事件的地方，而且当那些事情发生时，就是 Selector 告诉我们所发生的事件。</p><h3 id="通道（Channel）"><a href="#通道（Channel）" class="headerlink" title="通道（Channel）"></a>通道（Channel）</h3><p>通道是一个对象，通过它可以读取和写入数据，当然所有数据都通过 Buffer 对象来处理。我们永远不会将字节直接写入通道，而是将数据写入包含一个或者多个字节的缓冲区。同样也不会直接从通道中读取字节，而是通过数据从通道读入缓冲区，再从缓冲区获取这个字节。</p><p><img src="https://pic2.zhimg.com/80/v2-537ed6de4ca2cfeefd0dd11654519b65_720w.webp" alt="img"></p><h3 id="反应堆"><a href="#反应堆" class="headerlink" title="反应堆"></a>反应堆</h3><p>阻塞 I&#x2F;O 的通信模型如下图所示。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210091808348.png" alt="image-20221009180839283"></p><p>每个客户端连接成功后，服务端都会启动一个线程区处理该客户端请求。</p><p><strong>阻塞 I&#x2F;O 通信模型缺点</strong></p><ol><li>当客户端多时，会创建大量的处理线程。且每个线程都要占用栈空间和一些 CPU 时间。</li><li>阻塞可能带来频繁的上下文切换，且大部分上下文切换可能是无意义的。</li></ol><p>在这种情况下非阻塞 I&#x2F;O 就有了它的应用前景。</p><p><strong>Java NIO 工作原理。</strong></p><ol><li><strong>有一个专门的线程来处理所有 I&#x2F;O 事件，并负责分发。</strong></li><li><strong>事件驱动机制</strong>：事件到的时候出发，而不是同步地去监视事件。</li><li><strong>线程通信</strong>：线程之间通过 wait、notify 等方式通信。保证每次上下文切换都是<strong>有意义的</strong>，<strong>减少无谓的线程切换</strong>。</li></ol><blockquote><p> Java NIO 反应堆工作原理图。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210091814247.png" alt="image-20221009181444168"></p><p>（注：每个线程的处理流程大概都是读取数据、解码、计算处理、编码和发送响应。）</p></blockquote><h3 id="Netty-与-NIO"><a href="#Netty-与-NIO" class="headerlink" title="Netty 与 NIO"></a>Netty 与 NIO</h3><h4 id="Netty-支持的功能与特性"><a href="#Netty-支持的功能与特性" class="headerlink" title="Netty 支持的功能与特性"></a>Netty 支持的功能与特性</h4><p>根据定义，Netty 是一个异步的、事件驱动的、用来做高性能高可靠的网络应用的框架。优点如下：</p><ol><li>框架设计优雅，底层模型随意切换，适应不同的网络协议要求。</li><li>提供了很多的协议、安全、编解码的支持。</li><li>解决了很多 NIO 不易用的问题。</li><li>社区更为活跃。</li></ol><p>Netty 支持的功能与特性如下图所示。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210091819746.png" alt="image-20221009181932653"></p><ol><li>底层核心有：Zero-Copy-Capable Buffer，非常易用的零拷贝 Buffer；统一的 API；标准可扩展的事件模型。</li><li>传输方面支持的有：管道通信；HTTP 隧道；TCP 与 UDP。</li><li>协议方面的支持有：基于原始文本和二进制的协议；解压缩；大文件传输；流媒体传输；ProtoBuf 编解码；安全认证；HTTP 和 WebSocket。</li></ol><h4 id="Netty-采用-NIO-而非-AIO-的理由"><a href="#Netty-采用-NIO-而非-AIO-的理由" class="headerlink" title="Netty 采用 NIO 而非 AIO 的理由"></a>Netty 采用 NIO 而非 AIO 的理由</h4><blockquote><ol><li>Netty 不看重 Windows 上的使用，在 Linux 系统上，AIO 的底层实现仍使用 <code>epoll</code>，没有很好地实现 AIO，因此在性能上没有明显又是，且被 JDK 封装了一层，不容易深度优化。</li><li>Netty 整体架构采用 Reactor 模型，而 AIO 采用 Proactor 模型，混在一起会非常混乱，把 AIO 也改造成 Reactor 模型，看起来是把 Epoll 绕了个弯又绕回来。</li><li>AIO 还有个缺点是接受数据需要预先分配缓存， 而 NIO 是需要接收时才分配，所以对连接数量非常大但流量小的情况，AIO 会浪费很多内存。</li><li>Linux上 AIO 不够成熟，处理回调结果的速度跟不上处理需求。</li></ol></blockquote><h2 id="Nettty-高性能之道"><a href="#Nettty-高性能之道" class="headerlink" title="Nettty 高性能之道"></a>Nettty 高性能之道</h2><h3 id="传统-RPC-调用性能差的三大问题"><a href="#传统-RPC-调用性能差的三大问题" class="headerlink" title="传统 RPC 调用性能差的三大问题"></a>传统 RPC 调用性能差的三大问题</h3><h4 id="1-网络传输方式存在弊端"><a href="#1-网络传输方式存在弊端" class="headerlink" title="1. 网络传输方式存在弊端"></a>1. 网络传输方式存在弊端</h4><p>传统的 RPC 框架或者居于 RMI 等方式的远程服务（过程）调用都是采用 BIO，当客户端的并发压力或者网络时延 增大的时候，BIO 会因频繁的 “wait” 导致 I&#x2F;O 线程经常出席那阻塞的情况，由于线程本省无法高效地工作，I&#x2F;O 处理能力自然就会下降。</p><p><strong>采用 BIO 通信模型的服务端</strong>，通常由一个独立的 Acceptor 线程负责监听客户端的连接，接收到客户端连接之后为客户端创建一个新的线程处理请求消息，处理完成之后，返回应答消息给客户端，线程销毁，这就是典型的一请求一应答模型。<strong>这样的架构设计，最大的问题就是无法进行弹性伸缩。当用户访问量剧增时，并发量自然上升，而服务端的线程个数和并发访问数成线性正比，由于线程是 JVM 非常宝贵的系统资源，所以随着并发量的持续增加、线程数急剧膨胀，系统的性能也急剧下降，可能会发生句柄和线程堆栈溢出等问题，最终可能导致服务器宕机。</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210101942644.png" alt="image-20221010194225522"></p><h4 id="2-序列化方式存在弊端"><a href="#2-序列化方式存在弊端" class="headerlink" title="2. 序列化方式存在弊端"></a>2. 序列化方式存在弊端</h4><p>Java 序列化存在如下几个较为典型的问题：</p><ul><li>无法跨语言使用</li><li>比起第三方序列化框架，序列化后的字节流占用的空间太大（传输带宽占用太大）。</li><li>序列化性能较差，序列化时会占用较多的 CPU 资源。</li></ul><h4 id="3-线程模型存在弊端"><a href="#3-线程模型存在弊端" class="headerlink" title="3. 线程模型存在弊端"></a>3. 线程模型存在弊端</h4><p>由于传统的 RPC 框架均采用 BIO 模型，这使得每个 TCP 链家都需要分配 1 个线程，而线程资源是 JVM 非常宝贵的系统资源，当 I&#x2F;O 读写阻塞时无法及时释放时，会导致系统性能急剧下降，甚至会导致虚拟机无法创建新的线程。</p><h3 id="Netty-高性能的三个主题"><a href="#Netty-高性能的三个主题" class="headerlink" title="Netty 高性能的三个主题"></a>Netty 高性能的三个主题</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210101949866.png" alt="image-20221010194940812"></p><h4 id="I-x2F-O-传输模型"><a href="#I-x2F-O-传输模型" class="headerlink" title="I&#x2F;O 传输模型"></a>I&#x2F;O 传输模型</h4><p>用什么样的通道将数据发送给对方，是 BIO、NIO 还是 AIO，I&#x2F;O 传输模型在很大程度上决定了框架的性能。</p><h4 id="数据协议"><a href="#数据协议" class="headerlink" title="数据协议"></a>数据协议</h4><p>采用什么样的通信协议，是 HTTP 还是内部私有协议。协议的选择不同，性能模型也就不同。一般来说内部私有协议比公有协议的性能更高。</p><h4 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h4><p>线程模型涉及如何读取数据包，读取之后的编解码在哪个线程中进行，编解码后的消息如何派发等方面。线程模型设计得不同，对性能也会产生非常大得影响。</p><h3 id="异步非阻塞通信"><a href="#异步非阻塞通信" class="headerlink" title="异步非阻塞通信"></a>异步非阻塞通信</h3><p>与 Socket 类和ServerSocket 类相对应，NIO 也提供了 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现。这两种新增的 Channel 都支持阻塞和非阻塞两种 I&#x2F;O 模式。</p><ol><li><p>服务端得通行步骤</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210102002142.png" alt="image-20221010200208068"></p></li><li><p>客户端通信步骤：</p></li></ol><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210102002287.png" alt="image-20221010200238215"></p><p>通过上面的序列图，我们大概能够了解到 Netty 的 I&#x2F;O 线程 NioEventLoop 聚合了 Selector，可以同时并发处理成百上千个客户端 Channel，而且它的<strong>读写操作都是非阻塞的</strong>，这可以大幅提升 I&#x2F;O 线程的运行效率，<strong>避免由于频繁 I&#x2F;O 阻塞导致的线程挂起</strong>。另外，由于 Netty 采用的是<strong>异步通信模式</strong>，<strong>单个 I&#x2F;O 线程也可以并发处理多个用户端连接和读写操作</strong>，所以从根本上解决了传统 BIO 的但连接单线程模型的弊端，使整个系统的性能、弹性伸缩性能和可靠性都得到了极大的提升。</p><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>在<strong>操作系统</strong>的层面上<strong>零拷贝</strong>是指<strong>避免</strong>在<strong>用户态</strong>(User-space) 与<strong>内核态</strong>(Kernel-space)之间<strong>来回拷贝</strong>数据的技术。Netty 中零拷贝与操作系统层面上的零拷贝是完全不一样的，<strong>Netty 的零拷贝完全是在用户态（java层面）的，更多的是数据操作的优化。</strong></p><p>Netty 的零拷贝主要体现在如下五个方面。</p><ol><li>Netty 接收和发送 ByteBuffer 采用 DirectBuffer，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。<strong>如果使用传统的堆存（Heap Buffer）进行 Socket 的读写。那么 JVM 会将推存拷贝一份到直接内存中，然后才写入 Socket。</strong>相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</li><li>Netty 提供了多种组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方面地对组合 Buffer 进行操作，避免了传统的通过内存拷贝的方式将几个小 Buffer 合并成一个大 Buffer 的繁琐操作。</li><li>Netty 中文件传输采用 <code>transferTo()</code> 方法，它可以直接将文件缓冲区的数据发送到目标 <code>Channel</code>，避免了传统通过循环 <code>write()</code> 方式导致的内存拷贝问题。</li><li>通过 wrap 操作，我们可以将 <code>byte[]</code> 数组、ByteBuf、ByteBuffer 等包装成要给 Netty ByteBuf 对象，进而避免了拷贝技术。</li><li>ByteBuf 支持 slice 操作，可以将 ByteBuf分解为多个共享同一个存储区域的 ByteBuf，避免内存的拷贝。</li></ol><blockquote><p>对于很多操作系统，它接收文件缓冲区的内容直接发送给目标 Channel，而不需要从内核拷贝到应用程序内存，这种更加高效的传输实现了文件传输的零拷贝</p></blockquote><blockquote><p>这一块的详细文章推荐：<a href="https://mp.weixin.qq.com/s?__biz=MzUyNzgyNzAwNg==&mid=2247483933&idx=1&sn=d9776b9efe054b30523adbe60cb7524a&scene=21#wechat_redirect">NIO效率高的原理之零拷贝与直接内存映射</a></p></blockquote><h4 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h4><p>随着技术的发展，对象的分配和回收已经是一个非常轻量级的工作了。但是对于缓冲区来说还是有些特殊，尤其是对于堆外直接内存的分配和回收，是一种耗时的操作。<strong>为了尽量重复例用缓冲区内存</strong>，Netty 设计了一套<strong>基于内存池的缓冲区重用机制</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.devildyw.netty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.PooledByteBufAllocator;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Netty 内存池技术测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-10-10-20:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PoolBufferTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">byte</span>[] CONTENT = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">1800000</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">poolBuffer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------采用内存池分配器创建直接缓冲区----------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loop; i++) &#123;</span><br><span class="line">            poolBuffer = PooledByteBufAllocator.DEFAULT.directBuffer(<span class="number">1024</span>);</span><br><span class="line">            poolBuffer.writeBytes(CONTENT);</span><br><span class="line">            poolBuffer.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;内存池分配缓冲区耗时&quot;</span>+(endTime-startTime)+<span class="string">&quot;ms.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------采用非 堆内存分配器创建直接缓冲区----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loop; i++) &#123;</span><br><span class="line">            buffer = Unpooled.directBuffer();</span><br><span class="line">            buffer.writeBytes(CONTENT);</span><br><span class="line">            buffer.release();</span><br><span class="line">        &#125;</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;非内存池分配缓冲区耗时&quot;</span>+(endTime-startTime2)+<span class="string">&quot;ms.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210102105891.png" alt="image-20221010210500830"></p><h3 id="高效的-Reactor-线程模型"><a href="#高效的-Reactor-线程模型" class="headerlink" title="高效的 Reactor 线程模型"></a>高效的 Reactor 线程模型</h3><ol><li>Reactor 单线程模型</li></ol><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210102107177.png" alt="image-20221010210701111"></p><p><code>Acceptor</code> 负责接收客户端的 TCP 连接请求消息，链路建立成功之后，通过 <code>Dispatcher</code> 将对应的 <code>ByteBuffer</code> 派发到指定的 <code>Handler</code> 上进行消息解码，用户 <code>Handler</code> 通过 NIO 线程将消息发送给客户端。</p><p>对于并发量较小的业务场景，可以使用单线程模型。但单线程模型不适合高负载、高并发的场景。</p><ol start="2"><li>Reactor 多线程模型</li></ol><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210102113881.png" alt="image-20221010211346809"></p><ul><li>有一个专门的 NIO 线程 Acceptor 用于监听服务端、接收服务端的 TCP 连接请求。</li><li>网络 I&#x2F;O 读、写等操作只有一个 NIO 线程池负责，可以采用标准的 JDK 线程池来实现，它包含一个任务队列和多个可用的线程，由这些 NIO 线程负责消息的读取、节码、编码和发送。</li><li>一个 NIO 线程可用同时处理多条请求链路，但是一条链路只对应一个 NIO 线程，防止发生并发串行。</li></ul><ol start="3"><li>主从 Reactor 多线成模型</li></ol><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210102117819.png" alt="image-20221010211724752"></p><ul><li>服务端用于接收客户端连接的不再是单个 NIO 线程，而是分配了一个独立的 NIO 线程池。Acceptor 接收到客户端 TCP 连接请求并处理完成后（可能包含接入认证等），将新创建的 SocketChannel 注册到 I&#x2F;O 线程池（Sub Reactor 子线程池）的某个 I&#x2F;O 线程上，由它负责 SocketChannel 的读写和编解码工作。</li><li>Acceptor 线程仅仅用于客户端的登录、握手和安全认证，一旦链路建立成功，就将链路注册到后端 Sub Reactor 子线程池的 I&#x2F;O 线程上，再由 I&#x2F;O 线程负责后续的 I&#x2F;O 操作。</li></ul><p>利用主从Reactor多线程模型可以解决一个服务端监听线程无法有效处理所有客户端连接的性能不足的问题。因此，在Netty的官方Demo中，推荐使用该线程模型。</p><h3 id="无锁化的串行设计理念"><a href="#无锁化的串行设计理念" class="headerlink" title="无锁化的串行设计理念"></a>无锁化的串行设计理念</h3><p>为了尽可能避免锁竞争带来的性能损耗，<strong>可用通过串行化设计来避免多线程竞争和同步锁，即消息的处理尽可能在同一个线程内完成，不进行线程的切换。（减少上下文切换）</strong></p><p><strong>为了尽可能提升性能，Netty 采用了无锁化串行设计，在 I&#x2F;O 线程内部进行串行操作，避免多线程竞争导致的性能下降。</strong>表面上看似乎串行化设计对 CPU 利用率不高，并发程度不够。<strong>但是通过调整 NIO 线程池的线程参数，可用同时启动多个串行的线程并行运行，这种局部无锁化的串行线程设计相比一个队列——多个工作线程的模型更优。</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210102137205.png" alt="image.png"></p><h3 id="高效的并发编程"><a href="#高效的并发编程" class="headerlink" title="高效的并发编程"></a>高效的并发编程</h3><p>Netty 的高效并发编程主要体现在如下几点。</p><ol><li><strong>volatile 关键字的大量且正确的使用。</strong></li><li><strong>CAS 和原子类的广泛使用。</strong></li><li><strong>线程安全容器的使用</strong></li><li><strong>通过读写锁提升并发性能。</strong></li></ol><h3 id="对高性能序列化框架的支持"><a href="#对高性能序列化框架的支持" class="headerlink" title="对高性能序列化框架的支持"></a>对高性能序列化框架的支持</h3><p>Netty默认提供了对Google Protobuf的支持，用户也可以通过<strong>扩展Netty的编解码接口接入其他高性能的序列化框架进行编解码</strong>，例如Thrift的压缩二进制编解码框架。</p><h3 id="灵活的-TCP-参数配置能力"><a href="#灵活的-TCP-参数配置能力" class="headerlink" title="灵活的 TCP 参数配置能力"></a>灵活的 TCP 参数配置能力</h3><p>合理设置 TCP 参数在某些场景下对性能的提升具有显著的效果，例如 <code>SO_RCVBUF</code> 和 <code>SO_SNDBUF</code>：通常建议值为 128KB 或者 256KB。如果设置不当，对性能的影响也是非常大的。</p><p>对性能影响比较大的几个配置项。</p><ol><li><code>SO_RCVBUF</code> 和 <code>SO_SNDBUF</code>：通常建议值为128KB或者256KB。</li><li><code>SO_TCPNODELAY</code>：<code>Nagle</code> 算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发阻塞网络，从而提高网络应用效率。但是对于延时敏感的应用场景需要关闭该优化算法。</li></ol><blockquote><p><code>Nagle</code> 算法是以其发明人 John Nagle 的名字命名的，<strong>它用于将小的碎片数据连接成更大的保温来最小化所发送的报文数量。如果需要发送一些较小的保温，则需要禁用该算法</strong>。Netty <strong>默认禁用该算法</strong>，从而使得传输的<strong>延时最小化</strong>。</p></blockquote><ol start="3"><li>软中断：如果 Linux 内核版本支持 RPS（2.6.35 版本以上），开启 RPS 可以实现软中断，提升网络吞吐量。RPS 会<strong>根据数据包的源地址、目的地址，已经源端口和目标端口进行计算得到一个 hash 值，然后根据这个 hash 值来选择软中断 CPU 的运行</strong>。从<strong>上层来看，也就是将每个连接和 CPU 绑定，通过这个 Hash 值在多个 CPU 上均衡软中断，提升网络并行处理性能。</strong></li></ol><blockquote><p>Netty 在启动辅助类中可以灵活地配置 TCP 参数，满足不同的用户场景。相关配置如下表所示。（此表还有不详尽之处，大概了解，用作以后备）</p></blockquote><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210102149808.png" alt="image-20221010214936680"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210102149175.png" alt="image-20221010214957049"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202210102151047.png" alt="image-20221010215112965"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;《Netty4核心原理与手写RPC框架实战》读书笔记&quot;&gt;&lt;a href=&quot;#《Netty4核心原理与手写RPC框架实战》读书笔记&quot; class=&quot;headerlink&quot; title=&quot;《Netty4核心原理与手写RPC框架实战》读书笔记&quot;&gt;&lt;/a&gt;《Netty4核</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://devildyw.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Netty" scheme="https://devildyw.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud-Sentinel</title>
    <link href="https://devildyw.github.io/2022/09/25/Spring%20Cloud-Sentinel/"/>
    <id>https://devildyw.github.io/2022/09/25/Spring%20Cloud-Sentinel/</id>
    <published>2022-09-25T14:12:24.000Z</published>
    <updated>2022-09-25T14:16:12.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Cloud-Sentinel"><a href="#Spring-Cloud-Sentinel" class="headerlink" title="Spring Cloud-Sentinel"></a>Spring Cloud-Sentinel</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-Cloud-Sentinel&quot;&gt;&lt;a href=&quot;#Spring-Cloud-Sentinel&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud-Sentinel&quot;&gt;&lt;/a&gt;Spring Cloud-Sentinel&lt;/</summary>
      
    
    
    
    <category term="服务降级" scheme="https://devildyw.github.io/categories/%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/"/>
    
    
    <category term="Spring Cloud" scheme="https://devildyw.github.io/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--行为型模式之策略模式</title>
    <link href="https://devildyw.github.io/2022/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://devildyw.github.io/2022/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-09-06T04:52:09.000Z</published>
    <updated>2022-09-06T05:07:06.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式–行为型模式之策略模式"><a href="#设计模式–行为型模式之策略模式" class="headerlink" title="设计模式–行为型模式之策略模式"></a>设计模式–行为型模式之策略模式</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p><strong>策略模式</strong>是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209061256882.png" alt="策略设计模式"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一天， 你打算为游客们创建一款导游程序。 该程序的核心功能是提供美观的地图， 以帮助用户在任何城市中快速定位。</p><p>用户期待的程序新功能是自动路线规划： 他们希望输入地址后就能在地图上看到前往目的地的最快路线。</p><p>程序的首个版本只能规划公路路线。 驾车旅行的人们对此非常满意。 但很显然， 并非所有人都会在度假时开车。 因此你在下次更新时添加了规划步行路线的功能。 此后， 你又添加了规划公共交通路线的功能。</p><p>而这只是个开始。 不久后， 你又要为骑行者规划路线。 又过了一段时间， 你又要为游览城市中的所有景点规划路线。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209061256885.png" alt="导游代码将变得非常臃肿"></p><p>导游代码将变得非常臃肿。</p><p>尽管从商业角度来看， 这款应用非常成功， 但其技术部分却让你非常头疼： 每次添加新的路线规划算法后， 导游应用中主要类的体积就会增加一倍。 终于在某个时候， 你觉得自己没法继续维护这堆代码了。</p><p>无论是修复简单缺陷还是微调街道权重， 对某个算法进行任何修改都会影响整个类， 从而增加在已有正常运行代码中引入错误的风险。</p><p>此外， 团队合作将变得低效。 如果你在应用成功发布后招募了团队成员， 他们会抱怨在合并冲突的工作上花费了太多时间。 在实现新功能的过程中， 你的团队需要修改同一个巨大的类， 这样他们所编写的代码相互之间就可能会出现冲突。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>策略模式建议找出负责用许多不同方式完成特定任务的类， 然后将其中的算法抽取到一组被称为<em>策略</em>的独立类中。</p><p>名为<em>上下文</em>的原始类必须包含一个成员变量来存储对于每种策略的引用。 上下文并不执行任务， 而是将工作委派给已连接的策略对象。</p><p>上下文不负责选择符合任务需要的算法——客户端会将所需策略传递给上下文。 实际上， 上下文并不十分了解策略， 它会通过同样的通用接口与所有策略进行交互， 而该接口只需暴露一个方法来触发所选策略中封装的算法即可。</p><p>因此， 上下文可独立于具体策略。 这样你就可在不修改上下文代码或其他策略的情况下添加新算法或修改已有算法了。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209061256878.png" alt="路线规划策略"></p><p>路线规划策略。</p><p>在导游应用中， 每个路线规划算法都可被抽取到只有一个 <code>build­Route</code>生成路线方法的独立类中。 该方法接收起点和终点作为参数， 并返回路线中途点的集合。</p><p>即使传递给每个路径规划类的参数一模一样， 其所创建的路线也可能完全不同。 主要导游类的主要工作是在地图上渲染一系列中途点， 不会在意如何选择算法。 该类中还有一个用于切换当前路径规划策略的方法， 因此客户端 （例如用户界面中的按钮） 可用其他策略替换当前选择的路径规划行为。</p><h2 id="真实世界类比"><a href="#真实世界类比" class="headerlink" title="真实世界类比"></a>真实世界类比</h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209061256868.png" alt="各种出行策略"></p><p>各种前往机场的出行策略</p><p>假如你需要前往机场。 你可以选择乘坐公共汽车、 预约出租车或骑自行车。 这些就是你的出行策略。 你可以根据预算或时间等因素来选择其中一种策略。</p><h2 id="策略模式结构"><a href="#策略模式结构" class="headerlink" title="策略模式结构"></a>策略模式结构</h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209061256520.png" alt="策略设计模式的结构"></p><ol><li><strong>上下文</strong> （Con­text） 维护指向具体策略的引用， 且仅通过策略接口与该对象进行交流。</li><li><strong>策略</strong> （Strat­e­gy） 接口是所有具体策略的通用接口， 它声明了一个上下文用于执行策略的方法。</li><li><strong>具体策略</strong> （Con­crete Strate­gies） 实现了上下文所用算法的各种不同变体。</li><li>当上下文需要运行算法时， 它会在其已连接的策略对象上调用执行方法。 上下文不清楚其所涉及的策略类型与算法的执行方式。</li><li><strong>客户端</strong> （Client） 会创建一个特定策略对象并将其传递给上下文。 上下文则会提供一个设置器以便客户端在运行时替换相关联的策略。</li></ol><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>在本例中， 上下文使用了多个<strong>策略</strong>来执行不同的计算操作。</p><p>一个人想去一个目的地，他现在有四种策略可以选择，分别是 <strong>飞机</strong>、<strong>开车</strong>、<strong>骑车</strong>和<strong>坐公交</strong>。</p><p><code>Strategy 抽象策略类</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略类接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-06-12:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行策略的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Context 上下文</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上下文环境</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-06-12:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>&#123;</span><br><span class="line">        strategy.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ConcreteStrategies 具体策略类</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体策略类</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 乘坐飞机的策略</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-06-12:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AirPlaneStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;选择乘坐飞机,已为您规划好路线!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体策略类</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 骑自行车的策略</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-06-12:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BikeStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;选择骑自行车,已为您规划好路线!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体策略类</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 乘坐公交车的策略</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-06-12:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;选择乘坐公交车,已为您规划好路线!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体策略类</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 开车的策略</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-06-12:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;选择开车,已为您规划好路线!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Client 客户端</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-06-12:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建上下文</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建策略</span></span><br><span class="line">        <span class="type">BusStrategy</span> <span class="variable">busStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BusStrategy</span>();</span><br><span class="line">        <span class="type">BikeStrategy</span> <span class="variable">bikeStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BikeStrategy</span>();</span><br><span class="line">        <span class="type">AirPlaneStrategy</span> <span class="variable">airPlaneStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AirPlaneStrategy</span>();</span><br><span class="line">        <span class="type">CarStrategy</span> <span class="variable">carStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CarStrategy</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开车</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line">        context.setStrategy(busStrategy);</span><br><span class="line">        context.doSomething();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//骑车</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line">        context.setStrategy(bikeStrategy);</span><br><span class="line">        context.doSomething();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//飞机</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line">        context.setStrategy(airPlaneStrategy);</span><br><span class="line">        context.doSomething();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//公交</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line">        context.setStrategy(busStrategy);</span><br><span class="line">        context.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209061303618.png" alt="image-20220906130353573"></p><p><strong>将环境和策略耦合松散，防止随着策略的增加代码主体越来越臃肿。</strong></p><h2 id="策略模式适合应用场景"><a href="#策略模式适合应用场景" class="headerlink" title="策略模式适合应用场景"></a>策略模式适合应用场景</h2><p> <strong>当你想使用对象中各种不同的算法变体， 并希望能在运行时切换算法时， 可使用策略模式。</strong></p><p> 策略模式让你能够将对象关联至可以不同方式执行特定子任务的不同子对象， 从而以间接方式在运行时更改对象行为。</p><p> 当你有许多仅在执行某些行为时略有不同的相似类时， 可使用策略模式。</p><p> 策略模式让你能将不同行为抽取到一个独立类层次结构中， 并将原始类组合成同一个， 从而减少重复代码。</p><p> 如果算法在上下文的逻辑中不是特别重要， 使用该模式能将类的业务逻辑与其算法实现细节隔离开来。</p><p> 策略模式让你能将各种算法的代码、 内部数据和依赖关系与其他代码隔离开来。 不同客户端可通过一个简单接口执行算法， 并能在运行时进行切换。</p><p> 当类中使用了复杂条件运算符以在同一算法的不同变体中切换时， 可使用该模式。</p><p> 策略模式将所有继承自同样接口的算法抽取到独立类中， 因此不再需要条件语句。 原始对象并不实现所有算法的变体， 而是将执行工作委派给其中的一个独立算法对象。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li><strong>从上下文类中找出修改频率较高的算法 （也可能是用于在运行时选择某个算法变体的复杂条件运算符）。</strong></li><li><strong>声明该算法所有变体的通用策略接口。</strong></li><li><strong>将算法逐一抽取到各自的类中， 它们都必须实现策略接口。</strong></li><li><strong>在上下文类中添加一个成员变量用于保存对于策略对象的引用。 然后提供设置器以修改该成员变量。 上下文仅可通过策略接口同策略对象进行交互， 如有需要还可定义一个接口来让策略访问其数据。</strong></li><li><strong>客户端必须将上下文类与相应策略进行关联， 使上下文可以预期的方式完成其主要工作。</strong></li></ol><h2 id="策略模式优缺点"><a href="#策略模式优缺点" class="headerlink" title="策略模式优缺点"></a>策略模式优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>你可以在运行时切换对象内的算法。</li><li>你可以将算法的实现和使用算法的代码隔离开来。</li><li>你可以使用组合来代替继承。</li><li><em>开闭原则</em>。 你无需对上下文进行修改就能够引入新的策略。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>如果你的算法极少发生改变， 那么没有任何理由引入新的类和接口。 使用该模式只会让程序过于复杂。</li><li>客户端必须知晓策略间的不同——它需要选择合适的策略。</li><li>许多现代编程语言支持函数类型功能， 允许你在一组匿名函数中实现不同版本的算法。 这样， 你使用这些函数的方式就和使用策略对象时完全相同， 无需借助额外的类和接口来保持代码简洁。</li></ul><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul><li><a href="https://refactoringguru.cn/design-patterns/bridge">桥接模式</a>、 <a href="https://refactoringguru.cn/design-patterns/state">状态模式</a>和<a href="https://refactoringguru.cn/design-patterns/strategy">策略模式</a> （在某种程度上包括<a href="https://refactoringguru.cn/design-patterns/adapter">适配器模式</a>） 模式的接口非常相似。 实际上， 它们都基于<a href="https://refactoringguru.cn/design-patterns/composite">组合模式</a>——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</li><li><a href="https://refactoringguru.cn/design-patterns/command">命令模式</a>和<a href="https://refactoringguru.cn/design-patterns/strategy">策略</a>看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。<ul><li>你可以使用<em>命令</em>来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。</li><li>另一方面， <em>策略</em>通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。</li></ul></li><li><a href="https://refactoringguru.cn/design-patterns/decorator">装饰模式</a>可让你更改对象的外表， <a href="https://refactoringguru.cn/design-patterns/strategy">策略</a>则让你能够改变其本质。</li><li><a href="https://refactoringguru.cn/design-patterns/template-method">模板方法模式</a>基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。 <a href="https://refactoringguru.cn/design-patterns/strategy">策略</a>基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 <em>模板方法</em>在类层次上运作， 因此它是静态的。 <em>策略</em>在对象层次上运作， 因此允许在运行时切换行为。</li><li><a href="https://refactoringguru.cn/design-patterns/state">状态</a>可被视为<a href="https://refactoringguru.cn/design-patterns/strategy">策略</a>的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 <em>策略</em>使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但<em>状态</em>模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式–行为型模式之策略模式&quot;&gt;&lt;a href=&quot;#设计模式–行为型模式之策略模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式–行为型模式之策略模式&quot;&gt;&lt;/a&gt;设计模式–行为型模式之策略模式&lt;/h1&gt;&lt;h2 id=&quot;意图&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devildyw.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Developer" scheme="https://devildyw.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--行为型模式之状态模式</title>
    <link href="https://devildyw.github.io/2022/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>https://devildyw.github.io/2022/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-09-05T05:55:10.000Z</published>
    <updated>2022-09-05T06:14:03.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式–行为型模式之状态模式"><a href="#设计模式–行为型模式之状态模式" class="headerlink" title="设计模式–行为型模式之状态模式"></a>设计模式–行为型模式之状态模式</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p><strong>状态模式</strong>是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。</p><p><img src="https://refactoringguru.cn/images/patterns/content/state/state-zh.png" alt="状态设计模式"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>状态模式与<strong>有限状态机</strong> 的概念紧密相关。</p><p><img src="https://refactoringguru.cn/images/patterns/diagrams/state/problem1.png" alt="有限状态机"></p><p>有限状态机。</p><p>其主要思想是程序在任意时刻仅可处于几种<em>有限</em>的<em>状态</em>中。 在任何一个特定状态中， 程序的行为都不相同， 且可瞬间从一个状态切换到另一个状态。 不过， 根据当前状态， 程序可能会切换到另外一种状态， 也可能会保持当前状态不变。 这些数量有限且预先定义的状态切换规则被称为<em>转移</em>。</p><p>你还可将该方法应用在对象上。 假如你有一个 <code>文档</code> <code>Doc­u­ment</code> 类。 文档可能会处于 <code>草稿</code>Draft 、  <code>审阅中 </code> <code>Mod­er­a­tion</code> 和 <code>已发布</code> <code>Pub­lished</code> 三种状态中的一种。 文档的 <code>pub­lish</code>发布方法在不同状态下的行为略有不同：</p><ul><li>处于 <code>草稿</code>状态时， 它会将文档转移到审阅中状态。</li><li>处于 <code>审阅中</code>状态时， 如果当前用户是管理员， 它会公开发布文档。</li><li>处于 <code>已发布</code>状态时， 它不会进行任何操作。</li></ul><p><img src="https://refactoringguru.cn/images/patterns/diagrams/state/problem2-zh.png" alt="文档对象的全部状态"></p><p>文档对象的全部状态和转移。</p><p>状态机通常由众多条件运算符 （ <code>if</code>或 <code>switch</code> ） 实现， 可根据对象的当前状态选择相应的行为。  “状态” 通常只是对象中的一组成员变量值。 即使你之前从未听说过有限状态机， 你也很可能已经实现过状态模式。 下面的代码应该能帮助你回忆起来。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Document is</span><br><span class="line">    field state: string</span><br><span class="line">    // ……</span><br><span class="line">    method publish() is</span><br><span class="line">        switch (state)</span><br><span class="line">            &quot;draft&quot;:</span><br><span class="line">                state = &quot;moderation&quot;</span><br><span class="line">                break</span><br><span class="line">            &quot;moderation&quot;:</span><br><span class="line">                if (currentUser.role == &quot;admin&quot;)</span><br><span class="line">                    state = &quot;published&quot;</span><br><span class="line">                break</span><br><span class="line">            &quot;published&quot;:</span><br><span class="line">                // 什么也不做。</span><br><span class="line">                break</span><br><span class="line">    // ……</span><br></pre></td></tr></table></figure><p>当我们逐步在 <code>文档</code>类中添加更多状态和依赖于状态的行为后， 基于条件语句的状态机就会暴露其最大的弱点。 为了能根据当前状态选择完成相应行为的方法， 绝大部分方法中会包含复杂的条件语句。 修改其转换逻辑可能会涉及到修改所有方法中的状态条件语句， 导致代码的维护工作非常艰难。</p><p>这个问题会随着项目进行变得越发严重。 我们很难在设计阶段预测到所有可能的状态和转换。 随着时间推移， 最初仅包含有限条件语句的简洁状态机可能会变成臃肿的一团乱麻。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>状态模式建议为对象的所有可能状态新建一个类， 然后将所有状态的对应行为抽取到这些类中。</p><p>原始对象被称为<em>上下文</em> （<code>con­text</code>）， 它并不会自行实现所有行为， 而是会保存一个指向表示当前状态的状态对象的引用， 且将所有与状态相关的工作委派给该对象。</p><p><img src="https://refactoringguru.cn/images/patterns/diagrams/state/solution-zh.png" alt="文档将工作委派给一个状态对象"></p><p>文档将工作委派给一个状态对象。</p><p>如需将上下文转换为另外一种状态， 则需将当前活动的状态对象替换为另外一个代表新状态的对象。 采用这种方式是有前提的： 所有状态类都必须遵循同样的接口， 而且上下文必须仅通过接口与这些对象进行交互。</p><p>这个结构可能看上去与<a href="https://refactoringguru.cn/design-patterns/strategy">策略</a>模式相似， 但有一个关键性的不同——在状态模式中， 特定状态知道其他所有状态的存在， 且能触发从一个状态到另一个状态的转换； 策略则几乎完全不知道其他策略的存在。</p><h2 id="真实世界类比"><a href="#真实世界类比" class="headerlink" title="真实世界类比"></a>真实世界类比</h2><p>智能手机的按键和开关会根据设备当前状态完成不同行为：</p><ul><li>当手机处于解锁状态时， 按下按键将执行各种功能。</li><li>当手机处于锁定状态时， 按下任何按键都将解锁屏幕。</li><li>当手机电量不足时， 按下任何按键都将显示充电页面。</li></ul><h2 id="状态模式结构"><a href="#状态模式结构" class="headerlink" title="状态模式结构"></a>状态模式结构</h2><p><img src="https://refactoringguru.cn/images/patterns/diagrams/state/structure-zh.png" alt="状态设计模式的结构"></p><ol><li><p><strong>上下文</strong> （<code>Con­text</code>） 保存了对于一个具体状态对象的引用， 并会将所有与该状态相关的工作委派给它。 上下文通过状态接口与状态对象交互， 且会提供一个设置器用于传递新的状态对象。</p></li><li><p><strong>状态</strong> （<code>State</code>） 接口会声明特定于状态的方法。 这些方法应能被其他所有具体状态所理解， 因为你不希望某些状态所拥有的方法永远不会被调用。</p></li><li><p><strong>具体状态</strong> （<code>Con­crete States</code>） 会自行实现特定于状态的方法。 为了避免多个状态中包含相似代码， 你可以提供一个封装有部分通用行为的中间抽象类。</p><p>状态对象可存储对于上下文对象的反向引用。 状态可以通过该引用从上下文处获取所需信息， 并且能触发状态转移。</p></li><li><p>上下文和具体状态都可以设置上下文的下个状态， 并可通过替换连接到上下文的状态对象来完成实际的状态转换。</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>酒店中的房间有如下几个状态，<strong>已预定</strong>、<strong>以入住</strong>、<strong>以空闲</strong>。</p><p>由上可以分析出，房间是作为一个上下文对象，他有着三个状态，根据不同的操作可以更换当前房间的状态对象，以此改变房间对于用户互动做出的反应。</p><p><code>State</code> 抽象状态类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象状态类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-05-13:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HomeContnext</code> 状态上下文</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态上下文</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 房间对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-05-13:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改状态!&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">        <span class="comment">//不同状态响应的处理</span></span><br><span class="line">        state.handle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ConcreteState</code> 具体状态类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体状态类</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 已预定状态</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-05-13:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookedState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房间已预定！别人不能再定！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体状态类</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 以入住状态</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-05-13:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckInState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房间已入住！请勿打扰！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空闲状态</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-05-13:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FreeState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房间空闲！！！欢迎入住！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Client</code> 客户端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-05-13:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取房间对象</span></span><br><span class="line">        <span class="type">HomeContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HomeContext</span>();</span><br><span class="line">        <span class="comment">//设置房间状态</span></span><br><span class="line">        ctx.setState(<span class="keyword">new</span> <span class="title class_">FreeState</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">        ctx.setState(<span class="keyword">new</span> <span class="title class_">BookedState</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">        ctx.setState(<span class="keyword">new</span> <span class="title class_">CheckInState</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209051411049.png" alt="image-20220905141146000"></p><h2 id="状态模式适合应用场景"><a href="#状态模式适合应用场景" class="headerlink" title="状态模式适合应用场景"></a>状态模式适合应用场景</h2><p> <strong>如果对象需要根据自身当前状态进行不同行为， 同时状态的数量非常多且与状态相关的代码会频繁变更的话， 可使用状态模式。</strong></p><p> 模式建议你将所有特定于状态的代码抽取到一组独立的类中。 这样一来， 你可以在独立于其他状态的情况下添加新状态或修改已有状态， 从而减少维护成本。</p><p> <strong>如果某个类需要根据成员变量的当前值改变自身行为， 从而需要使用大量的条件语句时， 可使用该模式。</strong></p><p> 状态模式会将这些条件语句的分支抽取到相应状态类的方法中。 同时， 你还可以清除主要类中与特定状态相关的临时成员变量和帮手方法代码。</p><p> <strong>当相似状态和基于条件的状态机转换中存在许多重复代码时， 可使用状态模式。</strong></p><p> <strong>状态模式让你能够生成状态类层次结构， 通过将公用代码抽取到抽象基类中来减少重复。</strong></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li><p>确定哪些类是上下文。 它可能是包含依赖于状态的代码的已有类； 如果特定于状态的代码分散在多个类中， 那么它可能是一个新的类。</p></li><li><p>声明状态接口。 虽然你可能会需要完全复制上下文中声明的所有方法， 但最好是仅把关注点放在那些可能包含特定于状态的行为的方法上。</p></li><li><p>为每个实际状态创建一个继承于状态接口的类。 然后检查上下文中的方法并将与特定状态相关的所有代码抽取到新建的类中。</p><p>在将代码移动到状态类的过程中， 你可能会发现它依赖于上下文中的一些私有成员。 你可以采用以下几种变通方式：</p><ul><li>将这些成员变量或方法设为公有。</li><li>将需要抽取的上下文行为更改为上下文中的公有方法， 然后在状态类中调用。 这种方式简陋却便捷， 你可以稍后再对其进行修补。</li><li>将状态类嵌套在上下文类中。 这种方式需要你所使用的编程语言支持嵌套类。</li></ul></li><li><p>在上下文类中添加一个状态接口类型的引用成员变量， 以及一个用于修改该成员变量值的公有设置器。</p></li><li><p>再次检查上下文中的方法， 将空的条件语句替换为相应的状态对象方法。</p></li><li><p>为切换上下文状态， 你需要创建某个状态类实例并将其传递给上下文。 你可以在上下文、 各种状态或客户端中完成这项工作。 无论在何处完成这项工作， 该类都将依赖于其所实例化的具体类。</p></li></ol><h2 id="状态模式优缺点"><a href="#状态模式优缺点" class="headerlink" title="状态模式优缺点"></a>状态模式优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong><em>单一职责原则</em>。 将与特定状态相关的代码放在单独的类中。</strong></li><li><strong><em>开闭原则</em>。 无需修改已有状态类和上下文就能引入新状态。</strong></li><li><strong>通过消除臃肿的状态机条件语句简化上下文代码。</strong></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><strong>如果状态机只有很少的几个状态， 或者很少发生改变， 那么应用该模式可能会显得小题大作。</strong></li></ul><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul><li><a href="https://refactoringguru.cn/design-patterns/bridge">桥接模式</a>、 <a href="https://refactoringguru.cn/design-patterns/state">状态模式</a>和<a href="https://refactoringguru.cn/design-patterns/strategy">策略模式</a> （在某种程度上包括<a href="https://refactoringguru.cn/design-patterns/adapter">适配器模式</a>） 模式的接口非常相似。 实际上， 它们都基于<a href="https://refactoringguru.cn/design-patterns/composite">组合模式</a>——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</li><li><a href="https://refactoringguru.cn/design-patterns/state">状态</a>可被视为<a href="https://refactoringguru.cn/design-patterns/strategy">策略</a>的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 <em>策略</em>使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但<em>状态</em>模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式–行为型模式之状态模式&quot;&gt;&lt;a href=&quot;#设计模式–行为型模式之状态模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式–行为型模式之状态模式&quot;&gt;&lt;/a&gt;设计模式–行为型模式之状态模式&lt;/h1&gt;&lt;h2 id=&quot;意图&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devildyw.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Developer" scheme="https://devildyw.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--行为型模式之观察者模式</title>
    <link href="https://devildyw.github.io/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://devildyw.github.io/2022/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-09-04T04:31:24.000Z</published>
    <updated>2022-09-04T05:40:19.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式–行为型模式之观察者模式"><a href="#设计模式–行为型模式之观察者模式" class="headerlink" title="设计模式–行为型模式之观察者模式"></a>设计模式–行为型模式之观察者模式</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p><strong>观察者模式</strong>是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209041256185.png" alt="观察者设计模式"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>假如你有两种类型的对象：  <code>顾客</code>和 <code>商店</code> 。 顾客对某个特定品牌的产品非常感兴趣 （例如最新型号的 <code>iPhone</code> 手机）， 而该产品很快将会在商店里出售。</p><p>顾客可以每天来商店看看产品是否到货。 但如果商品尚未到货时， 绝大多数来到商店的顾客都会空手而归。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209041256484.png" alt="访问商店或发送垃圾邮件"></p><p>前往商店和发送垃圾邮件</p><p>另一方面， 每次新产品到货时， 商店可以向所有顾客发送邮件 （可能会被视为垃圾邮件）。 这样， 部分顾客就无需反复前往商店了， 但也可能会惹恼对新产品没有兴趣的其他顾客。</p><p>我们似乎遇到了一个矛盾： 要么让顾客浪费时间检查产品是否到货， 要么让商店浪费资源去通知没有需求的顾客。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>拥有一些值得关注的状态的对象通常被称为<em>目标</em>， 由于它要将自身的状态改变通知给其他对象， 我们也将其称为<em>发布者</em> （<code>pub­lish­er</code>）。 所有希望关注发布者状态变化的其他对象被称为<em>订阅者</em> （<code>sub­scribers</code>）。</p><p>观察者模式建议你为发布者类添加订阅机制， 让每个对象都能订阅或取消订阅发布者事件流。 不要害怕！ 这并不像听上去那么复杂。 实际上， 该机制包括 1） 一个用于存储订阅者对象引用的列表成员变量； 2） 几个用于添加或删除该列表中订阅者的公有方法。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209041256688.png" alt="订阅机制"></p><p>订阅机制允许对象订阅事件通知。</p><p>现在， 无论何时发生了重要的发布者事件， 它都要遍历订阅者并调用其对象的特定通知方法。</p><p><strong>实际应用中可能会有十几个不同的订阅者类跟踪着同一个发布者类的事件， 你不会希望发布者与所有这些类相耦合的。 此外如果他人会使用发布者类， 那么你甚至可能会对其中的一些类一无所知。</strong></p><p>因此， <strong>所有订阅者都必须实现同样的接口</strong>， 发布者仅通过该接口与订阅者交互。 接口中必须声明通知方法及其参数， 这样发布者在发出通知时还能传递一些上下文数据。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209041256693.png" alt="通知方法"></p><p>发布者调用订阅者对象中的特定通知方法来通知订阅者。</p><p>如果你的应用中有多个不同类型的发布者， 且<strong>希望订阅者可兼容所有发布者， 那么你甚至可以进一步让所有发布者遵循同样的接口</strong>。 该接口仅需描述几个订阅方法即可。 这样订阅者就能在不与具体发布者类耦合的情况下通过接口观察发布者的状态。</p><h2 id="真实世界类比"><a href="#真实世界类比" class="headerlink" title="真实世界类比"></a>真实世界类比</h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209041256088.png" alt="杂志和报纸订阅"></p><p>杂志和报纸订阅。</p><p>如果你订阅了一份杂志或报纸， 那就不需要再去报摊查询新出版的刊物了。 出版社 （即应用中的 “发布者”） 会在刊物出版后 （甚至提前） 直接将最新一期寄送至你的邮箱中。</p><p>出版社负责维护订阅者列表， 了解订阅者对哪些刊物感兴趣。 当订阅者希望出版社停止寄送新一期的杂志时， 他们可随时从该列表中退出。</p><h2 id="观察者模式结构"><a href="#观察者模式结构" class="headerlink" title="观察者模式结构"></a>观察者模式结构</h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209041256695.png" alt="观察者设计模式的结构"></p><ol><li><strong>发布者</strong> （<code>Pub­lish­er</code>） 会向其他对象发送值得关注的事件。 事件会在发布者自身状态改变或执行特定行为后发生。 发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。</li><li>当新事件发生时， 发送者会遍历订阅列表并调用每个订阅者对象的通知方法。 该方法是在订阅者接口中声明的。</li><li><strong>订阅者（观察者）</strong> （<code>Sub­scriber</code>） 接口声明了通知接口。 在绝大多数情况下， 该接口仅包含一个 <code>update</code>更新方法。 该方法可以拥有多个参数， 使发布者能在更新时传递事件的详细信息。</li><li><strong>具体订阅者</strong> （<code>Con­crete Sub­scribers</code>） 可以执行一些操作来回应发布者的通知。 所有具体订阅者类都实现了同样的接口， 因此发布者不需要与具体类相耦合。</li><li>订阅者通常需要一些上下文信息来正确地处理更新。 因此， 发布者通常会将一些上下文数据作为通知方法的参数进行传递。 发布者也可将自身作为参数进行传递， 使订阅者直接获取所需的数据。</li><li><strong>客户端</strong> （Client） 会分别创建发布者和订阅者对象， 然后为订阅者注册发布者更新。</li></ol><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="手动实现"><a href="#手动实现" class="headerlink" title="手动实现"></a>手动实现</h3><p>再此示例中，目标对象就是所谓的发布者，而观察者就是一个一个的观察目标对象内值是否发生改变的订阅者。</p><p><strong><code>Subject</code></strong> 抽象发布者&#x2F;目标对象  一旦发生了改变就会通知订阅者们。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者模式: 目标对象模板</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-04-12:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//存储订阅者</span></span><br><span class="line">    List&lt;Observer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册订阅者方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(T obs)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除订阅者方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(T obs)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知所有的观察者更新状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyAllObservers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Observer</code></strong> 观察者&#x2F;订阅者  一旦目标对象发生改变，订阅者会被通知</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者模式: 定义观察者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-04-12:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Subject subject)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>ConcreteSubject</code></strong> 具体目标&#x2F;具体发布者 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者模式: 目标对象（主体对象 topic）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-04-12:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span>&lt;Observer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">        <span class="comment">//主题对象（目标对象）值发生了变化，请通知所有的观察者</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer obs)</span> &#123;</span><br><span class="line">        list.add(obs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer obs)</span> &#123;</span><br><span class="line">        list.remove(obs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyAllObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : list) &#123;</span><br><span class="line">            <span class="comment">//更新每一个观察者中的信息</span></span><br><span class="line">            observer.update(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>ConcreteObserver</code></strong> 具体观察者&#x2F;订阅者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者模式: 观察者 实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-04-12:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverA</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//myState需要跟目标对象的state值保持一致</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> myState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMyState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> myState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMyState</span><span class="params">(<span class="type">int</span> myState)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myState = myState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新为和目标对象的值一致</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        myState = ((ConcreteSubject)subject).getState();</span><br><span class="line">        <span class="comment">//一但发送了改变 就会将改变后值打印到控制台</span></span><br><span class="line">        System.out.println(myState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>Client</code></strong> 客户端 调用代码 测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-04-12:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//目标对象</span></span><br><span class="line">        <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建多个观察者</span></span><br><span class="line">        <span class="type">ObserverA</span> <span class="variable">obs1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObserverA</span>();</span><br><span class="line">        <span class="type">ObserverA</span> <span class="variable">obs2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObserverA</span>();</span><br><span class="line">        <span class="type">ObserverA</span> <span class="variable">obs3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObserverA</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将这三个观察者添加到subject对象的观察者队伍中</span></span><br><span class="line">        subject.registerObserver(obs1);</span><br><span class="line">        subject.registerObserver(obs2);</span><br><span class="line">        subject.registerObserver(obs3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//改变subject的状态</span></span><br><span class="line">        subject.setState(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//我们查看观察者的状态是不是也发生了改变</span></span><br><span class="line"><span class="comment">//        System.out.println(obs1.);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//再次改变subject的状态</span></span><br><span class="line">        subject.setState(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果:</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209041306526.png" alt="image-20220904130656485"></p><p>可以发现目标对象的值发生修改后，所有订阅者都被通知了并且做出了响应的打印操作。</p><hr><h3 id="Java内置观察者模式实现"><a href="#Java内置观察者模式实现" class="headerlink" title="Java内置观察者模式实现"></a>Java内置观察者模式实现</h3><p>在 <code>java.util</code> 包中包含由基本的 <code>Observer</code> 接口和 <code>Observable</code> 抽象类，功能上和 <code>Observer</code> 接口和 <code>Subject</code> 接口类似。不过在使用上，内置的就方便许多了，因为i许多功能比如说<strong>注册</strong>、<strong>删除</strong>、<strong>通知</strong>观察者的哪些功能已经内置好了。</p><p><code>ConcreteSubject</code> 具体观察者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者模式: 目标对象</span></span><br><span class="line"><span class="comment"> * 继承 Observable</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-04-12:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> s)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.state = s; <span class="comment">//目标对象的状态发生了改变</span></span><br><span class="line">        setChanged(); <span class="comment">//表示目标对象已经做了更改</span></span><br><span class="line">        notifyObservers(state); <span class="comment">//通知所有的观察者(订阅者)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>观察者只需要继承Observable父类。发送消息的方式执行如下代码即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setChanged(); <span class="comment">//表示目标对象已经做了更改</span></span><br><span class="line">notifyObservers(state); <span class="comment">//通知所有的观察者(订阅者) 值发生了改变</span></span><br></pre></td></tr></table></figure><p><code>void setChange()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setChanged</span><span class="params">()</span> &#123;</span><br><span class="line">    changed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>void notifyObservers(Object arg)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(Object arg)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * a temporary array buffer, used as a snapshot of the state of</span></span><br><span class="line"><span class="comment">     * current Observers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object[] arrLocal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; <span class="comment">//获取锁 进入同步锁代码块 从主存中获取最新值</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (!changed) <span class="comment">// 获取到最新得changed 如果不为true就直接返回 否则执行如下代码</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        arrLocal = obs.toArray(); <span class="comment">//获取所有得订阅者</span></span><br><span class="line">        clearChanged(); <span class="comment">//清除修改标志</span></span><br><span class="line">    &#125; <span class="comment">//退出同步代码块 将值写入主存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//再调用订阅者得update方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        ((Observer)arrLocal[i]).update(<span class="built_in">this</span>, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ObserverA</code> 具体观察者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者模式: 观察者(消息订阅者)</span></span><br><span class="line"><span class="comment"> * 实现Observer接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-04-12:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverA</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//myState需要跟目标对象的state值保持一致</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> myState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMyState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> myState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMyState</span><span class="params">(<span class="type">int</span> myState)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myState = myState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span> &#123;</span><br><span class="line">        myState = ((ConcreteSubject) o).getState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Client</code> 客户端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-04-13:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//目标对象</span></span><br><span class="line">        <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建多个观察者</span></span><br><span class="line">        <span class="type">ObserverA</span> <span class="variable">obs1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObserverA</span>();</span><br><span class="line">        <span class="type">ObserverA</span> <span class="variable">obs2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObserverA</span>();</span><br><span class="line">        <span class="type">ObserverA</span> <span class="variable">obs3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObserverA</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将这三个观察者添加到subject对象的观察者队伍中</span></span><br><span class="line">        subject.addObserver(obs1);</span><br><span class="line">        subject.addObserver(obs2);</span><br><span class="line">        subject.addObserver(obs3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//改变subject的状态</span></span><br><span class="line">        subject.set(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//我们查看观察者的状态是不是也发生了改变</span></span><br><span class="line">        System.out.println(obs1.getMyState());</span><br><span class="line">        System.out.println(obs2.getMyState());</span><br><span class="line">        System.out.println(obs3.getMyState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再次改变subject的状态</span></span><br><span class="line">        subject.set(<span class="number">30</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//我们查看观察者的状态是不是也发生了改变</span></span><br><span class="line">        System.out.println(obs1.getMyState());</span><br><span class="line">        System.out.println(obs2.getMyState());</span><br><span class="line">        System.out.println(obs3.getMyState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移除一个订阅者</span></span><br><span class="line">        subject.deleteObserver(obs2);</span><br><span class="line">        subject.set(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//我们查看观察者的状态是不是也发生了改变</span></span><br><span class="line">        System.out.println(obs1.getMyState());</span><br><span class="line">        System.out.println(obs2.getMyState());</span><br><span class="line">        System.out.println(obs3.getMyState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>观察者也就是订阅者只需要实现Observer接口并重写相关update方法即可，在目标实现中我们发现触发的时候执行的就是观察者的update方法。</p><p>执行结果：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209041339351.png" alt="image-20220904133910295"></p><p>这样就实现了官方提供观察者模式，其实这里的Observable和Observer和我们前面自定义的Subject和Observer差不多，只是考虑更全面罢了。</p><h2 id="观察者模式适合应用场景"><a href="#观察者模式适合应用场景" class="headerlink" title="观察者模式适合应用场景"></a>观察者模式适合应用场景</h2><p> 当一个对象状态的改变需要改变其他对象， 或实际对象是事先未知的或动态变化的时， 可使用观察者模式。</p><p> 当你使用图形用户界面类时通常会遇到一个问题。 比如， 你创建了自定义按钮类并允许客户端在按钮中注入自定义代码， 这样当用户按下按钮时就会触发这些代码。</p><p>观察者模式允许任何实现了订阅者接口的对象订阅发布者对象的事件通知。 你可在按钮中添加订阅机制， 允许客户端通过自定义订阅类注入自定义代码。</p><p> 当应用中的一些对象必须观察其他对象时， 可使用该模式。 但仅能在有限时间内或特定情况下使用。</p><p> 订阅列表是动态的， 因此订阅者可随时加入或离开该列表。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li><p>仔细检查你的业务逻辑， 试着将其拆分为两个部分： 独立于其他代码的核心功能将作为发布者； 其他代码则将转化为一组订阅类。</p></li><li><p>声明订阅者接口。 该接口至少应声明一个 <code>update</code>方法。</p></li><li><p>声明发布者接口并定义一些接口来在列表中添加和删除订阅对象。 记住发布者必须仅通过订阅者接口与它们进行交互。</p></li><li><p>确定存放实际订阅列表的位置并实现订阅方法。 通常所有类型的发布者代码看上去都一样， 因此将列表放置在直接扩展自发布者接口的抽象类中是显而易见的。 具体发布者会扩展该类从而继承所有的订阅行为。</p><p>但是， 如果你需要在现有的类层次结构中应用该模式， 则可以考虑使用组合的方式： 将订阅逻辑放入一个独立的对象， 然后让所有实际订阅者使用该对象。</p></li><li><p>创建具体发布者类。 每次发布者发生了重要事件时都必须通知所有的订阅者。</p></li><li><p>在具体订阅者类中实现通知更新的方法。 绝大部分订阅者需要一些与事件相关的上下文数据。 这些数据可作为通知方法的参数来传递。</p><p>但还有另一种选择。 订阅者接收到通知后直接从通知中获取所有数据。 在这种情况下， 发布者必须通过更新方法将自身传递出去。 另一种不太灵活的方式是通过构造函数将发布者与订阅者永久性地连接起来。</p></li><li><p>客户端必须生成所需的全部订阅者， 并在相应的发布者处完成注册工作。</p></li></ol><h2 id="观察者模式优缺点"><a href="#观察者模式优缺点" class="headerlink" title="观察者模式优缺点"></a>观察者模式优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong><em>开闭原则</em>。 你无需修改发布者代码就能引入新的订阅者类 （如果是发布者接口则可轻松引入发布者类）。</strong></li><li>观察者模式在观察目标和观察者之间建立一个抽象的耦合。</li><li>观察者模式支持广播通信。</li><li>你可以在运行时建立对象之间的联系。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>订阅者的通知顺序是随机的这一点是不支持的。</li><li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化（可以自己定义，该缺点可以被解决）。</li></ul><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul><li><p><a href="https://refactoringguru.cn/design-patterns/chain-of-responsibility">责任链模式</a>、 <a href="https://refactoringguru.cn/design-patterns/command">命令模式</a>、 <a href="https://refactoringguru.cn/design-patterns/mediator">中介者模式</a>和<a href="https://refactoringguru.cn/design-patterns/observer">观察者模式</a>用于处理请求发送者和接收者之间的不同连接方式：</p><ul><li><em>责任链</em>按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。</li><li><em>命令</em>在发送者和请求者之间建立单向连接。</li><li><em>中介者</em>清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。</li><li><em>观察者</em>允许接收者动态地订阅或取消接收请求。</li></ul></li><li><p><a href="https://refactoringguru.cn/design-patterns/mediator">中介者</a>和<a href="https://refactoringguru.cn/design-patterns/observer">观察者</a>之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。</p><p><em>中介者</em>的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 <em>观察者</em>的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。</p><p>有一种流行的中介者模式实现方式依赖于<em>观察者</em>。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当<em>中介者</em>以这种方式实现时， 它可能看上去与<em>观察者</em>非常相似。</p><p>当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和<em>观察者</em>并不相同， 但这仍是一种中介者模式。</p><p>假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式–行为型模式之观察者模式&quot;&gt;&lt;a href=&quot;#设计模式–行为型模式之观察者模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式–行为型模式之观察者模式&quot;&gt;&lt;/a&gt;设计模式–行为型模式之观察者模式&lt;/h1&gt;&lt;h2 id=&quot;意图&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devildyw.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Developer" scheme="https://devildyw.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--行为型模式之中介者模式</title>
    <link href="https://devildyw.github.io/2022/09/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://devildyw.github.io/2022/09/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-09-03T04:13:53.000Z</published>
    <updated>2022-09-03T04:33:13.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式–行为型模式之中介者模式"><a href="#设计模式–行为型模式之中介者模式" class="headerlink" title="设计模式–行为型模式之中介者模式"></a>设计模式–行为型模式之中介者模式</h1><blockquote><p>定义一个对象来封装一系列对象的交互。中介者模式使各对象之间不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间地交互</p></blockquote><h2 id="场景介绍："><a href="#场景介绍：" class="headerlink" title="场景介绍："></a>场景介绍：</h2><p><strong>房产中介</strong></p><ol><li>假如没有总经理。下面三个部门：财务部、市场部、研发部。财务部要发工资，让大家核对公司需要跟市场部和研发部都通气；市场部要接个新项目，需要研发部处理技术、需要财务部出资金。市场部跟各个部门打交道。 虽然只有三个部门，但是关系非常乱。</li></ol><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209031218895.png" alt="img"></p><ol><li>实际上，公司都有总经理。各个部门有什么事情都通报到总经理这里，总经理再通知各个相关部门。</li></ol><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209031218868.png" alt="img"></p><ol><li>这就是一个典型的“中介者模式”，总经理起到一个中介、协调的作用</li></ol><p><strong>实现核心</strong></p><p>  如果一个系统中对象之间的联系呈现为网状结构，对象之间存在大量多对多关系，将导致关系及其复杂，这些对象称为”同事对象”，我们可以引入一个中介者对象，使各个同事对象只跟中介者对象打交道，将复杂的网络结构化解为星型结构。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209031218017.png" alt="img"></p><h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><ul><li>在用户与用户直接聊天的设计方案中，用户对象之间存在很强的关联性，将导致系统出现如下问题：</li><li>系统结构复杂：对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。</li><li>对象可重用性差：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。</li><li>系统扩展性低：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。</li><li>在面向对象的软件设计与开发过程中，根据“单一职责原则”，我们应该尽量将对象细化，使其只负责或呈现单一的职责。</li><li>对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式，这就是中介者模式的模式动机。</li></ul><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>中介者模式(Mediator Pattern)定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p>中介者模式包含如下角色：</p><ul><li><strong>Mediator: 抽象中介者</strong> 定义一个接口，该接口用于与各同事对象之间的通信；</li><li><strong>ConcreteMediator: 具体中介者</strong> 是抽象中介者的子类，通过协调各个同事对象来实现协作行为，了解并维护它的各个同事对象的引用；</li><li><strong>Colleague: 抽象同事类</strong> 定义各同事的公有方法；</li><li><strong>ConcreteColleague: 具体同事类</strong> 是抽象同事类的子类，每一个同事对象都引用一个中介者对象；</li></ul><p><strong>每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中定义的方法。</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209031219661.jpeg" alt="../_images/Mediator.jpg"></p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209031219678.jpeg" alt="../_images/seq_Mediator.jpg"></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>抽象中介者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中介者接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-03-11:51</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册 同事</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dname</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> d</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String dname, Department d)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行 处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">command</span><span class="params">(String dname)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体中介者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中介者的实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-03-11:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">President</span> <span class="keyword">implements</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Department&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Department&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String dname, Department d)</span> &#123;</span><br><span class="line">        map.put(dname,d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">command</span><span class="params">(String dname)</span> &#123;</span><br><span class="line">        map.get(dname).selfAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象同事类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同事类的接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-03-11:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">selfAction</span><span class="params">()</span>; <span class="comment">//做本部门的事情</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">outAction</span><span class="params">()</span>; <span class="comment">//向总经理发出申请</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体同事类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 财务部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-03-12:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Financial</span> <span class="keyword">implements</span> <span class="title class_">Department</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Financial</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">        <span class="comment">//注册到中介者的管理列表中</span></span><br><span class="line">        mediator.register(<span class="string">&quot;financial&quot;</span>,<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selfAction</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;提供资金支持！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outAction</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数钱&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开发部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-03-12:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Development</span> <span class="keyword">implements</span> <span class="title class_">Department</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Development</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">        mediator.register(<span class="string">&quot;development&quot;</span>,<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selfAction</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汇报工作！没钱了，需要资金支持！&quot;</span>);</span><br><span class="line">        <span class="comment">//中介者做协同处理 并不用我们单独去调用指定对象完成操作 而是借助了中介者</span></span><br><span class="line">        mediator.command(<span class="string">&quot;financial&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outAction</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;专心科研，开发项目！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 市场部 同事类的具体实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-03-11:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Market</span> <span class="keyword">implements</span> <span class="title class_">Department</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Market</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">        mediator.register(<span class="string">&quot;market&quot;</span>,<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selfAction</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汇报工作！项目承接的进度，需要资金支持！&quot;</span>);</span><br><span class="line"><span class="comment">//中介者做协同处理 并不用我们单独去调用指定对象完成操作 而是借助了中介者</span></span><br><span class="line">        mediator.command(<span class="string">&quot;financial&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outAction</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;跑去接项目！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-03-12:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取中介者对象</span></span><br><span class="line">        <span class="type">Mediator</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">President</span>();</span><br><span class="line">        <span class="comment">//获取同事对象，实例化的时候会在中介者对象中注册</span></span><br><span class="line">        <span class="type">Market</span> <span class="variable">market</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Market</span>(m);</span><br><span class="line">        <span class="type">Development</span> <span class="variable">development</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Development</span>(m);</span><br><span class="line">        <span class="type">Financial</span> <span class="variable">financial</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Financial</span>(m);</span><br><span class="line"></span><br><span class="line">        market.selfAction();</span><br><span class="line">        market.outAction();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过中介者的加入，将同事类之间的耦合关系松散，当同事之间有调用关系时，并不是通过添加引用直接调用，而是通过中介者完成协调。将这样的调用关系全部交给中介者。</strong></p><p><strong>执行结果：</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209031226123.png" alt="image-20220903122604085"></p><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>中介者模式可以使对象之间的关系数量急剧减少。</p><p>中介者承担两方面的职责：</p><ul><li>中转作用（结构性）：<strong>通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。该中转作用属于中介者在结构上的支持。</strong></li><li>协调作用（行为性）：<strong>中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。</strong></li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209031219419.jpeg" alt="../_images/Mediator_eg.jpg"></p><p>时序图</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209031219158.jpeg" alt="../_images/seq_Mediator_eg.jpg"></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>实例：虚拟聊天室</p><p>某论坛系统欲增加一个虚拟聊天室，允许论坛会员通过该聊天室进行信息交流，普通会员(CommonMember)可以给其他会员发送文本信息，钻石会员(DiamondMember)既可以给其他会员发送文本信息，还可以发送图片信息。该聊天室可以对不雅字符进行过滤，如“日”等字符；还可以对发送的图片大小进行控制。用中介者模式设计该虚拟聊天室。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>中介者模式的优点</p><ul><li>简化了对象之间的交互。</li><li>将各同事解耦。</li><li>减少子类生成。</li><li>可以简化各同事类的设计和实现。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>中介者模式的缺点</p><ul><li>在具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。</li></ul><h2 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h2><p>在以下情况下可以使用中介者模式：</p><ul><li>系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。</li><li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。</li><li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象。</li><li>交互的公共行为，如果需要改变行为则可以增加新的中介者类。</li></ul><h2 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h2><p><strong>MVC架构中控制器</strong></p><p>Controller 作为一种中介者，它负责控制视图对象View和模型对象Model之间的交互。如在Struts中，Action就可以作为JSP页面与业务对象之间的中介者。</p><h2 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h2><p>中介者模式与迪米特法则</p><ul><li>在中介者模式中，<strong>通过创造出一个中介者对象，将系统中有关的对象所引用的其他对象数目减少到最少</strong>，使得一个对象与其同事之间的相互作用被这个对象与中介者对象之间的相互作用所取代。因此，<strong>中介者模式就是迪米特法则的一个典型应用。</strong></li></ul><p>中介者模式与GUI开发</p><ul><li>中介者模式可以方便地应用于图形界面(GUI)开发中，在比较复杂的界面中可能存在多个界面组件之间的交互关系。</li><li>对于这些复杂的交互关系，有时候我们可以引入一个中介者类，将这些交互的组件作为具体的同事类，将它们之间的引用和控制关系交由中介者负责，在一定程度上简化系统的交互，这也是中介者模式的常见应用之一。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>中介者模式用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</li><li>中介者模式包含四个角色：抽象中介者用于定义一个接口，该接口用于与各同事对象之间的通信；具体中介者是抽象中介者的子类，通过协调各个同事对象来实现协作行为，了解并维护它的各个同事对象的引用；抽象同事类定义各同事的公有方法；具体同事类是抽象同事类的子类，每一个同事对象都引用一个中介者对象；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中定义的方法。</li><li>通过引入中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构，中介者承担了中转作用和协调作用。中介者类是中介者模式的核心，它对整个系统进行控制和协调，简化了对象之间的交互，还可以对对象间的交互进行进一步的控制。</li><li>中介者模式的主要优点在于简化了对象之间的交互，将各同事解耦，还可以减少子类生成，对于复杂的对象之间的交互，通过引入中介者，可以简化各同事类的设计和实现；中介者模式主要缺点在于具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。</li><li>中介者模式适用情况包括：系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解；一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象；想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式–行为型模式之中介者模式&quot;&gt;&lt;a href=&quot;#设计模式–行为型模式之中介者模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式–行为型模式之中介者模式&quot;&gt;&lt;/a&gt;设计模式–行为型模式之中介者模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;定</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devildyw.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Developer" scheme="https://devildyw.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--行为型模式之命令模式</title>
    <link href="https://devildyw.github.io/2022/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://devildyw.github.io/2022/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-09-01T13:34:46.000Z</published>
    <updated>2022-09-02T05:12:34.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式–行为型模式之命令模式"><a href="#设计模式–行为型模式之命令模式" class="headerlink" title="设计模式–行为型模式之命令模式"></a>设计模式–行为型模式之命令模式</h1><blockquote><p>将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作</p></blockquote><h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。</p><p>命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>命令模式(Command Pattern)：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p>命令模式包含如下角色：</p><ul><li><strong>Command: 抽象命令类</strong> 抽象命令类中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作；</li><li><strong>ConcreteCommand: 具体命令类</strong> 抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中；</li><li><strong>Invoker: 调用者</strong> 请求的发送者，又称为请求者，它通过命令对象来执行请求；</li><li><strong>Receiver: 接收者</strong> 接收者执行与请求相关的操作，它具体实现对请求的业务处理。</li><li><strong>Client:客户类</strong></li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209021255066.jpeg" alt="../_images/Command.jpg"></p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209021255813.jpeg" alt="../_images/seq_Command.jpg"></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>抽象命令类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-01-22:53</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 抽象命令角色</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 对子类的规范约束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体命令类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-01-22:56</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 具体命令对象</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 将会调用命令接收的方法 只是将一条一条的命令封装成了对象(请求) 命令始终是命令 真正执行的是接收命令的并执行的角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LightOffCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LightOffCommand</span><span class="params">(Receiver receiver)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        receiver.turnOFF();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LightOffCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LightOffCommand</span><span class="params">(Receiver receiver)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        receiver.turnOFF();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-01-22:59</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 命令调用者 负责调用</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 客户端通过将具体的命令对象创建后  传入该对象即可调用对应的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接收者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-01-22:57</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 命令接收者</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 正则执行命令的角色 命令对象内部会调用该对象的方法完成真正的命令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnON</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行开灯操作...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOFF</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行关灯操作...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-09-01-23:04</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 客户端</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 用户发送请求的客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//配置客户端</span></span><br><span class="line">        <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receiver</span>();</span><br><span class="line">        <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Invoker</span>();</span><br><span class="line">        <span class="comment">//创建请求</span></span><br><span class="line">        <span class="type">LightOnCommand</span> <span class="variable">lightOnCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightOnCommand</span>(receiver);</span><br><span class="line">        <span class="type">LightOffCommand</span> <span class="variable">lightOffCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightOffCommand</span>(receiver);</span><br><span class="line">        <span class="comment">//发送请求 并执行</span></span><br><span class="line">        invoker.execute(lightOnCommand);</span><br><span class="line">        invoker.execute(lightOffCommand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209021307264.png" alt="image-20220902130729225"></p><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p><strong>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。</strong></p><ul><li>每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。</li><li>命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li><li>命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li><li>命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>实例一：电视机遥控器</p><ul><li>电视机是请求的接收者，遥控器是请求的发送者，遥控器上有一些按钮，不同的按钮对应电视机的不同操作。抽象命令角色由一个命令接口来扮演，有三个具体的命令类实现了抽象命令接口，这三个具体命令类分别代表三种操作：打开电视机、关闭电视机和切换频道。显然，电视机遥控器就是一个典型的命令模式应用实例。</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209021255802.jpeg" alt="../_images/Command_eg.jpg"></p><p>时序图:</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202209021255789.jpeg" alt="../_images/seq_Command_eg.jpg"></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>命令模式的优点</p><ul><li>降低系统的耦合度。</li><li>新的命令可以很容易地加入到系统中。</li><li>可以比较容易地设计一个命令队列和宏命令（组合命令）。</li><li>可以方便地实现对请求的Undo和Redo。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>命令模式的缺点</p><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。</li></ul><h2 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h2><p>在以下情况下可以使用命令模式：</p><ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li><li>系统需要将一组操作组合在一起，即支持宏命令</li></ul><h2 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h2><p>很多系统都提供了宏命令功能，如UNIX平台下的Shell编程，可以将多条命令封装在一个命令对象中，只需要一条简单的命令即可执行一个命令序列，这也是命令模式的应用实例之一。</p><h2 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h2><p>宏命令又称为组合命令，它是命令模式和组合模式联用的产物。</p><p>-宏命令也是一个具体命令，不过它包含了对其他命令对象的引用，在调用宏命令的execute()方法时，将递归调用它所包含的每个成员命令的execute()方法，一个宏命令的成员对象可以是简单命令，还可以继续是宏命令。执行一个宏命令将执行多个具体命令，从而实现对命令的批处理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在命令模式中，将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作模式或事务模式。</li><li>命令模式包含四个角色：抽象命令类中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作；具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中；调用者即请求的发送者，又称为请求者，它通过命令对象来执行请求；接收者执行与请求相关的操作，它具体实现对请求的业务处理。</li><li>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li><li>命令模式的主要优点在于降低系统的耦合度，增加新的命令很方便，而且可以比较容易地设计一个命令队列和宏命令，并方便地实现对请求的撤销和恢复；其主要缺点在于可能会导致某些系统有过多的具体命令类。</li><li>命令模式适用情况包括：需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互；需要在不同的时间指定请求、将请求排队和执行请求；需要支持命令的撤销操作和恢复操作，需要将一组操作组合在一起，即支持宏命令。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式–行为型模式之命令模式&quot;&gt;&lt;a href=&quot;#设计模式–行为型模式之命令模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式–行为型模式之命令模式&quot;&gt;&lt;/a&gt;设计模式–行为型模式之命令模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;将一个请求</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devildyw.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Developer" scheme="https://devildyw.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--结构型模式之代理模式</title>
    <link href="https://devildyw.github.io/2022/08/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://devildyw.github.io/2022/08/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-30T03:57:19.000Z</published>
    <updated>2022-08-30T04:17:10.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式–结构型模式之代理模式"><a href="#设计模式–结构型模式之代理模式" class="headerlink" title="设计模式–结构型模式之代理模式"></a>设计模式–结构型模式之代理模式</h1><blockquote><p>给某一个对象提供一个代理或占位符，并且代理对象来控制对原对象的访问</p></blockquote><h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>在某些情况下，一个客户不想或者不能直接引用一个对 象，此时可以通过一个称之为“代理”的第三者来实现 间接引用。代理对象可以在客户端和目标对象之间起到 <strong>中介</strong>的作用，<strong>并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。</strong></p><p>通过引入一个新的对象（如小图片和远程代理 对象）来实现对真实对象的操作或者将新的对 象作为真实对象的一个替身，这种实现机制即 为代理模式，通过引入代理对象来间接访问一 个对象，这就是代理模式的模式动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>代理模式(Proxy Pattern) ：给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。代理模式的英 文叫做Proxy或Surrogate，它是一种对象结构型模式。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p>代理模式包含如下角色：</p><ul><li><strong>Subject: 抽象主题角色</strong> 声明了真实主题和代理主题的共同接口；</li><li><strong>Proxy: 代理主题角色</strong> 内部包含对真实主题的引用，从而可以在任何时候操作真实主题对象，<strong>控制和限制被代理角色的实现，并且拥有自己的处理方法（预处理和善后）</strong>；</li><li><strong>RealSubject: 真实主题角色</strong> 定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的方法。</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208301159203.jpeg" alt="../_images/Proxy.jpg"></p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208301159540.jpeg" alt="../_images/seq_Proxy.jpg"></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>抽象主题角色</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">movie</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真实主题角色</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Star</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">movie</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getClass().getSimpleName() + <span class="string">&quot;: 经纪人接了一部电影,我负责拍就好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理主题角色</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被代理对象  代理角色持有被代理角色的引用</span></span><br><span class="line">    <span class="keyword">private</span> Subject star;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建时注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Agent</span><span class="params">(Subject star)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.star = star;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为代理角色添加了额外的服务 这里是接戏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">movie</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getClass().getSimpleName() + <span class="string">&quot;: 剧本很好，这部电影接下了&quot;</span>);</span><br><span class="line">        star.movie();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端Client：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">star</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Star</span>();</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Agent</span>(star);</span><br><span class="line">        </span><br><span class="line">        proxy.movie();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208301205678.png" alt="image-20220830120554645"></p><p>代理角色持有被代理角色的引用，<strong>要访问被代理角色必须通过代理</strong>，负责被代理角色本职之外的职能，并且具有准入和过滤的功能。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>代理模式的优点</p><ul><li><strong>代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。</strong></li><li><strong>远程代理使得客户端可以访问在远程机器上的对象，远程机器 可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</strong></li><li><strong>虚拟代理通过使用一个小对象来代表一个大对象，可以减少系 统资源的消耗，对系统进行优化并提高运行速度。</strong></li><li><strong>保护代理可以控制对真实对象的使用权限。</strong></li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>代理模式的缺点</p><ul><li><strong>由于在客户端和真实主题之间增加了代理对象，因此 有些类型的代理模式可能会造成请求的处理速度变慢。</strong></li><li><strong>实现代理模式需要额外的工作，有些代理模式的实现 非常复杂。</strong></li></ul><h2 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h2><p>根据代理模式的使用目的，常见的代理模式有以下几种类型：</p><ul><li>远程(Remote)代理：为一个位于不同的地址空间的对象提供一个本地 的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在 另一台主机中，远程代理又叫做大使(Ambassador)。</li><li>虚拟(Virtual)代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li><li>Copy-on-Write代理：它是虚拟代理的一种，把复制（克隆）操作延迟 到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个 开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li><li>保护(Protect or Access)代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li><li>缓冲(Cache)代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li><li>防火墙(Firewall)代理：保护目标不让恶意用户接近。</li><li>同步化(Synchronization)代理：使几个用户能够同时使用一个对象而没有冲突。</li><li>智能引用(Smart Reference)代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。</li></ul><h2 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h2><p>EJB、Web Service等分布式技术都是代理模式的应用。在EJB中使用了RMI机制，远程服务器中的企业级Bean在本地有一个桩代理，客户端通过桩来调用远程对象中定义的方法，而无须直接与远程对象交互。在EJB的使用中需要提供一个公共的接口，客户端针对该接口进行编程，无须知道桩以及远程EJB的实现细节。</p><p><strong>在调用某个接口前后做日志处理，这时使用代理也可以满足对修改关闭，对扩展开发的原则。（用动态代理做更方便，更轻便）</strong></p><h2 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h2><p>几种常用的代理模式</p><ul><li>图片代理：一个很常见的代理模式的应用实例就是对大图浏览的控制。</li><li>用户通过浏览器访问网页时先不加载真实的大图，而是通过代理对象的方法来进行处理，在代理对象的方法中，先使用一个线程向客户端浏览器加载一个小图片，然后在后台使用另一个线程来调用大图片的加载方法将大图片加载到客户端。当需要浏览大图片时，再将大图片在新网页中显示。如果用户在浏览大图时加载工作还没有完成，可以再启动一个线程来显示相应的提示信息。通过代理技术结合多线程编程将真实图片的加载放到后台来操作，不影响前台图片的浏览。</li><li>远程代理：远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户完全可以认为被代理的远程业务对象是局域的而不是远程的，而远程代理对象承担了大部分的网络通信工作。</li><li>虚拟代理：当一个对象的加载十分耗费资源的时候，虚拟代理的优势就非常明显地体现出来了。虚拟代理模式是一种内存节省技术，那些占用大量内存或处理复杂的对象将推迟到使用它的时候才创建。</li></ul><p>-在应用程序启动的时候，可以用代理对象代替真实对象初始化，节省了内存的占用，并大大加速了系统的启动时间。</p><p><strong>动态代理</strong></p><ul><li>动态代理是一种较为高级的代理模式，它的典型应用就是Spring AOP。</li><li>在传统的代理模式中，客户端通过Proxy调用RealSubject类的request()方法，同时还在代理类中封装了其他方法(如preRequest()和postRequest())，可以处理一些其他问题。</li><li>如果按照这种方法使用代理模式，那么真实主题角色必须是事先已经存在的，并将其作为代理对象的内部成员属性。如果一个真实主题角色必须对应一个代理主题角色，这将导致系统中的类个数急剧增加，因此需要想办法减少系统中类的个数，此外，如何在事先不知道真实主题角色的情况下使用代理主题角色，这都是动态代理需要解决的问题。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在代理模式中，要求给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。 - 代理模式包含三个角色：抽象主题角色声明了真实主题和代理主题的共同接口；代理主题角色内部包含对真实主题的引用，从而可以在任何时候操作真实主题对象；真实主题角色定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的方法。 - 代理模式的优点在于能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；其缺点在于由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，并且实现代理模式需要额外的工作，有些代理模式的实现非常复杂。远程代理为一个位于不同的地址空间的对象提供一个本地的代表对象，它使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。- 如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建，这个小对象称为虚拟代理。虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。 - 保护代理可以控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</p><blockquote><p>后续会学习 Java的动态代理。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式–结构型模式之代理模式&quot;&gt;&lt;a href=&quot;#设计模式–结构型模式之代理模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式–结构型模式之代理模式&quot;&gt;&lt;/a&gt;设计模式–结构型模式之代理模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给某一个对</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devildyw.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Developer" scheme="https://devildyw.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--结构型模式之享元模式</title>
    <link href="https://devildyw.github.io/2022/08/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>https://devildyw.github.io/2022/08/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-29T04:07:31.000Z</published>
    <updated>2022-08-29T05:26:12.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式–结构型模式之享元模式"><a href="#设计模式–结构型模式之享元模式" class="headerlink" title="设计模式–结构型模式之享元模式"></a>设计模式–结构型模式之享元模式</h1><blockquote><p>运用共享技术有效地支持大量细粒度对象的复用</p></blockquote><blockquote><p>spring的常量池、数据库连接池、缓冲池等等这些都是享元模式的应用</p><p>比如：我们每次创建字符串对象时，如果每次都创建一个新的字符串对象的话，内存开销会很大，所以如果第一次创建了字符串对象“七夕“，下次再创建相同的字符串”七夕“时，只是把它的引用指向”七夕“，这样就实现了”七夕“字符串再内存中的共享。</p></blockquote><p><strong>享元拆开来讲，享，即共享，元，可以理解为元数据，内存当中的数据，对象。看来是共享对象喽</strong></p><h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>面向对象技术可以很好地解决一些灵活性或可扩展性问题，但在很多情况下需要在系统中增加类和对象的个数。当对象数量太多时，将导致运行代价过高，带来性能下降等问题。</p><ul><li>享元模式正是为解决这一类问题而诞生的。享元模式通过共享技术实现相同或相似对象的重用。</li><li>在享元模式中可以共享的相同内容称为内部状态(IntrinsicState)，而那些需要外部环境来设置的不能共享的内容称为外部状态(Extrinsic State)，由于区分了内部状态和外部状态，因此可以通过设置不同的外部状态使得相同的对象可以具有一些不同的特征，而相同的内部状态是可以共享的。</li><li>在享元模式中通常会出现工厂模式，需要创建一个享元工厂来负责维护一个享元池(Flyweight Pool)用于存储具有相同内部状态的享元对象。</li><li>在享元模式中共享的是享元对象的内部状态，外部状态需要通过环境来设置。在实际使用中，能够共享的内部状态是有限的，因此享元对象一般都设计为较小的对象，它所包含的内部状态较少，这种对象也称为细粒度对象。享元模式的目的就是使用共享技术来实现大量细粒度对象的复用。</li></ul><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p>享元模式包含如下角色：</p><ul><li><strong>Flyweight: 抽象享元类</strong> 定义了享元对象需要实现的公共操作方法。在该方法中会使用一个状态作为输入参数，也叫外部状态。</li><li><strong>ConcreteFlyweight: 具体享元类</strong> 能够复用享元工厂内部状态并实现享元类公共操作的具体实现类。</li><li><strong>UnsharedConcreteFlyweight: 非共享具体享元类</strong> 不复用享元工厂内部状态，但实现享元类的具体实现类。</li><li><strong>FlyweightFactory: 享元工厂类</strong> 管理一个享元对象类的缓存池</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208291310426.jpeg" alt="../_images/Flyweight.jpg"></p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208291310753.jpeg" alt="../_images/seq_Flyweight.jpg"></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 <em>Circle</em> 对象。</p><p>对于相同颜色不同坐标的圆，我们可以将原有颜色的圆复用，这样可以减少很多内存空间，如果不进行复用而是每个坐标每个颜色圆都创建新的对象，那么该示例中就会出现20个新增对象。</p><p><strong>抽象享元类</strong> 创建一个Shape接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体享元类</strong> 创建实现接口的实体类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="comment">//颜色</span></span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//x坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//y坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//半径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(<span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRadius</span><span class="params">(<span class="type">int</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Circle: Draw()[&quot;</span> +</span><br><span class="line">                <span class="string">&quot;color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, x=&quot;</span> + x +</span><br><span class="line">                <span class="string">&quot;, y=&quot;</span> + y +</span><br><span class="line">                <span class="string">&quot;, radius=&quot;</span> + radius +</span><br><span class="line">                <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>享元工厂类</strong> 创建一个工厂，生成基于给定信息的实体类的对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个缓存池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String, Shape&gt; circleMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> color 颜色</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Shape</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title function_">getCircle</span><span class="params">(String color)</span>&#123;</span><br><span class="line">        <span class="comment">//从缓存池中获取 防止每次都生成新的对象导致内存中对象数量太多(节约内存空间)</span></span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> (Circle) circleMap.get(color);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果缓冲池中没有 才去创建新的对象 并且将创建好的对象加入缓存池中</span></span><br><span class="line">        <span class="keyword">if</span> (circle == <span class="literal">null</span>)&#123;</span><br><span class="line">            circle = <span class="keyword">new</span> <span class="title class_">Circle</span>(color);</span><br><span class="line">            circleMap.put(color,circle);</span><br><span class="line">            System.out.println(<span class="string">&quot;Creating circle of color : &quot;</span> + color);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端</strong> 使用该工厂，通过传递颜色信息来获取实体类的对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String colors[] = &#123;<span class="string">&quot;Red&quot;</span>, <span class="string">&quot;Green&quot;</span>, <span class="string">&quot;Blue&quot;</span>, <span class="string">&quot;White&quot;</span>, <span class="string">&quot;Black&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> (Circle) ShapeFactory.getCircle(getRandomColor());</span><br><span class="line">            circle.setX(getRandomX());</span><br><span class="line">            circle.setY(getRandomY());</span><br><span class="line">            circle.setRadius(<span class="number">100</span>);</span><br><span class="line">            circle.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取随机颜色</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getRandomColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> colors[(<span class="type">int</span>) (Math.random() * colors.length)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取随机x坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getRandomX</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取随机y坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getRandomY</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208291319413.png" alt="image-20220829131943337"></p><p>可以发现我们花了20个不同坐标不同颜色的圆，但实际上只创建了5个对象。</p><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>享元模式是一个考虑系统性能的设计模式，通过使用享元模式可以节约内存空间，提高系统的性能。</p><p>享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。</p><p><strong>享元模式以共享的方式高效地支持大量的细粒度对象，享元对象能做到共享的关键是区分内部状态(Internal State)和外部状态(External State)。</strong></p><ul><li><strong>内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享（例如该示例中的圆的颜色）。</strong></li><li><strong>外部状态是随环境改变而改变的、不可以共享的状态（例如该示例中圆的坐标）。</strong>享元对象的外部状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>spring的常量池、数据库连接池、缓冲池等；英雄联盟中，一台服务器要连接多个客户端（多个玩家），如果每个玩家进去地图都要创建对象，那对象将无数啊。。。。。所以这里要使用享元模式，将地图对象减少到几个实例。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>享元模式的优点</p><ul><li>享元模式的优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。</li><li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>享元模式的缺点</p><ul><li>享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。</li><li>为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。</li></ul><h2 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h2><p>在以下情况下可以使用享元模式：</p><ul><li>一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费。</li><li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li><li>使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。</li></ul><h2 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h2><p>享元模式在编辑器软件中大量使用，如在一个文档中多次出现相同的图片，则只需要创建一个图片对象，通过在应用程序中设置该图片出现的位置，可以实现该图片在不同地方多次重复显示。</p><h2 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h2><p>单纯享元模式和复合享元模式</p><ul><li>单纯享元模式：在单纯享元模式中，所有的享元对象都是可以共享的，即所有抽象享元类的子类都可共享，不存在非共享具体享元类。</li><li>复合享元模式：将一些单纯享元使用组合模式加以组合，可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。</li></ul><p>享元模式与其他模式的联用</p><ul><li>在享元模式的享元工厂类中通常提供一个静态的工厂方法用于返回享元对象，使用简单工厂模式来生成享元对象。</li><li>在一个系统中，通常只有唯一一个享元工厂，因此享元工厂类可以使用单例模式进行设计。</li><li>享元模式可以结合组合模式形成复合享元模式，统一对享元对象设置外部状态。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>享元模式运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用，它是一种对象结构型模式。</li><li>享元模式包含四个角色：抽象享元类声明一个接口，通过它可以接受并作用于外部状态；具体享元类实现了抽象享元接口，其实例称为享元对象；非共享具体享元是不能被共享的抽象享元类的子类；享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中。</li><li>享元模式以共享的方式高效地支持大量的细粒度对象，享元对象能做到共享的关键是区分内部状态和外部状态。其中内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享；外部状态是随环境改变而改变的、不可以共享的状态。</li><li>享元模式主要优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份；其缺点是使得系统更加复杂，并且需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。</li><li>享元模式适用情况包括：一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费；对象的大部分状态都可以外部化，可以将这些外部状态传入对象中；多次重复使用享元对象。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式–结构型模式之享元模式&quot;&gt;&lt;a href=&quot;#设计模式–结构型模式之享元模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式–结构型模式之享元模式&quot;&gt;&lt;/a&gt;设计模式–结构型模式之享元模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;运用共享技</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devildyw.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Developer" scheme="https://devildyw.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--结构型模式之外观模式</title>
    <link href="https://devildyw.github.io/2022/08/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://devildyw.github.io/2022/08/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-28T03:59:27.000Z</published>
    <updated>2022-08-28T05:33:39.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式–结构型模式之外观模式"><a href="#设计模式–结构型模式之外观模式" class="headerlink" title="设计模式–结构型模式之外观模式"></a>设计模式–结构型模式之外观模式</h1><blockquote><p>为子系统的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</p></blockquote><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p>外观模式包含如下角色：</p><ul><li><strong>Facade: 外观角色</strong>  客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理；</li><li><strong>SubSystem:子系统角色</strong> 在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能。</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208281326965.jpeg" alt="../_images/Facade.jpg"></p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208281325570.jpeg" alt="../_images/seq_Facade.jpg"></p><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。 -外观模式也是“迪米特法则”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。 - 外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。 -外观模式的目的在于降低系统的复杂程度。 -外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>假设一台电脑，它包含了 CPU（处理器），Memory（内存） ，Disk（硬盘）这几个部件，若想要启动电脑，则先后必须启动 CPU、Memory、Disk。关闭也是如此。</p><p>但是实际上我们在电脑开&#x2F;关机时根本不需要去操作这些组件，因为电脑已经帮我们都处理好了，并隐藏了这些东西。</p><p>这些组件好比子系统角色，而电脑就是一个外观角色。</p><h3 id="SubSystem-子系统角色"><a href="#SubSystem-子系统角色" class="headerlink" title="SubSystem 子系统角色"></a>SubSystem 子系统角色</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CPU</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startup</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cpu startup!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cpu shutdown!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startup</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;memory startup!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;memory shutdown!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Disk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;disk startup!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;disk shutdown!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Facade-外观角色"><a href="#Facade-外观角色" class="headerlink" title="Facade 外观角色"></a>Facade 外观角色</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CPU cpu;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Memory memory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Disk disk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu = <span class="keyword">new</span> <span class="title class_">CPU</span>();</span><br><span class="line">        <span class="built_in">this</span>.memory = <span class="keyword">new</span> <span class="title class_">Memory</span>();</span><br><span class="line">        <span class="built_in">this</span>.disk = <span class="keyword">new</span> <span class="title class_">Disk</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开机时 computer的startup方法 帮助我们调用了各个组件的开机方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start the computer!&quot;</span>);</span><br><span class="line">        cpu.startup();</span><br><span class="line">        memory.startup();</span><br><span class="line">        disk.startup();</span><br><span class="line">        System.out.println(<span class="string">&quot;start computer finished!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关机时 computer的shutdown方法 帮助我们调用了各个组件的关机方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;begin to close the computer!&quot;</span>);</span><br><span class="line">        cpu.shutdown();</span><br><span class="line">        memory.shutdown();</span><br><span class="line">        disk.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;computer closed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        computer.startup();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line">        computer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208281331933.png" alt="image-20220828133152882"></p><hr><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>外观模式的优点</p><ul><li>对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。</li><li>实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。</li><li>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li><li>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>外观模式的缺点</p><ul><li>不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</li><li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li></ul><h2 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h2><p>在以下情况下可以使用外观模式：</p><ul><li>当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。</li><li>客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。</li><li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li></ul><h2 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h2><ul><li><p>一个系统有多个外观类</p><p>在外观模式中，通常只需要一个外观类，并且此外观类只有一个实例，换言之它是一个单例类。在很多情况下为了节约系统资源，一般将外观类设计为单例类。当然这并不意味着在整个系统里只能有一个外观类，在一个系统中可以设计多个外观类，每个外观类都负责和一些特定的子系统交互，向用户提供相应的业务功能。</p></li><li><p>不要试图通过外观类为子系统增加新行为</p><p>不要通过继承一个外观类在子系统中加入新的行为，这种做法是错误的。外观模式的用意是为子系统提供一个集中化和简化的沟通渠道，而不是向子系统加入新的行为，新的行为的增加应该通过修改原有子系统类或增加新的子系统类来实现，不能通过外观类来实现。</p></li><li><p>外观模式与迪米特法则</p><p>外观模式创造出一个外观对象，将客户端所涉及的属于一个子系统的协作伙伴的数量减到最少，使得客户端与子系统内部的对象的相互作用被外观对象所取代。外观类充当了客户类与子系统类之间的“第三者”，降低了客户类与子系统类之间的耦合度，外观模式就是实现代码重构以便达到“迪米特法则”要求的一个强有力的武器。</p></li><li><p>抽象外观类的引入</p><p>外观模式最大的缺点在于违背了“开闭原则”，当增加新的子系统或者移除子系统时需要修改外观类，可以通过引入抽象外观类在一定程度上解决该问题，客户端针对抽象外观类进行编程。对于新的业务需求，不修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改源代码并更换外观类的目的。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在外观模式中，外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。</li><li>外观模式包含两个角色：外观角色是在客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理；在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能。</li><li>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</li><li>外观模式主要优点在于对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易，它实现了子系统与客户之间的松耦合关系，并降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程；其缺点在于不能很好地限制客户使用子系统类，而且在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li><li>外观模式适用情况包括：要为一个复杂子系统提供一个简单接口；客户程序与多个子系统之间存在很大的依赖性；在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式–结构型模式之外观模式&quot;&gt;&lt;a href=&quot;#设计模式–结构型模式之外观模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式–结构型模式之外观模式&quot;&gt;&lt;/a&gt;设计模式–结构型模式之外观模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;为子系统的</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devildyw.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Developer" scheme="https://devildyw.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--结构型模式之装饰模式</title>
    <link href="https://devildyw.github.io/2022/08/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>https://devildyw.github.io/2022/08/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-27T03:26:46.000Z</published>
    <updated>2022-08-27T04:52:05.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式–结构型模式之装饰模式"><a href="#设计模式–结构型模式之装饰模式" class="headerlink" title="设计模式–结构型模式之装饰模式"></a>设计模式–结构型模式之装饰模式</h1><blockquote><p>动态地给一个对象增加一些额外的职责，就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案</p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>有时我们希望给某个对象而不是整个类添加一些功能，虽然使用继承是添加功能的一种方式，但是不够灵活，而且会导致子类增加了无用功能，耦合性太强。一种较为灵活的方式是将对象嵌入另一个对象中，通过该对象添加功能，称这个嵌入的对象为装饰。这个装饰与被装饰的对象接口一致，它将请求转发给被装饰对象，并在转发的前后进行额外操作。 装饰模式就是<strong>动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。</strong></p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>装饰模式包含如下角色：</p><ul><li><strong>Component: 抽象构件</strong> 定义了对象的接口，可以给这些对 象动态增加职责（方法）；</li><li><strong>ConcreteComponent: 具体构件（也可称为被装饰者）</strong> 具体构件定义了具体的构件对象，实现了 在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）；</li><li><strong>Decorator: 抽象装饰类</strong>   抽象装饰类是抽象构件类的子类，用于给具体构件增加职责，但是具 体职责在其子类中实现；</li><li><strong>ConcreteDecorator: 具体装饰类（装饰者）</strong> 具体装饰类是抽象装饰类的子类，负责向构 件添加新的职责。</li></ul><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><ul><li>模式名称：<strong>DECORATOR</strong>（装饰）</li><li>类型：对象结构型模式</li><li>意图：动态地给一个对象添加一些额外的职责。就增加功能来说， Decorator模式相比生成子类更为灵活。</li><li>适用性：<ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li></ul></li><li>效果：</li><li>优点：<ul><li>比继承更灵活。</li><li>避免在层次结构高层的类有太多的特征。</li><li>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。</li><li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”</li></ul></li><li>缺点：<ul><li>多层装饰比较复杂，加大学习与理解的难度</li><li>较与继承更加容易出错，排错也比较困难。</li></ul></li></ul><h2 id="下面通过一个例子，来深入理解装饰模式"><a href="#下面通过一个例子，来深入理解装饰模式" class="headerlink" title="下面通过一个例子，来深入理解装饰模式"></a>下面通过一个例子，来深入理解装饰模式</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">有一家咖啡店，生意很火爆，想要更新订单系统，来满足目前的饮料供应需求。原先的设计如下：</span><br><span class="line">有一个饮料的抽象类，所有的饮品都继承此类。类中包含了变量 description(描述)，和方法 getDescription()获取描述信息，以及抽象方法cost()花费。子类要实现cost方法。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208271225090.webp" alt="image.png"></p><p>在原先饮品种类少的情况还可以，如果说为了提高市场竞争力和消费升级，要增加多种饮品，并按照加入的不同调味品收取不同的费用。要是还按照之前的方式创建子类实现cost，就会造成子类过多，并且如果某一种调味料价格有变动，需要修改的类就很多，不利于维护。</p><p>这时可能会说直接在饮料类中添加调味料变量，设置和获取是否有某种调味料的方法就好了，将饮料类中cost方法提供实现，用于判断调味料的价钱，子类只需 计算自己的价值，配置有哪种调料，并加上父类的就行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 饮料类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">double</span> milkCost;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">double</span> soyCost;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">double</span> mochaCost;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">double</span> whipCost;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> hasMilk;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> hasSoy;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> hasMocha;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> hasWhip;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDescription</span><span class="params">(String description)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHasMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hasMilk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHasMilk</span><span class="params">(<span class="type">boolean</span> hasMilk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hasMilk = hasMilk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHasSoy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hasSoy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHasSoy</span><span class="params">(<span class="type">boolean</span> hasSoy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hasSoy = hasSoy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHasMocha</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hasMocha;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHasMocha</span><span class="params">(<span class="type">boolean</span> hasMocha)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hasMocha = hasMocha;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHasWhip</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hasWhip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHasWhip</span><span class="params">(<span class="type">boolean</span> hasWhip)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hasWhip = hasWhip;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">condimentCost</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(hasMilk)&#123;</span><br><span class="line">            condimentCost+=milkCost;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(hasMocha)&#123;</span><br><span class="line">            condimentCost+=mochaCost;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(hasSoy)&#123;</span><br><span class="line">            condimentCost+=soyCost;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(hasWhip)&#123;</span><br><span class="line">            condimentCost+= whipCost;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> condimentCost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DarkRoast</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DarkRoast</span><span class="params">()</span> &#123;</span><br><span class="line">        setDescription(<span class="string">&quot;Most Excellent Dark Roast&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2.3</span> + <span class="built_in">super</span>.cost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种方式存在几个问题：</p><ol><li>调料价格变东需要修改现有代码</li><li>添加或删除新的调料，需要变动相应的变量和方法，以及 cost的计算。</li><li>如果有新的饮料不适合原有调料加入，子类依然有这些没用的调料。</li><li>如果想要双倍调料还需要修改cost并且添加变量。 由此看出这种方式明显违反了设计原则中的 开闭原则：对扩展开放，对修改关闭。在例子中，变化的是每种饮料的价格，价格需要根据调味品发生改变。那就先以饮料作为对象，用调味品对象装饰。</li></ol><p>装饰模式类图结构</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208271225028.webp" alt="image.png"></p><p>从中可以看出：</p><ol><li>装饰者和被装饰着有相同的父类</li><li>可以使用一个或多个装饰类装饰对象</li><li>装饰对象可以替代被装饰类对象。</li><li>装饰对象可以在被装饰者的行为执行前后进行操作。</li></ol><p>根据装饰者模式进行调整</p><ol><li>先将饮料作为被封装者</li></ol><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208271225061.webp" alt="image.png"></p><p>2.用摩卡装饰饮料</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208271225111.webp" alt="image.png"></p><p>3.再将被摩卡装饰的对象作为被装饰者，使用 奶泡进行装饰</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208271225312.webp" alt="image.png"></p><p>下面来看下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">装饰和被装饰的父类 </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span>  <span class="title class_">Beverage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被装饰者类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DarkRoast</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DarkRoast&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2.3</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装饰者的父类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CondimentDecorator</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Beverage beverage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CondimentDecorator</span> <span class="params">(Beverage beverage)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Beverage <span class="title function_">getBeverage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装饰者实现类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mocha</span> <span class="keyword">extends</span> <span class="title class_">CondimentDecorator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mocha</span><span class="params">(Beverage beverage)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(beverage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getBeverage().getDescription()+<span class="string">&quot; Mocha&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBeverage().cost()+<span class="number">.20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Whip</span> <span class="keyword">extends</span> <span class="title class_">CondimentDecorator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Whip</span><span class="params">(Beverage beverage)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(beverage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getBeverage().getDescription()+<span class="string">&quot; Whip&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBeverage().cost()+<span class="number">.10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用情况</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//声明了具体构建</span></span><br><span class="line">        <span class="type">Beverage</span> <span class="variable">beverage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DarkRoast</span>();</span><br><span class="line">        System.out.println(beverage.getDescription()+<span class="string">&quot; $ &quot;</span>+beverage.cost());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对其进行装饰</span></span><br><span class="line">        <span class="type">Mocha</span> <span class="variable">mocha</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mocha</span>(beverage);</span><br><span class="line">        System.out.println(mocha.getDescription()+<span class="string">&quot; $ &quot;</span>+mocha.cost());</span><br><span class="line"></span><br><span class="line">        <span class="type">Whip</span> <span class="variable">whip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Whip</span>(beverage);</span><br><span class="line">        System.out.println(whip.getDescription()+<span class="string">&quot; $ &quot;</span>+ whip.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208271250750.png" alt="image-20220827124904754"></p><h2 id="Java-I-x2F-O的装饰模式"><a href="#Java-I-x2F-O的装饰模式" class="headerlink" title="Java I&#x2F;O的装饰模式"></a>Java I&#x2F;O的装饰模式</h2><p>java.io包内的类看起来比较多，其实就是利用了装饰模式</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208271225042.webp" alt="image.png"></p><p>其中：<code>InputStream</code>是装饰类和被装饰类的父类；<code>FileInputStream</code>，<code>StringBufferInputStream</code>，<code>ByteArrayInputStream</code>是被装饰类， <code>FilterInputStream</code>是装饰类的父类，<code>BufferedInputStream</code>，<code>LineNumberInputStream</code>，<code>DataInputStream</code>是装饰类。</p><h2 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h2><p>在以下情况下可以使用装饰模式：</p><ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。</li><li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）.</li></ul><h2 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h2><p>装饰模式的简化-需要注意的问题:</p><ul><li>一个装饰类的接口必须与被装饰类的接口保持相同，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待。</li><li>尽量保持具体构件类Component作为一个“轻”类，也就是说不要把太多的逻辑和状态放在具体构件类中，可以通过装饰类</li></ul><p>对其进行扩展。 - 如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式–结构型模式之装饰模式&quot;&gt;&lt;a href=&quot;#设计模式–结构型模式之装饰模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式–结构型模式之装饰模式&quot;&gt;&lt;/a&gt;设计模式–结构型模式之装饰模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;动态地给一</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devildyw.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Developer" scheme="https://devildyw.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--结构型模式之桥接模式</title>
    <link href="https://devildyw.github.io/2022/08/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://devildyw.github.io/2022/08/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-26T08:15:05.000Z</published>
    <updated>2022-08-27T04:38:11.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式–结构型模式之桥接模式"><a href="#设计模式–结构型模式之桥接模式" class="headerlink" title="设计模式–结构型模式之桥接模式"></a>设计模式–结构型模式之桥接模式</h1><blockquote><p>将抽象部分与它的实现部分解耦，使得两个都能够独立变化</p></blockquote><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><blockquote><p>推荐一读的概述</p></blockquote><p>毛笔和蜡笔是两种很常见的文具，它们都归属于画笔。假设需要大、中、小 3 种型号的画笔，能够绘制 12 种不同的颜色，如果使用蜡笔，需要准备 3 × 12 &#x3D; 36 支，但是如果使用毛笔，只需要提供 3 种型号的毛笔，外加一个包含 12 种颜色的调色板，涉及的对象个数仅为 3 + 12 &#x3D; 15，远小于 36 ，却能够实现 36 支蜡笔同样的功能。如果增加一种新型号的画笔，并且也需要具有 12 种颜色，对应的蜡笔需要增加 12 支，而毛笔只需要增加 1 支。</p><p>不难得知，在蜡笔中，颜色和型号两个不同的变化维度耦合在一起，无论是对颜色进行扩展还是对型号进行扩展势必会影响另一个维度；但在毛笔中，颜色和型号实现了分离，增加新的颜色或者型号对另一方没有任何影响。如果使用软件工程中的术语，可以认为在蜡笔中颜色和型号之间存在较强的耦合性，而毛笔很好地将二者解耦，使用起来更加的灵活，扩展也更为方便。在软件开发中有一种设计模式可以用来处理与画笔类似的具有多变化维度的情况，这就是<strong>桥接模式</strong>。</p><p>在桥接模式中将两个独立变化的维度设计为两个独立的继承等级结构，而不是将二者耦合在一起形成多层继承结构。桥接模式在抽象层建立起一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。</p><blockquote><p><strong>桥接模式</strong>：将抽象部分与它的实现部分解耦，使得两者都能够独立变化。</p></blockquote><p>桥接模式是一种对象结构型模式，它又被称为柄体（Handle and Body）模式或接口（Interface）模式。桥接模式用一种巧妙地方式处理多层继承存在的问题，用抽象关系取代了传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系，使得系统更加灵活，并易于扩展，同时有效地控制了系统中类的个数。</p><h2 id="2-结构与实现"><a href="#2-结构与实现" class="headerlink" title="2 结构与实现"></a>2 结构与实现</h2><h3 id="2-1-桥接模式结构"><a href="#2-1-桥接模式结构" class="headerlink" title="2.1 桥接模式结构"></a>2.1 桥接模式结构</h3><p>桥接模式包含以下 4 个角色：</p><ol><li>**Abstraction(抽象类)**：其中定义了一个实现类接口类型的对象并可以维护该对象，它与 Implementor 之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。</li><li><strong>RefinedAbstraction(扩充抽象类)<strong>：它扩充由抽象类定义的接口，它实现了在抽象类中定义的抽象业务方法，</strong>在扩充抽象类中可以调用在实现类接口中定义的业务方法；</strong></li><li>**Implementor(实现类接口)**：实现类接口定义了实现类的接口，实现类接口仅提供基本操作，而抽象类定义的接口可能会做更多更复杂的操作；</li><li>**ConcreteImplementor(具体实现类)**：具体实现类实现了实现类接口并且具体实现它，在不同的具体实现类中提供基本操作的不同实现，在程序运行时，具体实现类对象将替换其父类对象，提供给客户端具体的业务操作方法。</li></ol><h3 id="2-2-桥接模式举例"><a href="#2-2-桥接模式举例" class="headerlink" title="2.2 桥接模式举例"></a>2.2 桥接模式举例</h3><h4 id="一、背景介绍"><a href="#一、背景介绍" class="headerlink" title="一、背景介绍"></a>一、背景介绍</h4><p>某软件公司要开发一个跨平台图像浏览系统，要求该系统能够显示 BMP、JPG、GIF、PNG 等多种格式的文件，并且能够在 Windows、Linux、UNIX 等多个操作系统上运行。系统首先将各种格式的文件解析为像素矩阵（Matrix），然后将像素矩阵显示在屏幕上，在不同的操作系统中可以调用不同的绘制函数来绘制像素矩阵。系统需要具有较好的扩展性，以便在将来支持新的文件格式和操作系统。请使用桥接模式。</p><h4 id="二、项目结构"><a href="#二、项目结构" class="headerlink" title="二、项目结构"></a>二、项目结构</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208261617013.png" alt="image-20220826161740971"></p><h4 id="三、项目-UML"><a href="#三、项目-UML" class="headerlink" title="三、项目 UML"></a>三、项目 UML</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208261615858.webp" alt="UML"></p><h4 id="四、抽象类"><a href="#四、抽象类" class="headerlink" title="四、抽象类"></a>四、抽象类</h4><h5 id="Image-抽象类"><a href="#Image-抽象类" class="headerlink" title="Image 抽象类"></a>Image 抽象类</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Image</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title class_">OSImpl</span> osImpl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入实现类接口对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Image</span>(<span class="title class_">OSImpl</span> osImpl) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">osImpl</span> = osImpl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">void</span> <span class="title function_">parseFile</span>(<span class="title class_">String</span> fileName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="五、扩充抽象类"><a href="#五、扩充抽象类" class="headerlink" title="五、扩充抽象类"></a>五、扩充抽象类</h4><h5 id="BMPImage-扩充抽象类"><a href="#BMPImage-扩充抽象类" class="headerlink" title="BMPImage 扩充抽象类"></a>BMPImage 扩充抽象类</h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BMPImage</span> <span class="keyword">extends</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    public <span class="type">BMPImage</span>(<span class="type">OSImpl</span> osImpl) &#123;</span><br><span class="line">        <span class="keyword">super</span>(osImpl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void parseFile(<span class="type">String</span> fileName) &#123;</span><br><span class="line">        <span class="comment">//模拟解析BMP文件并获取一个像素矩阵对象 m</span></span><br><span class="line">        <span class="type">Matrix</span> matrix = <span class="keyword">new</span> <span class="type">Matrix</span>();</span><br><span class="line">        osImpl.doPaint(matrix);</span><br><span class="line">        <span class="type">System</span>.out.println(fileName+<span class="string">&quot;, 格式为BMP.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JPGImage-扩充抽象类"><a href="#JPGImage-扩充抽象类" class="headerlink" title="JPGImage 扩充抽象类"></a>JPGImage 扩充抽象类</h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">JPGImage</span> <span class="keyword">extends</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    public <span class="type">JPGImage</span>(<span class="type">OSImpl</span> osImpl) &#123;</span><br><span class="line">        <span class="keyword">super</span>(osImpl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void parseFile(<span class="type">String</span> fileName) &#123;</span><br><span class="line">        <span class="comment">//模拟解析BMP文件并获取一个像素矩阵对象 m</span></span><br><span class="line">        <span class="type">Matrix</span> matrix = <span class="keyword">new</span> <span class="type">Matrix</span>();</span><br><span class="line">        osImpl.doPaint(matrix);</span><br><span class="line">        <span class="type">System</span>.out.println(fileName+<span class="string">&quot;, 格式为JPG.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="GIFImage-扩充抽象类"><a href="#GIFImage-扩充抽象类" class="headerlink" title="GIFImage 扩充抽象类"></a>GIFImage 扩充抽象类</h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">GIFImage</span> <span class="keyword">extends</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    public <span class="type">GIFImage</span>(<span class="type">OSImpl</span> osImpl) &#123;</span><br><span class="line">        <span class="keyword">super</span>(osImpl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void parseFile(<span class="type">String</span> fileName) &#123;</span><br><span class="line">        <span class="comment">//模拟解析BMP文件并获取一个像素矩阵对象 m</span></span><br><span class="line">        <span class="type">Matrix</span> matrix = <span class="keyword">new</span> <span class="type">Matrix</span>();</span><br><span class="line">        osImpl.doPaint(matrix);</span><br><span class="line">        <span class="type">System</span>.out.println(fileName+<span class="string">&quot;, 格式为GIF.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="PNGImage-扩充抽象类"><a href="#PNGImage-扩充抽象类" class="headerlink" title="PNGImage 扩充抽象类"></a>PNGImage 扩充抽象类</h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PNGImage</span> <span class="keyword">extends</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    public <span class="type">PNGImage</span>(<span class="type">OSImpl</span> osImpl) &#123;</span><br><span class="line">        <span class="keyword">super</span>(osImpl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void parseFile(<span class="type">String</span> fileName) &#123;</span><br><span class="line">        <span class="comment">//模拟解析BMP文件并获取一个像素矩阵对象 m</span></span><br><span class="line">        <span class="type">Matrix</span> matrix = <span class="keyword">new</span> <span class="type">Matrix</span>();</span><br><span class="line">        osImpl.doPaint(matrix);</span><br><span class="line">        <span class="type">System</span>.out.println(fileName+<span class="string">&quot;, 格式为PNG.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="六、实现类接口"><a href="#六、实现类接口" class="headerlink" title="六、实现类接口"></a>六、实现类接口</h4><h5 id="OSImpl"><a href="#OSImpl" class="headerlink" title="OSImpl"></a>OSImpl</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OSImpl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPaint</span><span class="params">(Matrix m)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="七、具体实现类"><a href="#七、具体实现类" class="headerlink" title="七、具体实现类"></a>七、具体实现类</h4><h5 id="WindowsImpl"><a href="#WindowsImpl" class="headerlink" title="WindowsImpl"></a>WindowsImpl</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowImpl</span> <span class="keyword">implements</span> <span class="title class_">OSImpl</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">doPaint</span>(<span class="params">Matrix m</span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">print</span>(<span class="string">&quot;在 Windows 操作系统中显示图像：&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="LinuxImpl"><a href="#LinuxImpl" class="headerlink" title="LinuxImpl"></a>LinuxImpl</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinuxImpl</span> <span class="keyword">implements</span> <span class="title class_">OSImpl</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">doPaint</span>(<span class="params">Matrix m</span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">print</span>(<span class="string">&quot;在 Linux 操作系统中显示图像：&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="UnixImpl"><a href="#UnixImpl" class="headerlink" title="UnixImpl"></a>UnixImpl</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnixImpl</span> <span class="keyword">implements</span> <span class="title class_">OSImpl</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">doPaint</span>(<span class="params">Matrix m</span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">print</span>(<span class="string">&quot;在 Unix 操作系统中显示图像：&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="八、Matrix-辅助类"><a href="#八、Matrix-辅助类" class="headerlink" title="八、Matrix 辅助类"></a>八、Matrix 辅助类</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="九、测试客户类"><a href="#九、测试客户类" class="headerlink" title="九、测试客户类"></a>九、测试客户类</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        Image image;</span><br><span class="line">        image = <span class="keyword">new</span> <span class="built_in">GIFImage</span>(<span class="keyword">new</span> <span class="built_in">WindowImpl</span>());</span><br><span class="line">        image.<span class="built_in">parseFile</span>(<span class="string">&quot;杜颖淼&quot;</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;--------------------------------------------&quot;</span>);</span><br><span class="line">        image = <span class="keyword">new</span> <span class="built_in">PNGImage</span>(<span class="keyword">new</span> <span class="built_in">LinuxImpl</span>());</span><br><span class="line">        image.<span class="built_in">parseFile</span>(<span class="string">&quot;这是一个文件&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="十、测试结果"><a href="#十、测试结果" class="headerlink" title="十、测试结果"></a>十、测试结果</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208261621578.png" alt="image-20220826162105535"></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>从举例容易看出，客户端面向抽象编程，每个维度都有一个高级抽象类，每个维度的具体选项继承自该高级抽象类。<strong>举例中我们通过 xml 配置文件配置各个维度的选择，选择什么类型的图片？选择什么操作系统？实现了不同维度的的解耦。</strong></p><p>桥接模式十设计 Java 虚拟机和实现 JDBC 等驱动程序的核心模式之一，应用较为广泛。在软件开发中如果一个类或一个系统有多个变化维度都可以尝试使用桥接模式对其进行设计。桥接模式为多维度变化的系统提供了一套完整的解决方案，并且降低了系统的复杂度。</p><h3 id="3-1-桥接模式优点"><a href="#3-1-桥接模式优点" class="headerlink" title="3.1 桥接模式优点"></a>3.1 桥接模式优点</h3><ol><li>分离抽象接口及其实现部分。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓的抽象何实现沿着各自维度的变化，也就是说抽象和实现不在同一个继承层次结构中，而是“子类化”它们，使它们各自具有自己的子类，以便任意组合子类，从而获得多维度组合对象。</li><li>在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了单一职责原则，复用性较差，并且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大地减少了子类的个数。</li><li>桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度都不需要修改原有系统，符合开闭原则。</li></ol><h3 id="3-2-桥接模式缺点"><a href="#3-2-桥接模式缺点" class="headerlink" title="3.2 桥接模式缺点"></a>3.2 桥接模式缺点</h3><ol><li>桥接模式的使用会增加系统的理解和设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。</li><li>桥接模式要求正确地识别出系统中地两个独立变化的维度，因此其使用的范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。</li></ol><h3 id="3-3-桥接模式适用环境"><a href="#3-3-桥接模式适用环境" class="headerlink" title="3.3 桥接模式适用环境"></a>3.3 桥接模式适用环境</h3><ol><li>如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li><li>抽象部分和实现部分可以用继承的方式独立扩展而互不影响，在程序运行时可以动态地将一个抽象化子类地对象和一个实现化子类地对象进行组合，即系统需要对抽象化角色和实现化角色进行多态耦合。</li><li>一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展。</li><li>对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</li></ol><blockquote><p>抽象类和实现类接口都可以对调，因为对于不同规格的毛笔而言，每一种规格都可以有不同的颜色使用；对于不同的颜色而言每一种颜色都有不同规格的毛笔来使用。我们使用时权衡即可。</p></blockquote><h1 id="推荐链接"><a href="#推荐链接" class="headerlink" title="推荐链接"></a>推荐链接</h1><p><a href="https://zhuanlan.zhihu.com/p/58903776">秒懂设计模式之桥接模式（Bridge Pattern） - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式–结构型模式之桥接模式&quot;&gt;&lt;a href=&quot;#设计模式–结构型模式之桥接模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式–结构型模式之桥接模式&quot;&gt;&lt;/a&gt;设计模式–结构型模式之桥接模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;将抽象部分</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devildyw.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Developer" scheme="https://devildyw.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--结构型设计模式之适配器模式</title>
    <link href="https://devildyw.github.io/2022/08/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://devildyw.github.io/2022/08/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-25T07:51:20.000Z</published>
    <updated>2022-08-27T04:37:06.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式–结构型设计模式之适配器模式"><a href="#设计模式–结构型设计模式之适配器模式" class="headerlink" title="设计模式–结构型设计模式之适配器模式"></a>设计模式–结构型设计模式之适配器模式</h1><blockquote><p>将一个类的接口转换成客户希望的另一个接口。该模式让接口不兼容的类可以一起工作</p></blockquote><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><h3 id="1）概述"><a href="#1）概述" class="headerlink" title="1）概述"></a>1）概述</h3><p>​        在现实生活中，经常出现两个对象因接口不兼容而不能在一起工作的实例，这时需要第三者进行适配。例如，讲中文的人同讲英文的人对话时需要一个翻译，用直流电的笔记本电脑接交流电源时需要一个电源适配器，用计算机访问照相机的 SD 内存卡时需要一个读卡器等。还有像下面这张图一样：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208251751012.webp" alt="在这里插入图片描述"></p><p>​        在软件设计中也可能出现：</p><ol><li><strong>需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题。</strong></li><li>如果想增加现有组件的复用率也可以使用适配器模式。</li></ol><h3 id="2）介绍"><a href="#2）介绍" class="headerlink" title="2）介绍"></a>2）介绍</h3><p>适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p><p>Adapter模式的宗旨：<strong>保留现有类所提供的服务，向客户提供接口，以满足客户的期望</strong>。</p><h3 id="3）角色结构"><a href="#3）角色结构" class="headerlink" title="3）角色结构"></a>3）角色结构</h3><p>适配器模式（Adapter）包含以下主要角色：</p><ul><li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li><li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ul><blockquote><p>适配器就是使用现有的组件（适配者）来实现目标接口规范（目标接口）来完成转化的一个类。</p></blockquote><h3 id="4）使用场景"><a href="#4）使用场景" class="headerlink" title="4）使用场景"></a>4）使用场景</h3><p>适配器模式（Adapter）通常适用于以下场景。</p><ul><li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。（<del>就是所谓的加一层，一层不行就加两层</del>）😁</li><li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li></ul><h2 id="二、类适配器"><a href="#二、类适配器" class="headerlink" title="二、类适配器"></a>二、类适配器</h2><p>当客户在接口中定义了他期望的行为时，我们就可以应用适配器模式，提供一个实现该接口的类，并且扩展已有的类，通过创建子类来实现适配。</p><p><code>实现方式</code>：<strong>定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件</strong>。</p><p>我们直接用之前的那个图来做个例子：中国人到了欧洲，的给自己电脑充电，但因为自己电脑是双叉，欧式是三叉，这中间就得需要一个转换器。<strong>对于电脑而言，它只能是双叉的，但是现在只有三叉的插座，想要充电，就必须能让双叉的插头能够插入三叉的插座上，此时我们需要一个适配器，将三叉插座的电传输给双叉的插头。此时的目标是双叉，需要将三叉的电传输到双叉的线上。</strong></p><blockquote><p>可能使用sd卡和tf卡的案例比较好理解，对于同一台电脑而言它只能插入sd卡，但是呢我们现在不想让他插入sd读取数据了，我想让他读取tf卡，但是电脑不能匹配，此时就只能使用tf卡转sd的适配器了，通过读sd的方式读取了tf卡。对于该问题，目标接口就是sd卡，而适配者是tf卡，tf卡不符合现有接口规范（sd卡），需要通过适配器（适配器通过现有组件tf的读写方式实现了sd接口的规范）完成了转化。</p></blockquote><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208251751008.webp" alt="在这里插入图片描述"></p><h3 id="2-1、代码"><a href="#2-1、代码" class="headerlink" title="2.1、代码"></a>2.1、代码</h3><p>适配者（Adaptee）：即图中的欧式三叉</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EuropeSocket</span> &#123;</span><br><span class="line">    <span class="comment">/** 欧式三叉 通电 接通电 插座*/</span></span><br><span class="line">    String <span class="title function_">useEuropesocket</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 欧式三叉实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EuropeSocketImpl</span> <span class="keyword">implements</span> <span class="title class_">EuropeSocket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">useEuropesocket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span><span class="string">&quot;使用欧式三叉充电&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标（Target）接口：即中国双叉</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChineseSocket</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用中国双叉充电</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">useChineseSocket</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中国插头的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChineseSocketImpl</span> <span class="keyword">implements</span> <span class="title class_">ChineseSocket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">useChineseSocket</span><span class="params">()</span> &#123;</span><br><span class="line">        String msg=<span class="string">&quot;使用中国双叉充电&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适配器（Adapter）类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义适配器类 中国双叉转为欧洲三叉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChineseAdapterEurope</span> <span class="keyword">extends</span> <span class="title class_">EuropeSocketImpl</span> <span class="keyword">implements</span> <span class="title class_">ChineseSocket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">useChineseSocket</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用转换器转换完成&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> useEuropesocket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>电脑类，对于电脑类而言，它只能使用双叉的充电器，所以客户端希望的目标类就是中国双叉。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">useChineseSocket</span><span class="params">(ChineseSocket chineseSocket)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(chineseSocket == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;sd card null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chineseSocket.useChineseSocket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">ChineseSocket</span> <span class="variable">chineseSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChineseSocketImpl</span>();</span><br><span class="line">        System.out.println(computer.useChineseSocket(chineseSocket));</span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        <span class="type">ChineseAdapterEurope</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChineseAdapterEurope</span>();</span><br><span class="line">        System.out.println(computer.useChineseSocket(adapter));</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出：</span></span><br><span class="line"><span class="comment">         * 使用中国双叉充电</span></span><br><span class="line"><span class="comment">         * ------------</span></span><br><span class="line"><span class="comment">         * 使用转换器转换完成</span></span><br><span class="line"><span class="comment">         * 使用欧式三叉充电</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码就是简单的演示了适配器的使用。</p><p><code>注</code>:类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。</p><h2 id="三、对象适配器"><a href="#三、对象适配器" class="headerlink" title="三、对象适配器"></a>三、对象适配器</h2><p>对象适配器”通过组合除了满足“用户期待接口”还降低了代码间的不良耦合。在工作中推荐使用“对象适配”。</p><p>实现方式：<strong>对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口</strong>。</p><p>题目还是和上面一样的哈。代码其实差异很小</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>适配者（Adaptee）：即图中的欧式三叉</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EuropeSocket</span> &#123;</span><br><span class="line">    <span class="comment">/** 欧式三叉 通电 接通电 插座*/</span></span><br><span class="line">    String <span class="title function_">useEuropesocket</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 欧式三叉实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EuropeSocketImpl</span> <span class="keyword">implements</span> <span class="title class_">EuropeSocket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">useEuropesocket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span><span class="string">&quot;使用欧式三叉充电&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标（Target）接口：即中国双叉</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChineseSocket</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用中国双叉充电</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">useChineseSocket</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中国插头的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChineseSocketImpl</span> <span class="keyword">implements</span> <span class="title class_">ChineseSocket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">useChineseSocket</span><span class="params">()</span> &#123;</span><br><span class="line">        String msg=<span class="string">&quot;使用中国双叉充电&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适配器（Adapter）类： 就是这个适配器内做了一些更改 从继承改为了成员变量的方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChineseAdapterEurope</span> <span class="keyword">implements</span> <span class="title class_">ChineseSocket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EuropeSocket europeSocket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChineseAdapterEurope</span><span class="params">(EuropeSocket europeSocket)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.europeSocket = europeSocket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">useChineseSocket</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用转换器转换完成&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> europeSocket.useEuropesocket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>电脑类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">useChineseSocket</span><span class="params">(ChineseSocket chineseSocket)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(chineseSocket == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;sd card null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chineseSocket.useChineseSocket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">ChineseSocket</span> <span class="variable">chineseSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChineseSocketImpl</span>();</span><br><span class="line">        System.out.println(computer.useChineseSocket(chineseSocket));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        <span class="comment">//这里做了更改</span></span><br><span class="line">        EuropeSocket europeSocket=<span class="keyword">new</span> <span class="title class_">EuropeSocketImpl</span>();</span><br><span class="line">        <span class="type">ChineseAdapterEurope</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChineseAdapterEurope</span>(europeSocket);</span><br><span class="line">        System.out.println(computer.useChineseSocket(adapter));</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出：</span></span><br><span class="line"><span class="comment">         * 使用中国双叉充电</span></span><br><span class="line"><span class="comment">         * ------------</span></span><br><span class="line"><span class="comment">         * 使用转换器转换完成</span></span><br><span class="line"><span class="comment">         * 使用欧式三叉充电</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是对象适配器啦，</p><p>适合于解决问题常见：</p><ul><li>　需要的东西有，但不能用，且短时间无法改造。即，使得一个功能适合不同的环境。</li><li>　　在开发中，系统的数据、行为都匹配，但接口不符时，可以考虑适配器。</li><li>　　<strong>希望复用一些现存的类，但是接口又与复用环境的要求不一致，应该考虑用适配器模式。</strong>（使用一个已经存在的类，但它的接口（即，方法)，与需要的不相同时）</li></ul><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><strong>适配器模式（Adapter）可扩展为双向适配器模式，双向适配器类既可以把适配者接口转换成目标接口，也可以把目标接口转换成适配者接口</strong>。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p><strong>优点</strong>：</p><ul><li>客户端通过适配器可以透明地调用目标接口。</li><li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。<strong>提高了类的复用</strong></li><li><strong>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题</strong>。灵活性好</li><li>可以让任何两个没有关联的类一起运行</li><li><strong>在很多业务场景中符合开闭原则</strong></li></ul><p><strong>其缺点是</strong>：</p><ul><li>适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。</li><li>增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。（如：明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难）</li></ul><p> <strong>核心思想：</strong></p><p>继承或者依赖（引用）适配者对象，然后实现目标的接口。确保原来代码不改变的情况下，增加新的功能。</p><p>因为目标类是需要使用的，而我们现在并不能直接使用目标类（一个已存在的类，但是它不符合现有的接口规范），而需要通过适配器将现有的组件转化为目标类，所以适配器需由现有组件实现目标接口的功能（转化使其符合现有规范）来完成转化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式–结构型设计模式之适配器模式&quot;&gt;&lt;a href=&quot;#设计模式–结构型设计模式之适配器模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式–结构型设计模式之适配器模式&quot;&gt;&lt;/a&gt;设计模式–结构型设计模式之适配器模式&lt;/h1&gt;&lt;blockquo</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devildyw.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Developer" scheme="https://devildyw.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot Actuator</title>
    <link href="https://devildyw.github.io/2022/08/23/Spring%20Boot%20Actuator/"/>
    <id>https://devildyw.github.io/2022/08/23/Spring%20Boot%20Actuator/</id>
    <published>2022-08-23T11:50:23.000Z</published>
    <updated>2022-08-23T14:09:05.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot-Actuator"><a href="#Spring-Boot-Actuator" class="headerlink" title="Spring Boot Actuator"></a>Spring Boot Actuator</h1><p>在企业级应用中，学习了如何进行SpringBoot应用的功能开发，以及如何写单元测试、集成测试等还是不够的。在实际的软件开发中还需要：<strong>应用程序的监控和管理</strong>。SpringBoot的Actuator模块实现了应用的监控与管理。这样的需求在分布式服务中基本是必须的，项目上线后的监控也是如此</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>生产系统中，往往需要对系统实际运行的情况（例如cpu、io、disk、db、业务功能等指标）进行监控运维。在SpringBoot项目中Actuator模块提供了众多HTTP接口端点（Endpoint），<strong>来提供应用程序运行时的内部状态信息。</strong></p><p>Actuator模块提供了一个监控和管理生产环境的模块，可以使用<strong>http、jmx、ssh、telnet等</strong>来管理和监控应用。包括应用的审计（Auditing）、健康（health）状态信息、数据采集（metrics gathering）统计等监控运维的功能。同时，提供了可以扩展 Actuator端点（Endpoint）自定义监控指标。这些指标都是以<strong>JSON接口数据的方式呈现</strong>。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用Spring Boot Actuator需要加入如下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>actuator并没有默认集成在自动配置中（所以需要手动引入），而在作为独立的项目来呈现的。当引入了上面的依赖，默认会引入actuator相关的两个项目：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-actuator-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中<code>spring-boot-actuator</code>为功能实现，<code>spring-boot-actuator-autoconfigure</code>为自动配置。</p><p>需要注意：因<code>SpringBoot Actuator</code>会暴露服务的详细信息，为了保障安全性，建议添加安全控制的相关依赖<code>spring-boot-starter-security</code>，这样在访问应用监控端点时，都需要输入验证信息。所需依赖如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然也可以手动自定义不需要引入<code>security</code></p><p>关于security的使用我们在此不进行展开，可在application文件中配置相应的访问密码：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">admin</span></span><br></pre></td></tr></table></figure><p>经过以上步骤的操作，启动SpringBoot项目，actuator便自动集成配置了，可通过：</p><p><a href="http://localhost:8080/actuator">http://localhost:8080/actuator</a> 访问，结果如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_links&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;self&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://localhost:8080/actuator&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;health&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://localhost:8080/actuator/health&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;health-path&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://localhost:8080/actuator/health/&#123;*path&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>默认支持的链接有：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/actuator</span><br><span class="line">/actuator/health</span><br><span class="line">/actuator/health/&#123;*path&#125;</span><br></pre></td></tr></table></figure><p>可以在application配置文件中配置开启更多的监控信息：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">info:</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#/info获取info前缀的配置信息 这一项必不可少</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">ALWAYS</span></span><br><span class="line">    <span class="attr">shutdown:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li><p><code>management.endpoints.web.exposure.include</code>&#x3D;’*’，代表开启全部监控，也可仅配置需要开启的监控，如： <code>management.endpoints.web.exposure.include</code>&#x3D;beans,trace。</p></li><li><p><code>management.endpoint.health.show-details</code>&#x3D;always，health endpoint开启显示全部细节。默认情况下&#x2F;actuator&#x2F;health是公开的，但不显示细节。</p></li><li><p><code>management.endpoints.web.base-path</code>&#x3D;&#x2F;monitor，启用指定的url地址访问根路径，默认路径为&#x2F;actuator&#x2F;*，开启则访问路径变为&#x2F;monitor&#x2F;*。</p></li><li><p><code>management.endpoint.shutdown.enabled</code>&#x3D;true，启用接口关闭<code>SpringBoot</code>。</p></li></ul><p>监控信息如果需要跨越调用，可通过<code>CORS</code>配置来支持，默认处于禁用状态。设置<code>management.endpoints.web.cors.allowed-origins</code>属性后开启。</p><p>比如允许来自<a href="https://www.choupangxia.com/">https://www.choupangxia.com</a> 域的GET和POST调用：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">cors:</span></span><br><span class="line">        <span class="attr">allowed-origins:</span> <span class="string">https://www.choupangxia.com</span></span><br><span class="line">        <span class="attr">allowed-methods:</span> <span class="string">GET,POST</span></span><br></pre></td></tr></table></figure><h2 id="REST接口"><a href="#REST接口" class="headerlink" title="REST接口"></a>REST接口</h2><p>Spring Boot Actuator提供了非常丰富的监控接口，可以通过这些接口了解应用程序运行时的内部状况。Actuator也支持用户自定义添加端点，可以根据实际应用，定义一些比较关心的指标，在运行期进行监控。</p><table><thead><tr><th>HTTP方法</th><th>路径</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>&#x2F;auditevents</td><td>显示当前应用程序的审计事件信息</td></tr><tr><td>GET</td><td>&#x2F;beans</td><td>显示一个应用中所有Spring Beans的完整列表</td></tr><tr><td>GET</td><td>&#x2F;conditions</td><td>显示配置类和自动配置类(configuration and auto-configuration classes)的状态及它们被应用或未被应用的原因。</td></tr><tr><td>GET</td><td>&#x2F;configprops</td><td>显示一个所有@ConfigurationProperties的集合列表</td></tr><tr><td>GET</td><td>&#x2F;env</td><td>显示来自Spring的ConfigurableEnvironment的属性。</td></tr><tr><td>GET</td><td>&#x2F;flyway</td><td>显示数据库迁移路径，如果有的话。</td></tr><tr><td>GET</td><td>&#x2F;health</td><td>显示应用的健康信息（当使用一个未认证连接访问时显示一个简单的’status’，使用认证连接访问则显示全部信息详情）</td></tr><tr><td>GET</td><td>&#x2F;info</td><td>显示任意的应用信息</td></tr><tr><td>GET</td><td>&#x2F;liquibase</td><td>展示任何Liquibase数据库迁移路径，如果有的话</td></tr><tr><td>GET</td><td>&#x2F;metrics</td><td>展示当前应用的metrics信息</td></tr><tr><td>GET</td><td>&#x2F;mappings</td><td>显示一个所有@RequestMapping路径的集合列表</td></tr><tr><td>GET</td><td>&#x2F;scheduledtasks</td><td>显示应用程序中的计划任务</td></tr><tr><td>GET</td><td>&#x2F;sessions</td><td>允许从Spring会话支持的会话存储中检索和删除(retrieval and deletion)用户会话。使用Spring Session对反应性Web应用程序的支持时不可用。</td></tr><tr><td>POST</td><td>&#x2F;shutdown</td><td>允许应用以优雅的方式关闭（默认情况下不启用）</td></tr><tr><td>GET</td><td>&#x2F;threaddump</td><td>执行一个线程dump</td></tr></tbody></table><p>如果使用web应用(Spring MVC, Spring WebFlux, 或者 Jersey)，还可以使用以下接口：</p><table><thead><tr><th>HTTP方法</th><th>路径</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>&#x2F;heapdump</td><td>返回一个GZip压缩的hprof堆dump文件</td></tr><tr><td>GET</td><td>&#x2F;jolokia</td><td>通过HTTP暴露JMX beans（当Jolokia在类路径上时，WebFlux不可用）</td></tr><tr><td>GET</td><td>&#x2F;logfile</td><td>返回日志文件内容（如果设置了logging.file或logging.path属性的话），支持使用HTTP Range头接收日志文件内容的部分信息</td></tr><tr><td>GET</td><td>&#x2F;prometheus</td><td>以可以被Prometheus服务器抓取的格式显示metrics信息</td></tr></tbody></table><h2 id="接口详解"><a href="#接口详解" class="headerlink" title="接口详解"></a>接口详解</h2><p>health主要用来检查应用的运行状态，这是使用频次最高的监控点。通常使用此接口显示应用实例的运行状态，以及应用不“健康”的原因，比如数据库连接、磁盘空间不够等，如常用的eureka，zookeeper，consul注册中心就是靠该接口检测实例健康状态的。</p><p>默认情况下health的状态是开放的，访问：<a href="http://localhost:8080/actuator/health">http://localhost:8080/actuator/health</a> 即可看到应用的状态。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;UP&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>设置状态码顺序：<code>setStatusOrder(Status.DOWN,Status.OUT*OF*SERVICE, Status.UP, Status.UNKNOWN</code>)。过滤掉不能识别的状态码。如果无任何状态码，整个<code>SpringBoot</code>应用的状态是UNKNOWN。将所有收集到的状态码排序。返回有序状态码序列中的第一个状态码，作为整个<code>SpringBoot</code>应用的状态。</p><p>Health通过合并几个健康指数检查应用的健康情况。<code>SpringBoot Actuator</code>会自动配置以下内容：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code>CassandraHealthIndicator</code></td><td>检查Cassandra数据库是否已启动。</td></tr><tr><td><code>CouchbaseHealthIndicator</code></td><td>检查Couchbase群集是否已启动。</td></tr><tr><td><code>DiskSpaceHealthIndicator</code></td><td>检查磁盘空间不足。</td></tr><tr><td><code>DataSourceHealthIndicator</code></td><td>检查是否可以建立连接DataSource。</td></tr><tr><td><code>ElasticsearchHealthIndicator</code></td><td>检查Elasticsearch集群是否已启动。</td></tr><tr><td><code>InfluxDbHealthIndicator</code></td><td>检查InfluxDB服务器是否已启动。</td></tr><tr><td><code>JmsHealthIndicator</code></td><td>检查JMS代理是否启动。</td></tr><tr><td><code>MailHealthIndicator</code></td><td>检查邮件服务器是否已启动。</td></tr><tr><td><code>MongoHealthIndicator</code></td><td>检查Mongo数据库是否已启动。</td></tr><tr><td><code>Neo4jHealthIndicator</code></td><td>检查Neo4j服务器是否已启动。</td></tr><tr><td><code>RabbitHealthIndicator</code></td><td>检查Rabbit服务器是否已启动。</td></tr><tr><td><code>RedisHealthIndicator</code></td><td>检查Redis服务器是否启动。</td></tr><tr><td><code>SolrHealthIndicator</code></td><td>检查Solr服务器是否已启动。</td></tr></tbody></table><p>可以通过设置 <code>management.health.defaults.enabled</code>属性来全部禁用。</p><h2 id="原生端点"><a href="#原生端点" class="headerlink" title="原生端点"></a>原生端点</h2><p>原生端点分为三大类：</p><ul><li>应用配置类：获取应用程序中加载的应用配置、环境变量、自动化配置报告等与Spring Boot应用密切相关的配置类信息。</li><li>度量指标类：获取应用程序运行过程中用于监控的度量指标，比如：内存信息、线程池信息、HTTP请求统计等。</li><li>操作控制类：提供了对应用的关闭等操作类功能。</li></ul><hr><h3 id="应用配置类"><a href="#应用配置类" class="headerlink" title="应用配置类"></a>应用配置类</h3><p>&#x2F;conditions：该端点用来获取应用的自动化配置报告，其中包括所有自动化配置的候选项。同时还列出了每个候选项自动化配置的各个先决条件是否满足。该端点可以帮助我们方便的找到一些自动化配置为什么没有生效的具体原因。</p><p>该报告内容将自动化配置内容分为两部分：positiveMatches中返回的是条件匹配成功的自动化配置和negativeMatches中返回的是条件匹配不成功的自动化配置。</p><p>部分代码如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;contexts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;application&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;positiveMatches&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;AuditEventsEndpointAutoConfiguration&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OnAvailableEndpointCondition&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@ConditionalOnAvailableEndpoint marked as exposed by a &#x27;management.endpoints.web.exposure&#x27; property&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;BeansEndpointAutoConfiguration&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OnAvailableEndpointCondition&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@ConditionalOnAvailableEndpoint marked as exposed by a &#x27;management.endpoints.web.exposure&#x27; property&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;BeansEndpointAutoConfiguration#beansEndpoint&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OnBeanCondition&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@ConditionalOnMissingBean (types: org.springframework.boot.actuate.beans.BeansEndpoint; SearchStrategy: all) did not find any beans&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>&#x2F;info：就是在配置文件中配置的以info开头的信息，如配置为：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-boot-actuator</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;app&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;spring-boot-actuator&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>info中配置的参数也可以通过符号*@*包围的属性值来自pom.xml文件中的元素节点。如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">info:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">        <span class="attr">artifact:</span> <span class="string">@project.artifactId@</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">@project.name@</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">@project.description@</span></span><br><span class="line">        <span class="attr">ersion:</span> <span class="string">@project.version@</span></span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;artifact&quot;</span><span class="punctuation">:</span> <span class="string">&quot;spring-learn&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;spring-learn&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Demo project for Spring Boot&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.1-SNAPSHOT&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>&#x2F;beans：该端点用来获取应用上下文中创建的所有Bean。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;contexts&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;application&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;beans&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;endpointCachingOperationInvokerAdvisor&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;aliases&quot;</span>: [],</span><br><span class="line">                    <span class="string">&quot;scope&quot;</span>: <span class="string">&quot;singleton&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;org.springframework.boot.actuate.endpoint.invoker.cache.CachingOperationInvokerAdvisor&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;resource&quot;</span>: <span class="string">&quot;class path resource [org/springframework/boot/actuate/autoconfigure/endpoint/EndpointAutoConfiguration.class]&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;dependencies&quot;</span>: [<span class="string">&quot;environment&quot;</span>]</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;defaultServletHandlerMapping&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;aliases&quot;</span>: [],</span><br><span class="line">                    <span class="string">&quot;scope&quot;</span>: <span class="string">&quot;singleton&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;org.springframework.web.servlet.HandlerMapping&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;resource&quot;</span>: <span class="string">&quot;class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration<span class="variable">$EnableWebMvcConfiguration</span>.class]&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;dependencies&quot;</span>: []</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;parentId&quot;</span>: <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口展现了bean的别名、类型、是否单例、类的地址、依赖等信息。</p><p>&#x2F;configprops：该端点用来获取应用中配置的属性信息报告。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;spring.transaction-org.springframework.boot.autoconfigure.transaction.TransactionProperties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;spring.transaction&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>上面展示了TransactionProperties属性的配置信息。</p><p>&#x2F;mappings：该端点用来返回所有SpringMVC的控制器映射关系报告。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;handler&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Actuator web endpoint &#x27;beans&#x27;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;predicate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;GET /actuator/beans, produces [application/vnd.spring-boot.actuator.v2+json || application/json]&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;details&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;handlerMethod&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;className&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.springframework.boot.actuate.endpoint.web.servlet.AbstractWebMvcEndpointHandlerMapping.OperationHandler&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;handle&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;descriptor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(Ljavax/servlet/http/HttpServletRequest;Ljava/util/Map;)Ljava/lang/Object;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;requestMappingConditions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;consumes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;headers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;methods&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;GET&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;params&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;patterns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;/actuator/beans&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;produces&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;mediaType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;application/vnd.spring-boot.actuator.v2+json&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;negated&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;mediaType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;application/json&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;negated&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>/env</code>：该端点与<code>/configprops</code>不同，它用来获取应用所有可用的环境属性报告。包括：环境变量、JVM属性、应用的配置配置、命令行中的参数。</p><h3 id="度量指标类"><a href="#度量指标类" class="headerlink" title="度量指标类"></a>度量指标类</h3><p>应用配置类提供的指标为静态报告，而度量指标类端点提供的报告内容则是动态变化的，提供了应用程序在运行过程中的一些快照信息，比如：内存使用情况、HTTP请求统计、外部资源指标等。这些端点对于构建微服务架构中的监控系统非常有帮助。</p><p>&#x2F;metrics：该端点用来返回当前应用的各类重要度量指标，比如：内存信息、线程信息、垃圾回收信息等。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;names&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;jvm.memory.max&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;jvm.threads.states&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;http.server.requests&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;process.files.max&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;jvm.gc.memory.promoted&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;system.load.average.1m&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;jvm.memory.used&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;jvm.gc.max.data.size&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;jvm.gc.pause&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;jvm.memory.committed&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;system.cpu.count&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;logback.events&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;tomcat.global.sent&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;jvm.buffer.memory.used&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;tomcat.sessions.created&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;jvm.threads.daemon&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;system.cpu.usage&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;jvm.gc.memory.allocated&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;tomcat.global.request.max&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;tomcat.global.request&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;tomcat.sessions.expired&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;jvm.threads.live&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;jvm.threads.peak&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;tomcat.global.received&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;process.uptime&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;tomcat.sessions.rejected&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;process.cpu.usage&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;tomcat.threads.config.max&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;jvm.classes.loaded&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;jvm.classes.unloaded&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;tomcat.global.error&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;tomcat.sessions.active.current&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;tomcat.sessions.alive.max&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;jvm.gc.live.data.size&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;tomcat.threads.current&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;process.files.open&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;jvm.buffer.count&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;jvm.buffer.total.capacity&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;tomcat.sessions.active.max&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;tomcat.threads.busy&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;process.start.time&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>从上面的示例中有这些重要的度量值：</p><ul><li>系统信息：包括处理器数量processors、运行时间uptime和instance.uptime、系统平均负载systemload.average。</li><li>mem.*：内存概要信息，包括分配给应用的总内存数量以及当前空闲的内存数量。这些信息来自java.lang.Runtime。</li><li>heap.*：堆内存使用情况。这些信息来自java.lang.management.MemoryMXBean接口中getHeapMemoryUsage方法获取的java.lang.management.MemoryUsage。</li><li>nonheap.*：非堆内存使用情况。这些信息来自java.lang.management.MemoryMXBean接口中getNonHeapMemoryUsage方法获取的java.lang.management.MemoryUsage。</li><li>threads.*：线程使用情况，包括线程数、守护线程数（daemon）、线程峰值（peak）等，这些数据均来自java.lang.management.ThreadMXBean。</li><li>classes.*：应用加载和卸载的类统计。这些数据均来自java.lang.management.ClassLoadingMXBean。</li><li>gc.*：垃圾收集器的详细信息，包括垃圾回收次数gc.ps_scavenge.count、垃圾回收消耗时间gc.ps_scavenge.time、标记-清除算法的次数gc.ps_marksweep.count、标记-清除算法的消耗时间gc.ps_marksweep.time。这些数据均来自java.lang.management.GarbageCollectorMXBean。</li><li>httpsessions.*：Tomcat容器的会话使用情况。包括最大会话数httpsessions.max和活跃会话数httpsessions.active。该度量指标信息仅在引入了嵌入式Tomcat作为应用容器的时候才会提供。</li><li>gauge.*：HTTP请求的性能指标之一，它主要用来反映一个绝对数值。比如上面示例中的gauge.response.hello: 5，它表示上一次hello请求的延迟时间为5毫秒。</li><li>counter.*：HTTP请求的性能指标之一，它主要作为计数器来使用，记录了增加量和减少量。如上示例中counter.status.200.hello: 11，它代表了hello请求返回200状态的次数为11。</li></ul><p>&#x2F;threaddump：会生成当前线程活动的快照。方便我们在日常定位问题的时候查看线程的情况。主要展示了线程名、线程ID、线程的状态、是否等待锁资源等信息。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;threads&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;threadName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Reference Handler&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;threadId&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;blockedTime&quot;</span><span class="punctuation">:</span> <span class="number">-1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;blockedCount&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;waitedTime&quot;</span><span class="punctuation">:</span> <span class="number">-1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;waitedCount&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lockName&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lockOwnerId&quot;</span><span class="punctuation">:</span> <span class="number">-1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lockOwnerName&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;daemon&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;inNative&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;suspended&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;threadState&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RUNNABLE&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;priority&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stackTrace&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;classLoaderName&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;moduleName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.base&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;moduleVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;11.0.4&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;methodName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;waitForReferencePendingList&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;fileName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Reference.java&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;lineNumber&quot;</span><span class="punctuation">:</span> <span class="number">-2</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;className&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.lang.ref.Reference&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;nativeMethod&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">&quot;lockedMonitors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lockedSynchronizers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;className&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.util.concurrent.locks.ReentrantLock$NonfairSync&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;identityHashCode&quot;</span><span class="punctuation">:</span> <span class="number">2060076420</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lockInfo&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;threadName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DestroyJavaVM&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;threadId&quot;</span><span class="punctuation">:</span> <span class="number">42</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;blockedTime&quot;</span><span class="punctuation">:</span> <span class="number">-1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;blockedCount&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;waitedTime&quot;</span><span class="punctuation">:</span> <span class="number">-1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;waitedCount&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lockName&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lockOwnerId&quot;</span><span class="punctuation">:</span> <span class="number">-1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lockOwnerName&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;daemon&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;inNative&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;suspended&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;threadState&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RUNNABLE&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;priority&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stackTrace&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lockedMonitors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lockedSynchronizers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lockInfo&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>&#x2F;trace：该端点用来返回基本的HTTP跟踪信息。默认情况下，跟踪信息的存储采用。（2.2版本以后不在默认提供）</p><h3 id="操作控制类"><a href="#操作控制类" class="headerlink" title="操作控制类"></a>操作控制类</h3><p>&#x2F;shutdown：配置文件中配置开启此功能：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">management.endpoint.shutdown.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>使用 curl 模拟 post 请求此接口：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">curl -X POST <span class="string">&quot;http://localhost:8080/actuator/shutdown&quot;</span>复制代码</span><br></pre></td></tr></table></figure><p>显示结果为：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Shutting down, bye...&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>由此可见shutdown可以关闭Spring Boot项目</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-Boot-Actuator&quot;&gt;&lt;a href=&quot;#Spring-Boot-Actuator&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot Actuator&quot;&gt;&lt;/a&gt;Spring Boot Actuator&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="监控" scheme="https://devildyw.github.io/categories/%E7%9B%91%E6%8E%A7/"/>
    
    
    <category term="Spring" scheme="https://devildyw.github.io/tags/Spring/"/>
    
  </entry>
  
</feed>
