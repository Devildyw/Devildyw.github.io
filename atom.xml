<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Devil的个人博客</title>
  
  <subtitle>永远相信美好的事情即将发生</subtitle>
  <link href="https://devildyw.github.io/atom.xml" rel="self"/>
  
  <link href="https://devildyw.github.io/"/>
  <updated>2022-06-11T17:11:27.424Z</updated>
  <id>https://devildyw.github.io/</id>
  
  <author>
    <name>Devil</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式--工厂方法设计模式</title>
    <link href="https://devildyw.github.io/2022/06/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://devildyw.github.io/2022/06/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-06-11T13:57:45.000Z</published>
    <updated>2022-06-11T17:11:27.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式–工厂方法设计模式"><a href="#设计模式–工厂方法设计模式" class="headerlink" title="设计模式–工厂方法设计模式"></a>设计模式–工厂方法设计模式</h1><h2 id="1-1-模式动机"><a href="#1-1-模式动机" class="headerlink" title="1.1. 模式动机"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html#id16">1.1. 模式动机</a></h2><p>现在对该系统进行修改，不再设计一个按钮工厂类来统一负责所有产品的创建，而是将具体按钮的创建过程交给专门的工厂子类去完成，我们先定义一个抽象的按钮工厂类，再定义具体的工厂类来生成圆形按钮、矩形按钮、菱形按钮等，它们实现在抽象按钮工厂类中定义的方法。这种抽象化的结果使这种结构可以在不修改具体工厂类的情况下引进新的产品，如果出现新的按钮类型，只需要为这种新类型的按钮创建一个具体的工厂类就可以获得该新按钮的实例，这一特点无疑使得工厂方法模式具有超越简单工厂模式的优越性，更加符合“开闭原则”。</p><h2 id="1-2-模式定义"><a href="#1-2-模式定义" class="headerlink" title="1.2. 模式定义"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html#id17">1.2. 模式定义</a></h2><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><h2 id="1-3-模式结构"><a href="#1-3-模式结构" class="headerlink" title="1.3. 模式结构"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html#id18">1.3. 模式结构</a></h2><p>工厂方法模式包含如下角色：</p><ul><li><code>Product</code>：抽象产品</li><li><code>ConcreteProduct</code>：具体产品</li><li><code>Factory</code>：抽象工厂</li><li><code>ConcreteFactory</code>：具体工厂</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/FactoryMethod.jpg" alt="../_images/FactoryMethod.jpg"></p><h2 id="1-4-时序图"><a href="#1-4-时序图" class="headerlink" title="1.4. 时序图"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html#id19">1.4. 时序图</a></h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/seq_FactoryMethod.jpg" alt="../_images/seq_FactoryMethod.jpg"></p><h2 id="1-5-代码分析"><a href="#1-5-代码分析" class="headerlink" title="1.5. 代码分析"></a><a href="https://github.com/Devildyw/design-patterns/tree/master/DesignPatterns-Java/FactoryMethodPattern">1.5. 代码分析</a></h2><p><strong>注释也可以仔细看看哦</strong></p><p>抽象产品类<code>Vehicles.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dyw.factoryMethodPattern.product;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-06-11-20:13</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * &lt;strong&gt;该类为工厂方法设计模式中的抽象产品角色&lt;/strong&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;基类&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Vehicles</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交通工具的核心方法 &quot;运行&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体产品类<code>Bike.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dyw.factoryMethodPattern.product;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-06-11-20:13</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * &lt;strong&gt;该类角色为工厂方法设计模式中的具体产品角色&lt;/strong&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;自行车继承自交通工具抽象类实现了抽象方法&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bike</span> <span class="keyword">extends</span> <span class="title class_">Vehicles</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bike is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象工厂类<code>VehiclesFactory.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dyw.factoryMethodPattern.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dyw.factoryMethodPattern.product.Vehicles;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-06-11-21:52</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;strong&gt;工厂方法设计模式 该类为抽象工厂角色&lt;/strong&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *     这里创建了一个抽象的工厂类 是为了让具体工厂的子类来实现这个特定的方法 以便于生产产品</span></span><br><span class="line"><span class="comment"> *     之所以这样便于生产产品是相较于简单工厂设计模式的，简单工厂设计模式生产产品是将生产过程耦合在了一起</span></span><br><span class="line"><span class="comment"> *     这样在产品不多的时候或是产品种类确定不会经常改变时较为好用，但是我们实际生产中很难确定自己的产品种类就一定不变</span></span><br><span class="line"><span class="comment"> *     所以我们可以使用工厂方法设计模式，他不在原来的类上进行修改，而是给出了一个抽象类 新添加的产品需要创建一个具体工厂类</span></span><br><span class="line"><span class="comment"> *     实现具体的抽象方法以便于创建具体的产品。符合开闭原则的同时也避免了简单工厂设计模式的高耦合性。</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">VehiclesFactory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 具体工厂继承该类并且实现该抽象方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Vehicles</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Vehicles <span class="title function_">createProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体工厂类<code>BikeFactory.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dyw.factoryMethodPattern.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dyw.factoryMethodPattern.product.Bike;</span><br><span class="line"><span class="keyword">import</span> com.dyw.factoryMethodPattern.product.Vehicles;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-06-12-0:44</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;strong&gt;工厂方法设计模式 该类为具体工厂角色&lt;/strong&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BikeFactory</span> <span class="keyword">extends</span> <span class="title class_">VehiclesFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Vehicles <span class="title function_">createProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在生成bike...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bike</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示类<code>Main.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dyw.factoryMethodPattern.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dyw.factoryMethodPattern.factory.BikeFactory;</span><br><span class="line"><span class="keyword">import</span> com.dyw.factoryMethodPattern.factory.VehiclesFactory;</span><br><span class="line"><span class="keyword">import</span> com.dyw.factoryMethodPattern.product.Vehicles;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-06-12-0:48</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * &lt;strong&gt;该类用于向读者展示工厂方法是否有效&lt;/strong&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;这里仅仅只是展示了一个产品的工厂生产 通过这一个例子 读者足以理解本片想要表达的含义&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//这里我想要一辆自行车</span></span><br><span class="line">        <span class="comment">//首先创建一个工厂类 让他帮我们创建类</span></span><br><span class="line">        <span class="type">VehiclesFactory</span> <span class="variable">bikeFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BikeFactory</span>();</span><br><span class="line">        <span class="comment">//工厂类调用特定方法生产产品</span></span><br><span class="line">        <span class="type">Vehicles</span> <span class="variable">product</span> <span class="operator">=</span> bikeFactory.createProduct();</span><br><span class="line">        <span class="comment">//执行产品特有的方法</span></span><br><span class="line">        product.work();</span><br><span class="line">        <span class="comment">//检验结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果:</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220612010908971.png" alt="image-20220612010908971"></p><h2 id="2-6-模式分析"><a href="#2-6-模式分析" class="headerlink" title="2.6. 模式分析"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html#id21">2.6. 模式分析</a></h2><p>工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</p><h2 id="1-7-实例"><a href="#1-7-实例" class="headerlink" title="1.7. 实例"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html#id22">1.7. 实例</a></h2><p>日志记录器</p><p>某系统日志记录器要求支持多种日志记录方式，如文件记录、数据库记录等，且用户可以根据要求动态选择日志记录方式， 现使用工厂方法模式设计该系统。</p><p>结构图：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/loger.jpg" alt="../_images/loger.jpg"></p><p>时序图：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/seq_loger.jpg" alt="../_images/seq_loger.jpg"></p><h2 id="1-8-工厂方法模式的优点"><a href="#1-8-工厂方法模式的优点" class="headerlink" title="1.8. 工厂方法模式的优点"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html#id23">1.8. 工厂方法模式的优点</a></h2><ul><li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li><li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li></ul><h2 id="1-9-工厂方法模式的缺点"><a href="#1-9-工厂方法模式的缺点" class="headerlink" title="1.9. 工厂方法模式的缺点"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html#id24">1.9. 工厂方法模式的缺点</a></h2><ul><li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li></ul><h2 id="1-10-适用环境"><a href="#1-10-适用环境" class="headerlink" title="1.10. 适用环境"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html#id25">1.10. 适用环境</a></h2><p>在以下情况下可以使用工厂方法模式：</p><ul><li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li><li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li><li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li></ul><h2 id="1-11-模式应用"><a href="#1-11-模式应用" class="headerlink" title="1.11. 模式应用"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html#id26">1.11. 模式应用</a></h2><p><code>JDBC</code>中的工厂方法:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection conn=DriverManager.getConnection(<span class="string">&quot;jdbc:microsoft:sqlserver://loc</span></span><br><span class="line"><span class="string">alhost:1433; DatabaseName=DB;user=sa;password=&quot;</span>);</span><br><span class="line">Statement statement=conn.createStatement();</span><br><span class="line">ResultSet rs=statement.executeQuery(<span class="string">&quot;select * from UserInfo&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="1-12-模式扩展"><a href="#1-12-模式扩展" class="headerlink" title="1.12. 模式扩展"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html#id27">1.12. 模式扩展</a></h2><ul><li>使用多个工厂方法：在抽象工厂角色中可以定义多个工厂方法，从而使具体工厂角色实现这些不同的工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同的产品对象的需求。</li><li>产品对象的重复使用：工厂对象将已经创建过的产品保存到一个集合（如数组、List等）中，然后根据客户对产品的请求，对集合进行查询。如果有满足要求的产品对象，就直接将该产品返回客户端；如果集合中没有这样的产品对象，那么就创建一个新的满足要求的产品对象，然后将这个对象在增加到集合中，再返回给客户端。</li><li>多态性的丧失和模式的退化：如果工厂仅仅返回一个具体产品对象，便违背了工厂方法的用意，发生退化，此时就不再是工厂方法模式了。一般来说，工厂对象应当有一个抽象的父类型，如果工厂等级结构中只有一个具体工厂类的话，抽象工厂就可以省略，也将发生了退化。当只有一个具体工厂，在具体工厂中可以创建所有的产品对象，并且工厂方法设计为静态方法时，工厂方法模式就退化成简单工厂模式。</li></ul><h2 id="1-13-总结"><a href="#1-13-总结" class="headerlink" title="1.13. 总结"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html#id28">1.13. 总结</a></h2><ul><li>工厂方法模式又称为工厂模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</li><li>工厂方法模式包含四个角色：抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类型，即产品对象的共同父类或接口；具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，它们之间往往一一对应；抽象工厂中声明了工厂方法，用于返回一个产品，它是工厂方法模式的核心，任何在模式中创建对象的工厂类都必须实现该接口；具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例。</li><li>工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</li><li>工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</li><li>工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式–工厂方法设计模式&quot;&gt;&lt;a href=&quot;#设计模式–工厂方法设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式–工厂方法设计模式&quot;&gt;&lt;/a&gt;设计模式–工厂方法设计模式&lt;/h1&gt;&lt;h2 id=&quot;1-1-模式动机&quot;&gt;&lt;a href=&quot;#1</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devildyw.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Developer" scheme="https://devildyw.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="https://devildyw.github.io/2022/05/21/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>https://devildyw.github.io/2022/05/21/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</id>
    <published>2022-05-21T12:59:28.000Z</published>
    <updated>2022-05-21T13:04:40.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="布隆过滤器-BloomFilter"><a href="#布隆过滤器-BloomFilter" class="headerlink" title="布隆过滤器(BloomFilter)"></a>布隆过滤器(BloomFilter)</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>​    我们经常会将一部分数据放在redis等缓存中，比如产品信息。这样有查询请求进来，我们就可以根据产品id直接去缓存中取得数据，如果没有再去读取数据库，再将数据放入缓存，再返回数据，大大减少了访问数据库的次数，这是提升性能最普遍的方式。</p><p>​    但是如果现在有大量的请求进来，而且都在请求一个不存在的id，就会导致大量的请求去访问数据库，而数据库对于不存在的id是需要遍历整个表之后返回一个null的，这样大量的请求访问数据库，很大可能导致数据库宕机，</p><p>这时我们急需一个解决方案，在无效id访问缓存的之前就判断该id不存在。布隆过滤器就是一个很好的选择。</p><hr><h2 id="背景及意义"><a href="#背景及意义" class="headerlink" title="背景及意义"></a>背景及意义</h2><p>​    <strong>布隆过滤器</strong>（英语：Bloom Filter）是 1970 年由一个叫做布隆的老哥提出的。它底层实际上是一个很长的bit数组和一系列随机映射函数。主要用于判断一个元素是否在一个集合中。</p><p>​    通常我们会遇到很多要判断一个元素是否在某个集合中的业务场景(比如缓存场景)，一般想到的是将集合中所有元素保存起来，然后通过比较确定。链表、树、散列表（又叫哈希表，Hash table）等等数据结构都是这种思路。但是随着集合中元素的增加，我们需要的存储空间也会呈现线性增长，最终达到瓶颈。同时检索速度也越来越慢，这个时候，布隆过滤器（Bloom Filter）就应运而生。</p><hr><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>布隆过滤器的数据结构如图所示</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/20200714114525436.png" alt="在这里插入图片描述"></p><p>可以发现最底层是一个bit数组，通过一系列hash算法将元素映射到bit数组上。下面我们来介绍一下布隆过滤器（<code>Bloom Filter</code>）的算法。</p><hr><p><strong>当一个元素加入到布隆过滤器中的时候，会进行如下操作。</strong></p><blockquote><ul><li>使用布隆过滤器中的hash函数对元素值进行计算，得到元素的hash值（有几个hash函数获得几个hash值）。</li><li>根据得到的hash值，在bit数组中把对应下标的值由0置为1.</li></ul></blockquote><p><strong>当我们需要判断一个元素是否存在于布隆过滤器中时，会进行如下操作。</strong></p><blockquote><ul><li>对给定元素再次进行相同的hash计算；</li><li>得到值之后判断bit数组中的每个元素是否都为1，如果值为1，那么说明整个值在布隆过滤器中，如果存在一个值不为1，说明该元素不在过滤器中。</li></ul></blockquote><p>如果我们需要判断某个字符串是否在布隆过滤器中时，只需要对给定字符串再次进行相同的哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p><p><strong>因为hash冲突的缘故，不同元素通过hash计算可能会得到相同的hash值；所以布隆过滤器计算得到一个元素是否存在时，可能会出现误判，但是如果布隆过滤器判断一个元素不存在，那么该元素一定不存在。</strong></p><p>对于布隆过滤器的误判的情况，可以通过增加bit数组的大小或者调整hash函数来减小概率。</p><p><strong>综上，我们可以得出：布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p><hr><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote><ol><li>增加和查询元素的时间复杂度为：O(K), (K为哈希函数的个数，一般比较小)，与数据量大小无关</li><li>哈希函数相互之间没有关系，方便硬件并行运算</li><li>布隆过滤器不需要存储元素本身，在某些对保密要求比较严格的场合有很大优势</li><li>在能够承受一定的误判时，布隆过滤器比其他数据结构有这很大的空间优势</li><li>数据量很大时，布隆过滤器可以表示全集，其他数据结构不能</li><li>使用同一组散列函数的布隆过滤器可以进行交、并、差运算</li></ol></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote><ol><li>有误判率，即存在假阳性(False Position)，即不能准确判断元素是否在集合中(补救方法：再建立一个白<br>名单，存储可能会误判的数据)</li><li>不能获取元素本身</li><li>一般情况下不能从布隆过滤器中删除元素</li><li>如果采用计数方式删除，可能会存在计数回绕问题</li></ol></blockquote><hr><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>判断给定数据是否存在：比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5亿以上！）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤、黑名单功能等等。</li><li>去重：比如爬给定网址的时候对已经爬取过的 URL 去重。</li><li>钓鱼网站识别</li><li>秒杀系统：查看用户是否重复购买</li></ul><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p><code>Bloom-Filter.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.dyw.bloomFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022-05-21-20:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BloomFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * bit数组的默认大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">2</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过这个数组可以创建6个不同的hash函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] SEEDS = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>,<span class="number">13</span>,<span class="number">46</span>,<span class="number">91</span>,<span class="number">134</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * bit数组。数组中的元素只能是 0 或者 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BitSet bits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放包含 hash 函数的类的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SimpleHash[] func = <span class="keyword">new</span> <span class="title class_">SimpleHash</span>[SEEDS.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有参构造 指定bit数组大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BloomFilter</span><span class="params">(<span class="type">int</span> size)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        bits = <span class="keyword">new</span> <span class="title class_">BitSet</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BloomFilter</span><span class="params">()</span>&#123;</span><br><span class="line">        bits = <span class="keyword">new</span> <span class="title class_">BitSet</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 静态代码块</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化多个不同的Hash函数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; SEEDS.length; i++) &#123;</span><br><span class="line">            func[i] = <span class="keyword">new</span> <span class="title class_">SimpleHash</span>(size, SEEDS[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素到位数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (SimpleHash f : func) &#123;</span><br><span class="line">            bits.set(f.hash(value), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断指定元素是否存在于位数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (SimpleHash f : func) &#123;</span><br><span class="line">            ret = ret &amp;&amp; bits.get(f.hash(value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类。用于 hash 操作！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SimpleHash</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> cap;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> seed;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SimpleHash</span><span class="params">(<span class="type">int</span> cap, <span class="type">int</span> seed)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.cap = cap;</span><br><span class="line">            <span class="built_in">this</span>.seed = seed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 计算 hash 值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">            <span class="type">int</span> h;</span><br><span class="line">            <span class="keyword">return</span> (value == <span class="literal">null</span>) ? <span class="number">0</span> : Math.abs(seed * (cap - <span class="number">1</span>) &amp; ((h = value.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="End"><a href="#End" class="headerlink" title="-End-"></a>-End-</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;布隆过滤器-BloomFilter&quot;&gt;&lt;a href=&quot;#布隆过滤器-BloomFilter&quot; class=&quot;headerlink&quot; title=&quot;布隆过滤器(BloomFilter)&quot;&gt;&lt;/a&gt;布隆过滤器(BloomFilter)&lt;/h1&gt;&lt;h2 id=&quot;引言&quot;</summary>
      
    
    
    
    <category term="数据结构" scheme="https://devildyw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法" scheme="https://devildyw.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Cache</title>
    <link href="https://devildyw.github.io/2022/05/18/Cache/"/>
    <id>https://devildyw.github.io/2022/05/18/Cache/</id>
    <published>2022-05-18T09:23:15.000Z</published>
    <updated>2022-05-18T09:23:15.843Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://devildyw.github.io/2022/05/15/Docker/"/>
    <id>https://devildyw.github.io/2022/05/15/Docker/</id>
    <published>2022-05-15T06:57:20.000Z</published>
    <updated>2022-05-18T09:56:05.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Docker 是一个开源的应用容器引擎，基于 Go 语言   并遵从Apache2.0协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><h2 id="为什么会有Docker的出现"><a href="#为什么会有Docker的出现" class="headerlink" title="为什么会有Docker的出现"></a>为什么会有Docker的出现</h2><p>​    传统上认为，软件编码开发&#x2F;测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等（Java为例）。而为了让这些程序可以顺利的执行，开发团队也得准备完成的部署文件，让运维团队得以部署应用程序，开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过即便如此，任然常常发生部署失败的状况。Docker的出现使得Docker得以打破过期【程序即应用】的观念。通过镜像（images）将作业系统核心除外，运作应用程序所需要的系统环境，由下而上打包，达到系统程序跨平台间的无缝接轨运作。</p><h2 id="Docker的理念"><a href="#Docker的理念" class="headerlink" title="Docker的理念"></a>Docker的理念</h2><p>Docker是基于Go语言实现的云开源项目。</p><p>Docker的主要目标是&#96;“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次镜像，处处运行”。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220515154552629.png" alt="image-20220515154552629"></p><p>Linux容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用打成镜像，通过镜像成为运行在Docker容器上面的实例，而 Docker容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。</p><p><strong>Docker解决了运行环境和配置问题的软件容器， 方便做持续集成并有助于整体发布的容器虚拟化技术。</strong></p><hr><h2 id="Docker的优势"><a href="#Docker的优势" class="headerlink" title="Docker的优势"></a>Docker的优势</h2><p><strong>简化程序：</strong><br>Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的  Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的    任务，在Docker容器的处理下，只需要数秒就能完成。</p><p><strong>节省开支：</strong><br>一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。</p><h2 id="容器与虚拟机的比较"><a href="#容器与虚拟机的比较" class="headerlink" title="容器与虚拟机的比较"></a>容器与虚拟机的比较</h2><p>上文我们提到了容器，那么容器和传统的虚拟机有什么区别呢？</p><h3 id="容器发展简史"><a href="#容器发展简史" class="headerlink" title="容器发展简史"></a>容器发展简史</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220515155014898.png" alt="image-20220515155014898"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220515155023912.png" alt="image-20220515155023912"></p><h3 id="传统虚拟机"><a href="#传统虚拟机" class="headerlink" title="传统虚拟机"></a>传统虚拟机</h3><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。</p><ul><li>传统虚拟机技术：模拟一个完整的操作系统，先虚拟出一套硬件，然后在其上安装操作系统，最后在系统上再运行应用程序<br>缺点：资源占用多，启动慢<br>虚拟机偏向于硬件</li></ul><p>使用虚拟机运行多个相互隔离的应用时，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/12979420-15eaabb27b008ce1" alt="img"></p><p>从下到上理解上图：</p><p><strong>基础设施</strong>（Infrastructure）。它可以是你的个人电脑，数据中心的服务器，或者是云主机。</p><p><strong>主操作系统</strong>（Host Operating System）。你的个人电脑之上，运行的可能是MacOS，Windows或者某个Linux发行版。</p><p><strong>虚拟机管理系统</strong>（Hypervisor）。利用Hypervisor，可以在主操作系统之上运行多个不同的从操作系统,实现硬件资源虚拟化。类型1的Hypervisor有支持MacOS的HyperKit，支持Windows的Hyper-V以及支持Linux的KVM。类型2的Hypervisor有VirtualBox和VMWare。</p><p><strong>从操作系统</strong>（Guest Operating System）。假设你需要运行3个相互隔离的应用，则需要使用Hypervisor启动3个从操作系统，也就是3个虚拟机。这些虚拟机都非常大，也许有700MB，这就意味着它们将占用2.1GB的磁盘空间。更糟糕的是，它们还会消耗很多CPU和内存。</p><p><strong>各种依赖</strong>。每一个从操作系统都需要安装许多依赖。如果你的的应用需要连接PostgreSQL的话，则需要安装libpq-dev；如果你使用Ruby的话，应该需要安装gems；如果使用其他编程语言，比如Python或者Node.js，都会需要安装对应的依赖库。</p><p>应用。安装依赖之后，就可以在各个从操作系统分别运行应用了，这样各个应用就是相互隔离的。</p><hr><h3 id="Docker容器技术"><a href="#Docker容器技术" class="headerlink" title="Docker容器技术"></a>Docker容器技术</h3><ul><li>Docker容器技术：不是模拟一个完整的操作系统，没有进行硬件虚拟，而是对进程进行隔离，封装成容器，容器内的应用程序是直接使用宿主机的内核，且容器之间是互相隔离的，互不影响<br>优点：更轻便、效率高、启动快、秒级<br>Docker容器技术更多的偏向于软件</li></ul><p>使用Docker容器运行多个相互隔离的应用时，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/12979420-005836e6ff3e6b39" alt="img"></p><p><strong>主操作系统</strong>（Host Operating System）。所有主流的Linux发行版都可以运行Docker。对于MacOS和Windows，也有一些办法”运行”Docker。</p><p><strong>Docker守护进程</strong>（Docker Daemon）。Docker守护进程取代了Hypervisor，运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。它是运行在操作系统之上的后台进程，负责管理Docker容器。</p><p><strong>各种依赖</strong>。对于Docker，应用的所有依赖都打包在Docker镜像中，Docker容器是基于Docker镜像创建的。</p><p><strong>应用</strong>。应用的源代码与它的依赖都打包在Docker镜像中，不同的应用需要不同的Docker镜像。不同的应用运行在不同的Docker容器中，它们是相互隔离的。</p><hr><h3 id="两者之间的区别"><a href="#两者之间的区别" class="headerlink" title="两者之间的区别"></a>两者之间的区别</h3><ul><li><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</p></li><li><p>而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p></li><li><p>作为一种轻量级的虚拟化方式，Docker在运行应用上跟传统的虚拟机方式相比具有显著优势：</p></li><li><p>Docker容器很快，启动和停止可以在秒级实现，这相比传统的虚拟机方式要快得多。</p></li><li><p>Docker容器对系统资源需求很少，一台主机上可以同时运行数千个Docker容器。</p></li><li><p>Docker通过类似Git的操作来方便用户获取、分发和更新应用镜像，指令简明，学习成本较低。</p></li><li><p>Docker通过<code>Dockerfile</code>配置文件来支持灵活的自动化创建和部署机制，提高工作效率。</p></li><li><p>Docker容器除了运行其中的应用之外，基本不消耗额外的系统资源，保证应用性能的同时，尽量减小系统开销。</p></li><li><p>Docker利用Linux系统上的多种防护机制实现了严格可靠的隔离。从1.3版本开始，Docker引入了安全选项和镜像签名机制，极大地提高了使用Docker的安全性。</p><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动速度</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为MB</td><td>一般为GB</td></tr><tr><td>性能</td><td>接近原生</td><td>弱于原生</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr><tr><td>隔离性</td><td>安全隔离</td><td>完全隔离</td></tr></tbody></table></li></ul><h2 id="Docker能干嘛"><a href="#Docker能干嘛" class="headerlink" title="Docker能干嘛"></a>Docker能干嘛</h2><ul><li><p>开发&#x2F;运维（DevOps）新一代开发工程师</p><blockquote><ul><li>· 一次构建、随处运行</li><li>· 更快速的应用交付和部署<ul><li>传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。Docker化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间。</li></ul></li><li>· 更便捷的升级和扩缩容<ul><li>随着微服务架构和Docker的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭乐高积木一样，每个Docker容器将变成一块“积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级。</li></ul></li><li>· 更简单的系统运维<ul><li>应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复。</li></ul></li><li>· 更高效的计算资源利用<ul><li>Docker是内核级虚拟化，其不像传统的虚拟化技术一样需要额外的Hypervisor支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率。</li></ul></li></ul></blockquote></li><li><p>Docker的应用场景</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220515162158635.png" alt="image-20220515162158635"></p></li></ul><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><hr><h4 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h4><p>Docker 支持 64 位版本 CentOS 7&#x2F;8，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 <code>overlay2</code> 存储层驱动）无法使用，并且部分功能可能不太稳定。</p><h4 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h4><p>旧版本的 Docker 称为 <code>docker</code> 或者 <code>docker-engine</code>，使用以下命令卸载旧版本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><h2 id="使用-yum-安装"><a href="#使用-yum-安装" class="headerlink" title="使用 yum 安装"></a>使用 yum 安装</h2><p>执行以下命令安装依赖包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure><p>鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。</p><p><strong>这里演示的是阿里云的镜像库</strong></p><p>执行下面的命令添加 <code>yum</code> 软件源：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">$ sudo sed -i <span class="string">&#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27;</span> /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 官方源</span></span><br><span class="line"><span class="comment"># $ sudo yum-config-manager \</span></span><br><span class="line"><span class="comment">#     --add-repo \</span></span><br><span class="line"><span class="comment">#     https://download.docker.com/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure><h2 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><h2 id="建立-docker-用户组"><a href="#建立-docker-用户组" class="headerlink" title="建立 docker 用户组"></a>建立 docker 用户组</h2><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立 <code>docker</code> 组：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure><p>将当前用户加入 <code>docker</code> 组：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><p>退出当前终端并重新登录，进行如下测试。</p><h2 id="测试-Docker-是否安装正确"><a href="#测试-Docker-是否安装正确" class="headerlink" title="测试 Docker 是否安装正确"></a>测试 Docker 是否安装正确</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run --<span class="built_in">rm</span> hello-world</span><br><span class="line"></span><br><span class="line">Unable to find image <span class="string">&#x27;hello-world:latest&#x27;</span> locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">b8dfde127a29: Pull complete</span><br><span class="line">Digest: sha256:308866a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">&quot;hello-world&quot;</span> image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure><p>若能正常输出以上信息，则说明安装成功。</p><h2 id="Docker镜像加速"><a href="#Docker镜像加速" class="headerlink" title="Docker镜像加速"></a>Docker镜像加速</h2><p>如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker 国内镜像加速。</p><p><strong>这里演示的是阿里云的镜像加速器</strong></p><p>配置镜像加速器:(针对Docker客户端版本大于 1.10.0 的用户)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://3h5lqxa4.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><hr><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p><strong>Docker 使用客户端-服务器 (C&#x2F;S) 架构模式，使用远程API来管理和创建Docker容器。</strong></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/24/1687d76498e7d980~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="de4146cd809a9f320512b316ed5e4570.png"></p><p><strong>Docker组件:</strong></p><blockquote><ul><li><p>docker Client客户端————&gt;向docker服务器进程发起请求，如:创建、停止、销毁容器等操作</p></li><li><p>docker Server服务器进程—–&gt;处理所有docker的请求，管理所有容器</p></li><li><p>docker Registry镜像仓库——&gt;镜像存放的中央仓库，可看作是存放二进制的scm</p></li></ul></blockquote><hr><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><h4 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h4><p>操作系统分为<strong>内核</strong>和<strong>用户空间</strong>.对于<code>linux</code>这类操作系统而言,内核启动后,会挂载<code>root</code>文件文件系统为其提供用户空间支持。而<strong>Docker镜像</strong>（<code>image</code>），就相当于是一个<code>root</code>文件系统。比如官方镜像<code>ubuntu:18.04</code>就包含了完整的一套<code>Ubuntu18.04</code>最小系统的root文件系统。</p><p>Docker镜像是一个特殊的文件系统，除恶了提供容器运行时所需要的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像<strong>不包含</strong>任何动态数据，其内容在构建之后也不会改变。</p><h4 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h4><p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 <code>ISO</code> 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><p>后续我会为大家详细介绍如何构建镜像。</p><hr><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h4><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><table><thead><tr><th>Docker</th><th>面向对象</th></tr></thead><tbody><tr><td>容器</td><td>对象</td></tr><tr><td>镜像</td><td>类</td></tr></tbody></table><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。看到这里也就不迷惑为什么有人会把虚拟机和Docker容器混淆了，前面我也介绍了他们之间的区别（虚拟机需要虚拟一套硬件出来）。‘</p><p>容器与镜像一样，也是使用分层存储，每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为<strong>容器存储层</strong></p><p><strong>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</strong></p><p>注意：按照《Docker最佳实践》的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的写入操作，都应该使用<strong>数据卷</strong>、或者<strong>绑定宿主目录</strong>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。（毕竟容器宕掉了数据也没了，还是有一个稳定的地方存储数据安全有一点。）</p><p><strong>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</strong></p><hr><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><h4 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h4><p>Docker Registry就是一个可以集中存储、分发镜像的服务。我将镜像构建完成之后，可以很容易的在当前宿主机上运行，但是，如果我需要其他服务器上使用该镜像，或者分享给别人使用时Docker Registry就很有用了。</p><p><strong>一个Docker Registry中可以有多个仓库（<code>Repository</code>）；每个仓库可以包含多个标签（<code>Tag</code>）；每个标签对应一个镜像。</strong></p><p>通常，<strong>一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。</strong>我们可以通过 <strong><code>&lt;仓库名&gt;:&lt;标签&gt;</code></strong> 的格式来指定具体是这个软件哪个版本的镜像。<strong>如果不给出标签，将以 <code>latest</code> 作为默认标签。</strong></p><p>以 <a href="https://hub.docker.com/_/ubuntu">Ubuntu 镜像</a> 为例，<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，<code>16.04</code>, <code>18.04</code>。我们可以通过 <code>ubuntu:16.04</code>，或者 <code>ubuntu:18.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p><p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p><p><strong>Docker Registry</strong>分为公开服务和私有服务</p><hr><h4 id="Docker-Registry-公开服务"><a href="#Docker-Registry-公开服务" class="headerlink" title="Docker Registry 公开服务"></a>Docker Registry 公开服务</h4><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/">Docker Hub</a>，这也是默认的 Registry，并拥有大量的高质量的 <a href="https://hub.docker.com/search?q=&type=image&image_filter=official">官方镜像</a>。除此以外，还有 Red Hat 的 <a href="https://quay.io/repository/">Quay.io</a>；Google 的 <a href="https://cloud.google.com/container-registry/">Google Container Registry</a>，<a href="https://kubernetes.io/">Kubernetes</a> 的镜像使用的就是这个服务；代码托管平台 <a href="https://github.com/">GitHub</a> 推出的 <a href="https://docs.github.com/cn/packages/working-with-a-github-packages-registry/working-with-the-container-registry">ghcr.io</a>。</p><p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（<code>Registry Mirror</code>），这些镜像服务被称为 <strong>加速器</strong>。常见的有 <a href="https://www.aliyun.com/product/acr?source=5176.11533457&userCode=8lx5zmtu">阿里云加速器</a>、<a href="https://www.daocloud.io/mirror#accelerator-doc">DaoCloud 加速器</a> 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在 <a href="https://docker-practice.github.io/zh-cn/install/mirror.html">安装 Docker</a> 一节中有详细的配置方法。</p><p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://c.163.com/hub#/m/library/">网易云镜像服务</a>、<a href="https://hub.daocloud.io/">DaoCloud 镜像市场</a>、<a href="https://www.aliyun.com/product/acr?source=5176.11533457&userCode=8lx5zmtu">阿里云镜像库</a> 等。</p><hr><h4 id="私有-Docker-Registry"><a href="#私有-Docker-Registry" class="headerlink" title="私有 Docker Registry"></a>私有 Docker Registry</h4><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/">Docker Registry</a> 镜像，可以直接使用做为私有 Registry 服务。在 <a href="https://docker-practice.github.io/zh-cn/repository/registry.html">私有仓库</a> 一节中，会有进一步的搭建私有 Registry 服务的讲解。</p><p>开源的 Docker Registry 镜像只提供了 <a href="https://docs.docker.com/registry/spec/api/">Docker Registry API</a> 的服务端实现，足以支持 <code>docker</code> 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p><p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，<a href="https://github.com/goharbor/harbor">Harbor</a> 和 <a href="https://docker-practice.github.io/zh-cn/repository/nexus3_registry.html">Sonatype Nexus</a>。</p><hr><hr><h2 id="使用Docker镜像"><a href="#使用Docker镜像" class="headerlink" title="使用Docker镜像"></a>使用Docker镜像</h2><p>镜像是Docker的三大组件之一</p><p>Docker运行容器之前，需要本地存在对应的镜像，如果本地不存在该镜像，Docker会从镜像仓库中下载该镜像。</p><p>本部分会介绍关于使用Docker镜像的一些操作，包括：</p><blockquote><ul><li>从仓库中获取镜像；</li><li>管理本地主机上的镜像；</li><li>介绍镜像实现的基本原理。</li></ul></blockquote><h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><p>在Docker Registry中我们提到了，<a href="https://hub.docker.com/search?q=&type=image">Docker Hub</a> 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure><p>具体**[选项]**可以通过<code>docker pull --help</code> 查看，这里详细介绍下镜像命名的格式。</p><ul><li>Docker镜像仓库地址：地址的格式一般是<code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是Docker Hub（<code>docker.io</code>）。</li><li>仓库名：仓库名是两端式名称，即<code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于Docker Hub，如果不给出用户名，则默认<code>library</code>，也就是官方镜像。</li></ul><p>如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull ubuntu:18.04</span><br><span class="line">18.04: Pulling from library/ubuntu</span><br><span class="line">92dc2a97ff99: Pull complete</span><br><span class="line">be13a9d27eb8: Pull complete</span><br><span class="line">c8299583700a: Pull complete</span><br><span class="line">Digest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:18.04</span><br><span class="line">docker.io/library/ubuntu:18.04</span><br></pre></td></tr></table></figure><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub （<code>docker.io</code>）获取镜像。而镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。<code>docker pull</code> 命令的输出结果最后一行给出了镜像的完整名称，即： <code>docker.io/library/ubuntu:18.04</code>。</p><p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要，以确保下载一致性。</p><p>在使用上面命令的时候，你可能会发现，你所看到的每层 ID 以及 <code>sha256</code> 的摘要和这里的不一样。这是因为官方镜像是一直在维护的，有任何新的 bug，或者版本更新，都会进行修复再以原来的标签发布，这样可以确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。</p><p><em>如果从 Docker Hub 下载镜像非常缓慢，可以参照 <a href="https://docker-practice.github.io/zh-cn/install/mirror.html">镜像加速器</a> 一节配置加速器。</em></p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>有了镜像，我们就可以以这个镜像为基础启动并运行一个容器。以上面的<code>ubuntu:18.04</code>为例，如果我们打算能启动里面的<code>bash</code>并进行交互操作的话，可以执行下面的命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -it --<span class="built_in">rm</span> ubuntu:18.04 bash</span><br><span class="line"></span><br><span class="line">root@e7009c6ce357:/<span class="comment"># cat /etc/os-release</span></span><br><span class="line">NAME=<span class="string">&quot;Ubuntu&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;18.04.1 LTS (Bionic Beaver)&quot;</span></span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=<span class="string">&quot;Ubuntu 18.04.1 LTS&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;18.04&quot;</span></span><br><span class="line">HOME_URL=<span class="string">&quot;https://www.ubuntu.com/&quot;</span></span><br><span class="line">SUPPORT_URL=<span class="string">&quot;https://help.ubuntu.com/&quot;</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">&quot;https://bugs.launchpad.net/ubuntu/&quot;</span></span><br><span class="line">PRIVACY_POLICY_URL=<span class="string">&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span></span><br><span class="line">VERSION_CODENAME=bionic</span><br><span class="line">UBUNTU_CODENAME=bionic</span><br></pre></td></tr></table></figure><p><code>docker run</code> 就是运行容器的命令，具体格式我们会在 <a href="https://docker-practice.github.io/zh-cn/container">容器</a>介绍中进行详细讲解，我们这里简要的说明一下上面用到的参数。</p><ul><li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li><li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li><li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li></ul><p>进入容器后，我们就可以在Shell下操作，执行任何所需的命令。如上述代码</p><p>可以通过<code>exit</code>退出这个容器。</p><h1 id="持续更新中。。。"><a href="#持续更新中。。。" class="headerlink" title="持续更新中。。。"></a>持续更新中。。。</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="中间件" scheme="https://devildyw.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Developer" scheme="https://devildyw.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>Paxos</title>
    <link href="https://devildyw.github.io/2022/05/04/Paxos/"/>
    <id>https://devildyw.github.io/2022/05/04/Paxos/</id>
    <published>2022-05-04T13:39:07.000Z</published>
    <updated>2022-05-04T14:08:18.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Paxos算法详解"><a href="#Paxos算法详解" class="headerlink" title="Paxos算法详解"></a>Paxos算法详解</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    Paxos是什么? Paxos算法是基于<strong>消息传递</strong>且具有<strong>高度容错特性</strong>的<strong>一致性算法</strong>，是目前公认的解决<strong>分布式一致性</strong>问题<strong>最有效</strong>的算法之一。    </p><p>​    Paxos算法是Lamport宗师提出的一种基于消息传递的分布式一致性算法,它使其获得了2013年图灵奖.</p><p>​    自Paxos问世以来就持续垄断了分布式一致性算法，Paxos这个名词几乎等同于分布式一致性。（Google Chubby的作者Mike Burrows说过这个世界上<strong>只有一种</strong>一致性算法，那就是Paxos，其它的算法都是<strong>残次品</strong>。）Google的很多大型分布式系统都采用了Paxos算法来解决分布式一致性问题，如Chubby、Megastore以及Spanner等。开源的ZooKeeper，以及MySQL 5.7推出的用来取代传统的主从复制的MySQL Group Replication等纷纷采用Paxos算法解决分布式一致性问题。</p><p>​    然而，Paxos的最大特点<strong>就是难，不仅难以理解，更难以实现。</strong></p><h2 id="Paxos解决的问题"><a href="#Paxos解决的问题" class="headerlink" title="Paxos解决的问题"></a>Paxos解决的问题</h2><p>​    在常见的分布式系统中，总会发生诸如<strong>机器宕机</strong>或<strong>网络异常</strong>（包括消息的延迟、丢失、重复、乱序，还有网络分区）等情况。Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对<strong>某个数据的值</strong>达成<strong>一致</strong>，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。</p><p> <strong>注意：</strong>这里指的<strong>某个数据的值</strong>并不一定只是狭义上的某个数，它可以使日志，也可以是一条命令（command）… 根据应用场景的不同，<strong>某个数据的值</strong>有着不同得含义。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/1752522-d2136179b456e13e.png" alt="问题产生的背景"></p><h2 id="Paxos介绍"><a href="#Paxos介绍" class="headerlink" title="Paxos介绍"></a>Paxos介绍</h2><h3 id="Paxos的三种角色"><a href="#Paxos的三种角色" class="headerlink" title="Paxos的三种角色"></a>Paxos的三种角色</h3><ul><li><strong>Proposer: 提议者</strong></li><li><strong>Acceptor: 决策者</strong></li><li><strong>Learners: 最终决策学习者</strong></li></ul><p>​    在具体的实现中，一个进程可能同时充当多种角色。比如一个进程可能及时<strong>Proposer又是Accdeptor又是Learner。</strong></p><p>​    既然有提议者，那么一定有提议，这里还有个有很重的概念叫做<strong>提案（Proposal）</strong>。最终要达成一致的value就在提案里面。</p><p>Proposer可以提出（propose）提案；Acceptor可以接受（accept）提案；如果某个提案被选定（chosen），那么该提案里的value就被选定了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Paxos算法详解&quot;&gt;&lt;a href=&quot;#Paxos算法详解&quot; class=&quot;headerlink&quot; title=&quot;Paxos算法详解&quot;&gt;&lt;/a&gt;Paxos算法详解&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Chubby</title>
    <link href="https://devildyw.github.io/2022/05/04/Chubby/"/>
    <id>https://devildyw.github.io/2022/05/04/Chubby/</id>
    <published>2022-05-04T13:38:00.000Z</published>
    <updated>2022-05-04T13:38:47.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chubby"><a href="#Chubby" class="headerlink" title="Chubby"></a>Chubby</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chubby&quot;&gt;&lt;a href=&quot;#Chubby&quot; class=&quot;headerlink&quot; title=&quot;Chubby&quot;&gt;&lt;/a&gt;Chubby&lt;/h1&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式----创建型模式之简单工厂设计模式</title>
    <link href="https://devildyw.github.io/2022/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F----%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://devildyw.github.io/2022/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F----%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-04-27T17:29:10.000Z</published>
    <updated>2022-04-29T05:44:39.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式—-创建型模式之单例设计模式"><a href="#设计模式—-创建型模式之单例设计模式" class="headerlink" title="设计模式—-创建型模式之单例设计模式"></a>设计模式—-创建型模式之单例设计模式</h1><h2 id="5-1-模式动机"><a href="#5-1-模式动机" class="headerlink" title="5.1. 模式动机"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/singleton.html#id17">5.1. 模式动机</a></h2><p>对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。</p><p>如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。</p><p>一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。</p><h2 id="5-2-模式定义"><a href="#5-2-模式定义" class="headerlink" title="5.2. 模式定义"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/singleton.html#id18">5.2. 模式定义</a></h2><p>单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p><p>单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。</p><h2 id="5-3-模式结构"><a href="#5-3-模式结构" class="headerlink" title="5.3. 模式结构"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/singleton.html#id19">5.3. 模式结构</a></h2><p>单例模式包含如下角色：</p><ul><li>Singleton：单例</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/Singleton.jpg" alt="../_images/Singleton.jpg"></p><h2 id="5-4-时序图"><a href="#5-4-时序图" class="headerlink" title="5.4. 时序图"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/singleton.html#id20">5.4. 时序图</a></h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/seq_Singleton.jpg" alt="../_images/seq_Singleton.jpg"></p><h2 id="5-5-代码分析"><a href="#5-5-代码分析" class="headerlink" title="5.5. 代码分析"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/singleton.html#id21">5.5. 代码分析</a></h2><p>懒汉式:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HungrySingleton</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在程序加载时 就将类初始化 生成实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">HungrySingleton</span> <span class="variable">HUNGRY_SINGLETON</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HungrySingleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二: 静态代码块</span></span><br><span class="line"><span class="comment">//    private static HungrySingleton HUNGRY_SINGLETON = null;</span></span><br><span class="line"><span class="comment">//    static &#123;</span></span><br><span class="line"><span class="comment">//        HUNGRY_SINGLETON = new HungrySingleton();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器私有化 防止重复创建类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HungrySingleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当被调用时 直接将该方法返回即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> HUNGRY_SINGLETON</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HUNGRY_SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个可以打印数组的方法 用于测试</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[] array)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t : array) &#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>懒汉式:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个类实例的变量 用于等待调用 调用后 作为初始化对象的容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">LazySingleton</span> <span class="variable">LAZY_SINGLETON</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器私有化 防止被调用重复生成实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当被调用时 如果没有被实例化 则实例化</span></span><br><span class="line"><span class="comment">     * 已经实例化了 直接返回</span></span><br><span class="line"><span class="comment">     * &lt;br&gt;</span></span><br><span class="line"><span class="comment">     * &lt;h2&gt;注意:&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">     * 这种写法的缺点就是线程安全无法保证</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> LAZY_SINGLETON</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//如果LAZY_SINGLETON为空</span></span><br><span class="line">        <span class="keyword">if</span> (LAZY_SINGLETON==<span class="literal">null</span>)&#123;</span><br><span class="line">            LAZY_SINGLETON = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LAZY_SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个可以打印数组的方法 用于测试</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[] array)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t : array) &#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>懒汉式改良版:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingletonPlus</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个类实例的变量 用于等待调用 调用后 作为初始化对象的容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">LazySingletonPlus</span> <span class="variable">LAZY_SINGLETON_PLUS</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器私有化 防止被调用重复生成实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingletonPlus</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当被调用时 如果没有被实例化 则实例化</span></span><br><span class="line"><span class="comment">     * 已经实例化了 直接返回</span></span><br><span class="line"><span class="comment">     * &lt;br&gt;</span></span><br><span class="line"><span class="comment">     * &lt;h2&gt;注意:&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">     * 这种写法的缺点就是线程安全无法保证</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> LAZY_SINGLETON</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingletonPlus <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//第一层检查  如果LAZY_SINGLETON为空</span></span><br><span class="line">        <span class="keyword">if</span> (LAZY_SINGLETON_PLUS==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//加锁 第一个线程调用该方法的会获得一个锁 这个锁为悲观锁 保证只有一个线程进入</span></span><br><span class="line">            <span class="comment">//假设有线程A和线程B两个线程同时通过第一层判断，那么它们需要排队进入同步代码块，</span></span><br><span class="line">            <span class="comment">//假设线程A先进入同步代码块，那么实例由线程A创建，那么当线程B进入同代码块时便不能通过第二层检查，</span></span><br><span class="line">            <span class="comment">//即直接返回实例。这样便实现了线程安全的懒加载。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingletonPlus.class)&#123;</span><br><span class="line">                <span class="comment">//第二层检查 此时如果实例还未被创建 则交由此处创造</span></span><br><span class="line">                <span class="comment">//如果这里是被别人抢先一步获得锁 这里是阻塞完毕 实例已经被先行进入锁的线程创建了</span></span><br><span class="line">                <span class="comment">//则这里的判断是跳出条件判断的作用 防止锁死无法跳出 导致线程阻塞.</span></span><br><span class="line">                <span class="keyword">if</span> (LAZY_SINGLETON_PLUS==<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//最后创造实例</span></span><br><span class="line">                    LAZY_SINGLETON_PLUS = <span class="keyword">new</span> <span class="title class_">LazySingletonPlus</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回实例</span></span><br><span class="line">        <span class="keyword">return</span> LAZY_SINGLETON_PLUS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个可以打印数组的方法 用于测试</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[] array)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t : array) &#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>测试代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        <span class="comment">//饿汉式</span></span><br><span class="line">        <span class="type">HungrySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> HungrySingleton.getInstance();</span><br><span class="line">        instance.print(array);</span><br><span class="line">        <span class="type">HungrySingleton</span> <span class="variable">instance3</span> <span class="operator">=</span> HungrySingleton.getInstance();</span><br><span class="line">        System.out.println(instance==instance3);</span><br><span class="line">        System.out.println(<span class="string">&quot;=======================================&quot;</span>);</span><br><span class="line">        <span class="comment">//普通懒汉式</span></span><br><span class="line">        <span class="type">LazySingleton</span> <span class="variable">instance1</span> <span class="operator">=</span> LazySingleton.getInstance();</span><br><span class="line">        instance1.print(array);</span><br><span class="line">        <span class="type">LazySingleton</span> <span class="variable">instance4</span> <span class="operator">=</span> LazySingleton.getInstance();</span><br><span class="line">        System.out.println(instance1==instance4);</span><br><span class="line">        System.out.println(<span class="string">&quot;=======================================&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220428005355210.png" alt="image-20220428005355210"></p><h2 id="5-6-模式分析"><a href="#5-6-模式分析" class="headerlink" title="5.6. 模式分析"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/singleton.html#id22">5.6. 模式分析</a></h2><p>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，就是单例类——Singleton。单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法，该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。</p><p>在单例模式的实现过程中，需要注意如下三点：</p><ul><li>单例类的构造函数为私有；</li><li>提供一个自身的静态私有成员变量；</li><li>提供一个公有的静态工厂方法。</li></ul><h2 id="5-7-实例"><a href="#5-7-实例" class="headerlink" title="5.7. 实例"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/singleton.html#id23">5.7. 实例</a></h2><p>在操作系统中，打印池(Print Spooler)是一个用于管理打印任务的应用程序，通过打印池用户可以删除、中止或者改变打印任务的优先级，在一个系统中只允许运行一个打印池对象，如果重复创建打印池则抛出异常。现使用单例模式来模拟实现打印池的设计。</p><h2 id="5-8-优点"><a href="#5-8-优点" class="headerlink" title="5.8. 优点"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/singleton.html#id24">5.8. 优点</a></h2><ul><li>提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。</li><li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。</li><li>允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。</li></ul><h2 id="5-9-缺点"><a href="#5-9-缺点" class="headerlink" title="5.9. 缺点"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/singleton.html#id25">5.9. 缺点</a></h2><ul><li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li><li>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</li></ul><h2 id="5-10-适用环境"><a href="#5-10-适用环境" class="headerlink" title="5.10. 适用环境"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/singleton.html#id26">5.10. 适用环境</a></h2><p>在以下情况下可以使用单例模式：</p><ul><li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。</li><li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</li><li>在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式</li></ul><h2 id="5-11-模式应用"><a href="#5-11-模式应用" class="headerlink" title="5.11. 模式应用"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/singleton.html#id27">5.11. 模式应用</a></h2><p>一个具有自动编号主键的表可以有多个用户同时使用，但数据库中只能有一个地方分配下一个主键编号，否则会出现主键重复，因此该主键编号生成器必须具备唯一性，可以通过单例模式来实现。</p><h2 id="5-12-模式扩展"><a href="#5-12-模式扩展" class="headerlink" title="5.12. 模式扩展"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/singleton.html#id28">5.12. 模式扩展</a></h2><h2 id="5-13-总结"><a href="#5-13-总结" class="headerlink" title="5.13. 总结"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/singleton.html#id29">5.13. 总结</a></h2><ul><li>单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。</li><li>单例模式只包含一个单例角色：在单例类的内部实现只生成一个实例，同时它提供一个静态的工厂方法，让客户可以使用它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有。</li><li>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法。该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。</li><li>单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。</li><li>单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式—-创建型模式之单例设计模式&quot;&gt;&lt;a href=&quot;#设计模式—-创建型模式之单例设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式—-创建型模式之单例设计模式&quot;&gt;&lt;/a&gt;设计模式—-创建型模式之单例设计模式&lt;/h1&gt;&lt;h2 id=&quot;5</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devildyw.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Developer" scheme="https://devildyw.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="https://devildyw.github.io/2022/04/27/JavaScript/"/>
    <id>https://devildyw.github.io/2022/04/27/JavaScript/</id>
    <published>2022-04-27T09:46:48.000Z</published>
    <updated>2022-04-30T07:53:58.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>JavaScript 是 web 开发人员必须学习的 3 门语言中的一门：</p><ol><li><strong>HTML</strong> 定义了网页的内容</li><li><strong>CSS</strong> 描述了网页的布局</li><li><strong>JavaScript</strong> 控制了网页的行为</li></ol><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><strong>JavaScript 能够改变 HTML 内容</strong></li></ul><p>​    <code>getElementById()</code> 是多个 JavaScript HTML 方法之一。</p><p>本例使用该方法来“查找” id&#x3D;”demo” 的 HTML 元素，并把元素内容（<code>innerHTML</code>）更改为 “Hello JavaScript”：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;<span class="title class_">JavaScript</span> 起步&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>JavaScript 能够改变HTML内容.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&#x27;document.getElementById(&quot;demo&quot;).innerHTML=&quot;Hello JavaScript&quot;&#x27;</span>&gt;</span>点击我 </span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>JavaScript 能够改变 HTML 属性</strong></li></ul><p>​    本例通过改变 <code>&lt;img&gt;</code> 标签的 <code>src</code> 属性（source）来改变一张 HTML 图像：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;<span class="title class_">JavaScript</span> 能做什么？&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>JavaScript 能够改变 HTML 属性值。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>在本例中，JavaScript 改变了图像的 src 属性值。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;document.getElementById(&#x27;myImage&#x27;).src=&#x27;/i/eg_bulbon.gif&#x27;&quot;</span>&gt;</span>开灯<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;myImage&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/i/eg_bulboff.gif&quot;</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;document.getElementById(&#x27;myImage&#x27;).src=&#x27;/i/eg_bulboff.gif&#x27;&quot;</span>&gt;</span>关灯<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>JavaScript 能够改变 HTML 样式 (CSS)</strong></li></ul><p>​    改变 HTML 元素的样式，是改变 HTML 属性的一种变种：</p><p><strong>实例</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&quot;25px&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>JavaScript 能够隐藏 HTML 元素</strong></li></ul><p>​    可通过改变 <code>display</code> 样式来隐藏 HTML 元素：</p><p><strong>实例</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">style</span>.<span class="property">display</span>=<span class="string">&quot;none&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>JavaScript 能够显示 HTML 元素</strong></li></ul><p>可通过改变 <code>display</code> 样式来显示隐藏的 HTML 元素：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">style</span>.<span class="property">display</span>=<span class="string">&quot;block&quot;</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="JavaScript使用"><a href="#JavaScript使用" class="headerlink" title="JavaScript使用"></a>JavaScript使用</h2><p><strong><code>&lt;script&gt; </code>标签</strong></p><p>在 HTML 中，JavaScript 代码必须位于 <code>&lt;script&gt;</code> 与 <code>&lt;/script&gt;</code> 标签之间。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;我的第一段 JavaScript&quot;</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="JavaScript-函数和事件"><a href="#JavaScript-函数和事件" class="headerlink" title="JavaScript 函数和事件"></a>JavaScript 函数和事件</h4><p>JavaScript <em>函数</em>是一种 JavaScript 代码块，它可以在调用时被执行。</p><hr><h4 id="lt-head-gt-或-lt-body-gt-中的-JavaScript"><a href="#lt-head-gt-或-lt-body-gt-中的-JavaScript" class="headerlink" title="&lt;head&gt; 或 &lt;body&gt; 中的 JavaScript"></a><code>&lt;head&gt;</code> 或 <code>&lt;body&gt;</code> 中的 JavaScript</h4><p>您能够在 HTML 文档中放置任意数量的脚本。</p><p>脚本可被放置与 HTML 页面的 <code>&lt;body&gt;</code> 或 <code>&lt;head&gt;</code> 部分中，或兼而有之。</p><hr><h4 id="外部脚本"><a href="#外部脚本" class="headerlink" title="外部脚本"></a>外部脚本</h4><p>js脚本可以放置于外部文件中，在html的<code>&lt;head&gt;</code>标签中使用<code>link:src</code>引入</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>外部 JavaScript 的优势</strong></p><p>在外部文件中放置脚本有如下优势：</p><ul><li>分离了 HTML 和代码</li><li>使 HTML 和 JavaScript 更易于阅读和维护</li><li>已缓存的 JavaScript 文件可加速页面加载</li></ul><p>如需向一张页面添加多个脚本文件 - 请使用多个 script 标签：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;myScript1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;myScript2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="JavaScript语法"><a href="#JavaScript语法" class="headerlink" title="JavaScript语法"></a>JavaScript语法</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><ul><li><p><strong>innerHTML</strong></p><p>如需访问 HTML 元素，JavaScript 可使用 <code>document.getElementById(id)</code> 方法。</p><p><strong>提示：</strong>更改 HTML 元素的 innerHTML 属性是在 HTML 中显示数据的常用方法。</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;<span class="title class_">JavaScript</span>输出&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = <span class="number">5</span>+<span class="number">6</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>document.write()</strong></li><li><strong>注意：</strong>在 HTML 文档完全加载后使用 <code>document.write()</code> 将<em>删除所有已有的 HTML</em> ：</li><li><strong>提示：</strong><code>document.write()</code> 方法仅用于测试。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">       <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="number">5</span>+<span class="number">6</span>);</span><br><span class="line">   &lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>使用 window.alert()</strong></li><li>您能够使用警告框来显示数据：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">       <span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="number">5</span>+<span class="number">6</span>);</span><br><span class="line">   &lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li><p>使用 console.log()</p><p>在浏览器中，您可使用 <code>console.log()</code> 方法来显示数据。</p><p>请通过 F12 来激活浏览器控制台，并在菜单中选择“控制台”。</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>+<span class="number">6</span>);</span><br><span class="line">   &lt;/script&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="JavaScript-语句"><a href="#JavaScript-语句" class="headerlink" title="JavaScript 语句"></a>JavaScript 语句</h3><p><strong>在 HTML 中，JavaScript 语句是由 web 浏览器“执行”的“指令”。</strong></p><p>JavaScript是一项编程语言 类似java的语法。</p><ul><li>以分号结尾</li></ul><h4 id="JavaScript关键词"><a href="#JavaScript关键词" class="headerlink" title="JavaScript关键词"></a>JavaScript关键词</h4><p>​    JavaScript 语句常常通过某个关键词来标识需要执行的 JavaScript 动作。</p><p>下面的表格列出了一部分将在教程中学到的关键词：</p><table><thead><tr><th align="left">关键词</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">break</td><td align="left">终止 switch 或循环。</td></tr><tr><td align="left">continue</td><td align="left">跳出循环并在顶端开始。</td></tr><tr><td align="left">debugger</td><td align="left">停止执行 JavaScript，并调用调试函数（如果可用）。</td></tr><tr><td align="left">do … while</td><td align="left">执行语句块，并在条件为真时重复代码块。</td></tr><tr><td align="left">for</td><td align="left">标记需被执行的语句块，只要条件为真。</td></tr><tr><td align="left">function</td><td align="left">声明函数。</td></tr><tr><td align="left">if … else</td><td align="left">标记需被执行的语句块，根据某个条件。</td></tr><tr><td align="left">return</td><td align="left">退出函数。</td></tr><tr><td align="left">switch</td><td align="left">标记需被执行的语句块，根据不同的情况。</td></tr><tr><td align="left">try … catch</td><td align="left">对语句块实现错误处理。</td></tr><tr><td align="left">var</td><td align="left">声明变量。</td></tr></tbody></table><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>语法方面除了使用若引用类型var定义变量之外 类型方面、符号方面、标识符定义规范等与其他编程语言一致，参考Java</p><hr><h2 id="WebAPI"><a href="#WebAPI" class="headerlink" title="WebAPI"></a>WebAPI</h2><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430152136094.png" alt="image-20220430152136094"></p><h4 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430152252269.png" alt="image-20220430152252269"></p><p><strong>DOM把以上内容都看做是对象</strong></p><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><h5 id="根据ID获取元素"><a href="#根据ID获取元素" class="headerlink" title="根据ID获取元素"></a>根据ID获取元素</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;time&quot;</span>&gt;</span>2019-9-9<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> time = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;time&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">dir</span>(time);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>获取到的元素其实是一个对象.</strong></p><hr><h5 id="根据标签名获取元素"><a href="#根据标签名获取元素" class="headerlink" title="根据标签名获取元素"></a>根据标签名获取元素</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(div);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>获取到的元素是一个集合对象(伪数组).</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430153616839.png" alt="image-20220430153616839"></p><p>得到的元素是动态的.</p><p>可以通过获取标签对应的元素 再通过这个元素的获取他的子元素.</p><hr><h5 id="根据类名获取元素"><a href="#根据类名获取元素" class="headerlink" title="根据类名获取元素"></a>根据类名获取元素</h5><p><code>getElementsByClassName()</code>根据类名获得某些元素集合</p><hr><h5 id="指定选择器来获取元素"><a href="#指定选择器来获取元素" class="headerlink" title="指定选择器来获取元素"></a>指定选择器来获取元素</h5><p><code>querySelector()</code>如果是类名则需要加点<code>querySelector(&#39;.classname&#39;)</code>类似于CSS选择器写法id也是这样.</p><hr><h4 id="事件三要素"><a href="#事件三要素" class="headerlink" title="事件三要素"></a>事件三要素</h4><ol><li>事件是由三部分组成得 <strong>事件源 事件类型 事件处理程序</strong> 我们也称为事件三要素<ol><li>事件源 事件被触发的对象</li><li>事件类型 如何出发 什么事件 比如鼠标点击(onclick) 还是鼠标经过</li><li>事件处理程序 通过函数赋值的方式 完成.</li></ol></li></ol><hr><h1 id="持续更新中。。。"><a href="#持续更新中。。。" class="headerlink" title="持续更新中。。。"></a>持续更新中。。。</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript&quot;&gt;&lt;a href=&quot;#JavaScript&quot; class=&quot;headerlink&quot; title=&quot;JavaScript&quot;&gt;&lt;/a&gt;JavaScript&lt;/h1&gt;&lt;p&gt;JavaScript 是 web 开发人员必须学习的 3 门语言中的一门：&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Zookeeper</title>
    <link href="https://devildyw.github.io/2022/04/26/Zookeeper/"/>
    <id>https://devildyw.github.io/2022/04/26/Zookeeper/</id>
    <published>2022-04-26T06:59:01.000Z</published>
    <updated>2022-05-04T03:35:14.317Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Zookeeper-一-简单介绍和历史由来"><a href="#Zookeeper-一-简单介绍和历史由来" class="headerlink" title="Zookeeper(一) 简单介绍和历史由来"></a>Zookeeper(一) 简单介绍和历史由来</h1><p><a href="https://www.w3cschool.cn/zookeeper/zookeeper_overview.html">Zookeeper 概述_w3cschool</a></p><p><a href="https://blog.csdn.net/yyx3214/article/details/97114603">(15条消息) zookeeper的前世今生_柠檬草。的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Zookeeper-一-简单介绍和历史由来&quot;&gt;&lt;a href=&quot;#Zookeeper-一-简单介绍和历史由来&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper(一) 简单介绍和历史由来&quot;&gt;&lt;/a&gt;Zookeeper(一) 简单介绍和历史由来</summary>
      
    
    
    
    <category term="分布式" scheme="https://devildyw.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="Middleware" scheme="https://devildyw.github.io/tags/Middleware/"/>
    
  </entry>
  
  <entry>
    <title>CSS</title>
    <link href="https://devildyw.github.io/2022/04/25/CSS/"/>
    <id>https://devildyw.github.io/2022/04/25/CSS/</id>
    <published>2022-04-25T14:32:04.000Z</published>
    <updated>2022-05-04T05:05:34.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS层叠样式表"><a href="#CSS层叠样式表" class="headerlink" title="CSS层叠样式表"></a>CSS层叠样式表</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>但用HTML写一个页面并不够美观，并且HTML也并不适合用来做简单的样式。</p><p><strong>CSS：网页的美容师</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425223707651.png" alt="image-20220425223707651"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425223904716.png" alt="image-20220425223904716"></p><hr><h2 id="CSS语法规范"><a href="#CSS语法规范" class="headerlink" title="CSS语法规范"></a>CSS语法规范</h2><p>使用HTML时，需要遵从一定的规范，CSS也是如此。想要熟练地使用CSS对网页进行修饰，首先需要了解CSS样式规则</p><p>CSS 规则集（rule-set）由选择器和声明块组成：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/selector.gif" alt="CSS 选择器"></p><blockquote><p><strong>选择器指向您需要设置样式的 HTML 元素。</strong></p><p><strong>声明块包含一条或多条用分号分隔的声明。</strong></p><p><strong>每条声明都包含一个 CSS 属性名称和一个值，以冒号分隔。(键值对)</strong></p><p><strong>多条 CSS 声明用分号分隔，声明块用花括号括起来。</strong></p></blockquote><hr><h2 id="CSS代码风格"><a href="#CSS代码风格" class="headerlink" title="CSS代码风格"></a>CSS代码风格</h2><p>风格并非强制规范，而是符合实际开发书写方式</p><ol><li><strong>样式格式书写</strong></li><li><strong>样式大小写风格</strong></li><li><strong>样式空格风格</strong></li></ol><hr><h3 id="样式格式书写"><a href="#样式格式书写" class="headerlink" title="样式格式书写"></a>样式格式书写</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425224953831.png" alt="image-20220425224953831"></p><hr><h3 id="样式大小写风格"><a href="#样式大小写风格" class="headerlink" title="样式大小写风格"></a>样式大小写风格</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425225045699.png" alt="image-20220425225045699"></p><hr><h3 id="样式空格风格"><a href="#样式空格风格" class="headerlink" title="样式空格风格"></a>样式空格风格</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425225208125.png" alt="image-20220425225208125"></p><hr><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>选择器（选择符）就是根据不同的需求把不同的标签选择出来这就是选择器的作用。简单来说，<strong>就是选择标签用的。</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/selector.gif" alt="CSS 选择器"></p><p>以上CSS做了两件事：</p><ol><li>找到所有的h1标签。选择器（选对人）。</li><li>设置这些标签的样式，比如颜色为红色（作对事）。</li></ol><h3 id="选择器分类"><a href="#选择器分类" class="headerlink" title="选择器分类"></a>选择器分类</h3><p>我们可以将 CSS 选择器分为五类：</p><ul><li><strong>简单选择器：</strong>（根据名称、<code>id</code>、类来选取元素）</li><li><strong>组合器选择器：</strong>（根据它们之间的特定关系来选取元素）</li><li><strong>伪类选择器</strong>：（根据特定状态选取元素）</li><li><strong>伪元素选择器</strong>：（选取元素的一部分并设置其样式）</li><li><strong>属性选择器</strong>：（根据属性或属性值来选取元素）</li></ul><hr><h4 id="CSS-id-选择器"><a href="#CSS-id-选择器" class="headerlink" title="CSS id 选择器"></a>CSS <code>id</code> 选择器</h4><p><code>id</code> 选择器使用 HTML 元素的 id 属性来选择特定元素。</p><p>元素的 <code>id</code> 在页面中是唯一的，因此 id 选择器用于选择一个唯一的元素！</p><p>要选择具有特定 id 的元素，请写一个井号（<code>＃</code>），后跟该元素的 id。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#para1</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center; 内容居中</span><br><span class="line">  <span class="attribute">color</span>: red; 文本颜色为红色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="CSS-类选择器"><a href="#CSS-类选择器" class="headerlink" title="CSS 类选择器"></a>CSS 类选择器</h4><p>类选择器选择有特定 <code>class</code> 属性的 HTML 元素。</p><p>如需选择拥有特定 <code>class</code> 的元素，请写一个句点（<code>.</code>）字符，后面跟类名。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.center</span> &#123; <span class="comment">/*标签p中的center类*/</span></span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多类名使用方式"><a href="#多类名使用方式" class="headerlink" title="多类名使用方式"></a>多类名使用方式</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.red</span> &#123;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">           <span class="comment">/* 背景颜色 */</span></span><br><span class="line">           <span class="attribute">background-color</span>: red;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="selector-class">.font35</span> &#123;</span><br><span class="line">           <span class="attribute">font-size</span>: <span class="number">35px</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red font35&quot;</span>&gt;</span>刘德华<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425231901421.png" alt="image-20220425231901421"></p><p><strong>多类名开发场景：</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425232017238.png" alt="image-20220425232017238"></p><p><strong>总结：</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425232049117.png"></p><hr><h4 id="CSS-通用选择器"><a href="#CSS-通用选择器" class="headerlink" title="CSS 通用选择器"></a>CSS 通用选择器</h4><p>通用选择器（*）选择页面上的所有的 HTML 元素。</p><p>不用主动调用，自动给所有元素使用样式</p><p>特殊情况才使用</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220426225329412.png" alt="image-20220426225329412"></p><p>下面的 CSS 规则会影响页面上的每个 HTML 元素：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="CSS-分组选择器"><a href="#CSS-分组选择器" class="headerlink" title="CSS 分组选择器"></a>CSS 分组选择器</h4><p>分组选择器选取所有具有相同样式定义的 HTML 元素。(即直接选择标签)</p><p>请看下面的 CSS 代码（h1、h2 和 p 元素具有相同的样式定义）：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们对上述代码中的选择器进行分组：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220426224733284.png" alt="image-20220426224733284"></p><p>口诀: id选择器的口诀: 样式**#定义**，结构id调用，只能调用一次，别人切勿使用。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-id">#p</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">230</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h5 id="id选择器和类选择器的区别"><a href="#id选择器和类选择器的区别" class="headerlink" title="id选择器和类选择器的区别"></a>id选择器和类选择器的区别</h5><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220426225128326.png" alt="image-20220426225128326"></p><hr><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425231237265.png" alt="image-20220425231237265"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220426225443244.png" alt="image-20220426225443244"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220426225548503.png" alt="image-20220426225548503"></p><h4 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430011628771.png" alt="image-20220430011628771"></p><hr><h5 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h5><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430140917829.png" alt="image-20220430140917829"></p><hr><h5 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h5><ul><li>只能够选择作为某元素最近的一级子元素.</li><li><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430141208960.png" alt="image-20220430141208960"></li></ul><hr><h5 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h5><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430142013280.png" alt="image-20220430142013280"></p><hr><h5 id="链接伪类选择器"><a href="#链接伪类选择器" class="headerlink" title="链接伪类选择器"></a>链接伪类选择器</h5><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430142718973.png" alt="image-20220430142718973"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430142811453.png" alt="image-20220430142811453"></p><p><strong>注意事项:</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430143118431.png" alt="image-20220430143118431"></p><p><strong>链接伪类选择器实际工作开发中的写法:</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430143207303.png" alt="image-20220430143207303"></p><h5 id="focus伪类选择器"><a href="#focus伪类选择器" class="headerlink" title=":focus伪类选择器"></a>:focus伪类选择器</h5><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430143607788.png" alt="image-20220430143607788"></p><hr><p>小样例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.red</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* 背景颜色 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span><span class="selector-class">.green</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>红色<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;green&quot;</span>&gt;</span>红色<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>红色<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425231558469.png" alt="image-20220425231558469"></p><hr><h2 id="CSS字体属性"><a href="#CSS字体属性" class="headerlink" title="CSS字体属性"></a>CSS字体属性</h2><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><p>CSS使用font-family属性定义文本的字体系列。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h2</span>,<span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;Microsoft Yahei&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220426230244841.png" alt="image-20220426230244841"></p><hr><h4 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h4><p>CSS使用<strong>font-size</strong>属性定义字体大小</p> <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220426230739770.png" alt="image-20220426230739770"></p><p>注意： 标题标签不能使用body统一设置 需要单独设置 加一个h2的选择器 </p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="字体粗细"><a href="#字体粗细" class="headerlink" title="字体粗细"></a>字体粗细</h4><p>CSS使用font-weight设置字体粗细</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220426232119994.png" alt="image-20220426232119994"></p><hr><h4 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h4><p>CSS使用font-style设置文字样式</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-style</span>: italic; <span class="comment">/*倾斜的字体*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: normal; <span class="comment">/*正常的字体 不倾斜*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220426232443954.png" alt="image-20220426232443954"></p><hr><h4 id="复合属性"><a href="#复合属性" class="headerlink" title="复合属性"></a>复合属性</h4><p>CSS使用font设置字体系列、大小、粗细、和文字样式（如斜体)</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* font-style: italic;</span></span><br><span class="line"><span class="comment">    font-weight: 700;</span></span><br><span class="line"><span class="comment">    font-size: 16px;</span></span><br><span class="line"><span class="comment">    font-family: &#x27;Microsoft yahei&#x27;; */</span></span><br><span class="line">    <span class="comment">/* 上面的代码可以使用复合属性设置 font */</span></span><br><span class="line">    <span class="attribute">font</span>: italic <span class="number">700</span> <span class="number">16px</span> <span class="string">&#x27;Microsoft yahei&#x27;</span>;</span><br><span class="line">    <span class="comment">/* 但是严格要求顺序 不能更换顺序 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>&lt;div&gt;    今天是个好天气&lt;/div&gt;</code></pre><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220426233051163.png" alt="image-20220426233051163"></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font</span>: <span class="number">100px</span> <span class="string">&#x27;Microsoft yahei&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="字体属性总结"><a href="#字体属性总结" class="headerlink" title="字体属性总结"></a>字体属性总结</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220426233333113.png" alt="image-20220426233333113"></p><hr><h4 id="装饰文本"><a href="#装饰文本" class="headerlink" title="装饰文本"></a>装饰文本</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220429135537803.png" alt="image-20220429135537803"></p><hr><h4 id="文本缩进"><a href="#文本缩进" class="headerlink" title="文本缩进"></a>文本缩进</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220429135902762.png" alt="image-20220429135902762"></p><hr><h4 id="文本行高"><a href="#文本行高" class="headerlink" title="文本行高"></a>文本行高</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430002934404.png" alt="image-20220430002934404"></p><h3 id="文本属性总结"><a href="#文本属性总结" class="headerlink" title="文本属性总结"></a>文本属性总结</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430002934404.png"></p><hr><h2 id="CSS的元素显示模式"><a href="#CSS的元素显示模式" class="headerlink" title="CSS的元素显示模式"></a>CSS的元素显示模式</h2><p>作用: 网页的标签非常多，在不同的地方会用到不同类型的标签，了解他们的特点<strong>可以更好的布局我们的网页</strong>。</p><p>元素显示模式就是<strong>元素（标签）以什么方式进行显示</strong>，比如<code>&lt;div&gt;</code>自己占一行，比如一行可以放多个<code>&lt;span&gt;</code>.</p><p>HTML元素一般为<strong>块元素</strong>和<strong>行内元素</strong>两种类型</p><hr><h3 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430144422309.png" alt="image-20220430144422309"></p><p><strong>注意：</strong><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430144730430.png"></p><hr><h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430145327498.png" alt="image-20220430145327498"></p><p><strong>注意：</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430145556486.png" alt="image-20220430145556486"></p><h3 id="行内块级元素"><a href="#行内块级元素" class="headerlink" title="行内块级元素"></a>行内块级元素</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430145910158.png" alt="image-20220430145910158"></p><hr><h3 id="CSS的元素显示模式的总结"><a href="#CSS的元素显示模式的总结" class="headerlink" title="CSS的元素显示模式的总结"></a>CSS的元素显示模式的总结</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430150105316.png" alt="image-20220430150105316"></p><hr><h3 id="元素显示模式的切换"><a href="#元素显示模式的切换" class="headerlink" title="元素显示模式的切换"></a>元素显示模式的切换</h3><p>常用于行内元素转化为块级元素的地方</p><p>因为行内元素不能够指定宽高的参数.</p><p>可以使用display属性来切换元素显示模式</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;<span class="comment">/*转换为块级*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline;<span class="comment">/*转换为行内*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;<span class="comment">/*转换为行内块级元素*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="侧边栏案例"><a href="#侧边栏案例" class="headerlink" title="侧边栏案例"></a>侧边栏案例</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 设置链接属性 将其设置为块级 背景颜色 缩进 字体大小 下划线 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">230px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">        </span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#55585a</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">14px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-indent</span>: <span class="number">2em</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#ff6700</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>手机 电话卡<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>电视 盒子<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>笔记本 平板<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>出行 穿戴<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>智能 路由器<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>健康 儿童<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>耳机 音响<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220504115819894.png" alt="image-20220504115819894"></p><hr><h3 id="文字垂直居中小技巧"><a href="#文字垂直居中小技巧" class="headerlink" title="文字垂直居中小技巧"></a>文字垂直居中小技巧</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220504115949285.png" alt="image-20220504115949285"></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">40px</span>;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220504120108580.png" alt="image-20220504120108580"></p><hr><h2 id="CSS背景设置"><a href="#CSS背景设置" class="headerlink" title="CSS背景设置"></a>CSS背景设置</h2><h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220504120448675.png" alt="image-20220504120448675"></p><hr><h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220504121033371.png" alt="image-20220504121033371"></p><hr><h3 id="背景平铺"><a href="#背景平铺" class="headerlink" title="背景平铺"></a>背景平铺</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220504121338046.png" alt="image-20220504121338046"></p><hr><h3 id="背景图片的位置"><a href="#背景图片的位置" class="headerlink" title="背景图片的位置"></a>背景图片的位置</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220504121559622.png" alt="image-20220504121559622"></p><hr><h2 id="CSS引入方式"><a href="#CSS引入方式" class="headerlink" title="CSS引入方式"></a>CSS引入方式</h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430003236850.png" alt="image-20220430003236850"></p><hr><h4 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430003405466.png" alt="image-20220430003405466"></p><ul><li>一般用在测试过程中,不适合实际开发过程中</li></ul><hr><h4 id="行内样式表"><a href="#行内样式表" class="headerlink" title="行内样式表"></a>行内样式表</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430003711733.png" alt="image-20220430003711733"></p><hr><h4 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430003941662.png" alt="image-20220430003941662"></p><hr><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>新闻页面html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font</span>: <span class="number">16px</span> <span class="number">28px</span> <span class="string">&#x27;Microsoft YahHei&#x27;</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">h1</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-weight</span>: <span class="number">700</span>; <span class="comment">/*文字加粗*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center; <span class="comment">/*文字居中*/</span></span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.gray</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#888888</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.search</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#666666</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">170px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.btn</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font</span>: <span class="number">700</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 所有段落首行缩进 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-indent</span>: <span class="number">2em</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 想要图片水平居中 需要给他的父类添加text-align */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.pic</span> &#123; </span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>中共中央政治局召开会议 分析研究当前经济形势和经济工作 审议《国家“十四五”期间人才发展规划》 中共中央总书记习近平主持会议<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gray&quot;</span>&gt;</span>（原标题：中共中央政治局召开会议 分析研究当前经济形势和经济工作 审议《国家“十四五”期间人才发展规划》 中共中央总书记习近平主持会议）<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>网易新闻<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入查询条件&quot;</span> <span class="attr">class</span>=<span class="string">&quot;search&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>中共中央政治局召开会议 中共中央总书记习近平主持会议（来源：视频综合）<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">中共中央政治局4月29日召开会议，分析研究当前经济形势和经济工作，审议《国家“十四五”期间人才发展规划》。中共中央总书记习近平主持会议。</span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cms-bucket.ws.126.net/2022/0222/348a6d62j00r7p5ey004oc000go006yc.jpg?imageView&amp;thumbnail=600y250&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>会议认为，今年以来，面对百年变局和世纪疫情相互叠加的复杂局面，在以习近平同志为核心的党中央坚强领导下，各地区各部门有力统筹疫情防控和经济社会发展，我国经济运行总体实现平稳开局，成功举办北京冬奥会、冬残奥会。成绩来之不易。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>会议指出，新冠肺炎疫情和乌克兰危机导致风险挑战增多，我国经济发展环境的复杂性、严峻性、不确定性上升，稳增长、稳就业、稳物价面临新的挑战。做好经济工作、切实保障和改善民生至关重要。要坚定信心、攻坚克难，确保党中央大政方针落实到位。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>会议强调，疫情要防住、经济要稳住、发展要安全，这是党中央的明确要求。要根据病毒变异和传播的新特点，高效统筹疫情防控和经济社会发展，坚定不移坚持人民至上、生命至上，坚持外防输入、内防反弹，坚持动态清零，最大程度保护人民生命安全和身体健康，最大限度减少疫情对经济社会发展的影响。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>会议要求，要加大宏观政策调节力度，扎实稳住经济，努力实现全年经济社会发展预期目标，保持经济运行在合理区间。要加快落实已经确定的政策，实施好退税减税降费等政策，用好各类货币政策工具。要抓紧谋划增量政策工具，加大相机调控力度，把握好目标导向下政策的提前量和冗余度。要全力扩大国内需求，发挥有效投资的关键作用，强化土地、用能、环评等保障，全面加强基础设施建设。要发挥消费对经济循环的牵引带动作用。要稳住市场主体，对受疫情严重冲击的行业、中小微企业和个体工商户实施一揽子纾困帮扶政策。要做好能源资源保供稳价工作，抓好春耕备耕工作。要切实保障和改善民生，稳定和扩大就业，组织好重要民生商品供应，保障城市核心功能运转，稳控安全生产形势，维护社会大局稳定。要坚持全国一盘棋，确保交通物流畅通，确保重点产业链供应链、抗疫保供企业、关键基础设施正常运转。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>会议强调，要有效管控重点风险，守住不发生系统性风险底线。要坚持房子是用来住的、不是用来炒的定位，支持各地从当地实际出发完善房地产政策，支持刚性和改善性住房需求，优化商品房预售资金监管，促进房地产市场平稳健康发展。要及时回应市场关切，稳步推进股票发行注册制改革，积极引入长期投资者，保持资本市场平稳运行。要促进平台经济健康发展，完成平台经济专项整改，实施常态化监管，出台支持平台经济规范健康发展的具体措施。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>会议指出，要坚持办好自己的事，加快构建新发展格局，坚定不移深化供给侧结构性改革，用改革的办法解决发展中的问题，加快实现高水平科技自立自强，建设强大而有韧性的国民经济循环体系。要坚持扩大高水平对外开放，积极回应外资企业来华营商便利等诉求，稳住外贸外资基本盘。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>会议强调，各级领导干部在工作中要有“时时放心不下”的责任感，担当作为，求真务实，防止各类“黑天鹅”、“灰犀牛”事件发生。各级党委和政府要团结带领广大干部群众齐心协力、顽强拼搏，以实际行动迎接党的二十大胜利召开。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>会议指出，编制《国家“十四五”期间人才发展规划》是党中央部署的一项重要工作，是落实中央人才工作会议精神的具体举措，也是国家“十四五”规划的一项重要专项规划。要全面加强党对人才工作的领导，牢固确立人才引领发展的战略地位，全方位培养引进用好人才。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>会议强调，要坚持重点布局、梯次推进，加快建设世界重要人才中心和创新高地。北京、上海、粤港澳大湾区要坚持高标准，努力打造成创新人才高地示范区。一些高层次人才集中的中心城市要采取有力措施，着力建设吸引和集聚人才的平台，加快形成战略支点和雁阵格局。要大力培养使用战略科学家，打造大批一流科技领军人才和创新团队，造就规模宏大的青年科技人才队伍，培养大批卓越工程师。要把人才培养的着力点放在基础研究人才的支持培养上，为他们提供长期稳定的支持和保障。要深化人才发展体制机制改革，为各类人才搭建干事创业的平台。各级党委（党组）要强化主体责任，完善党管人才工作格局，统筹推进人才工作重大举措落地生效，积极为用人主体和人才排忧解难，加强对人才的政治引领和政治吸纳，引导广大人才爱党报国、敬业奉献，胸怀祖国、服务人民。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>会议还研究了其他事项。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430010452990.png" alt="image-20220430010452990"></p><hr><h2 id="Emmet语法"><a href="#Emmet语法" class="headerlink" title="Emmet语法"></a>Emmet语法</h2><h3 id="Emmet语法快速生成Html标签语法"><a href="#Emmet语法快速生成Html标签语法" class="headerlink" title="Emmet语法快速生成Html标签语法"></a>Emmet语法快速生成Html标签语法</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430010638902.png" alt="image-20220430010638902"></p><hr><h3 id="Emmet语法快速生成样式语法"><a href="#Emmet语法快速生成样式语法" class="headerlink" title="Emmet语法快速生成样式语法"></a>Emmet语法快速生成样式语法</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430010934814.png" alt="image-20220430010934814"></p><hr><h3 id="快速格式化代码"><a href="#快速格式化代码" class="headerlink" title="快速格式化代码"></a>快速格式化代码</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220430011256189.png" alt="image-20220430011256189"></p><hr><h1 id="持续更新中。。。"><a href="#持续更新中。。。" class="headerlink" title="持续更新中。。。"></a>持续更新中。。。</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS层叠样式表&quot;&gt;&lt;a href=&quot;#CSS层叠样式表&quot; class=&quot;headerlink&quot; title=&quot;CSS层叠样式表&quot;&gt;&lt;/a&gt;CSS层叠样式表&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="前端" scheme="https://devildyw.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="CSS" scheme="https://devildyw.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>HTML</title>
    <link href="https://devildyw.github.io/2022/04/24/Html/"/>
    <id>https://devildyw.github.io/2022/04/24/Html/</id>
    <published>2022-04-24T15:48:59.000Z</published>
    <updated>2022-04-25T14:31:31.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a><code>HTML</code></h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    这里主要用于自己学习前端过程中的一些比较难记的知识点或是容易出错的地方，所以内容不是那么完整。一些基础的标签建议之间看文档知道意思就行了。在学习其他的内容的过程中会使用，此时就可以练习加深印象。</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ul><li><p>表格主要用于展示数据</p></li><li><p>表格所有内容都应该包含在<code>&lt;table&gt;</code>标签中</p></li><li><p>表头应该包含在<code>&lt;thead&gt;</code>(语义标签)中</p></li><li><p>表体应该包含在<code>&lt;tbody&gt;</code>(语义标签)中</p></li><li><p>表位应该包含在<code>&lt;tfoot&gt;</code>(语义标签)中</p></li><li><p><code>&lt;tr&gt;</code>表示表中的一行是比<code>&lt;table&gt;</code>低一级的</p></li><li><p><code>&lt;th&gt;</code>表格头，内容居中，加粗显示</p></li><li><p><code>&lt;td&gt;</code>普通表格，内容左对齐</p></li></ul><p><em><strong>【注意】：浏览器一般是通过加载全部表格数据后才显示，但是当数据量很大时，希望能加载一部分，即显示一部分？？</strong></em></p><p>— 使用 <strong>带结构的表格</strong>！！！ 即使用<thead>  <tbody> <tfoot>三个标签</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/20190313151313759.PNG" alt="img"></p><p><strong>【注意】：如果需要单元格合并？？？—使用 跨列属性<code>colspan</code>、<code>rowspan</code></strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Table<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>丁杨维<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!---这里对表进行了列合并和行合并 都为合并2格-&gt;</span></span><br><span class="line"><span class="comment">                &lt;td&gt;20&lt;/td&gt;</span></span><br><span class="line"><span class="comment">                &lt;!-- &lt;td&gt;男&lt;/td&gt; --&gt;</span><span class="comment">&lt;!--合并之后 后写列或是行的元素就是多余的了就可以去掉--&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>丁杨维<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- &lt;td&gt;20&lt;/td&gt; --&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- &lt;td&gt;男&lt;/td&gt; --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425000232732.png" alt="image-20220425000232732"></p><hr><h3 id="table标签的属性"><a href="#table标签的属性" class="headerlink" title="table标签的属性"></a>table标签的属性</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/20190313144717432.jpg" alt="img"></p><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ul><li><p><code>&lt;ol&gt;</code>标签标识里面包含的元素都是有序的可以理解为<code>order list</code></p></li><li><p><code>&lt;li&gt;</code>标签定义列表项目。</p></li><li><p>&#96;&#96;&#96;html</p><!-- 有序列表 --><pre><code>&lt;ol&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;1&lt;/li&gt;&lt;/ol&gt;</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ![image-20220425000813561](https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425000813561.png)</span><br><span class="line"></span><br><span class="line">  有着数字序号标识顺序</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### **无序列表***</span><br><span class="line"></span><br><span class="line">* `&lt;ul&gt;`标签 标识该标签包含的数据是无序的但`&lt;ul&gt;`标签和`&lt;ol&gt;`标签都无法包含除`&lt;li&gt;`之外的内容</span><br><span class="line">* `&lt;li&gt;`标签定义列表项目。 但是`&lt;li&gt;`标签中却可以包含任何标签</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">&lt;!-- 无序列表 --&gt;</span><br><span class="line">    &lt;h4&gt;你喜欢的食物&lt;/h4&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            5</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425001049361.png" alt="image-20220425001049361"></p><p>黑点无法像数字序号那样有着顺序的含义.</p><hr><h3 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a><strong>自定义列表</strong></h3><ul><li><strong><code>&lt;dl&gt;</code></strong> 标签定义了定义列表（definition list）、**<code>&lt;dl&gt;</code>** 标签用于结合 <strong><code>&lt;dt&gt;</code><strong>（定义列表中的项目）和</strong><code>&lt;dd&gt;</code></strong> （描述列表中的项目）。</li><li>**<code>&lt;dt&gt;</code>**标签（定义列表中的项目）</li><li><strong><code>&lt;dd&gt;</code></strong> （描述列表中的项目）</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自定义列表 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dt</span>&gt;</span>关注我们<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>微信<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>qq<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>weibo<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425001428912.png" alt="image-20220425001428912"></p><hr><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>在HTML中，一个完整的表单通常由表单域，表单控件（表单元素）和提示信息3个部分构成。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425205501066.png" alt="image-20220425205501066"></p><hr><h3 id="表单域"><a href="#表单域" class="headerlink" title="表单域"></a>表单域</h3><p><strong>表单域</strong>是一个包含表单元素的区域</p><p>在HTML标签中，<code>&lt;form&gt;</code>标签用于定义表单域，以实现用户信息的收集和传递。</p><p><code>&lt;form&gt;</code>标签会把它范围内的表单信息提交给服务器。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425210050698.png" alt="image-20220425210050698"></p><hr><h3 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a><a href="https://www.runoob.com/tags/tag-input.html">表单元素</a></h3><p><code>&lt;input&gt;</code> 元素有很多形态，根据不同的 <em>type</em> 属性（必选属性）。</p><p><code>type</code>属性有：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425210352522.png" alt="image-20220425210352522"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425212053862.png" alt="image-20220425212053862"></p><p><code>placeholder</code>与<code>value</code>不同 <code>value</code>相当于会是一个默认值的方式显示在文本框中，而<code>placeholder</code>这是以描述的方式显示起到提醒的作用。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 文本框 value就是该input的描述信息会显示出来(默认值)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;请输入用户名&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 密码框 用于用户填写密码 会有非明文显示的功能 placeholder则是真正的描述不会影响内容 只是起提醒的作用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 单按钮 可以实现多选一--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name是表单元素的名字 这里性别单选按钮必须有相同的名字name 才可以实现多选1 --&gt;</span></span><br><span class="line">    男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">checked</span>&gt;</span> 女 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--复选框 可以实现多选--&gt;</span></span><br><span class="line">    吃饭<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;aihao&quot;</span> <span class="attr">checked</span>&gt;</span> 睡觉<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;aihao&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425212312274.png" alt="image-20220425212312274"></p><h4 id="input-type"><a href="#input-type" class="headerlink" title="input:type"></a><code>input:type</code></h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--提交表单中的数据--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 重置表单中元素的默认值 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;重置&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425213025395.png" alt="image-20220425213025395"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 普通按钮 长搭配js一起使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;button&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 上传文件 使用此标签即可选择文件上传 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425214453918.png" alt="image-20220425214453918"></p><h4 id="lt-lable-gt-标签"><a href="#lt-lable-gt-标签" class="headerlink" title="&lt;lable&gt;标签"></a><code>&lt;lable&gt;</code>标签</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425214600618.png" alt="image-20220425214600618"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;nan&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;nan&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;nv&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;nv&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425215214816.png" alt="image-20220425215214816"></p><p>核心：<code>&lt;label&gt;</code>标签的<strong>for属性的值</strong>与相关元素的<strong>id属性相同</strong></p><h4 id="lt-select-gt-表单元素"><a href="#lt-select-gt-表单元素" class="headerlink" title="&lt;select&gt;表单元素"></a><code>&lt;select&gt;</code>表单元素</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425215400451.png" alt="image-20220425215400451"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        籍贯:</span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>山东<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425215653010.png" alt="image-20220425215653010"></p><p>注意：</p><blockquote><ul><li><p><code>&lt;select&gt;</code>中至少包含一对<code>&lt;option&gt;</code></p></li><li><p>在<code>&lt;option&gt;</code>中定义<code>selected = &quot;selected&quot;</code> 时，当前项即为默认选中项</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><h4 id="lt-textarea-gt-表单元素"><a href="#lt-textarea-gt-表单元素" class="headerlink" title="&lt;textarea&gt;表单元素"></a><code>&lt;textarea&gt;</code>表单元素</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425220048166.png" alt="image-20220425220048166"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        今日反馈:</span><br><span class="line">    <span class="comment">&lt;!-- cols:行数 rows:列数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span>留言板:由textarea实现<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425220432726.png" alt="image-20220425220432726"></p><p>该阶段<code>Demo</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>青春不常在,抓紧谈恋爱<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--第一行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;nan&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;nan&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;nv&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;nv&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--第二行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>生日<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>--请选择年份--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>2001<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>2002<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>2003<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>--请选择月份--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>--请选择日--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--第三行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>所在地区<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;北京&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--第四行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>婚姻状况<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hyzk&quot;</span> <span class="attr">id</span>=<span class="string">&quot;jiehun&quot;</span> <span class="attr">checked</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;jiehun&quot;</span>&gt;</span>结婚<span class="tag">&lt;/<span class="name">label</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hyzk&quot;</span> <span class="attr">id</span>=<span class="string">&quot;yihun&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;yihun&quot;</span>&gt;</span>已婚<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hyzk&quot;</span> <span class="attr">id</span>=<span class="string">&quot;lihun&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;lihun&quot;</span>&gt;</span>离婚<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--第五行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>学历<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;博士后&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--第六行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>喜欢类型<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;xhlx&quot;</span> <span class="attr">id</span>=<span class="string">&quot;qingchun&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;qingchun&quot;</span>&gt;</span>清纯<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;xhlx&quot;</span> <span class="attr">id</span>=<span class="string">&quot;keai&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;keai&quot;</span>&gt;</span>可爱<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--第七行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>个人介绍<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;3&quot;</span>&gt;</span>个人简介<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--第八行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;免费注册&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--第九行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">checked</span>&gt;</span>我同意注册条款</span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--第十行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#a&quot;</span>&gt;</span>我是会员,立即登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--第十一行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h5</span>&gt;</span>我承诺<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span> 年满十八、单身<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>抱着严肃的态度<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>真诚寻找另一半<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220425222817761.png" alt="image-20220425222817761"></p><hr><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul><li><a href="https://www.w3school.com.cn/">w3school 在线教程</a></li><li><a href="https://developer.mozilla.org/zh-CN/">MDN Web Docs (mozilla.org)</a></li></ul><hr><h1 id="持续更新中。。。。"><a href="#持续更新中。。。。" class="headerlink" title="持续更新中。。。。"></a>持续更新中。。。。</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;&lt;code&gt;HTML&lt;/code&gt;&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="前端" scheme="https://devildyw.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="HTML5" scheme="https://devildyw.github.io/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>Filter</title>
    <link href="https://devildyw.github.io/2022/04/24/Filter/"/>
    <id>https://devildyw.github.io/2022/04/24/Filter/</id>
    <published>2022-04-24T09:24:56.000Z</published>
    <updated>2022-04-24T09:26:13.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Filter是对客户端访问资源的过滤，符合条件的放行，不符合条件的不放行，并且可以对目标资源访问前后进行逻辑处理的一个组件。</p><h2 id="过滤器的作用"><a href="#过滤器的作用" class="headerlink" title="过滤器的作用"></a>过滤器的作用</h2><p>​    Java过滤器是处于客户端与服务器资源文件之间的一道过滤网，在访问资源文件之前，通过一系列的过滤器可以对请求进行修改、判断等，把不符合规则的请求在中途拦截或修改；也可以对响应进行过滤，拦截或修改响应。例如：修改响应体或是请求体的字符集。</p><hr><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ul><li>步骤： <ul><li>使用Maven创建一个Web项目</li><li>导入<code>javax.servlet-api</code>依赖</li><li>编写一个过滤器继承<code>Filter</code>执行过滤操作</li><li>编写一个<code>Servlet</code>继承<code>HttpServlet</code>执行业务处理操作</li><li>在<code>web.xml/</code>注解中进行配置（配置<code>servlet</code> 和 <code>filter</code> ）</li></ul></li></ul><p>​    <code>CharsetFilter.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharsetFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这里做一些初始化操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这里做一些过滤器被销毁前的操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这里执行过滤请求&quot;</span>);</span><br><span class="line">        <span class="comment">//比如将请求的字符集改为utf-8</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        System.out.println(request.getCharacterEncoding());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里也可以设置响应体的相关参数</span></span><br><span class="line">        System.out.println(response.getCharacterEncoding());</span><br><span class="line">        <span class="comment">//改后放行</span></span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;这里过滤响应&quot;</span>);</span><br><span class="line">        System.out.println(response.getCharacterEncoding());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    <code>ServiceServlet.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        out.println(req.getParameter(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>web.xml</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    注册servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>servlet.ServiceServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.CharsetFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>xml</code>配置</p><p><code>url-pattern</code>：代表要过滤的资源的匹配</p><p><code>filter-name</code>：过滤器名称 用于映射 于<code>servlet-name</code>作用相同</p><p><code>filter-class</code>： 过滤器类的全限定名称</p><p><code>servlet-name</code>：代表要过滤的<code>Servlet</code>的资源匹配</p></blockquote><hr><h2 id="Filter的生命周期其与生命周期相关的方法"><a href="#Filter的生命周期其与生命周期相关的方法" class="headerlink" title="Filter的生命周期其与生命周期相关的方法"></a>Filter的生命周期其与生命周期相关的方法</h2><p>Filter接口有三个方法，这三个方法都与Filter的生命后期有关。</p><ul><li><code>init(FilterConfig)</code>： 代表filter对象初始化方法，filter对象由<code>tomcat</code>创建并且会将配置文件（<code>web.xml</code>）生成一个<code>FilterConfig</code>对象注入其中。</li><li><code>doFilter(ServletRequest,ServletResponse,FilterChain)</code>： 代表filter对象执行过滤的核心方法如果某资源在已经被配置到这个filter进行过滤的话，那么每次访问这个资源都会执行<code>doFilter()</code>方法，与<code>Servlet</code>的<code>Service()</code>方法类似。</li><li><code>destory()</code>： 代表filter销毁的方法，这里可以执行一些销毁前的操作， 当filter对象销毁时会执行这个方法。</li></ul><hr><h3 id="Filter对象的生命周期"><a href="#Filter对象的生命周期" class="headerlink" title="Filter对象的生命周期"></a>Filter对象的生命周期</h3><ul><li><strong>Filter何时创建：服务器启动时就创建该filter对象</strong></li><li><strong>Filter合适销毁： 服务器关闭时filter销毁</strong></li></ul><p><strong>注意：<code>Filter</code>与<code>Servlet</code>一样都是默认单例的。</strong></p><hr><h2 id="Filter相关API"><a href="#Filter相关API" class="headerlink" title="Filter相关API"></a>Filter相关<code>API</code></h2><ol><li><p><code>init(FilterConfig)</code></p><ol><li><code>Filter</code>创建时会去执行的<code>init</code>方法</li><li>参数<code>FilterConfig</code>代表该<code>Filter</code>对象配置信息的对象，内部封装的是该Filter的配置信息。由<code>Tomcat</code>创建该Filter对象时从配置文件中读取封装为一个<code>FilterConfig</code>后注入。</li></ol></li><li><p><code>destroy()</code></p><ol><li>filter对象销毁时执行</li><li>这里可以执行一些销毁前需要执行的操作，因为filter对象销毁时该方法会被执行</li></ol></li><li><p><code>doFilter(ServletRequest,ServletResponse,FilterChain)</code></p><ol><li><p>当该filter映射的<code>url-pattern</code>对应的资源被访问了 会执行该方法</p></li><li><p>其中的参数</p><blockquote><ul><li><code>ServletRequest/ServletResponse</code>：每次在执行<code>doFilter</code>方法时 web容器负责创建一个<code>request</code>和一个<code>response</code>对象作为<code>doFilter</code>的参数传递进来。该<code>request</code>和<code>response</code>就是在访问目标资源的<code>service</code>方法时的<code>request</code>和<code>response</code>。</li><li><code>FilterChain</code>: 过滤器链对象， 通过该对象的<code>doFilter</code>方法可以放行该请求，如果该过滤器上还有过滤器没有过滤该请求，那么转交给它，如果没有则直接到达<code>Servlet</code>的<code>service()</code>。</li></ul></blockquote></li></ol></li></ol><hr><h2 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h2><p>​    在一个 Web 应用程序中可以注册多个 Filter 程序，每个 Filter 程序都可以针对某一个 URL 进行拦截。如果多个 Filter 程序都对同一个 URL 进行拦截，那么这些 Filter 就会组成一个Filter 链（也称过滤器链）。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/e7aa5e26bcbc923a1235b5e70b6e938f.png" alt="e7aa5e26bcbc923a1235b5e70b6e938f.png"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/5-1Z6121G30B63.png" alt="Filter链"></p><ul><li>拦截顺序和过滤器<code>web.xml</code>注册顺序（<code>filter-mapping</code>）一致。</li><li>由上图可知过滤器链过滤的顺序准许”先进后出”的原则。</li></ul><h3 id="过滤器链代码演示"><a href="#过滤器链代码演示" class="headerlink" title="过滤器链代码演示"></a>过滤器链代码演示</h3><p><code>Servlet.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;html/text;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        System.out.println(<span class="string">&quot;请求已接受&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;请求已接受&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Filter01.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Filter01</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求经过过滤器01&quot;</span>);</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">        System.out.println(<span class="string">&quot;响应经过过滤器01&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Filter02.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Filter02</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求经过过滤器02&quot;</span>);</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">        System.out.println(<span class="string">&quot;响应经过过滤器02&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>web.xml</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>servlet.Servlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/filterServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    过滤器链注册--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.Filter01<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/filterServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.Filter02<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/filterServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>控制台输出（可以看到 先进后出）</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220424163848783.png" alt="image-20220424163848783"></p><hr><h2 id="Filter的url-pattern配置"><a href="#Filter的url-pattern配置" class="headerlink" title="Filter的url-pattern配置"></a><code>Filter</code>的<code>url-pattern</code>配置</h2><ul><li><p>匹配单个资源</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.Filter02<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/filterServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>统配符匹配（最常使用）</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.Filter02<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>扩展名匹配 （<code>*.abc *.jsp</code>）<strong>注意不能和统配符混用</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.Filter02<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="End"><a href="#End" class="headerlink" title="-End-"></a>-End-</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Filter&quot;&gt;&lt;a href=&quot;#Filter&quot; class=&quot;headerlink&quot; title=&quot;Filter&quot;&gt;&lt;/a&gt;Filter&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="JavaEE" scheme="https://devildyw.github.io/categories/JavaEE/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式----创建型模式之简单工厂设计模式</title>
    <link href="https://devildyw.github.io/2022/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://devildyw.github.io/2022/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-04-17T09:29:10.000Z</published>
    <updated>2022-04-17T09:30:56.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式—-创建型模式之简单工厂设计模式"><a href="#设计模式—-创建型模式之简单工厂设计模式" class="headerlink" title="设计模式—-创建型模式之简单工厂设计模式"></a>设计模式—-创建型模式之简单工厂设计模式</h1><h2 id="1-1-模式动机"><a href="#1-1-模式动机" class="headerlink" title="1.1. 模式动机"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id15">1.1. 模式动机</a></h2><p>考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。</p><hr><h2 id="1-2-模式定义"><a href="#1-2-模式定义" class="headerlink" title="1.2. 模式定义"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id16">1.2. 模式定义</a></h2><p>简单工厂模式(<code>Simple Factory Pattern</code>)：又称为<strong>静态工厂方法</strong>(<code>Static Factory Method</code>)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><hr><h2 id="1-3-模式结构"><a href="#1-3-模式结构" class="headerlink" title="1.3. 模式结构"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id17">1.3. 模式结构</a></h2><p>简单工厂模式包含如下角色：</p><ul><li><p><code>Factory</code>：工厂角色</p><p>工厂角色负责实现创建所有实例的内部逻辑</p></li><li><p><code>Product</code>：抽象产品角色</p><p>抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</p></li><li><p><code>ConcreteProduct</code>：具体产品角色</p><p>具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</p></li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/SimpleFactory.jpg" alt="../_images/SimpleFactory.jpg"></p><hr><h2 id="1-4-时序图"><a href="#1-4-时序图" class="headerlink" title="1.4. 时序图"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id18">1.4. 时序图</a></h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/seq_SimpleFactory.jpg" alt="../_images/seq_SimpleFactory.jpg"></p><hr><h2 id="1-5-代码分析"><a href="#1-5-代码分析" class="headerlink" title="1.5. 代码分析"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id19">1.5. 代码分析</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VehiclesGenerator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CAR</span> <span class="operator">=</span> <span class="string">&quot;Car&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BIKE</span> <span class="operator">=</span> <span class="string">&quot;Bike&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TRAIN</span> <span class="operator">=</span> <span class="string">&quot;Train&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">AIRPLANE</span> <span class="operator">=</span> <span class="string">&quot;Airplane&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方式一 交通工具生成器</span></span><br><span class="line"><span class="comment">     * 使用if 判断字段来生成实例</span></span><br><span class="line"><span class="comment">     * 返回值为抽象类类型 根据继承的知识我们知道 父类只能拥有子类重写的方法</span></span><br><span class="line"><span class="comment">     * 所以如果子类有额外的方法时需要向下转型.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vehiclesType 交通工具的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的交通工具</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Vehicles <span class="title function_">getInstance</span><span class="params">(String vehiclesType)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vehiclesType.equals(CAR))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vehiclesType.equals(TRAIN))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Train</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vehiclesType.equals(BIKE))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bike</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vehiclesType.equals(AIRPLANE))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Airplane</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">VehiclesGenerator</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-6-模式分析"><a href="#1-6-模式分析" class="headerlink" title="1.6. 模式分析"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id20">1.6. 模式分析</a></h2><ul><li>将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。</li><li>在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。</li><li>简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。</li><li>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</li></ul><hr><h2 id="1-7-实例"><a href="#1-7-实例" class="headerlink" title="1.7. 实例"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id21">1.7. 实例</a></h2><p><a href="https://github.com/Devildyw/design-patterns/tree/master/DesignPatterns-Java/SimpleFactoryPattern">简单工厂设计模式实例</a></p><hr><h2 id="1-8-简单工厂模式的优点"><a href="#1-8-简单工厂模式的优点" class="headerlink" title="1.8. 简单工厂模式的优点"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id22">1.8. 简单工厂模式的优点</a></h2><ul><li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。</li><li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li><li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li></ul><hr><h2 id="1-9-简单工厂模式的缺点"><a href="#1-9-简单工厂模式的缺点" class="headerlink" title="1.9. 简单工厂模式的缺点"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id23">1.9. 简单工厂模式的缺点</a></h2><ul><li>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</li><li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</li><li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li><li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li></ul><hr><h2 id="1-10-适用环境"><a href="#1-10-适用环境" class="headerlink" title="1.10. 适用环境"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id24">1.10. 适用环境</a></h2><p><strong>在以下情况下可以使用简单工厂模式：</strong></p><ul><li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li><li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li></ul><hr><h2 id="1-11-模式应用"><a href="#1-11-模式应用" class="headerlink" title="1.11. 模式应用"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id25">1.11. 模式应用</a></h2><ol><li><code>JDK</code>类库中广泛使用了简单工厂模式，如工具类<code>java.text.DateFormat</code>，它用于格式化一个本地日期或者时间。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title function_">getDateInstance</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title function_">getDateInstance</span><span class="params">(<span class="type">int</span> style)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title function_">getDateInstance</span><span class="params">(<span class="type">int</span> style,Locale</span></span><br><span class="line"><span class="params">locale)</span>;</span><br></pre></td></tr></table></figure><ol><li><code>Java</code>加密技术</li></ol><p>获取不同加密算法的密钥生成器:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">KeyGenerator keyGen=KeyGenerator.getInstance(<span class="string">&quot;DESede&quot;</span>);</span><br></pre></td></tr></table></figure><p>创建密码器:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cipher cp=Cipher.getInstance(<span class="string">&quot;DESede&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="1-12-总结"><a href="#1-12-总结" class="headerlink" title="1.12. 总结"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id26">1.12. 总结</a></h2><ul><li>创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。</li><li>简单工厂模式又称为静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</li><li>简单工厂模式包含三个角色：工厂角色负责实现创建所有实例的内部逻辑；抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</li><li>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</li><li>简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。</li><li>简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。</li></ul><hr><p><strong>摘自:</strong><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html"> 简单工厂模式( Simple Factory Pattern ) — Graphic Design Patterns (design-patterns.readthedocs.io)</a></p><h1 id="End"><a href="#End" class="headerlink" title="-End-"></a>-End-</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式—-创建型模式之简单工厂设计模式&quot;&gt;&lt;a href=&quot;#设计模式—-创建型模式之简单工厂设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式—-创建型模式之简单工厂设计模式&quot;&gt;&lt;/a&gt;设计模式—-创建型模式之简单工厂设计模式&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devildyw.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Developer" scheme="https://devildyw.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>restTemplate</title>
    <link href="https://devildyw.github.io/2022/04/16/restTemplate/"/>
    <id>https://devildyw.github.io/2022/04/16/restTemplate/</id>
    <published>2022-04-16T08:50:04.000Z</published>
    <updated>2022-04-16T09:04:44.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h1><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/wallhaven-8oky1j.jpg" alt="General 1920x1080 Gordon Zuchhold (Artstation) digital art science fiction pixel art city cyberpunk animation futuristic city ArtStation artwork futuristic"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><code>RestTemplate</code>是由<code>Spring</code>框架提供的一个可用于应用中调用<code>rest</code>服务的类它简化了与<code>http</code>服务的通信方式，统一了<code>RESTFul</code>的标准，封装了<code>http</code>连接，我们只需要传入<code>url</code>及其返回值类型即可。相较于之前常用的<code>HttpClient</code>，<code>RestTemplate</code>是一种更为优雅的调用<code>RESTFul</code>服务的方式。</li><li>在<code>Spring</code>应用程序中访问第三方<code>REST服务</code>与使用<code>Spring RestTemplate</code>类有关。<code>RestTemplate</code>类的设计原则与许多其他<code>Spring</code>的模板类(例如<code>JdbcTemplate</code>)相同，为执行复杂任务提供了一种具有默认行为的简化方法。</li><li><code>RestTemplate</code>默认依赖JDK提供了<code>http</code>连接的能力（<code>HttpURLConnection</code>），如果有需要的话也可以通过<code>setRequestFactory</code>方法替换为例如<code>Apache HttpCompoent、Netty或OKHttp</code>等其他<code>Http libaray</code>。</li><li>考虑到了<code>RestTemplate</code>类是为了调用REST服务而设计的，因此它的主要方法与<code>REST</code>的基础紧密相连就不足为奇了，后者时<code>HTTP</code>协议的方法：<code>HEAD、GET、POST、PUT、DELETE、OPTIONS</code>例如，<code>RestTemplate</code>类具有<code>headForHeaders()、getForObject()、putForObject()，put()和delete()</code>等方法。</li></ul><h2 id="创建RestTemplate"><a href="#创建RestTemplate" class="headerlink" title="创建RestTemplate"></a>创建<code>RestTemplate</code></h2><p>​    因为<code>RestTemplate</code>是<code>Spirng</code>框架提供的所以只要是一个<code>Springboot</code>项目就不用考虑导包的问题，这些都是提供好的。</p><p>​    但是<code>Spring</code>并没有将其加入<code>SpringBean</code>容器中，需要我们手动加入，因为我们首先创建一个<code>Springboot</code>配置类，再在配置类中将我们的<code>RestTemlate</code>注册到<code>Bean</code>容器中</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​    使用<code>Springboot</code>提供的<code>RestTemplateBuilder</code>构造类来构造一个<code>RestTemplate</code>，可以自定义一些连接参数，如：连接超时时间，读取超时时间，还有认证信息等</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415202710768.png" alt="image-20220415202710768"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">(RestTemplateBuilder builder)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">                <span class="comment">//设置连接超时时间</span></span><br><span class="line">                .setConnectTimeout(Duration.ofSeconds(<span class="number">5000</span>))</span><br><span class="line">                <span class="comment">//设置读取超时时间</span></span><br><span class="line">                .setReadTimeout(Duration.ofSeconds(<span class="number">5000</span>))</span><br><span class="line">                <span class="comment">//设置认证信息</span></span><br><span class="line">                .basicAuthentication(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                <span class="comment">//设置根路径</span></span><br><span class="line">                .rootUri(<span class="string">&quot;https://api.test.com/&quot;</span>)</span><br><span class="line">                <span class="comment">//构建</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加自定义的拦截器"><a href="#添加自定义的拦截器" class="headerlink" title="添加自定义的拦截器"></a>添加自定义的拦截器</h4><p>​    自定义拦截器示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomClientHttpRequestInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ClientHttpRequestInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ClientHttpResponse <span class="title function_">intercept</span><span class="params">(HttpRequest request, <span class="type">byte</span>[] body, ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印请求明细</span></span><br><span class="line">        logRequestDetails(request,body);</span><br><span class="line">        <span class="type">ClientHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> execution.execute(request, body);</span><br><span class="line">        <span class="comment">//打印响应明细</span></span><br><span class="line">        logResponseDetails(response);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logRequestDetails</span><span class="params">(HttpRequest request, <span class="type">byte</span>[] body)</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Headers:&#123;&#125;&quot;</span>,request.getHeaders());</span><br><span class="line">        log.debug(<span class="string">&quot;body:&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>(body, StandardCharsets.UTF_8));</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>,request.getMethod(),request.getMethodValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logResponseDetails</span><span class="params">(ClientHttpResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Status code : &#123;&#125;&quot;</span>,response.getStatusCode());</span><br><span class="line">        log.debug(<span class="string">&quot;Status text : &#123;&#125;&quot;</span>,response.getStatusText());</span><br><span class="line">        log.debug(<span class="string">&quot;Headers : &#123;&#125;&quot;</span>,response.getHeaders());</span><br><span class="line">        log.debug(<span class="string">&quot;Response body: &#123;&#125;&quot;</span>, StreamUtils.copyToString(response.getBody(),StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    使用<code>RestTemplateBuilder</code>构造类，添加自定义拦截器，构造带有自定义拦截器的<code>RestTemplate</code>实例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">(RestTemplateBuilder builder)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">                .additionalInterceptors(<span class="keyword">new</span> <span class="title class_">CustomClientHttpRequestInterceptor</span>())</span><br><span class="line">                <span class="comment">//构建</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    测试请求确实经过了拦截器，注册成功（注意请求和响应的流只会被读取一次，这里我们读取了response后返回的response就读取不到刚刚读过的内容了）</p><p>​    <img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415204816204.png" alt="image-20220415204816204"></p><hr><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​    使用<code>RestTemplate</code>构造方法构造一个<code>RestTemlate</code>，虽然不能像<code>RestTemplate</code>构造类那样更详细、更多样的配置参数，但是<code>RestTemplate</code>构造方法在一般情况是够用的。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415195208601.png" alt="image-20220415195208601"></p><ul><li>无参构造 全部参数默认</li><li>指定<code>ClientHttpRequestFactory</code> 的构造方法可以指定自己实现的<code>ClientHttpRequestFactory</code>（客户端<code>http</code>请求工厂）其他的与无参构造相同。<ul><li><code>ClientHttpRequestFactory</code></li></ul></li><li>指定<code>List&lt;HttpMessageConverter&lt;?&gt;&gt;</code>的构造方法可以指定自己是实现的<code>HttpMessageConverter</code>（<code>Http</code>消息转换器）传入其他与无参构造相同。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>​    两者方法都可使用，前者提供了多样的自定义参数的选择，可以将<code>RestTemplate</code>配置的更为完善，后者则简化了配置虽然配置多样性不如前者，但是日常使用调用些<code>API</code>还是足以使用</p><h2 id="RestTemplate-API使用"><a href="#RestTemplate-API使用" class="headerlink" title="RestTemplate API使用"></a><code>RestTemplate API</code>使用</h2><p>​    在使用<code>RestTemplate</code>前先让我们看看<code>RestTemplate</code>有哪些<code>API</code></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415205801633.png" alt="image-20220415205801633"><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415205831801.png" alt="image-20220415205831801"></p><p>​    相信大家看到这么多方法，一定很头大，但是我们仔细看上述的方法，我们可以提取出主要的几种方法是(这里只讨论Http请求的)：</p><ul><li><strong><code>GET</code></strong></li><li><strong><code>POST</code></strong></li><li><strong><code>PUT</code></strong></li><li><strong><code>DELETE</code></strong></li><li><strong><code>HEAD</code></strong></li><li><strong><code>OPTIONS</code></strong></li><li><strong><code>EXCHANGE</code></strong></li><li><strong><code>EXECUTE</code></strong></li></ul><p>​    <strong>这里我给大家安利一个一个网站，它提供免费的RESTFul api的样例测试。</strong><a href="http://httpbin.org/">httpbin A simple HTTP Request &amp; Response Service.</a></p><hr><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>​    通过上图我们可以发现<code>RestTemlate</code>发送<code>GET</code>请求的方法有两种</p><blockquote><ul><li><code>public &lt;T&gt; T getForObject(...)</code></li><li><code>public &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(...)</code></li></ul></blockquote><h4 id="getForEntity"><a href="#getForEntity" class="headerlink" title="getForEntity()"></a><strong><code>getForEntity()</code></strong></h4><p>​    后缀带有<code>Entity</code>的方法都代表返回一个<code>ResponseEntity&lt;T&gt;</code>，<code>ResponseEntity&lt;T&gt;</code>是Spring对<code>HTTP</code>请求响应的封装，包括了几个重要的元素，如响应码，<code>contentType、contentLength</code>、响应消息体等</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415211830207.png" alt="image-20220415211830207"></p><p>​    通过它继承父类(<code>HttpEntity&lt;T&gt;</code>)的<code>getHeader()</code>方法我们可以获取<code>contentType、contentLength</code>、响应消息体等。比如下面这个例子。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryWeather</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        ResponseEntity&lt;Object&gt; forEntity = restTemplate.getForEntity(<span class="string">&quot;https://restapi.amap.com/v3/weather/weatherInfo?city=510100&amp;key=e7a5fa943f706602033b6b329c49fbc6&quot;</span>, Object.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;状态码:&quot;</span>+forEntity.getStatusCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;状态码内容:&quot;</span>+forEntity.getStatusCodeValue());</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> forEntity.getHeaders();</span><br><span class="line">        System.out.println(<span class="string">&quot;响应头:&quot;</span>+headers);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">body</span> <span class="operator">=</span> forEntity.getBody();</span><br><span class="line">        System.out.println(<span class="string">&quot;响应内容:&quot;</span>+body);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    该例子中<code>getForEntity()</code>方法的第一个参数为我要调用服务的<code>URL</code>，第二个参数则为响应内容的类的类型（Java嘛 万物皆对象）还可以添加第三个参数，第三个参数为一个可变参数 代表着调用服务时的传参。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415212800839.png" alt="image-20220415212800839">    <strong>第三个参数可以使用key-value的map来传入参数</strong></p><p>​    <strong>get请求也可通过向在url上添加查询参数来发送带有请求的参数</strong></p><hr><h4 id="getForObject"><a href="#getForObject" class="headerlink" title="getForObject()"></a><strong><code>getForObject()</code></strong></h4><p>​    相比于前者<code>getForEntity()</code>该方法则是，更偏向于直接获取响应内容的，因为他直接返回响应实体的<code>body</code>（响应内容），。比如下面这个例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryWeather</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Object</span> <span class="variable">body</span> <span class="operator">=</span> restTemplate.getForObject(<span class="string">&quot;https://restapi.amap.com/v3/weather/weatherInfo?city=510100&amp;key=e7a5fa943f706602033b6b329c49fbc6&quot;</span>, Object.class);</span><br><span class="line">        System.out.println(body);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><pre><code> 方法参数签名与`getForEntity()`基本一致。</code></pre><hr><p>​    当你只需要返回的响应内容时，使用<code>getForObject()</code>是一个很好的选择，但当你需要获得更详细的响应信息，如响应头中的信息，你就只能选择<code>getForEntity()</code>了。</p><hr><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>​    <code>POST</code>请求有如下三种方法</p><blockquote><ul><li><code>public URI postForLocation(...)</code></li><li><code>public &lt;T&gt; T postForObject(...)</code></li><li><code>public &lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(...)</code></li></ul></blockquote><p>​    后两种用法与<code>GET</code>基本一致不做详细介绍，这里着重介绍<code>postForLocation()</code></p><hr><h4 id="postForEntity"><a href="#postForEntity" class="headerlink" title="postForEntity()"></a><code>postForEntity()</code></h4><p>​    该方法有三个参数，第一个为调用服务的地址（URL）</p><p>​    第二个参数表示上传的参数(json格式提交)</p><p>​    第三个表示返回响应内容的具体类型</p><p>​    第四个参数也用于指定参数（在URL中添加）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryWeather</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;鲁大师&quot;</span>);</span><br><span class="line">        ResponseEntity&lt;Object&gt; objectResponseEntity = restTemplate.postForEntity(<span class="string">&quot;https://restapi.amap.com/v3/weather/weatherInfo?city=510100&amp;key=e7a5fa943f706602033b6b329c49fbc6&quot;</span>, user, Object.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息响应内容:&quot;</span>+objectResponseEntity.getBody());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h4 id="postForObject"><a href="#postForObject" class="headerlink" title="postForObject()"></a><code>postForObject()</code></h4><p>​    使用方法与<code>getForObject</code>类似只是多了一个传入对象参数（传入方式与<code>postForEntity()</code>相同）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryWeather</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;鲁大师&quot;</span>);</span><br><span class="line">        ResponseEntity&lt;Object&gt; objectResponseEntity = restTemplate.postForEntity(<span class="string">&quot;https://httpbin.org/post&quot;</span>, user, Object.class);</span><br><span class="line">        <span class="type">MediaType</span> <span class="variable">contentType</span> <span class="operator">=</span> objectResponseEntity.getHeaders().getContentType();</span><br><span class="line">        System.out.println(contentType);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息响应内容:&quot;</span>+objectResponseEntity.getBody());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h4 id="postForLocation"><a href="#postForLocation" class="headerlink" title="postForLocation()"></a><code>postForLocation()</code></h4><p>​    <code>postForLocation</code>传参用法与前两者一致，只不过返回从实体变成了一个<code>URL</code>，因此它不需要指定返回响应内容的类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryWeather</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;鲁大师&quot;</span>);</span><br><span class="line">        <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> restTemplate.postForLocation(<span class="string">&quot;https://httpbin.org/post&quot;</span>, user);</span><br><span class="line">        System.out.println(uri);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个只需要服务提供者返回一个 URI 即可，该<code>URI</code>返回值体现的是：用于提交完成数据之后的页面跳转，或数据提交完成之后的下一步数据操作<code>URI</code>。</p><h4 id="使用POST以表单方式提交"><a href="#使用POST以表单方式提交" class="headerlink" title="使用POST以表单方式提交"></a>使用POST以表单方式提交</h4><p>​    这里我们着重说一下，如何自己封装一个请求体。</p><p>​    我们需要用到如下几个类</p><blockquote><ul><li><code>HttpHeaders</code></li><li><code>MultiValueMap&lt;K,V&gt;</code></li><li><code>HttpEntity&lt;T&gt;</code></li></ul></blockquote><h5 id="HttpHeaders"><a href="#HttpHeaders" class="headerlink" title="HttpHeaders"></a><code>HttpHeaders</code></h5><p>​    故名思意，就是用来封装Http请求的请求头的，这里我们要设置他的<code>ContentType</code>为**<code>MediaType.APPLICATION_FORM_URLENCODED</code>**以使得我们提交的参数是以Form(表单)的形式提交。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置请求头, x-www-form-urlencoded格式的数据</span></span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        <span class="comment">//这里指定参数以UTF-8编码格式传输</span></span><br><span class="line">        <span class="type">MediaType</span> <span class="variable">mediaType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaType</span>(MediaType.APPLICATION_FORM_URLENCODED, UTF_8);</span><br><span class="line">        httpHeaders.setContentType(mediaType);</span><br><span class="line">        <span class="comment">//提交参数设置</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">        map.add(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;鲁大师&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h5 id="MultiValueMap-lt-K-V-gt"><a href="#MultiValueMap-lt-K-V-gt" class="headerlink" title="MultiValueMap&lt;K,V&gt;"></a><code>MultiValueMap&lt;K,V&gt;</code></h5><p>​    该类是用来封装请求参数的，是以<code>key-value</code>的形式封装但是以单个key对应多个value的格式传输(也就是是以单个<code>key:[value...]</code>的格式传输的)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提交参数设置</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">        map.add(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;鲁大师&quot;</span>);</span><br></pre></td></tr></table></figure><p>​    <strong>如果像传输单个<code>key</code>对应单个<code>value</code>使用普通的<code>Map</code>传参即可</strong></p><hr><h5 id="HttpEntity-lt-T-gt"><a href="#HttpEntity-lt-T-gt" class="headerlink" title="HttpEntity&lt;T&gt;"></a><code>HttpEntity&lt;T&gt;</code></h5><p>​    该类是用来封装请求的，主要作用就是将请求头和请求体封装在一起成为一个请求实体 T用来指定用来封装参数的容器的类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组装请求体</span></span><br><span class="line">        HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; request = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(map, httpHeaders);</span><br></pre></td></tr></table></figure><hr><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>通过上述介绍后，我们就可以自己封装一个以form形式提交参数的<code>POST</code>请求了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//请求地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://httpbin.org/post&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置请求头, x-www-form-urlencoded格式的数据</span></span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        httpHeaders.setContentType(MediaType.APPLICATION_FORM_URLENCODED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交参数设置</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">        map.add(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;鲁大师&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//组装请求体</span></span><br><span class="line">        HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; request = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(map, httpHeaders);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送post请求并打印结果 以String类型接收响应结果JSON字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> restTemplate.postForObject(url, request, String.class);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416124128856.png" alt="image-20220416124128856"></p><p>​    通过拦截器拦截了请求并对请求头进行拆包，可以发现<code>ContentType</code>已经被修改成了<code>x-www-form-urlencoded</code>格式了。</p><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>​    <code>PUT</code>请求的方法只有一类</p><blockquote><ul><li><code>void put()</code></li></ul></blockquote><h4 id="PUT-1"><a href="#PUT-1" class="headerlink" title="PUT()"></a><code>PUT()</code></h4><p>​    使用方法与<code>postForEntity()</code>参数基本一致，只是<code>put</code>方法没有返回值（也就不必去设置响应内容的类型了）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//请求地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/put&quot;</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;鲁大师&quot;</span>);</span><br><span class="line">        restTemplate.put(url,user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>​    与<code>PUT</code>一样，<code>DELETE</code>方法只有一类</p><blockquote><ul><li><code>void delete()</code></li></ul></blockquote><h4 id="delete"><a href="#delete" class="headerlink" title="delete()"></a><code>delete()</code></h4><p>​    <code>delete()</code>可以指定<code>url</code>中的中的参数，但是<code>RestTemplate</code>的<code>delete()</code>方法是不支持上传<code>requestBody</code>的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/delete&quot;</span>;</span><br><span class="line">    restTemplate.delete(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="HEADER"><a href="#HEADER" class="headerlink" title="HEADER"></a>HEADER</h3><p>​    <code>HEADER</code>也只有一类方法</p><blockquote><ul><li><code>public HttpHeaders headForHeaders()</code></li></ul></blockquote><p>​    主要用来发送请求获取响应头部信息，但是像<code>DELETE</code>、<code>PUT</code>这类没有响应的方法，是不能使用该方法的（因为没有响应也就没有响应头了）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//请求地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/get&quot;</span>;</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> restTemplate.headForHeaders(url);</span><br><span class="line">        System.out.println(httpHeaders);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416151836372.png" alt="image-20220416151836372"></p><hr><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><blockquote><ul><li><code>public Set&lt;HttpMethod&gt; optionsForAllow()</code></li></ul></blockquote><p>​    该方法的主要用来判断该服务地址，能够使用那种方法去执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//请求地址</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/get&quot;</span>;</span><br><span class="line">       Set&lt;HttpMethod&gt; httpMethods = restTemplate.optionsForAllow(url);</span><br><span class="line">       System.out.println(httpMethods);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416152755753.png" alt="image-20220416152755753"></p><hr><h3 id="EXCHANGE"><a href="#EXCHANGE" class="headerlink" title="EXCHANGE"></a>EXCHANGE</h3><blockquote><ul><li><code>&lt;T&gt; ResponseEntity&lt;T&gt; exchange()</code></li></ul></blockquote><p>​    该接口与其他接口不同</p><blockquote><ul><li>该方法允许用户指定请求的方法（<code>get,post,put</code>等）</li><li>可以在请求中增加body以及头信息，其内容通过参数<code>HttpEntity&lt;?&gt; requestEntity</code>描述</li><li><code>exchange</code>支持’含参数的类型(即泛型)’作为返回类型，该特性通过<code>ParameterizedTypeReferenceresponseType</code> 描述</li></ul></blockquote><p>​    该方法支持五个参数</p><blockquote><ul><li>第一个是服务地址</li><li>第二个是请求方法</li><li>第三个是写入的请求实体</li><li>第四个是响应内容的类型</li><li>第五个是扩展模板的变量或包含<code>URI</code>模板变量的映射</li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/post&quot;</span>;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;彭于晏&quot;</span>);</span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    httpHeaders.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">    HttpEntity&lt;User&gt; userHttpEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(user, httpHeaders);</span><br><span class="line">    ResponseEntity&lt;Object&gt; exchange = restTemplate.exchange(url, HttpMethod.POST, userHttpEntity, Object.class);</span><br><span class="line">    System.out.println(exchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    上述代码模拟了一个简单的<code>POST</code>请求 <strong>可以理解为可以动态的指定请求方法和请求实体的一个方法。</strong></p><p> <strong>响应实体</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416154441113.png" alt="image-20220416154441113"></p><hr><h3 id="EXECUTE"><a href="#EXECUTE" class="headerlink" title="EXECUTE"></a>EXECUTE</h3><blockquote><ul><li><code>&lt;T&gt; T execute()</code></li></ul></blockquote><p>​    该方法就是执行请求的方法，我们可以发现上述的所有方法的最后执行都是调用的该方法执行，所以他在<code>RestTemplate</code>中十分重要</p><p>​    该方法有五个参数</p><blockquote><ul><li>服务地址</li><li>请求的方法</li><li>准备请求的对象（<code>requestCallback</code>）</li><li>从响应中提取返回值的对象</li><li>扩展模板的变量或包含<code>URI</code>模板变量的映射</li></ul></blockquote><p><code>execute()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">execute</span><span class="params">(String url, HttpMethod method, <span class="meta">@Nullable</span> RequestCallback requestCallback,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> ResponseExtractor&lt;T&gt; responseExtractor, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">URI</span> <span class="variable">expanded</span> <span class="operator">=</span> getUriTemplateHandler().expand(url, uriVariables);</span><br><span class="line"><span class="keyword">return</span> doExecute(expanded, method, requestCallback, responseExtractor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    通过上述源码我们可以发现<code>execute()</code>方法只是将我们传入的<code>String</code>类型的<code>URL</code>转换为了<code>URL</code>类型，最后执行请求是由<code>doExecute()</code>方法</p><hr><h4 id="doExecute"><a href="#doExecute" class="headerlink" title="doExecute()"></a><code>doExecute()</code></h4><p>​    这里需要了解两个类：<code>RequestCallback</code>和<code>ResPonseExtractor</code></p><p>​    <code>RequestCallback</code>: <strong>用于操作请求头和body，在请求发出前执行。不需要关心关闭请求或处理错误：这都将由RestTemplate处理。</strong></p><p>​    该接口有两个实现类：</p><p>​    <img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/v2-6761e212c99b46b5b24de7784c5f6c44_720w.jpg" alt="img"></p><p>​    <code>ResPonseExtractor</code>: <strong>解析HTTP响应的数据，而且不需要担心异常和资源的关闭。</strong></p><p>​    该接口在<code>RestTemplate</code>中同样有两个实现类：</p><table><thead><tr><th><code>HeadersExtractor</code></th><th>提取响应<code>HttpHeaders</code>的响应提取器。直接提取响应体中的响应头</th><th></th></tr></thead><tbody><tr><td><code>ResponseEntityResponseExtractor&lt;T&gt;</code></td><td><code>HttpEntity</code><strong>的响应提取器。可以获取响应实体里面包括响应头，响应体等。具体请查看</strong><code>HttpEntity</code></td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/post&quot;</span>;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;彭于晏&quot;</span>);</span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    httpHeaders.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">    HttpEntity&lt;User&gt; userHttpEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(user, httpHeaders);</span><br><span class="line">    ResponseEntity&lt;Object&gt; execute = restTemplate.execute(url, HttpMethod.POST, restTemplate.httpEntityCallback(userHttpEntity), restTemplate.responseEntityExtractor(Object.class));</span><br><span class="line">    System.out.println(execute);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416161653708.png" alt="image-20220416161653708"></p><hr><h2 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h2><ul><li>前面我们介绍方法的时候发现有个一个可变参数，那个参数被描述成了<strong>扩展模板的变量或是包含<code>URI</code>模板变量的映射</strong></li></ul><p>我们来简单看一下这个参数，我们知道请求传参可以通过<code>url</code>拼接参数的方式传参，拼接参数也分为两种：</p><blockquote><ul><li>路径中嵌入占位的格式（<code>http://httpbin.org/&#123;1&#125;/post</code>）也叫模板映射</li><li>末尾添加<code>Key-value</code>格式（<code>http://httpbin.org/post?name=&quot;彭于晏&quot;</code>）即扩展模板的变量</li></ul></blockquote><ul><li>当我们最后一参数传入map时会以<code>key-value</code>的格式拼接在<code>URL</code>后（通俗的说就是这样设置的变量会跟着<code>URL</code>路径后面）</li></ul><p>​    <code>http://httpbin.org/post?name=&quot;彭于晏&quot;</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/get&quot;</span>;</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;彭于晏&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">forObject</span> <span class="operator">=</span> restTemplate.getForObject(url, Object.class, map);</span><br><span class="line">    System.out.println(forObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当我们传入简单的对象如String，Integer时且路径中有嵌入的占位符时就会代替调用URL中占位符</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/&#123;2&#125;/get&quot;</span>;</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">forObject</span> <span class="operator">=</span> restTemplate.getForObject(url, Object.class, <span class="number">99</span>);</span><br><span class="line">    System.out.println(forObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416163605771.png" alt="image-20220416163605771"></p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u012843361/article/details/79893638">spring cloud 做微服务时关于RestTemplate中的各种请求方法的使用总结_DWT_CCFK的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/31681913">RestTemplate 详解 - 知乎 (zhihu.com)</a></p><p><a href="https://www.jianshu.com/p/35aca2e31f06">RestTemplate使用教程 - 简书 (jianshu.com)</a></p><hr><h1 id="End"><a href="#End" class="headerlink" title="-End-"></a>-End-</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RestTemplate&quot;&gt;&lt;a href=&quot;#RestTemplate&quot; class=&quot;headerlink&quot; title=&quot;RestTemplate&quot;&gt;&lt;/a&gt;RestTemplate&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://ding-blog.os</summary>
      
    
    
    
    <category term="分布式" scheme="https://devildyw.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HttpClient</title>
    <link href="https://devildyw.github.io/2022/04/11/HttpClient/"/>
    <id>https://devildyw.github.io/2022/04/11/HttpClient/</id>
    <published>2022-04-11T09:53:07.000Z</published>
    <updated>2022-04-16T08:52:08.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Apache-HttpClient"><a href="#Apache-HttpClient" class="headerlink" title="Apache HttpClient"></a>Apache HttpClient</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>HttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。HttpClient 已经应用在很多的项目中，比如 Apache Jakarta 上很著名的另外两个开源项目 Cactus 和 <strong>HTMLUnit</strong> 都使用了 HttpClient。</p></blockquote><p>​    使用HttpClient、可以灵活地发送HTTP请求，并且Apache HttpClient提供了很多自定义的请求内容的API（包括连接超时时间设置等）。方便了开发人员测试接口（基于HTTP协议的），既提高了开发效率，也方便了提高代码的健壮性。（后续的RestTemplate的底层也是HttpClient）因此熟悉掌握HttpClient是很重要的必修内容，掌握了HttpClient后，对于HTTP的协议的了解也会更加深刻。</p><hr><h2 id="Apache-HttpClient特性"><a href="#Apache-HttpClient特性" class="headerlink" title="Apache HttpClient特性"></a>Apache HttpClient特性</h2><ul><li>基于标准，纯净的Java语言。实现了HTTP1.0和HTTP1.1</li><li>以可扩展的面向对象的结构实现了 HTTP 全部的方法（<code>GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE</code>）。</li><li>支持 HTTPS 协议。</li><li>通过 HTTP 代理建立透明的连接。</li><li>利用 CONNECT 方法通过 HTTP 代理建立隧道的 HTTPS 连接。</li><li><code>Basic,Digest,NTLMv1,NTLMv2,NTLM2Session,SNPNEGO/Kerberos </code>认证方案。</li><li>插件式的自定义认证方案。</li><li>便携可靠的套接字工厂使它更容易的使用第三方解决方案。</li><li>连接管理器支持多线程应用。支持设置最大连接数，同时支持设置每个主机的最大连接数，发现并关闭过期的连接。</li><li>自动处理 Set-Cookie 中的 Cookie。</li><li>插件式的自定义 Cookie 策略。</li><li>Request 的输出流可以避免流中内容直接缓冲到 Socket 服务器。</li><li>Response 的输入流可以有效的从 Socket 服务器直接读取相应内容。</li><li>在 HTTP 1.0 和 HTTP 1.1 中利用 KeepAlive 保持持久连接。</li><li>直接获取服务器发送的 response code 和 headers。</li><li>设置连接超时的能力。</li><li>实验性的支持 HTTP 1.1 response caching。</li></ul><h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><ul><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpmime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建<code>HttpClient</code>对象（http客户端对象）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();<span class="comment">//方式一</span></span><br><span class="line"><span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClients.createDefault();<span class="comment">//方式二</span></span><br></pre></td></tr></table></figure><p>两种方式相同，因为方式二的底层就是方式一。</p></li><li><p>创建请求方法的实例，并指定<code>URL</code>。因为<code>HttpClient</code>是实现了所有<code>Http</code>请求方法，我们只需要创建请求方法实例（Httpxxx），在方法实例中指定URL即可，例如我们要发送Get请求，就创建<code>HttpGet</code>对象。</p></li><li><p>如果需要发送带有参数的请求，可调用<code>HttpGet、HttpPost</code>共同的<code>setParam（HttpParams params）</code>来添加参数（该方法已经过时&#x2F;弃用了）；<code>HttpGet</code>推荐使用单独创建uri，构建自己的带参数的get请求的uri。<code>HttpPost</code>请求则是调用<code>setEntity(HttpEntity entity)</code>方法来设置请求参数（可以设置对象）。</p></li><li><p>发送请求则是<code>HttpClient</code>的工作，调用<code>HttpClient</code>的<code>execute(HttpUriRequeset request)</code>发送请求，该方法会返回一个<code>HttpResponse</code>（响应模板）</p></li><li><p>调用<code>HttpResponse</code>的<code>getAllHeader()</code>、<code>getHeaders(Sring name)</code>等方法可以获取服务器的响应头，除此之外还可以获取状态码等。通过<code>HttpResponse</code>的<code>getEntity()</code>方法可以获取响应的响应实体，该对象包装了服务器的响应内容，程序可以通过该对象获取服务器的响应内容。</p></li><li><p>最后需要释放资源，关闭<code>HttpClient</code>和<code>reseponse</code>的资源连接</p></li></ul><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p><code>GET请求</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * GET---无参测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGetTestOne</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获得http客户端</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line">        <span class="comment">//创建get请求</span></span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;https://www.cuit.edu.cn/&quot;</span>);</span><br><span class="line">        <span class="comment">//响应模型</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//有客户端指定get请求</span></span><br><span class="line">            response = client.execute(httpGet);</span><br><span class="line">            <span class="comment">//从响应模型中获取响应体</span></span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">responseEntity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;响应状态为:&quot;</span>+response.getStatusLine());</span><br><span class="line">            <span class="keyword">if</span> (responseEntity!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容长度为:&quot;</span>+responseEntity.getContentLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容为:&quot;</span>+ EntityUtils.toString(responseEntity));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//释放资源</span></span><br><span class="line">                <span class="keyword">if</span>(client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * GET--有参测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGetTestWayOne</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获得http客户端</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//参数</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            params.append(<span class="string">&quot;name=&quot;</span>).append(URLEncoder.encode(<span class="string">&quot;&amp;&quot;</span>,<span class="string">&quot;utf-8&quot;</span>)).append(<span class="string">&quot;&amp;&quot;</span>).append(<span class="string">&quot;age=24&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Get请求</span></span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;https://www.cuit.edu.cn/?&quot;</span> + params);</span><br><span class="line">        <span class="comment">//响应模型</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//配置信息</span></span><br><span class="line">            <span class="type">RequestConfig</span> <span class="variable">config</span> <span class="operator">=</span> RequestConfig.custom()</span><br><span class="line">                    <span class="comment">//设置连接超时时间</span></span><br><span class="line">                    .setConnectTimeout(<span class="number">5000</span>)</span><br><span class="line">                    <span class="comment">//设置请求超时时间</span></span><br><span class="line">                    .setConnectionRequestTimeout(<span class="number">5000</span>)</span><br><span class="line">                    <span class="comment">//socket读写超时时间</span></span><br><span class="line">                    .setSocketTimeout(<span class="number">5000</span>)</span><br><span class="line">                    <span class="comment">//设置是否允许重定向(默认为true)</span></span><br><span class="line">                    .setRedirectsEnabled(<span class="literal">true</span>)</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="comment">//将上面的配置信息配入Get请求中</span></span><br><span class="line">            httpGet.setConfig(config);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//由客户端执行Get请求</span></span><br><span class="line">            response = client.execute(httpGet);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从响应模型中获取响应实体</span></span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">responseEntity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;响应状态为:&quot;</span>+response.getStatusLine());</span><br><span class="line">            <span class="keyword">if</span> (responseEntity!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容长度为:&quot;</span>+responseEntity.getContentLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容为:&quot;</span>+ EntityUtils.toString(responseEntity,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientProtocolException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGetTestWayTwo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line">        <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ArrayList&lt;NameValuePair&gt; params = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            params.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;10&quot;</span>));</span><br><span class="line">            params.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>));</span><br><span class="line">            <span class="comment">//这里设置uri信息,并将参数集合放入uri;</span></span><br><span class="line">            <span class="comment">//注: 这里也支持一个键值对一个键值对地往里面方setParameter(String key, String value)</span></span><br><span class="line">            uri = <span class="keyword">new</span> <span class="title class_">URIBuilder</span>().setScheme(<span class="string">&quot;http&quot;</span>).setHost(<span class="string">&quot;www.cuit.edu.cn&quot;</span>)</span><br><span class="line"><span class="comment">//                    .setPort(12345).setPath(&quot;/xw&quot;)</span></span><br><span class="line">                    .setParameters(params).build();</span><br><span class="line">            System.out.println(uri);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建httpGet请求</span></span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(uri);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建响应模型</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">RequestConfig</span> <span class="variable">config</span> <span class="operator">=</span> RequestConfig.custom()</span><br><span class="line">                    .setConnectTimeout(<span class="number">5000</span>)</span><br><span class="line">                    .setConnectionRequestTimeout(<span class="number">5000</span>)</span><br><span class="line">                    .setSocketTimeout(<span class="number">5000</span>)</span><br><span class="line">                    .setRedirectsEnabled(<span class="literal">true</span>).build();</span><br><span class="line"></span><br><span class="line">            httpGet.setConfig(config);</span><br><span class="line">            response = client.execute(httpGet);</span><br><span class="line"></span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;响应状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容长度:&quot;</span>+entity.getContentLength());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容:&quot;</span>+EntityUtils.toString(entity,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientProtocolException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//new GetClient().doGetTestOne();</span></span><br><span class="line">        <span class="comment">//new GetClient().doGetTestWayOne();</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GetClient</span>().doGetTestWayTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>POST请求</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * POST 无参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPostTestOne</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获得http客户端</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line">        <span class="comment">//创建Post请求</span></span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://www.cuit.edu.cn/index.htm&quot;</span>);</span><br><span class="line">        <span class="comment">//创建响应模型</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            response = client.execute(httpPost);</span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;响应状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容长度:&quot;</span>+entity.getContentLength());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容:&quot;</span>+ EntityUtils.toString(entity,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * POST 有参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPostTestFour</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获的http客户端</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//参数</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//字符数据最好encoding; 这样一来, 某些特殊字符才嗯那个传过去(如:某人的名字就是&quot;&amp;&quot;,不encoding,传不过去)</span></span><br><span class="line">            params.append(<span class="string">&quot;phone=&quot;</span>).append(URLEncoder.encode(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            params.append(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">            params.append(<span class="string">&quot;password=admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建post请求</span></span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://www.cuit.edu.cn/?&quot;</span> + params);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置ContentType(注:如果只是传入普通参数的话,ContentType不一定非要用application/json)</span></span><br><span class="line">        httpPost.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//响应模型</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            response = client.execute(httpPost);</span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容长度: &quot;</span>+entity.getContentLength());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容: &quot;</span>+entity);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * POST---有参测试(对象参数)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPostTestTwo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获取Http客户端</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Post请求</span></span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://www.cuit.edu.cn/index.htm&quot;</span>);</span><br><span class="line">        <span class="comment">//User user = new User();</span></span><br><span class="line">        <span class="comment">//user.setName(&quot;潘晓婷&quot;);</span></span><br><span class="line">        <span class="comment">//user.setAge(18);</span></span><br><span class="line">        <span class="comment">//user.setGender(&quot;女&quot;);</span></span><br><span class="line">        <span class="comment">//user.setMotto(&quot;姿势要优雅~&quot;);</span></span><br><span class="line">        <span class="comment">// 我这里利用阿里的fastjson，将Object转换为json字符串;</span></span><br><span class="line">        <span class="comment">// (需要导入com.alibaba.fastjson.JSON包)</span></span><br><span class="line">        <span class="comment">//String jsonString = JSON.toJSONString(user);</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">StringEntity</span> <span class="variable">stringEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringEntity</span>(jsonString, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        httpPost.setEntity(stringEntity);</span><br><span class="line">        httpPost.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=utf8&quot;</span>);</span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            response = client.execute(httpPost);</span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容长度:&quot;</span>+entity.getContentLength());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容:&quot;</span>+EntityUtils.toString(entity,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//new PostClient().doPostTestOne();</span></span><br><span class="line">        <span class="comment">//new PostClient().doPostTestFour();</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">PostClient</span>().doPostTestTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>上传文件</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送文件</span></span><br><span class="line"><span class="comment">     注:如果想要灵活方便的传输文件的话，</span></span><br><span class="line"><span class="comment">     *    除了引入org.apache.httpcomponents基本的httpclient依赖外</span></span><br><span class="line"><span class="comment">     *    再额外引入org.apache.httpcomponents的httpmime依赖。</span></span><br><span class="line"><span class="comment">     *    追注:即便不引入httpmime依赖，也是能传输文件的，不过功能不够强大。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://www.cuit.edu.cn/file&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">MultipartEntityBuilder</span> <span class="variable">multipartEntityBuilder</span> <span class="operator">=</span> MultipartEntityBuilder.create();</span><br><span class="line">            <span class="comment">//第一个文件</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileKey</span> <span class="operator">=</span> <span class="string">&quot;files&quot;</span>;</span><br><span class="line">            <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\图片\\《Valorant》3440x1440带鱼屏游戏壁纸_彼岸图网.jpg&quot;</span>);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            防止服务端收到的文件名乱码. 我们这里可以先将文件名URLEncode, 然后服务端拿到文件后URLDecode</span></span><br><span class="line"><span class="comment">            文件名其实是放在请求头的Content-Disposition中 如其值form-data; name=&quot;files&quot;; filename=&quot;头像.jpg&quot;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            multipartEntityBuilder.addBinaryBody(fileKey,file1, ContentType.DEFAULT_BINARY, URLEncoder.encode(file1.getName(),<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//其他参数(注:自定义contentType,设置UTF-8是为了防止服务端拿到的参数出现乱码)</span></span><br><span class="line">            <span class="type">ContentType</span> <span class="variable">contentType</span> <span class="operator">=</span> ContentType.create(<span class="string">&quot;text/plain&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">            multipartEntityBuilder.addTextBody(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;等沙利文&quot;</span>,contentType);</span><br><span class="line">            multipartEntityBuilder.addTextBody(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;25&quot;</span>,contentType);</span><br><span class="line"></span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">httpEntity</span> <span class="operator">=</span> multipartEntityBuilder.build();</span><br><span class="line">            httpPost.setEntity(httpEntity);</span><br><span class="line">            response = client.execute(httpPost);</span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            <span class="keyword">if</span> (entity!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容长度:&quot;</span>+entity.getContentLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容:&quot;</span>+ EntityUtils.toString(entity,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            File file1 = new File(&quot;D:\\图片\\XXX.jpg&quot;);</span></span><br><span class="line"><span class="comment">            multipartEntityBuilder.addBinaryBody(fileKey,file1);</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileClient</span>().test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Stream请求</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://www.cuit.edu.cn/index.htm&quot;</span>);</span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(<span class="string">&quot;流啊流~&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            <span class="type">InputStreamEntity</span> <span class="variable">ise</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamEntity</span>(is);</span><br><span class="line">            httpPost.setEntity(ise);</span><br><span class="line"></span><br><span class="line">            response = client.execute(httpPost);</span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;响应状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line">            <span class="keyword">if</span> (entity!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容长度:&quot;</span>+entity.getContentLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容:&quot;</span>+ EntityUtils.toString(entity,StandardCharsets.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StreamClient</span>().test5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="END"><a href="#END" class="headerlink" title="-END-"></a>-END-</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Apache-HttpClient&quot;&gt;&lt;a href=&quot;#Apache-HttpClient&quot; class=&quot;headerlink&quot; title=&quot;Apache HttpClient&quot;&gt;&lt;/a&gt;Apache HttpClient&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="分布式" scheme="https://devildyw.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>事务的嵌套</title>
    <link href="https://devildyw.github.io/2022/04/09/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B5%8C%E5%A5%97/"/>
    <id>https://devildyw.github.io/2022/04/09/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B5%8C%E5%A5%97/</id>
    <published>2022-04-09T09:47:42.000Z</published>
    <updated>2022-04-09T09:50:51.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务的嵌套"><a href="#事务的嵌套" class="headerlink" title="事务的嵌套"></a>事务的嵌套</h1><p><strong>什么是嵌套事务？</strong><br>       嵌套是子事务在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。</p><p><strong>可以通过下述的问答进一步去熟悉嵌套事务？</strong></p><ol><li>如果子事务回滚，会发生什么？<br>      父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。</li><li>如果父事务回滚，会发生什么？<br>      父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。</li><li>事务的提交，是什么情况？<br>      父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。</li></ol><p>原文链接：<a href="https://blog.csdn.net/javashareauthor/article/details/82842177">https://blog.csdn.net/javashareauthor/article/details/82842177</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事务的嵌套&quot;&gt;&lt;a href=&quot;#事务的嵌套&quot; class=&quot;headerlink&quot; title=&quot;事务的嵌套&quot;&gt;&lt;/a&gt;事务的嵌套&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;什么是嵌套事务？&lt;/strong&gt;&lt;br&gt;       嵌套是子事务在父事务中执行，子事务是父事务的</summary>
      
    
    
    
    <category term="数据库" scheme="https://devildyw.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="database" scheme="https://devildyw.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Annotation</title>
    <link href="https://devildyw.github.io/2022/04/07/Annotation/"/>
    <id>https://devildyw.github.io/2022/04/07/Annotation/</id>
    <published>2022-04-07T14:09:56.000Z</published>
    <updated>2022-04-16T08:52:19.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    <code>Annotation</code>（注解）是JDK5开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类，方法或者变量，在框架中大量使用（如 Spring、Mybatis等）</p><blockquote><p>注解是一种能被添加到java代码中的元数据，类、方法、变量、参数和包都可以用注解来修饰。注解对于它所修饰的代码并没有直接的影响。</p></blockquote><p>​    下面是我简单写的一个自定义注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">msg</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;Hi&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    通过对上述文件的字节码（.class）的反编译（javap - p xxx.class）可以得到<code>@interface</code>其实就是一个继承了<code>Annotation</code>的一个接口</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javap -p Test.class</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">com</span>.dyw.annotation.Test <span class="keyword">extends</span> <span class="title class_">java</span>.lang.annotation.Annotation &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> java.lang.String <span class="title function_">msg</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期间直接扫描：</strong>编译器在编译Java代码的时候扫描对于的注解并处理，比如某个方法使用了<code>@Override</code>，编译器在编译的时候就会检测当前的方法是否重写了父类对于的方法。</li><li><strong>运行期间通过反射处理：</strong>这个经常在Spring框架中看到，例如Spring的<code>@Value</code>注解，就是通过反射来进行处理的。</li></ul><h2 id="注解详细介绍"><a href="#注解详细介绍" class="headerlink" title="注解详细介绍"></a>注解详细介绍</h2><p>我们通过上述的例子可以看到我们的注解上面还有着其他的注解例如<code>@Retention</code>、<code>@Target</code>（这些都统称为元注解）.</p><p>所以一个注解是由以下成分组成</p><blockquote><ul><li>元注解</li><li><code>public @interface 注解名称</code></li></ul></blockquote><hr><h3 id="元注解介绍"><a href="#元注解介绍" class="headerlink" title="元注解介绍"></a>元注解介绍</h3><p>​    JDK1.8版本为我们提供了6个标准的用来<strong>对注解类型进行注解的注解类</strong>（1.8之前只有四个），我们称之为<code>meta-annotation</code>（元注解）.</p><p>​    <strong>元注解只能用在注解之上（自定义注解时可用）</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407175816207.png" alt="image-20220407175816207"></p><blockquote><p><code>@Target</code></p><p><code>@Retention</code></p><p><code>@Documented</code></p><p><code>@Inherited</code></p><p><code>@Native</code>（1.8新增）</p><p><code>@Repeatable</code>（1.8新增）</p></blockquote><hr><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a><code>@Target</code></h4><p>官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">指示注解类型适用的上下文。注解类型可能适用的声明上下文和类型上下文在 JLS 9.6.4.1 中指定，并在源代码中由java.lang.annotation.ElementType的枚举常量表示。</span><br><span class="line">如果注解类型T上不存在@Target元注解，则类型T的注解可以写为除类型参数声明之外的任何声明的修饰符。</span><br><span class="line">如果存在@Target元注解，编译器将强制执行ElementType枚举常量指示的使用限制，符合 JLS 9.7.4。</span><br></pre></td></tr></table></figure><ul><li><strong>它指明了它所修饰的注解使用的范围 如果自定义的注解为含有@Target元注解修饰，那么默认可以是在（除类型参数之外的）任何项之上使用，若有@Target元注解修饰那么根据Value（ElementType枚举常量）的指定的目标进行规定。</strong></li></ul><h5 id="ElementType"><a href="#ElementType" class="headerlink" title="ElementType"></a><code>ElementType</code></h5><p><code>ElementType.class</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span> &#123;</span><br><span class="line">    <span class="comment">/** 类、接口（包括注解类型）或枚举声明 */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 字段声明（包括枚举常量） */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 方法声明 */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 参数声明 */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 构造函数声明 */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 局部变量声明 */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 注解类型声明 */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 包装声明 */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型参数声明 类型参数即Map&lt;String,Integer&gt;中的String和Integer这里是作为类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用类型 对应于 JLS 4.11 中的 15 个类型上下文，以及两个声明上下文：类型声明（包括注解类型声明）和类型参数声明。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>ElementType的枚举常量指明了注解可以使用的目标。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span><span class="comment">//可修饰在方法之上</span></span><br></pre></td></tr></table></figure><hr><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a><code>@Retention</code></h4><p>官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">指示要保留带注解类型的注解多长时间。如果注释类型声明中不存在保留注释，则保留策略默认为RetentionPolicy.CLASS 。</span><br><span class="line">仅当元注释类型直接用于注释时，保留元注释才有效。如果将元注释类型用作另一个注释类型中的成员类型，则它没有效果。</span><br></pre></td></tr></table></figure><ul><li>即<code>@Retention</code>用来约束注解的生命周期，分别有三个值，源码级别（source）、类文件级别（class）或者运行时级别（runtime）可以通过指定<code>@Retention</code>中的值来实现（值为<code>RetentionPolicy</code>枚举常量）。</li></ul><h5 id="RetentionPolicy-class"><a href="#RetentionPolicy-class" class="headerlink" title="RetentionPolicy.class"></a><code>RetentionPolicy.class</code></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RetentionPolicy</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解将被编译器丢弃。(该类型的注解信息指挥保留在源码中，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class文件中)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解将由编译器记录在类文件中，但不需要在运行时由 VM 保留。这是默认行为.(该类型的注解信息会保留在源码里和class文件里，在执行的时候，不会加载到虚拟机中) 该类型也是未指定<span class="doctag">@Retention</span>值的缺省值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解将由编译器记录在类文件中，并在运行时由 VM 保留，因此可以反射性地读取它们。(源码，class文件和执行时(VM)都保留注解的信息)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>注意：</strong>生命周期大小排序为<code>SOURCE &lt; CLASS &lt; RUNTIME</code>，范围依次增大，前者能使用的地方后者一定能使用。如果需要在运行时去动态获取注解信息，那只能使用<code>RUNTIME</code>；如果要在编译时进行一些预处理操作，比如生成一些辅助代码，就是用<code>CLASS</code>；如果只是做一些检查性的操作，比如<code>@Override和@SupperssWarning</code>，可选择<code>SOURCE</code></p><hr><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a><code>@Documented</code></h4><p>官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">表示默认情况下，带有类型的注释将由 javadoc 和类似工具记录。这种类型应该用于注解类型的声明，这些类型的注释会影响其客户对注释元素的使用。如果使用 Documented 对类型声明进行注释，则其注释将成为注释元素的公共 API 的一部分。</span><br></pre></td></tr></table></figure><ul><li>带上该注解后的注解表明，在默认情况下这个注解是由JavaDoc和类似工具记录的，即带上了该文档化的注解被使用再生成文档时，会称为API的一部分。（默认情况下JavaDoc是不包含注解的，除非声明注解的时候使用了<code>@Documented</code>）</li></ul><p><code>Person.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Person &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="meta">@Person(name = &quot;ding&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//@Person(name = &quot;ding&quot;)</span></span><br><span class="line">    <span class="meta">@Person(name = &quot;yang&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>生成的文档</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407193958620.png" alt="image-20220407193958620"></p><ul><li>不带<code>@Documented</code>注解生成的文档</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407194037553.png" alt="image-20220407194037553"></p><hr><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a><code>@Inherited</code></h4><p>官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">指示注解类型是自动继承的。如果注解类型声明中存在 Inherited 元注解，并且用户在类声明中查询注解类型，并且类声明没有该类型的注解，则将自动查询该类的超类以获取注解类型。将重复此过程，直到找到此类型的注释，或到达类层次结构（对象）的顶部。如果没有超类具有此类型的注释，则查询将指示所讨论的类没有此类注释。</span><br><span class="line">请注意，如果注释类型用于注释类以外的任何内容，则此元注释类型无效。另请注意，此元注释仅导致注释从超类继承；已实现接口上的注解无效。</span><br></pre></td></tr></table></figure><ul><li>被该元注解修饰的自定义注解再使用后会自动继承，如果使用了该自定义注解去修饰一个class那么这个注解也会作用于该class的子类。就是说如果某个类使用了被<code>@Inherited</code>修饰的注解，则其子类将会自动具有该注释</li></ul><p>​    <strong>注意：</strong> <code>@Inherited annotation</code>类型是被标注过的<code>class</code>的子类所继承。类并不从它所实现的接口继承<code>annotation</code>，方法并不从它所重载的方法继承<code>annotation</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span> <span class="comment">//使用@Inherited修饰的自定义注解</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Person &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>main.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Father.class.getAnnotation(Person.class));</span><br><span class="line">        System.out.println(Son.class.getAnnotation(Person.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">com</span>.dyw.annotation.obj.Father &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407204033473.png" alt="image-20220407204033473"></p><hr><h4 id="Native"><a href="#Native" class="headerlink" title="@Native"></a><code>@Native</code></h4><p>官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">表示可以从本机代码引用定义常量值的字段。注释可以被生成本机头文件的工具用作提示，以确定是否需要头文件，如果需要，它应该包含哪些声明。</span><br></pre></td></tr></table></figure><ul><li>使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可。</li></ul><hr><h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a><code>@Repeatable</code></h4><p>官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">注释类型java.lang.annotation.Repeatable用于指示它（元）注释其声明的注释类型是可重复的。 @Repeatable的值表示可重复注解类型的包含注解类型。</span><br></pre></td></tr></table></figure><blockquote><p><code>@Repeatable</code>允许在相同的程序元素中重复注解（不报错）。在需要对同一种注解多次使用时，往往需要借助 @Repeatable 注解。Java 8 版本以前，同一个程序元素前最多只能有一个相同类型的注解，如果需要在同一个元素前使用多个相同类型的注解，则必须使用注解“容器”。</p></blockquote><p>​    <strong>不使用<code>@Repeatable</code>修饰的自定义注解完成重复注解</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Persons &#123;</span><br><span class="line">    Person[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Person &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Persons(value = &#123;@Person(name = &quot;ding&quot;),@Person(name = &quot;yang&quot;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>使用<code>@Repeatable</code>修饰的自定义注解</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Persons &#123;</span><br><span class="line">    Person[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable(Persons.class)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Person &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Person(name = &quot;ding&quot;)</span></span><br><span class="line"><span class="meta">@Person(name = &quot;yang&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>两种方法不同的地方是，创建重复注解Person时加上了<code>@Repeatable</code>注解，指向存储注解Persons，这样使用时就可以直接重复使用Person注解。从上述例子可以看出使用<code>@Repeatable</code>注解更符合常规思维，可读性强。</p></li><li><p>但两种方法的效果相同，只是使用了<code>@Repeatable</code>注解简化了写法，这种简化的底层依旧是多个重复注解使用了一个被称作“容器”注解的value的成员的数组元素处理。</p></li></ul><hr><h3 id="JDK基本注解介绍"><a href="#JDK基本注解介绍" class="headerlink" title="JDK基本注解介绍"></a>JDK基本注解介绍</h3><p>​    基本注解包括</p><blockquote><ul><li><p><code>@Override</code></p></li><li><p><code>@Deprecated</code></p></li><li><p><code>@SuppressWarnings</code></p></li><li><p><code>@SafeVarargs </code></p></li><li><p><code>@FunctionalInterface</code></p></li></ul></blockquote><h4 id="Override"><a href="#Override" class="headerlink" title="@Override"></a><code>@Override</code></h4><p>​    官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">指示方法声明旨在覆盖超类型中的方法声明。如果使用此注解类型对方法进行注解，则编译器需要生成错误消息，除非至少满足以下条件之一：</span><br><span class="line">该方法确实覆盖或实现了在超类型中声明的方法。</span><br><span class="line">该方法的签名与Object中声明的任何公共方法的签名等效。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">msg</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">msg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果将子类中方法名<code>msg</code>改为<code>mg</code>会发生如下编译错误</li></ul><blockquote><p>java: 方法不会覆盖或实现超类型的方法</p></blockquote><ul><li>所以<code>@Override</code>的作用告诉编译器检查这个方法，保证父类要包含一个被该方法重写的方法，否者就会出错，这样可以帮助程序员避免一些低级错误。</li></ul><hr><h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a><code>@Deprecated</code></h4><p>​    官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">@Deprecated 注释的程序元素是不鼓励程序员使用的程序元素，通常是因为它很危险，或者因为存在更好的替代方案。当在非弃用代码中使用或覆盖弃用的程序元素时，编译器会发出警告。</span><br></pre></td></tr></table></figure><ul><li>通俗的说被该注解修饰的目标项是已经过时的了，不推荐使用的。**</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">msg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>@Deprecated</code>修饰了Son中的<code>msg</code>方法后，调用该方法会出现<strong>删除线</strong>和编译警告。</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407210522333.png" alt="image-20220407210522333"></p><hr><h4 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a><code>@SuppressWarnings</code></h4><p>​    官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">指示应在带注释的元素（以及带注释的元素中包含的所有程序元素）中抑制命名的编译器警告。请注意，给定元素中抑制的警告集是所有包含元素中抑制的警告的超集。例如，如果您注释一个类以抑制一个警告并注释一个方法以抑制另一个警告，则两个警告都将在方法中被抑制。</span><br><span class="line">作为风格问题，程序员应该始终在最有效的嵌套元素上使用此注释。如果您想在特定方法中抑制警告，您应该注释该方法而不是它的类。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *编译器要在带注​​释的元素中抑制的一组警告。允许重复名称。名称的第二次和连续出现将被忽略。存在无法识别的警告名称不是错误：编译器必须忽略它们无法识别的任何警告名称。但是，如果注释包含无法识别的警告名称，它们可以自由发出警告。</span></span><br><span class="line"><span class="comment">字符串&quot;unchecked&quot;用于抑制未经检查的警告。编译器供应商应结合此注释类型记录他们支持的其他警告名称。鼓励他们合作以确保相同的名称在多个编译器中工作。</span></span><br><span class="line"><span class="comment">回报：</span></span><br><span class="line"><span class="comment">要抑制的警告集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Java中的<code>@SuppressWarnings</code> 注解指示被该注解修饰的程序元素（以及该程序元素中的所有子元素）取消显示指定的编译器警告，且会一直作用于该程序元素的所有子元素。</p></li><li><p>如果你对于代码的规范不做要求又对编译器的警告感到烦躁那么你可以使用<code>@SuppressWarnings</code>（仅仅只是取消显示，并没有消除），它可以让你免去这些烦恼，当然编译器报错他是无法帮你取消显示的。</p></li><li><p>添加前：</p></li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407211856114.png" alt="image-20220407211856114"></p><ul><li>添加后：</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407212004111.png" alt="image-20220407212004111"></p><ul><li><p>注解的使用有以下三种：</p><ul><li>抑制单类型的警告：<code>@SuppressWarnings(&quot;unchecked&quot;)</code></li><li>抑制多类型的警告：<code>@SuppressWarnings(&quot;unchecked&quot;,&quot;rawtypes&quot;)</code></li><li>抑制所有类型的警告：<code>@SuppressWarnings(&quot;unchecked&quot;)</code></li></ul></li><li><p>抑制警告的关键字如下表所示：</p><table><thead><tr><th>关键字</th><th>用途</th></tr></thead><tbody><tr><td>all</td><td>抑制所有警告</td></tr><tr><td>boxing</td><td>抑制装箱、拆箱操作时候的警告</td></tr><tr><td>cast</td><td>抑制映射相关的警告</td></tr><tr><td>dep-ann</td><td>抑制启用注释的警告</td></tr><tr><td>deprecation</td><td>抑制过期方法警告</td></tr><tr><td>fallthrough</td><td>抑制在 switch 中缺失 breaks 的警告</td></tr><tr><td>finally</td><td>抑制 finally 模块没有返回的警告</td></tr><tr><td>hiding</td><td>抑制相对于隐藏变量的局部变量的警告</td></tr><tr><td>incomplete-switch</td><td>忽略不完整的 switch 语句</td></tr><tr><td>nls</td><td>忽略非 nls 格式的字符</td></tr><tr><td>null</td><td>忽略对 null 的操作</td></tr><tr><td>rawtypes</td><td>使用 generics 时忽略没有指定相应的类型</td></tr><tr><td>restriction</td><td>抑制禁止使用劝阻或禁止引用的警告</td></tr><tr><td>serial</td><td>忽略在 serializable 类中没有声明 serialVersionUID 变量</td></tr><tr><td>static-access</td><td>抑制不正确的静态访问方式警告</td></tr><tr><td>synthetic-access</td><td>抑制子类没有按最优方法访问内部类的警告</td></tr><tr><td>unchecked</td><td>抑制没有进行类型检查操作的警告</td></tr><tr><td>unqualified-field-access</td><td>抑制没有权限访问的域的警告</td></tr><tr><td>unused</td><td>抑制没被使用过的代码的警告</td></tr></tbody></table></li></ul><hr><h4 id="SafeVarargs"><a href="#SafeVarargs" class="headerlink" title="@SafeVarargs "></a><code>@SafeVarargs </code></h4><p>​    官方解释：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">程序员断言带注释的方法或构造函数的主体不会对其 varargs 参数执行潜在的不安全操作。将此注释应用于方法或构造函数会抑制有关不可具体化的变量 arity (vararg) 类型的未经检查的警告，并抑制有关在调用站点创建参数化数组的未经检查的警告。</span><br><span class="line">除了<span class="meta">@Target</span>元注解施加的使用限制外，编译器还需要对该注解类型实施额外的使用限制；如果使用<span class="meta">@SafeVarargs</span>注释对方法或构造函数声明进行注释，则这是编译时错误，并且：</span><br><span class="line">声明是一个固定的arity方法或构造函数</span><br><span class="line">声明是一个既不是<span class="keyword">static</span>也不是<span class="keyword">final</span>的变量 arity 方法。</span><br><span class="line">鼓励编译器在将此注释类型应用于方法或构造函数声明时发出警告，其中：</span><br><span class="line">变量 arity 参数具有可具体化的元素类型，包括原始类型、 Object和String 。 （对于可具体化的元素类型，此注释类型抑制的未经检查的警告已经不会出现。）</span><br><span class="line">方法或构造函数声明的主体执行潜在的不安全操作，例如对变量 arity 参数数组的元素的赋值会生成未经检查的警告。一些不安全的操作不会触发未经检查的警告。例如，别名在</span><br><span class="line">   <span class="meta">@SafeVarargs</span> <span class="comment">// 实际上并不安全！</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(List&lt;String&gt;... stringLists)</span> &#123;</span><br><span class="line">     Object[] array = stringLists;</span><br><span class="line">     List&lt;Integer&gt; tmpList = Arrays.asList(<span class="number">42</span>);</span><br><span class="line">     array[<span class="number">0</span>] = tmpList; <span class="comment">// 语义上无效，但可以编译</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringLists[<span class="number">0</span>].get(<span class="number">0</span>); <span class="comment">// 哦不，运行时的 ClassCastException！</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">在运行时导致ClassCastException 。</span><br><span class="line">该平台的未来版本可能会要求此类不安全操作出现编译器错误。</span><br></pre></td></tr></table></figure><p>在学习<code>@SafeVarargs</code>之前先来看看下面有一段代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        display(<span class="string">&quot;10&quot;</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(T ...array)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (T arg : array)&#123;</span><br><span class="line">            System.out.println(arg.getClass().getName()+<span class="string">&quot;:&quot;</span>+arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这段代码中我设计了一个接收可变参数的方法<code>public static &lt;T&gt; void display(T ...array)&#123;&#125;</code>可变参数方法中的参数类型相同，为此声明参数是需要指定泛型。</p><p>​    但是调用可变参数方法时，应该提供相同类型的参数，但是代码中传入了不同类型的参数集合，此时可以看到display签名处有如下警告</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407213806123.png" alt="image-20220407213806123"></p><p>​    翻译过来就是<code>参数化可变参数类型可能造成的堆污染</code>并且提示添加<code>@SafeVarargs</code>注解（仅仅起一个取消显示的作用，某种方面上来说是和 <code>@SuppressWarnings</code> 作用相同的）。</p><p>​    这个警告是 unchecked（未检查不安全代码），就是因为将非泛型变量赋值给泛型变量所发生的。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407214116091.png" alt="image-20220407214116091"></p><p>​    可以发现加上了<code>@SafeVarargs</code>注解后编译器警告没有显示了，你肯定会说我使用<code>@SuppressWarnings</code>效果也是一样的，效果虽然一样，但是两者相较来说这里使用<code>@SafeVarargs</code>注解更合适</p><p>​    <strong>注意：</strong><code>@SafeVarargs</code>注解<strong>不适用于非 <code>static</code> 或非 <code>final</code> 声明的方法</strong>，对于未声明为 <code>static</code> 或 <code>final</code> 的方法，如果要抑制 <code>unchecked</code> 警告，<strong>可以使用 <code>@SuppressWarnings</code> 注解。</strong></p><hr><h4 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a><code>@FunctionalInterface</code></h4><p>​    官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">一种信息性注解类型，用于指示接口类型声明旨在成为 Java 语言规范定义的功能接口。从概念上讲，函数式接口只有一个抽象方法。由于默认方法有一个实现，它们不是抽象的。如果接口声明了一个覆盖java.lang.Object的公共方法之一的抽象方法，这也不会计入接口的抽象方法计数，因为接口的任何实现都将具有来自java.lang.Object或其他地方的实现(接口的实现是类,所有类的父类都是Object)。</span><br><span class="line">请注意，函数式接口的实例可以使用 lambda 表达式、方法引用或构造函数引用来创建。</span><br><span class="line">如果使用此注解类型对类型进行注解，则编译器需要生成错误消息，除非：</span><br><span class="line">该类型是接口类型，而不是注解类型、枚举或类。</span><br><span class="line">带注解的类型满足功能接口的要求。</span><br><span class="line">但是，无论接口声明中是否存在FunctionalInterface注释，编译器都会将满足功能接口定义的任何接口视为功能接口。</span><br></pre></td></tr></table></figure><p>​    在学习Lambda表达式时，我们了解过函数式接口（接口中只有个一个抽象方法可以存在多个默认方法或多个static方法）。</p><ul><li><p><code>@FunctionalInterface</code>作用就是用来指定某一个接口必须是函数式接口的，所以<code>@FunctionalInterface</code>只能修饰接口。</p></li><li><p>这里我写了两个抽象方法出现了编译器报错</p></li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407214859347.png" alt="image-20220407214859347"></p><ul><li>这里我只写了一个抽象方法 一个static方法和一个默认方法 符合要求没有报错</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407215038533.png" alt="image-20220407215038533"></p><p>​    <strong>注意：</strong>如果接口声明了一个覆盖<code>java.lang.Object</code>的公共方法之一的抽象方法，这也不会计入接口的抽象方法计数</p><p>得出结论：<code>@FunctionalInterface</code>只是告诉编译器去检查这个接口是不是函数式接口，保证该接口只能包含一个抽象方法，否者就会出现编译错误。</p><hr><h2 id="写一个自己的注解"><a href="#写一个自己的注解" class="headerlink" title="写一个自己的注解"></a>写一个自己的注解</h2><p>注解的格式就是</p><blockquote><ul><li>元注解</li><li><code>public @interface 注解名</code></li><li>注解内容体</li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span> <span class="comment">//这里我希望我的注解能够生成在JavaDoc生成的文档中</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span> <span class="comment">//这里我希望我的注解能够在字节码文件中保留</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span> <span class="comment">//这里我希望我的注解可以修饰于类、接口、抽象类和方法上</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123; <span class="comment">//我声明了一个名为MyAnnotation的注解</span></span><br><span class="line">    <span class="comment">//定义带两个成员变量的注解</span></span><br><span class="line">    <span class="comment">//注解中的成员以方法的形式命名（注解的本质是接口） 并且可以带有默认值</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    想要获取注解中的成员变量需要使用反射的知识、首先需要获取类的Class对象，我们就可以通过的这个Class对象反射得到注解的成员变量了。</p><p>​    反射相关的可以参考这篇博客<a href="https://blog.csdn.net/D1842501760/article/details/120714043?spm=1001.2014.3001.5502">反射</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test</span>().testMyAnnotation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="meta">@MyAnnotation(name = &quot;dyw&quot;,age = 20)</span><span class="comment">//这里我们使用了我们刚才自定义的注解</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMyAnnotation</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">        <span class="comment">//这里获取Test类的Class对象 当类被编译后会当jvm加载时会生成该class文件的Class对象 通过这个Class对象可以完成反射相关的操作</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">testMyAnnotation</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getMethod(<span class="string">&quot;testMyAnnotation&quot;</span>);</span><br><span class="line">        <span class="comment">//通过Class对象的getAnnotation()方法反射得到我们的MyAnnotation对象</span></span><br><span class="line">        <span class="type">MyAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> testMyAnnotation.getAnnotation(MyAnnotation.class);</span><br><span class="line">        <span class="comment">//通过该对象可以获取注解类的成员</span></span><br><span class="line">        System.out.println(<span class="string">&quot;name :&quot;</span>+annotation.name());</span><br><span class="line">        System.out.println(<span class="string">&quot;age :&quot;</span>+annotation.age());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220408151357416.png" alt="image-20220408151357416"></p><p>​    这里只介绍了自定义注解类的简单用法，但是却完美展现了注解搭配反射可以碰撞出的巨大火花。熟悉掌握注解与反射后就有一定能力去学习那些大佬开发的框架的底层代码了。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://c.biancheng.net/java/java/135/">Java注解 (biancheng.net)</a></p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/package-summary.html">java.lang.annotation (Java Platform SE 8 ) (oracle.com)</a></p><p><a href="https://juejin.cn/post/6844903776088752141">理解注解中的@Inherited - 掘金 (juejin.cn)</a></p><p><a href="https://blog.csdn.net/qq_34576220/article/details/105731364">java元注解@Native &amp;&amp; @Repeatable （java8 新增）_似火似水的博客-CSDN博客_native注解</a></p><p><a href="%5D(https://blog.csdn.net/qq_34576220/article/details/105731364">反射</a></p><h1 id="END"><a href="#END" class="headerlink" title="-END-"></a>-END-</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Annotation&quot;&gt;&lt;a href=&quot;#Annotation&quot; class=&quot;headerlink&quot; title=&quot;Annotation&quot;&gt;&lt;/a&gt;Annotation&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="JavaSE" scheme="https://devildyw.github.io/categories/JavaSE/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API</title>
    <link href="https://devildyw.github.io/2022/04/06/RESTful%20API/"/>
    <id>https://devildyw.github.io/2022/04/06/RESTful%20API/</id>
    <published>2022-04-06T12:58:54.000Z</published>
    <updated>2022-04-16T08:52:43.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h1><p>正式学习RESTful API之前,我们需要把什么是API搞懂.</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/v2-1564b88f4461d69b90cd1ab50411f61b_b.jpg" alt="查看源图像"></h2><h2 id="什么是API"><a href="#什么是API" class="headerlink" title="什么是API?"></a>什么是API?</h2><p><strong>API（Application Programming Interface）</strong> 翻译过来是应用程序编程接口的意思。</p><p>相信大家对于API这个此已经不陌生了, 比如”我调用了某某的API”等 又比如我们在进行后端开发的时候，主要的工作就是为前端或者其他后端服务提供 API 比如查询用户数据的 API. </p><ul><li><p>API不仅仅代表了后端系统暴露出的接口, 像框架中提供的方法也属于是API的范畴.</p><p>例如: </p><ul><li>你写的程序需要由支付功能,需要微信支付,就需要去调用微信提供支付的相关API</li><li>使用JDK开发Java程序, 需要获取当前系统时间,需要使用JDK提供的Date相关的API</li><li>….</li></ul></li><li><p>API可以理解为程序与程序之间通信的桥梁, 其本质就是一个函数或者一个方法(函数和方法还是不同的)而已. 另外, API的使用也不是没有章法了, 它的相关规则或是使用协议由API的提供者制订.</p></li></ul><hr><h2 id="什么是RESTful-API"><a href="#什么是RESTful-API" class="headerlink" title="什么是RESTful API?"></a>什么是RESTful API?</h2><p><strong>RESTful API</strong> 经常也被叫做 <strong>REST API</strong>，它是基于 REST 构建的 API.</p><p>举个例子，如果我给你下面两个 API 你是不是立马能知道它们是干什么用的！这就是 RESTful API 的强大之处！</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">GET  /XXXX/classes: 查询列出所有班级</span><br><span class="line">POST  /XXXX/classes: 创建一个新的班级</span><br></pre></td></tr></table></figure><ul><li>由上述例子可以看出 RESTful API可以让人很清楚的知道每个API的目的与作用(前提是它有一定的基础 这个似乎不是什么问题).</li><li><strong>RESTful API</strong>可以让人看到URL+Http Method 就知道这个方法是干什么的, 让你看到HTTP状态码(status code)就知道请求结果如何</li></ul><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">http动作(请求方式) + url [动作+url合起来保证唯一性]</span><br></pre></td></tr></table></figure><p>我们在开发过程中设计API时也应当满足RESTful API的最基本要求(RESTful API 不是协议</p><p>规定, 但是提倡这样设计) <strong>接口中尽量使用名词</strong>, 例如<code>GET /notes/id</code>：获取某个指定 id 的笔记的信息）毕竟是使用Http Method(动词)操作的应当是名词才对.</p><h2 id="解读REST-了解内容"><a href="#解读REST-了解内容" class="headerlink" title="解读REST(了解内容)"></a>解读REST(了解内容)</h2><p><strong>REST</strong> 是 <code>REpresentational State Transfer</code> 的缩写。这个词组的翻译过来就是“<strong>表现层状态转化</strong>”。</p><p>实际上 REST 的全称是 <strong>Resource Representational State Transfer</strong> ，直白地翻译过来就是 <strong>“资源”在网络传输中以某种“表现形式”进行“状态转移”</strong> 。</p><ul><li><strong>资源(Resource):</strong> 任何东西都可以是资源, 图片,甚至是对象, 资源可以是一个集合,也可以是一个个体. 每一种资源都有特定的URL(统一资源标识符)与之对应, 如果我们需要访问这个资源只需要访问这个URI就可以访问.</li><li><strong>表现形式(Representational):</strong>“资源”是一个信息实体,它可以有多种外在表现形式.通常我们把资源具体呈现出来的形式有:<code>json</code>、<code>xml</code>、<code>image</code>、<code>txt</code>等等叫做它的**”表现形式”**。</li><li>**状态转移(State Transfer):**指的就是你的行为对于资源的操作(通过HTTP动词实现)引起资源的状态发生了变化.(ps:互联网通讯协议HTTP协议，是一个无状态协议，所有的资源状态都保存在服务器端.)</li></ul><p>综合总结:</p><blockquote><ul><li>每一个URI代表一种资源；</li><li>客户端与服务器之间,传递这种资源的某种表现形式比如<code>json</code>、<code>xml</code>、 <code>txt</code>、 <code>image</code>等；</li><li>客户端通过特定的HTTP动词，对服务器资源进行操作，实现”表现层状态转化”。</li></ul></blockquote><h2 id="RESTful-API-规范"><a href="#RESTful-API-规范" class="headerlink" title="RESTful API 规范"></a>RESTful API 规范</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6db537c4f5274fc098ed9bf710b41cc4~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.awebp" alt="RESTful API 设计规范"></p><p><strong>动作：</strong></p><blockquote><ul><li><strong><code>GET</code>：</strong>请求从服务器获取特定资源。举个例子：<code>GET /classes</code>（获取所有班级）</li><li><strong><code>POST</code> ：</strong>在服务器上创建一个新的资源。举个例子：<code>POST /classes</code>（创建班级）</li><li><strong><code>PUT</code> ：</strong>更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：<code>PUT /classes/12</code>（更新编号为 12 的班级）</li><li><strong><code>DELETE</code> ：</strong>从服务器删除特定的资源。举个例子：<code>DELETE /classes/12</code>（删除编号为 12 的班级）</li><li><code>PATCH</code> ：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，这里就不举例子了。</li></ul></blockquote><p><strong>路劲(接口命名)：</strong></p><p>路劲又称”终点”(endpoint), 表示API的具体网址。实际开发中的常见规范如下：</p><blockquote><ul><li><strong>网址中不能出现动词，只能都是名词，API中的名词也应该使用复数。</strong> 因为REST中的资源往往和数据库中的表相对应，而数据库中的表都是同种记录的”集合”（collection）。<strong>如果API调用并不涉及资源（如登录、运算等操作）可以使用动词。</strong>比如：**<code>GET /sign-login</code>**</li><li><strong>不用大写，建议用中杠<code>-</code>而不用下划线<code>_</code></strong> 。比如：**<code>GET /signLogin</code>**</li><li><strong>善用版本化API。</strong>当我们的API发生了重大改变而不兼容前期版本的时候，我们可以通过URL来实现版本化，比如**<code>/github.com/kataras/iris/v12</code>**。版本不必非要数字，只是数字使用最多，日期、季节都可以作为版本的标识符，项目团队达成共识即可。</li><li><strong>接口尽量使用名词，避免使用名词。</strong>RESTful API操作(HTTP Method)的是资源（名词）而不是动作（动词）。</li></ul></blockquote><p>现在有这样的一个API提供班级大学班级（class）的信息，还包括学生、老师的信息，则应该设计呈现吗这样。</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">GET    /classes：列出所有班级</span><br><span class="line">POST   /classes：新建一个班级</span><br><span class="line">GET   /classes/&#123;classId&#125;:获取某个指定班级的信息</span><br><span class="line">PUT   /classes/&#123;classId&#125;:更新某个指定班级的信息(一般倾向于整体更新)</span><br><span class="line">PATCH  /classes/&#123;classId&#125;：更新某个指定班级的信息（一般倾向部分更新）</span><br><span class="line">GET    /classes/&#123;classId&#125;/teachers：列出某个指定班级的所有老师的信息</span><br><span class="line">GET    /classes/&#123;classId&#125;/students：列出某个指定班级的所有学生的信息</span><br><span class="line">DELETE /classes/&#123;classId&#125;/teachers/&#123;ID&#125;：删除某个指定班级下的指定的老师的信息</span><br></pre></td></tr></table></figure><p><strong>反例:</strong></p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">/getAllclasses</span><br><span class="line">/createNewclass</span><br><span class="line">/deleteAllActiveclasses</span><br></pre></td></tr></table></figure><p>清理资源的层次结构,比如业务针对的范围是学校,那么学校会是一级资源:<code>/schools</code>、老师：<code>/shcools/teachers</code>、学生：<code>/shcools/students</code>就是二级资源。</p><h3 id="信息过滤"><a href="#信息过滤" class="headerlink" title="信息过滤"></a>信息过滤</h3><p>如果我们在查询的时候需要添加特定的条件的话，建议使用url中添加参数的形式。比如我们要查询state状态位active并且name为guideege的班级：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">GET/classes?state=active<span class="built_in">&amp;</span>name=guigege</span><br></pre></td></tr></table></figure><p>如果要实现分页查询：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">GET/classes?page=1<span class="built_in">&amp;</span>size=10 //指定第几页，每页十条数据</span><br></pre></td></tr></table></figure><h3 id="状态码（Status-Codes）"><a href="#状态码（Status-Codes）" class="headerlink" title="状态码（Status Codes）"></a>状态码（Status Codes）</h3><p><strong>状态码范围：</strong></p><table><thead><tr><th>2xx：成功</th><th>3xx：重定向</th><th>4xx：客户端错误</th><th>5xx：服务器错误</th><th></th><th align="right"></th></tr></thead><tbody><tr><td>200 成功</td><td>301 永久重定向</td><td>400 错误请求</td><td>500 服务器错误</td><td></td><td align="right"></td></tr><tr><td>201 创建</td><td>304 资源未修改</td><td>401 未授权</td><td>502 网关错误</td><td></td><td align="right"></td></tr><tr><td></td><td></td><td>403 禁止访问</td><td>504 网关超时</td><td></td><td align="right"></td></tr><tr><td></td><td></td><td>404 未找到</td><td></td><td></td><td align="right"></td></tr><tr><td></td><td></td><td>405 请求方法不对</td><td></td><td></td><td align="right"></td></tr></tbody></table><h2 id="RESTful-的极致-HATEOAS"><a href="#RESTful-的极致-HATEOAS" class="headerlink" title="RESTful 的极致 HATEOAS"></a>RESTful 的极致 HATEOAS</h2><blockquote><p>RESTful的极致是hateoas，但是这个基本不会在实际项目中用到。</p></blockquote><p>在 Spring 中有一个叫做 HATEOAS 的 API 库，通过它我们可以更轻松的创建出符合 HATEOAS 设计的 API。相关文章(可以参考)：</p><ul><li><a href="https://blog.aisensiy.me/2017/06/04/spring-boot-and-hateoas/">在 Spring Boot 中使用 HATEOASopen in new window</a></li><li><a href="https://spring.io/guides/tutorials/rest/">Building REST services with Springopen in new window</a> (Spring 官网 )</li><li><a href="https://www.baeldung.com/spring-hateoas-tutorial">An Intro to Spring HATEOASopen in new window</a></li><li><a href="https://github.com/spring-projects/spring-hateoas-examples/tree/master/hypermedia">spring-hateoas-examplesopen in new window</a></li><li><a href="https://spring.io/projects/spring-hateoas#learn">Spring HATEOASopen in new window</a> (Spring 官网)</li></ul><p>参考：</p><blockquote><p><a href="https://javaguide.cn/system-design/basis/RESTfulAPI.html#%E4%BD%95%E4%B8%BA-api">RestFul API | JavaGuide</a></p></blockquote><h1 id="END"><a href="#END" class="headerlink" title="-END-"></a>-END-</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RESTful-API&quot;&gt;&lt;a href=&quot;#RESTful-API&quot; class=&quot;headerlink&quot; title=&quot;RESTful API&quot;&gt;&lt;/a&gt;RESTful API&lt;/h1&gt;&lt;p&gt;正式学习RESTful API之前,我们需要把什么是API搞懂.&lt;/</summary>
      
    
    
    
    <category term="开发规范" scheme="https://devildyw.github.io/categories/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="Developer" scheme="https://devildyw.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>雪花算法</title>
    <link href="https://devildyw.github.io/2022/04/04/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/"/>
    <id>https://devildyw.github.io/2022/04/04/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-04T09:34:54.000Z</published>
    <updated>2022-04-06T13:52:37.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h1><p><strong>简介:</strong></p><ul><li>雪花算法是Twitter开源的分布式ID生成算法 <a href="https://github.com/twitter-archive/snowflake.git">Github仓库地址</a></li><li>雪花算法主要用于分布式系统中,数据库的ID生成</li><li>在自然界中并不存在两片完全一样的雪花,每一片雪花都拥有自己漂亮独特的形状,独一无二.雪花算法也表示生成的分布式id如雪花般独一无二.</li></ul><span id="more"></span><h2 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h2><p>随着业务被使用的人越来越多, 单机的数据库已经很难保证业务能够流畅稳定的运行了, 这是我们需要对数据库进行分库分表存储, 使用分布式集群, 但是这样每个表的数据怎么保证ID唯一呢? 如果使用主键递增肯定发生ID不唯一的冲突情况, 所以急需一种可以生成全局唯一ID的算法来解决这个囧境.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/v2-6d694779c7d47e3573939f21993318df_720w.jpg" alt="img"></p><hr><h3 id="分布式ID需要满足的要求"><a href="#分布式ID需要满足的要求" class="headerlink" title="分布式ID需要满足的要求"></a><strong>分布式ID需要满足的要求</strong></h3><h4 id="全局唯一"><a href="#全局唯一" class="headerlink" title="全局唯一:"></a>全局唯一:</h4><ul><li>这是最基本的要求</li></ul><h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能:"></a>高性能:</h4><ul><li>不能为了全局唯一就去生成一大长串,肯定需要考虑性能,既要考虑生成的效率,又要考虑查询的效率(即存储的效率).</li></ul><h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用:"></a>高可用:</h4><ul><li>生成分布式ID的服务要保证可用性高,无限接近100%</li></ul><h4 id="方便易用"><a href="#方便易用" class="headerlink" title="方便易用:"></a>方便易用:</h4><ul><li>拿来即用，使用方便，快速接入！</li></ul><hr><h4 id="安全"><a href="#安全" class="headerlink" title="安全:"></a>安全:</h4><ul><li>分布式ID中不应含有敏感信息,否则了解算法的不怀好意之人解码可能会获取到这些敏感信息.</li></ul><h4 id="有序递增"><a href="#有序递增" class="headerlink" title="有序递增:"></a>有序递增:</h4><ul><li>如果要把 ID 存放在数据库的话，<strong>ID 的有序性可以提升数据库写入速度</strong>。并且，很多时候 ，我们还很有可能会直接通过 ID 来进行排序。</li></ul><h4 id="要求具体的业务含义"><a href="#要求具体的业务含义" class="headerlink" title="要求具体的业务含义:"></a>要求具体的业务含义:</h4><ul><li>生成的ID如果能有具体的业务含义,可以让定位问题以及开发更透明化(例如根据ID就能确定是哪个业务)</li></ul><h4 id="独立部署"><a href="#独立部署" class="headerlink" title="独立部署:"></a>独立部署:</h4><ul><li>也就是分布式系统单独有一个发号器服务，专门用来生成分布式 ID。这样就生成 ID 的服务可以和业务相关的服务解耦。不过，这样同样带来了网络调用消耗增加的问题。总的来说，如果需要用到分布式 ID 的场景比较多的话，独立部署的发号器服务还是很有必要的。(企业级的大型项目中十分有必要)</li></ul><hr><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>雪花算法生成的ID是一个<strong>64bit</strong>的<strong>long</strong>型的数字且<strong>按时间趋势递增</strong>.大致有首位符号位(无效位), 时间戳插值, 机器编码, 序列号四部分组成.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/22531124-e47b04a4e5b26623.png" alt="img"></p><p>如图: </p><ul><li><strong>首位无效符:</strong> 主要用做为符号位,因为一般都是生成正数,所以符号位统一都是0</li><li>**时间戳:**占用41bit,精确到毫秒. 41bit位最好可以表示2^41-1毫秒, 转化成单位年为69年.</li><li><strong>机器编码:</strong> 占用10bit,其中高位5bit是数据中心ID,低位5bit是工作节点ID,最多可以容纳1024个节点.</li><li>**序列号:**占用12bit,每个节点每毫秒0开始不断累加,最多可以累加到2^12-1,一共可以生成4096个ID(包括了0)</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a><strong>Java代码实现</strong></h3><p><code>snowFlake</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dyw.snowFlake;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-04-04 14:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDWorker</span> &#123;</span><br><span class="line">    <span class="comment">//十位的工作机器码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> workerId; <span class="comment">//工作id 五位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> datacenterId; <span class="comment">//数据中心id 五位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//12位序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">sequence</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">twEpoch</span> <span class="operator">=</span> <span class="number">1288834974657L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//长度为5位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">workerIdBits</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">datacenterIdBits</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line">    <span class="comment">//最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">maxWorkerId</span> <span class="operator">=</span> ~(-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">maxDatacenterId</span> <span class="operator">=</span> ~(-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列号id长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">sequenceBits</span> <span class="operator">=</span> <span class="number">12L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">sequenceMask</span> <span class="operator">=</span> ~(-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//工作id需要左移的位数, 12位(序列号的位长)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">workerIdShift</span> <span class="operator">=</span> sequenceBits;</span><br><span class="line">    <span class="comment">//数据中心id需要左移的位数 序列号长+工作id长</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">datacenterIdShift</span> <span class="operator">=</span> sequenceBits + workerIdBits;</span><br><span class="line">    <span class="comment">//时间戳左移位数 = 序列号长+工作id长+工作位长</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">timestampLeftShift</span> <span class="operator">=</span> sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上次时间戳, 初始值位负值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastTimestamp</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workerId 工作节点id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> datacenterId 数据中心id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IDWorker</span><span class="params">(<span class="type">long</span> workerId, <span class="type">long</span> datacenterId)</span> &#123;</span><br><span class="line">        <span class="comment">//检查参数的合法性</span></span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;</span>,</span><br><span class="line">                timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId);</span><br><span class="line">        <span class="built_in">this</span>.workerId = workerId;</span><br><span class="line">        <span class="built_in">this</span>.datacenterId = datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getWorkerId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> workerId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDatacenterId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getSequence</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * //下一个ID生成算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> snowflakeId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//先获取当前系统时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> timeGen();</span><br><span class="line">        <span class="comment">//如果当前系统时间比上次获取id时间戳小就抛出异常 时钟往后移动可能会出现同样id所以这里必须抛异常结束执行</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            System.err.printf(<span class="string">&quot;clock is moving backwards.  Rejecting requests until %d.&quot;</span>,lastTimestamp);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(String.format(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>,</span><br><span class="line">                    lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前时间戳如果等于上次时间戳(同一毫秒内),则在序列号加一,否则序列号赋值为0, 从零开始</span></span><br><span class="line">        <span class="keyword">if</span>(timestamp==lastTimestamp)&#123;</span><br><span class="line">            <span class="comment">//这是使用&amp;sequenceMask是为了防止sequence溢出12位(前面要求了sequence的长度只能是12位)</span></span><br><span class="line">            sequence = (sequence+<span class="number">1</span>)&amp;sequenceMask;</span><br><span class="line">            <span class="comment">//如果防止刚好移除经过&amp;sequenceMask后 会变成0 可能会发生重复的情况</span></span><br><span class="line">            <span class="comment">//所以此时需要再次获取时间戳,并于上次时间戳作比较 直到与上次时间戳不一致返回当前时间戳避免重复</span></span><br><span class="line">            <span class="keyword">if</span>(sequence==<span class="number">0</span>)&#123;</span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//如果不在同一个时间戳中 代表该序列刚开始计数所以初始为0</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sequence = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将上次时间戳值更新</span></span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 返回结果：</span></span><br><span class="line"><span class="comment">         * (timestamp - TwEpoch) &lt;&lt; timestampLeftShift) 表示将时间戳减去初始时间戳，再左移相应位数</span></span><br><span class="line"><span class="comment">         * (datacenterId &lt;&lt; datacenterIdShift) 表示将数据id左移相应位数</span></span><br><span class="line"><span class="comment">         * (workerId &lt;&lt; workerIdShift) 表示将工作id左移相应位数</span></span><br><span class="line"><span class="comment">         * | 是按位或运算符，例如：x | y，只有当x，y都为0的时候结果才为0，其它情况结果都为1。</span></span><br><span class="line"><span class="comment">         * 因为个部分只有相应位上的值有意义，其它位上都是0，所以将各部分的值进行 | 运算就能得到最终拼接好的id</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - twEpoch)&lt;&lt;timestampLeftShift) |</span><br><span class="line">                (datacenterId&lt;&lt;datacenterIdShift) |</span><br><span class="line">                (workerId&lt;&lt;workerIdShift)|</span><br><span class="line">                sequence;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取时间戳,并于上次时间戳作比较</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastTimestamp 上一次获取的时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> timestamp 更新后的系统时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">tilNextMillis</span><span class="params">(<span class="type">long</span> lastTimestamp)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> timeGen();</span><br><span class="line">        <span class="keyword">while</span>(timestamp&lt;=lastTimestamp)&#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取系统时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 系统时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">timeGen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Go语言实现"><a href="#Go语言实现" class="headerlink" title="Go语言实现"></a><strong>Go语言实现</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> al</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutex = sync.Mutex&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">//初始时间戳</span></span><br><span class="line">twEpoch <span class="type">int64</span> = <span class="number">1288834974657</span></span><br><span class="line"><span class="comment">//长度为5位</span></span><br><span class="line">workerIdBits     <span class="type">int64</span> = <span class="number">5</span></span><br><span class="line">datacenterIdBits <span class="type">int64</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最大值</span></span><br><span class="line">maxWorkerId     <span class="type">int64</span> = <span class="number">-1</span> ^ (<span class="number">-1</span> &lt;&lt; workerIdBits)</span><br><span class="line">maxDatacenterId <span class="type">int64</span> = <span class="number">-1</span> ^ (<span class="number">-1</span> &lt;&lt; datacenterIdBits)</span><br><span class="line"></span><br><span class="line"><span class="comment">//序列号id长度</span></span><br><span class="line">sequenceBits <span class="type">int64</span> = <span class="number">12</span></span><br><span class="line">sequenceMask       = <span class="number">-1</span> ^ (<span class="number">-1</span> &lt;&lt; sequenceBits)</span><br><span class="line"></span><br><span class="line"><span class="comment">//工作id需要左移的位数, 12位(序列号的位长)</span></span><br><span class="line">workerIdShift = sequenceBits</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据中心id需要左移的位数 序列号长+工作id长</span></span><br><span class="line">datacenterIdShift = sequenceBits + workerIdBits</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间戳左移位数 = 序列号长+工作id长+工作位长</span></span><br><span class="line">timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//上次时间戳, 初始值位负值</span></span><br><span class="line"><span class="keyword">var</span> lastTimestamp <span class="type">int64</span> = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IDWorker <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//十位的工作机器码</span></span><br><span class="line">workerId     <span class="type">int64</span> <span class="comment">//工作id 五位</span></span><br><span class="line">datacenterId <span class="type">int64</span> <span class="comment">//数据中心id 五位</span></span><br><span class="line"><span class="comment">//12位序列号</span></span><br><span class="line">sequence <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitIDWorker</span><span class="params">(workerId, datacenterId <span class="type">int64</span>)</span></span> (*IDWorker, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">//检查参数合法性</span></span><br><span class="line"><span class="keyword">if</span> workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">var</span> err = errors.New(fmt.Sprintf(<span class="string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">var</span> err = errors.New(fmt.Sprintf(<span class="string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;</span>,</span><br><span class="line">timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId)</span><br><span class="line"><span class="keyword">return</span> &amp;IDWorker&#123;</span><br><span class="line">datacenterId: datacenterId,</span><br><span class="line">workerId:     workerId,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">下一个ID生成算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *IDWorker)</span></span> NextId() (id <span class="type">int64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">//上锁</span></span><br><span class="line">mutex.Lock()</span><br><span class="line"><span class="comment">//程序结束 释放锁</span></span><br><span class="line"><span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line"><span class="comment">//先获取当前系统时间</span></span><br><span class="line"><span class="keyword">var</span> timestamp = timeGen()</span><br><span class="line"><span class="comment">//如果当前系统时间比上次获取id时间戳小就抛出异常 时钟往后移动可能会出现同样id所以这里必须抛异常结束执行</span></span><br><span class="line"><span class="keyword">if</span> timestamp &lt; lastTimestamp &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;clock is moving backwards.  Rejecting requests until %d.&quot;</span>, lastTimestamp)</span><br><span class="line">err = errors.New(fmt.Sprintf(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>,</span><br><span class="line">lastTimestamp-timestamp))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取当前时间戳如果等于上次时间戳(同一毫秒内),则在序列号加一,否则序列号赋值为0, 从零开始</span></span><br><span class="line"><span class="keyword">if</span> timestamp == lastTimestamp &#123;</span><br><span class="line"><span class="comment">//这是使用&amp;sequenceMask是为了防止sequence溢出12位(前面要求了sequence的长度只能是12位)</span></span><br><span class="line">i.sequence = (i.sequence + <span class="number">1</span>) &amp; sequenceMask</span><br><span class="line"><span class="comment">//如果防止刚好移除经过&amp;sequenceMask后 会变成0 可能会发生重复的情况</span></span><br><span class="line"><span class="comment">//所以此时需要再次获取时间戳,并于上次时间戳作比较 直到与上次时间戳不一致返回当前时间戳避免重复</span></span><br><span class="line"><span class="keyword">if</span> i.sequence == <span class="number">0</span> &#123;</span><br><span class="line">timestamp = tilNextMillis(lastTimestamp)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果不在同一个时间戳中 代表该序列刚开始计数所以初始为0</span></span><br><span class="line">i.sequence = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将上次时间戳值更新</span></span><br><span class="line">lastTimestamp = timestamp</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回雪花算法生成的id</span></span><br><span class="line">id = ((timestamp - twEpoch) &lt;&lt; timestampLeftShift) |</span><br><span class="line">(i.datacenterId &lt;&lt; datacenterIdShift) |</span><br><span class="line">(i.workerId &lt;&lt; workerIdShift) |</span><br><span class="line">i.sequence</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i IDWorker)</span></span> WorkerId() <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i.workerId</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i IDWorker)</span></span> DatacenterId() <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i.datacenterId</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i IDWorker)</span></span> Sequence() <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i.sequence</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取系统时间戳</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeGen</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> time.Now().UnixMilli()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取时间戳,并于上次时间戳作比较</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tilNextMillis</span><span class="params">(lastTimestamp <span class="type">int64</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">var</span> timestamp = timeGen()</span><br><span class="line"><span class="keyword">for</span> timestamp &lt;= lastTimestamp &#123;</span><br><span class="line">timestamp = timeGen()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> timestamp</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;雪花算法&quot;&gt;&lt;a href=&quot;#雪花算法&quot; class=&quot;headerlink&quot; title=&quot;雪花算法&quot;&gt;&lt;/a&gt;雪花算法&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;简介:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;雪花算法是Twitter开源的分布式ID生成算法 &lt;a href=&quot;https://github.com/twitter-archive/snowflake.git&quot;&gt;Github仓库地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;雪花算法主要用于分布式系统中,数据库的ID生成&lt;/li&gt;
&lt;li&gt;在自然界中并不存在两片完全一样的雪花,每一片雪花都拥有自己漂亮独特的形状,独一无二.雪花算法也表示生成的分布式id如雪花般独一无二.&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://devildyw.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="算法" scheme="https://devildyw.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://devildyw.github.io/2022/03/28/Redis/"/>
    <id>https://devildyw.github.io/2022/03/28/Redis/</id>
    <published>2022-03-28T12:58:54.000Z</published>
    <updated>2022-04-09T09:49:02.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><a href="https://www.bilibili.com/video/BV1cr4y1671t?p=63&spm_id_from=pageDriver">Redis</a></h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p><strong>Redis是一种NOSQL型数据库,即一种非关系型数据库</strong></p><p>我们常见的Mysql是一种SQL型数据库,是一种关系型数据库</p><span id="more"></span><h3 id="SQL型数据库"><a href="#SQL型数据库" class="headerlink" title="SQL型数据库"></a><strong>SQL型数据库</strong></h3><h4 id="结构化-Structured"><a href="#结构化-Structured" class="headerlink" title="结构化 Structured"></a>结构化 <strong>Structured</strong></h4><ul><li>下面这张图,我们创建这张表之初就对表的字段做了指定与规定,比如下面这张表只有三个字段,每个字段我们都加上了不同的约束,并且规定了字段的类型和长度,就使得这张表具有很强的结构体系,后续插入修改的数据都必须遵守表的结构</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307174510020.png" alt="image-20220307174510020"></p><h4 id="关联的-Relational"><a href="#关联的-Relational" class="headerlink" title="关联的(Relational)"></a>关联的(Relational)</h4><ul><li><p>比如一个表中的某个字段被其他表中的字段所关联(外键) 这样表中的数据就会自动维护,当删除某个字段时,就会提示无法删除的情况,除此之外,关联的优点还有可以节省存储空间,不需要记录数据的全部信息,只需要记录一个数据的主键即可.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307175758165.png" alt="image-20220307175758165"></p><h4 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h4><ul><li><p>优点:语法固定</p></li><li><p>缺点:需要去学习大量的语法 </p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307180551365.png" alt="image-20220307180551365"></p></li></ul><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><ul><li><strong>满足ACID(原子性, 一致性, 隔离性, 持久性) 对关系性要求较高的业务采用SQL</strong></li></ul><h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><ul><li><strong>磁盘</strong></li></ul><h4 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h4><ul><li><strong>垂直</strong>(即一主多从 数据存储的大小没有改变 只是增强了数据的存储效率(读写分离))</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>数据结构稳定</li><li>相关业务对数据安全性,一致性较高.(ACID)</li></ul><hr></li></ul><h3 id="NOSQL"><a href="#NOSQL" class="headerlink" title="NOSQL"></a><strong>NOSQL</strong></h3><h4 id="非结构化"><a href="#非结构化" class="headerlink" title="非结构化"></a>非结构化</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307174959275.png" alt="image-20220307174959275"></p><ul><li>NoSQL有三种数据存储格式 分别为<strong>key-value型, Document型, 还有Graph型</strong> 没有SQL那种有很强的结构性 比如<strong>key-value型的存储格式中</strong> 不需要指定数据的类型, 只要是NoSQL支持的数据格式 都可以填入. 对于<strong>Document型中 数据的字段数量也可以不同可以任意增添数据字段</strong> 不需要上一条数据有四个字段 这次就可以只有三种</li></ul><h4 id="无关系的"><a href="#无关系的" class="headerlink" title="无关系的"></a>无关系的</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307175732140.png" alt="image-20220307175732140"></p><ul><li>一般通过json(Document)的形式存储,缺点就是这种的数据格式不能自己维护,需要程序员自己通过业务逻辑维护 ,并且可能会出现数据的冗余,比如同一个商品多个用户下单,多个用户的信息的存储中都有相同的订单数据,这需要程序员自己根据不同的业务逻辑来维护.</li></ul><h4 id="非SQL"><a href="#非SQL" class="headerlink" title="非SQL"></a>非SQL</h4><ul><li><p>优点: 不需要去学习大量的语法</p></li><li><p>缺点: 不同的NoSQL语句的格式用法可能不同</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307180601578.png" alt="image-20220307180601578"></p><h4 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h4><ul><li><strong>BASE(基本一致或者无事务 无法完全满足ACID) 业务对安全性要求较低的可以采用NoSQL</strong></li></ul><h4 id="存储方式-1"><a href="#存储方式-1" class="headerlink" title="存储方式"></a>存储方式</h4><ul><li><strong>内存</strong></li></ul><h4 id="扩展性-1"><a href="#扩展性-1" class="headerlink" title="扩展性"></a>扩展性</h4><ul><li><strong>水平</strong>(即多主多从 数据存储的大小增加 也增强了数据的存储效率(读写分离))</li></ul><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>数据结构不稳定</li><li>对一致性,安全性要求不高</li><li>对性能要求高</li></ul><hr><h2 id="认识Redis"><a href="#认识Redis" class="headerlink" title="认识Redis"></a><strong>认识Redis</strong></h2><p>Redis诞生与2009年全程时<strong>Remote Dictionary Server(远程词典服务器)</strong>,是一个基于内存的键值型NoSQL数据库.</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a><strong>特征</strong></h3></li><li><p>键值型(key-value)型, value支持多种不同的数据类型,功能丰富</p></li><li><p>单线程,每个命令具有原子性</p></li><li><p>低延迟,速度快(<strong>基于内存</strong>,IO多路复用,良好的编码)</p></li><li><p>支持数据持久化(持久化到磁盘)</p></li><li><p>支持主从集群,分片集群(将数据分部分存储到多个master中 增加数据存储的上限)</p></li><li><p>支持多语言客户端</p></li></ul><hr><h2 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a><strong>Redis常见命令</strong></h2><h3 id="Redis数据结构介绍"><a href="#Redis数据结构介绍" class="headerlink" title="Redis数据结构介绍"></a><strong>Redis数据结构介绍</strong></h3><p>Redis是一个key-value的数据库,key一般是String类型,不过value的类型多种多样</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307191247016.png" alt="image-20220307191247016"></p><p>基本类型: String, Hash, List, Set. SortedSet</p><p>特殊类型: GEO(主要用于存储地理位置信息), BitMap, HyperLog(用来做基数统计的算法), Stream(主要用于消息队列)</p><h3 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a><a href="http://www.redis.cn/commands.html"><strong>Redis通用命令</strong></a></h3><p>通用指令是部分数据类型的,都可以使用的指令,常见的有 用法详情可以官网查看:</p><ul><li><strong>keys</strong>:查看符合模板的所有key,不建议在生产设备上使用(因为Redis是单线程的 使用keys *命令查看会占用很大资源 导致线程堵塞)</li><li>DEL: 删除可以删除一个或多个key (del key1 key2)</li><li>EXISTS: 判断key是否存在</li><li>EXPIRE: 给一个key设置有效期,有效期到时该key会被自动删除</li><li>TTL: 查看一个key剩余有效期</li></ul><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a><strong>String类型</strong></h3><p>String类型,也就是字符串类型,是Redis中最简单的存储类型.</p><p>其value是字符串,不过根据字符串的格式不同,又可以分为3类</p><ul><li>String:普通字符串</li><li>int: 整数类型,可以做自增,自减操作</li><li>float: 浮点类型,可以做自增,自减操作</li></ul><p>不管是哪种格式,底层都是字节数组形式存储,只不过是编码方式不同,字符串类型的最大的空间不能超过512m(可以存储图片 只需要将图片转为字节数组的格式存储 但这样会耗很大空间 一般不这样用)</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220308233257985.png" alt="img">&#x2F;image-20220308233257985.png</p><h4 id="String类型的常见指令"><a href="#String类型的常见指令" class="headerlink" title="String类型的常见指令"></a>String类型的常见指令</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220308233444257.png" alt="image-20220308233444257"></p><p><strong>SETEX</strong>用法比较特殊: <strong><code>set name jack ex 20(存活时间 单位秒)</code></strong></p><h3 id="key的结构"><a href="#key的结构" class="headerlink" title="key的结构"></a><strong>key的结构</strong></h3><p>Redis的key允许有多个单词形成<strong>层级结构</strong>,多个单词之间用**<code>&#39;:&#39;</code>**隔开,格式如下:</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220308235659340.png" alt="image-20220308235659340"></p><p>这个格式并非固定,也可以根据自己的需求来删除或添加词条</p><p>例如 一个项目下有user和product两种不同类型的数据,我们可以这样定义key:</p><ul><li>user相关的key: project:user:1</li><li>product相关的key: project:producet:1</li></ul><p>这样的格式实际上是以层级结构的形式存储的**(主要是为了区分不同项目中相同的数据 用户的id可以为1 商品的id也可以为1)**</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309000908161.png" alt="image-20220309000908161"></p><p>如果value是一个java对象,例如要给User对象,则可以将对象序列化为JSON字符串后存储</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220308235948333.png" alt="image-20220308235948333"></p><p>​                    <strong><code>set project:user:1 &#39;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;ding&quot;&#125;&#39;</code></strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309000302102.png" alt="image-20220309000302102"></p><hr><h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a><strong>Hash类型</strong></h3><p>Hash类型,也叫散列,其value是一个无序字典,类似于java中的HashMap结构.</p><p>String结构是将对象序列化为JSON字符串后存储,当需要修改对象某个字段时很不方便:</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309191057489.png" alt="image-20220309191057489"></p><p>Hash结构可以将对象中的每个字段独立存储,可以针对单个字段做CRUD: 相对于String类型较为灵活</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309191148786.png" alt="image-20220309191148786"></p><h4 id="Hash类型的常见命令"><a href="#Hash类型的常见命令" class="headerlink" title="Hash类型的常见命令:"></a>Hash类型的常见命令:</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309191557981.png" alt="image-20220309191557981"></p><hr><h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a><strong>List类型</strong></h3><p>Redis中的List类型于Java中的LinkedList类似,可以看作是一个双向链表结构.既可以支持正向检索也可以支持反向检索.</p><p>特征也与LinkedList类似</p><ul><li><strong>有序</strong></li><li><strong>元素可以重复</strong></li><li><strong>插入和删除块</strong></li><li><strong>查询速度一般</strong></li></ul><p>常用来存储一个有序数据,例如:朋友圈点赞列表,批量列表等.</p><h4 id="List的常见命令"><a href="#List的常见命令" class="headerlink" title="List的常见命令"></a>List的常见命令</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309194126739.png" alt="image-20220309194126739"></p><hr><h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a><strong>Set类型</strong></h3><p>Redis的Set结构与Java的中HashSet类似,可以看做是一个value为null的HashMap.因为也是一个Hash表,因此具备与HashSet类似的特征</p><ul><li><strong>无序</strong></li><li><strong>元素不可重复</strong></li><li><strong>查找块</strong></li><li><strong>支持交集 并集 差集等功能</strong></li></ul><h4 id="Set类型的常见命令"><a href="#Set类型的常见命令" class="headerlink" title="Set类型的常见命令"></a><strong>Set类型的常见命令</strong></h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309195325392.png" alt="image-20220309195325392"></p><hr><h3 id="SortedSet类型-有序集合"><a href="#SortedSet类型-有序集合" class="headerlink" title="SortedSet类型(有序集合)"></a><strong>SortedSet类型(有序集合)</strong></h3><p>Redis的SortedSet是一个可排序的set集合,与Java中的TreeSet有些类似,但底层数据结构却差别很大.SortedSet中的每一个元素都带有一个score属性,可以基于score属性对元素排序,底层的实现是一个跳表(SkipList)加hash表.SortedSet具备下列特性:</p><ul><li><strong>可排序</strong></li><li><strong>元素不重复</strong></li><li><strong>查询速度快</strong></li></ul><p>因为SortedSet的可排序特性,经常被用来实现排行榜这样的功能</p><h4 id="SortedSet类型的常见命令"><a href="#SortedSet类型的常见命令" class="headerlink" title="SortedSet类型的常见命令"></a>SortedSet类型的常见命令</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309201610780.png" alt="image-20220309201610780"></p><h2 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a><strong>Redis的Java客户端</strong></h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309203536114.png" alt="image-20220309203536114"></p><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a><strong>Jedis</strong></h3><ul><li><p><strong>创建Maven工程</strong></p></li><li><p><strong>引入Jedis依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>建立连接</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@BeforeEach</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//建立连接</span></span><br><span class="line">       jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;81.68.186.20&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">       <span class="comment">//设置密码</span></span><br><span class="line">       jedis.auth(<span class="string">&quot;ffdd2021@&quot;</span>);</span><br><span class="line">       <span class="comment">//选择库</span></span><br><span class="line">       jedis.select(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>存取数据</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//存入数据</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;12&quot;</span>);</span><br><span class="line">       System.out.println(name);</span><br><span class="line">       <span class="comment">//获取数据</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">       System.out.println(name1);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//插入hash数据</span></span><br><span class="line">       <span class="type">long</span> <span class="variable">name</span> <span class="operator">=</span> jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">       System.out.println(name);</span><br><span class="line">       <span class="comment">//取出</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> jedis.hget(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">       System.out.println(name1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>关闭连接</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//关闭连接</span></span><br><span class="line">       <span class="keyword">if</span>(jedis!=<span class="literal">null</span>)&#123;</span><br><span class="line">           jedis.close();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>Jedis中数据的存储命令是与命令行一致的</strong></p><hr></li></ul></li></ul><h4 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h4><p>Jedis本身是线程不安全的,并且频繁的创建和销毁连接会有性能损耗,因此我们推荐大家使用Jedis连接池代替Jedis直连的方式.</p><p>类似SQL型的数据库连接池 不会直接关闭连接而是归还到连接池</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        <span class="comment">//连接总数</span></span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//最大连接数量</span></span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//最小连接数量</span></span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//最大等待时间</span></span><br><span class="line">        jedisPoolConfig.setMaxWait(Duration.ofMillis(<span class="number">10000</span>));</span><br><span class="line">        <span class="comment">//创建连接池对象</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jedisPoolConfig,<span class="string">&quot;81.68.186.20&quot;</span>,<span class="number">6379</span>,<span class="number">1000</span>,<span class="string">&quot;ffdd2021@&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个获取连接的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a><a href="https://spring.io/projects/spring-data-redis"><strong>SpringDataRedis</strong></a></h3><p>SpringData是Spring中数据操作的模板,包含对各种数据库的集成,其中对Redis的集成模板就叫做SpringDataRedis </p><ul><li><strong>提供了对不同Redis客户端的整合(Lettuce和Jedis)</strong></li><li><strong>提供了RedisTemplate统一API来操作Redis</strong></li><li><strong>支持Redis的发布订阅模型</strong></li><li><strong>支持Redis哨兵和Redis集群</strong></li><li><strong>支持基于Lettuce的响应式编程</strong></li><li><strong>支持JDK,JSON,字符串,Spring对象的数据序列化及反序列化</strong>(方便地将上述数据格式 转化为字节数组 更方便地去存储在Redis中)</li><li><strong>支持基于Redis的JDKCollection实现</strong></li></ul><p>SpringDataRedis中提供了RedisTemplate工具类,其中封装了各种对Redis的操作.并且将不同数据类型的操作API封装到了不同的类型中:</p><h4 id="RedisTemplate工具类"><a href="#RedisTemplate工具类" class="headerlink" title="RedisTemplate工具类"></a>RedisTemplate工具类</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309234553190.png" alt="image-20220309234553190"></p><h4 id="RedisTemplate使用"><a href="#RedisTemplate使用" class="headerlink" title="RedisTemplate使用"></a>RedisTemplate使用</h4><ul><li><p>导入依赖</p><ul><li><p>SpringDataRedis依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>连接池依赖(Jedis和Lettuce都是依赖于commons-pool2实现)</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置文件</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">81.68</span><span class="number">.186</span><span class="number">.20</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">ffdd2021@</span></span><br><span class="line">    <span class="comment"># 选择数据库 database: 1</span></span><br><span class="line">    <span class="comment"># pool SpringDataRedis默认使用的客户端是Lettuce 可以导入其他依赖来使用其他连接池</span></span><br><span class="line">    <span class="comment"># 必须要配置了连接池 连接池才能生效</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br></pre></td></tr></table></figure></li><li><p>注入RedisTemplate工具类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Redis01RedisTemplateApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;丁杨维&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310000959983.png" alt="image-20220310000959983"></p></li></ul><h4 id="SpringDataRedis的序列化方式"><a href="#SpringDataRedis的序列化方式" class="headerlink" title="SpringDataRedis的序列化方式"></a>SpringDataRedis的序列化方式</h4><p>RedisTemplate可以接收任意Object作为值写入Redis,只不过吸入人前会把Object序列化为字节形式,默认是采用的JDK序列化,得到的结果是这样的:(及使用RedisTemplate时没有指定泛型)</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220310185259667.png" alt="image-20220310185259667"></p><p><strong>缺点:</strong></p><ul><li><strong>可读性差</strong></li><li><strong>内存占用较大</strong></li></ul><hr><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h4><ul><li><p>如果key-value都是String类型 直接指定泛型为String即可 但如果value或者key为Object时就需要自己配置了.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310190944166.png" alt="image-20220310190944166"></p><p>Redis提供了设置key-value序列化方式的接口</p></li><li><p>首先导入Jackson的依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>最新版<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置类 <code>RedisConfig</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">//创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String,Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//创建JSON序列化工具  注意这里使用的时Jackson需要导入Jackson的相关依赖才行</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">genericJackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">//设置key的序列化</span></span><br><span class="line">        template.setKeySerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashKeySerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//设置value的序列化</span></span><br><span class="line">        template.setValueSerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实体类 <code>User</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Redis01RedisTemplateApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,Object&gt; redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;丁杨维&quot;</span>, <span class="number">19</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;user1&quot;</span>,user);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1=&quot;</span>+user1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310191828636.png" alt="image-20220310191828636"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310191838617.png" alt="image-20220310191838617"></p><p>通过配置使用了Jackson序列化对象对JSON字符串格式存储,在取出时也可以将JSON字符串反系列化为对象.</p><hr><h4 id="JSON序列化的问题"><a href="#JSON序列化的问题" class="headerlink" title="JSON序列化的问题"></a>JSON序列化的问题</h4><p>如上图 我们会发现使用JSON序列化存储value时,会默认带上全类名名称 这样会造成额外的内存开销. (<strong>为了在反序列化时知道对象的类型,JSON序列化器会将类的class类型写入json结果中,存入Redis.</strong> )而如果想使用JSON序列化器序列化对象,这一步又是必不可少的.</p><p><strong>解决方案:</strong></p><ul><li>为了节省内存空间, 我们并不会使用JSON序列化器来处理value, <strong>而是统一使用String序列化器</strong>, 要求只能存储String类型的Key和value. <strong>当需要存储Java对象时, 手动完成对象的序列化和反序列化</strong>.</li><li>Spring默认提供了一个StringRedisTemplate类,他的key和value的序列化方式默认就是String方式.省去了我们自定义RedisTemplate的过程.</li></ul><hr><h4 id="StringRedisTemplate类"><a href="#StringRedisTemplate类" class="headerlink" title="StringRedisTemplate类"></a>StringRedisTemplate类</h4><ul><li><p>Jackson的ObjectMapper提供了将Java对象序列化为Json字符串和反序列化为Java对象的API</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Redis01RedisTemplateApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTest</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;彭芳姐&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ObjectMapper提供了将对象转化为Json串的API</span></span><br><span class="line">        <span class="comment">//手动序列化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userString</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user2&quot;</span>,userString);</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动反序列化</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> mapper.readValue(userJson, User.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310194423995.png" alt="image-20220310194423995"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310194441788.png" alt="image-20220310194441788"></p><h3 id="RedisTemplate对Hash的操作"><a href="#RedisTemplate对Hash的操作" class="headerlink" title="RedisTemplate对Hash的操作"></a><strong>RedisTemplate对Hash的操作</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void doTest2()&#123;</span><br><span class="line">    stringRedisTemplate.opsForHash().put(&quot;key&quot;,&quot;hashKey&quot;,&quot;value&quot;);</span><br><span class="line">    stringRedisTemplate.opsForHash().put(&quot;key&quot;,&quot;hashKey1&quot;,&quot;value1&quot;);</span><br><span class="line"></span><br><span class="line">    Map&lt;Object, Object&gt; key = stringRedisTemplate.opsForHash().entries(&quot;key&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作习惯上更偏向于java的HashMap之类的.</p><p>stringRedisTemplate.opsForHash().entries(String key)会获得hash类型中的某个key的全部key-value信息.</p><p>剩余操作或其他类型操作可以参考官方文档.<a href="https://docs.spring.io/spring-data/redis/docs/current/api/">RedisAPI文档</a></p><hr><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a><strong>项目实战</strong></h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310200358089.png" alt="image-20220310200358089"></p><hr><h3 id="Session共享问题"><a href="#Session共享问题" class="headerlink" title="Session共享问题:"></a><strong>Session共享问题:</strong></h3><p>多台TomCat并不共享session存储空间,当请求切换到不同的tomcat服务时,导致数据丢失的问题</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310213458462.png" alt="image-20220310213458462"></p><p>session的代替方案应该满足:</p><ul><li><strong>数据共享</strong></li><li><strong>内存存储</strong></li><li><strong>key-value结构</strong></li></ul><p><strong>以上的要求Redis都满足, 可以使用Redis来代替Session存储,但也不是简单的存储.</strong></p><h3 id="基于Redis实现共享Session登陆"><a href="#基于Redis实现共享Session登陆" class="headerlink" title="基于Redis实现共享Session登陆"></a><strong>基于Redis实现共享Session登陆</strong></h3><p><strong>Redis要实现共享Session登陆, 需要满足key唯一性.</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310214224767.png" alt="image-20220310214224767"></p><ul><li>如果使用用户登陆存储一定的用户信息在Redis中时,一般使用token作为key,而value使用Hash类型.</li><li>学习Hash类型的时候我们学过 Hash类型的存储可以将对象的字段分别存储,可以针对单个字段进行crud,不需要每次改的是否传全部信息进行更改.</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309191148786.png" alt="image-20220309191148786"></p><p>使用token存储用户的非敏感信息,传到前端,前端利用浏览器的缓存存储</p><p><strong>注意</strong>:</p><ul><li>使用token存储到Redis时一定要设置过期时间,因为会耗费内存空间(如果存储的token太多 有没有及时清楚 可能会造成堆栈溢出)</li><li>使用 RedisTemplate.expire可以指定指定key-value的存活时间</li><li>在登陆拦截器中,验证了token后需要刷新token存活时间,及再执行一遍第二步.</li><li>常量等可以专门编写一个类来记录 <code>static final constant</code>防止自己写出错.</li><li>对于一些不需要登陆拦截的Controller当用户访问时,也是需要刷新token的,设置一个全局刷新的token的拦截器,将其优先级设置为最高,所有请求都由他拦截,后续的登录拦截只需要从,全局拦截器中的存储到ThreadLocal的用户信息取到验证即可.</li></ul></li></ul></li></ul><h3 id="全局请求拦截器"><a href="#全局请求拦截器" class="headerlink" title="全局请求拦截器"></a><strong>全局请求拦截器</strong></h3><p>作用:</p><ul><li>用于拦截所有请求,获取如果有token就获取token中的数据,并且刷新token,并且将数据存入ThreadLocal中,如果没有就直接放行.(后续可能会被登陆拦截器拦截 检查是否有用户信息, 如果没有就返回false)</li><li>全局请求拦截器的主要作用就是为了防止用户登陆后,访问一些不需要登陆拦截器的接口token无法刷新的情况.</li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><strong>缓存</strong></h2><p><strong>缓存</strong>就是数据交换的缓存区(称作Cache), 是存储数据的临时地方,一般读写性能较高</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311151533133.png" alt="image-20220311151533133"></p><h3 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h3><ul><li>降低后端负载</li><li>提高读写效率,降低响应时间.</li></ul><h3 id="缓存的成本"><a href="#缓存的成本" class="headerlink" title="缓存的成本"></a>缓存的成本</h3><ul><li>数据一致性成本</li><li>代码维护成本</li><li>运维成本</li></ul><h3 id="添加Redis缓存"><a href="#添加Redis缓存" class="headerlink" title="添加Redis缓存"></a>添加Redis缓存</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311152211102.png" alt="image-20220311152211102"></p><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311153346059.png" alt="image-20220311153346059"></p><p>对于经常修改的数据,可以采用主动更新策略,在修改数据库的同时,更新缓存,这样的数据一致性较好,相应的维护成本较高. 对于不经常修改的数据,采用默认策略即可.</p><h4 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h4><h5 id="Cache-Aside-Pattern-常用"><a href="#Cache-Aside-Pattern-常用" class="headerlink" title="Cache Aside Pattern*(常用)"></a>Cache Aside Pattern*(常用)</h5><ul><li>由缓存的调用者,在更新数据库同时更新缓存.</li></ul><h5 id="Read-x2F-Write-Through-Pattern"><a href="#Read-x2F-Write-Through-Pattern" class="headerlink" title="Read&#x2F;Write Through Pattern"></a>Read&#x2F;Write Through Pattern</h5><ul><li>缓存与数据库整合为一个服务, 有服务来维护一致性. 调用者调用该服务, 无需关心缓存的一致性.</li></ul><h5 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h5><ul><li>调用者只是操作缓存,有其他线程异步地将缓存数据持久化到数据库,保证最终一致性</li></ul><h3 id="操作缓存和数据库时的三个问题考虑-For-Cache-Aside-Pattern"><a href="#操作缓存和数据库时的三个问题考虑-For-Cache-Aside-Pattern" class="headerlink" title="操作缓存和数据库时的三个问题考虑(For Cache Aside Pattern)"></a>操作缓存和数据库时的三个问题考虑(For Cache Aside Pattern)</h3><ol><li><p>删除缓存还是更新缓存 ?</p><ul><li>更新缓存: 每次更新数据库都更新缓存, 无效写操作较多(<strong>×</strong>)</li><li>删除缓存: 更新数据库时让缓存失效, 查询时在更新缓存(<strong>√</strong>)</li></ul></li><li><p>如何保证数据与数据库的同时成功或失败 ?</p><ul><li>单体系统, 将缓存与数据库操作防止一个事务</li><li>分布式系统,利用TTC等分布式事务方案</li></ul></li><li><p>先操作缓存还是先操作数据库 ?</p><ul><li>对于先操作缓存,可能会出现在删除缓存后将要操作数据库时, 另一个线程在查询缓存, 此时缓存中已无数据, 缓存未命中查询数据库写入缓存的情况,然后才去更新我们的数据库 造成读到脏数据的线程安全问题.</li><li>对于先操作数据库,也可能出现(刚好一个缓存过期)一个线程想要来查询缓存,缓存未命中,查询数据库的情况,此时数据库还没有更新,在要进行吸入缓存之前数据库才更新,这就造成读取到脏数据的情况.</li><li>但是对于先操作数据库的情况,实际上写入缓存的时间是非常快的,是远远快于操作数据库的情况,所以基本上不会出现在写入缓存之前,还能操作数据库的情况,所以一般采用先操作数据库的情况. 相比于第一种安全性更高.</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311160417480.png" alt="image-20220311160417480"></p></li></ol><h3 id="缓存更新的最佳实践方案"><a href="#缓存更新的最佳实践方案" class="headerlink" title="缓存更新的最佳实践方案:"></a><strong>缓存更新的最佳实践方案:</strong></h3><ol><li>低一致性需求: 使用Redis自带的淘汰机制</li><li>高一致性需求: 主动更新,并以超时作为兜底<ul><li>读操作:<ul><li>缓存命中则直接返回</li><li>缓存 未命中则查询数据库,并写入缓存,设定超时时间</li></ul></li><li>写操作:<ul><li>先写入数据库,再删除缓存</li><li>要确保数据的于缓存操作的原子性</li></ul></li></ul></li></ol><hr><h2 id="缓存未命中"><a href="#缓存未命中" class="headerlink" title="缓存未命中"></a><strong>缓存未命中</strong></h2><p>当CPU在缓存中找到有用的数据时，称为命中。当缓存中没有CPU需要的数据时（这称为未命中）</p><hr><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><strong>缓存穿透</strong></h2><p><strong>缓存穿透</strong>是指客户端请求的数据在缓存中和数据库中都不存在,这样的缓存永远都不会生效,这些请求都会打到数据库.</p><p>一些不坏好意的人可能会利用这里点来多线程发送多次请求导致数据库崩坏. 不存在的数据在数据库中查询对于数据库来说是会遍历全部数据然后返回NULL这对数据库的压力很大.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311161920235.png" alt="image-20220311161920235"></p><p><strong>常见的解决方案</strong>:</p><ul><li><p><strong>缓存空对象</strong>*</p><ul><li>优点: 实现简单,维护方便</li><li>缺点:<ul><li>额外的内存消耗(一般设置过期时间,且过期时间较短)</li><li>可能造成短期的不一致(此时新增一条该key对应的数据,但是在TTL结束前,查询到的都是NULL 造成短期不一致)</li></ul></li></ul></li><li><p><strong>布隆过滤</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311162648729.png" alt="image-20220311162648729"></p><ul><li>优点: 内存占用较少, 没有多余key</li><li>缺点:<ul><li>实现复杂</li><li>存在误判</li></ul></li></ul></li></ul><p><strong>除此之外缓存穿透的解决方案还有:</strong></p><ul><li>增强id的复杂度,避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流(也可以减小数据库压力)</li></ul><hr><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h2><p><strong>缓存雪崩</strong>是指在同一时间段大量的缓存key同时失效或者Redis服务宕机,导致大量请求到达数据库,带来巨大压力.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311163954070.png" alt="image-20220311163954070"></p><p><strong>解决方案</strong>:</p><ul><li>给不同的key的TTL添加随机值(防止大量的缓存Key同时失效)</li><li>利用Redis集群提高服务的可用性(防止单机宕机的情况)</li><li>给缓存业务添加降级限流策略(待学)</li><li>给业务添加多级缓存</li></ul><hr><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><strong>缓存击穿</strong></h2><p><strong>缓存击穿问题</strong>也叫热点Key问题,就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务比较复杂</strong>的key突然失效了,无数的请求访问会在瞬间给数据库带来巨大的冲击.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311165255394.png" alt="image-20220311165255394"></p><p><strong>常见解决方案</strong>:</p><ul><li><p><strong>互斥锁</strong></p><ul><li><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311165723072.png" alt="image-20220311165723072"></li><li>加锁,性能低.</li></ul></li><li><p><strong>逻辑过期</strong></p><ul><li>设置逻辑过期时间 而非TTL</li><li>获取互斥锁 开启新线程,去查询数据库重建缓存数据.</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311170401649.png" alt="image-20220311170401649"></p></li></ul><p><strong>两种方案的比较</strong>:</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311170545184.png" alt="image-20220311170545184"></p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁实现原理是通过Redis中的String类型的SETNX(插入一个不存在的数据)方法.这样别人就无法修改了.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311172926169.png" alt="image-20220311172926169"></p><p>RedisTemplate中的api是 opsForValue.setIfAbsent()</p><h3 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h3><p>使用逻辑过期 需要给数据设置一个逻辑过期时间, 一般会创建一个RedisData类 将逻辑过期时间和业务数据封装在一起,避免了在原有的业务基础上修改代码(指在实体类上新增逻辑过期字段).</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="comment">//业务数据</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LocalDateTime.After(LocalDateTime time),如果时间过期那么返回</p><h2 id="封装Redis工具"><a href="#封装Redis工具" class="headerlink" title="封装Redis工具"></a><strong>封装Redis工具</strong></h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311180308032.png" alt="image-20220311180308032"></p><h2 id="全局ID生成器"><a href="#全局ID生成器" class="headerlink" title="全局ID生成器"></a><strong>全局ID生成器</strong></h2><p>当用户抢购时,就会生成订单数据保存到订单表中,而订单表如果使用数据库自增ID就存在一些问题:</p><ul><li><strong>id的规律性太明显</strong></li><li><strong>受单表数据量的限制</strong></li></ul><p>全局ID生成器,是一种在分布式系统下用来生成全局唯一ID的工具,一般满足下列特性:</p><ul><li><strong>唯一性</strong></li><li><strong>高可用</strong></li><li><strong>递增性</strong></li><li><strong>安全性</strong></li><li><strong>高性能</strong></li></ul><p>为了增加ID的安全性,我们可以不直接使用Redis自增的数值,而是拼接一些其他的信息.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311210845236.png" alt="image-20220311210845236">ID的组成部分:</p><blockquote><ul><li>符号位: 1bit, 永远为0</li><li>时间戳: 31bit,以秒为单位</li><li>序列号: 32bit,秒内的计数器, 支持每秒产生2^32个不同的ID</li></ul></blockquote><p>全局唯一ID生成策略:</p><blockquote><ul><li>UUID</li><li><strong>Redis自增</strong>*</li><li><strong>snowflake算法(雪花算法)</strong>*</li><li>数据库自增</li></ul></blockquote><p><strong>Redis自增策略</strong>:</p><ul><li>每天一个key, 方便统计订单量</li><li>ID构造是 时间戳 + 计数器</li></ul><h2 id="优惠券秒杀下单功能"><a href="#优惠券秒杀下单功能" class="headerlink" title="优惠券秒杀下单功能"></a>优惠券秒杀下单功能</h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312123558073.png" alt="image-20220312123558073"></p><h3 id="超卖问题-线程安全问题"><a href="#超卖问题-线程安全问题" class="headerlink" title="超卖问题(线程安全问题)"></a>超卖问题(线程安全问题)</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312131903889.png" alt="image-20220312131903889"></p><p><strong>解决方案: 加锁</strong></p><ul><li><strong>悲观锁</strong></li><li><strong>乐观锁</strong></li></ul><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>认为线程安全问题一定会发生,因此在操作数据之前先获取锁,确保线程串行执行.</p><blockquote><ul><li>例如Synchronized, Lock都属于悲观锁</li><li>优点: 简单粗暴</li><li>缺点: 性能一般</li></ul></blockquote><hr><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>认为线程安全问题不一定会发生,因此不加锁,只是在更新数据时去判断有没有其他线程对数据进行了修改</p><blockquote><ul><li>如果没有修改则认为是安全的, 自己才更新数据</li><li>如果已经被其他线程修改说明发生了线程安全问题,此时可以重试或异常.</li><li>优点: 性能好</li><li>缺点存在成功率低的问题</li></ul></blockquote><p>乐观锁的关键是判断之前查询到的数据是否被修改过,常见的方式有两种:</p><ul><li><p>版本号法</p><p>设置一个用于悲观锁修改是判断的字段(版本号),每次修改后都会被修改</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312132808463.png" alt="image-20220312132808463"></p></li><li><p>CAS法</p><p>利用本身的数据作为判断依据(不新增任何字段 用自身数据代替版本)</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312133142933.png" alt="image-20220312133142933"></p></li></ul><h3 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h3><p>同一张优惠券一个用户只能下一单</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312135825445.png" alt="image-20220312135825445"></p><h4 id="集群下的一人一单问题"><a href="#集群下的一人一单问题" class="headerlink" title="集群下的一人一单问题"></a>集群下的一人一单问题</h4><p>JVM中有一个锁监视器 单机情况下可以实现锁的监视,但是在集群模式下 多个的JVM有不同的锁监视器, 即集群模式下的悲观锁失效了(它只能保证单个JVM下的线程安全问题)</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312142218951.png" alt="image-20220312142218951"></p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><strong>分布式锁</strong></h3><p>**分布式锁:**满足分布式系统或集群模式下多进程可见并且互斥的锁.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312142754987.png" alt="image-20220312142754987"></p><blockquote><ul><li><strong>多线程可见</strong>*</li><li><strong>互斥</strong>*</li><li><strong>高可用</strong>*</li><li><strong>高性能(指获得锁的性能)</strong>*</li><li><strong>安全性</strong>*</li><li>…</li></ul></blockquote><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312143720266.png" alt="image-20220312143720266"></p><h3 id="实现分布式锁-此处的是实现都是基于一人一单的情况下"><a href="#实现分布式锁-此处的是实现都是基于一人一单的情况下" class="headerlink" title="实现分布式锁(此处的是实现都是基于一人一单的情况下)"></a><strong>实现分布式锁</strong>(此处的是实现都是基于一人一单的情况下)</h3><p>实现分布式锁需要实现两个基本方法</p><ul><li>获取锁</li><li>释放锁</li></ul><h3 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a><strong>基于Redis的分布式锁</strong></h3><p>利用SETNX的互斥机制 和DEL的删除机制</p><p>为了防止Redis异常宕机的情况下锁的安全性问题(需要设置锁的过期时间)</p><ul><li><p>获取锁:</p><ul><li><p>互斥: 确保只能有一个线程获取锁</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">添加锁, NX是互斥 EX是设置超时时间</span></span><br><span class="line">set lock thread1 NX EX 10</span><br></pre></td></tr></table></figure></li></ul></li><li><p>释放锁:</p><ul><li><p>手动释放</p></li><li><p>超时释放: 获取锁时添加一个超时时间</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">释放锁, 删除即可</span></span><br><span class="line">DEL key</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312145523204.png" alt="image-20220312145523204"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">//获取线程表示</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">//获取锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的分布式锁的线程安全问题</p><p>业务堵塞导致锁的时间到期释放, 第二个线程此时获取到锁,在执行业务中,一号线程业务堵塞完毕此时释放锁 就导致线程二的锁被释放了.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312152342991.png" alt="image-20220312152342991"></p><p>改进后</p><p>通过新增UUID+ThreadID作为锁标识 在释放锁之前判断锁标识是否一致(同一个线程的锁标识一致,这样就不会出现业务堵塞导致释放了其他线程的锁的情况)</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312152522311.png" alt="image-20220312152522311"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312152710464.png" alt="image-20220312152710464"></p><h4 id="改进Redis的分布式锁"><a href="#改进Redis的分布式锁" class="headerlink" title="改进Redis的分布式锁"></a>改进Redis的分布式锁</h4><p>修改之前的分布式锁实现,满足</p><ol><li><p>在获取锁时存入线程表示(可用UUID表示)</p></li><li><p>在释放锁时先获取锁中的线程标识,判断是否与当前线程标识一致</p><blockquote><ul><li><p>如果不一致则不释放锁</p></li><li><p>如果一致则释放锁</p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取线程标识</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX+Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">//获取锁中的标识</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="comment">//判断是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(threadId.equals(id))&#123;</span><br><span class="line">        <span class="comment">//一致就释放锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX+name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则就不释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>改良后的Redis分布式锁 依旧存在如下问题就是在 删除锁的时候发生了堵塞 导致超时释放锁 此时二号线程进入获得锁执行业务,但是刚好一号线程堵塞完毕就将二号线程的锁释放了.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312173903547.png" alt="image-20220312173903547"></p><h3 id="Redis的Lua脚本"><a href="#Redis的Lua脚本" class="headerlink" title="Redis的Lua脚本"></a>Redis的Lua脚本</h3><p>释放锁业务的Lua脚本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- 比较线程标示与锁中的标示是否一致</span><br><span class="line">if(redis.call(&#x27;get&#x27;, KEYS[1]) ==  ARGV[1]) then</span><br><span class="line">    -- 释放锁 del key</span><br><span class="line">    return redis.call(&#x27;del&#x27;, KEYS[1])</span><br><span class="line">end</span><br><span class="line">return 0</span><br></pre></td></tr></table></figure><h3 id="Java中调用Lua脚本"><a href="#Java中调用Lua脚本" class="headerlink" title="Java中调用Lua脚本"></a>Java中调用Lua脚本</h3><p>RedisTemplate可以直接调用Lua脚本</p><p>使用静态代码块初始化lua脚本</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">    UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将原来java中的两行代码,变为了一行代码, 就不会出现上述的情况</p><p>改良后的unlock方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX+name),</span><br><span class="line">            ID_PREFIX+Thread.currentThread().getId());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于Redis的分布式锁优化"><a href="#基于Redis的分布式锁优化" class="headerlink" title="基于Redis的分布式锁优化"></a>基于Redis的分布式锁优化</h3><p>基于SETNX实现的分布式锁存在下面的问题:</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312184555611.png" alt="image-20220312184555611"></p><p><a href="https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95"><strong>Redission官方文档</strong></a></p><p>Redission是一个在Redis的基础上实现的java驻内存数据网络(In-Memory Data Grid). 它不仅提供了一系列的分布式java常用对象,还提供了许多分布式服务,其中就包含了各种分布式锁的实现</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312200824948.png" alt="image-20220312200824948"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1cr4y1671t?p=63&amp;spm_id_from=pageDriver&quot;&gt;Redis&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Redis是一种NOSQL型数据库,即一种非关系型数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们常见的Mysql是一种SQL型数据库,是一种关系型数据库&lt;/p&gt;</summary>
    
    
    
    <category term="NoSQL" scheme="https://devildyw.github.io/categories/NoSQL/"/>
    
    
    <category term="database" scheme="https://devildyw.github.io/tags/database/"/>
    
  </entry>
  
</feed>
