<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Devil的个人博客</title>
  
  <subtitle>永远相信美好的事情即将发生</subtitle>
  <link href="https://devildyw.github.io/atom.xml" rel="self"/>
  
  <link href="https://devildyw.github.io/"/>
  <updated>2022-04-17T09:30:56.095Z</updated>
  <id>https://devildyw.github.io/</id>
  
  <author>
    <name>Devil</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式----创建型模式之简单工厂设计模式</title>
    <link href="https://devildyw.github.io/2022/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://devildyw.github.io/2022/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-04-17T09:29:10.000Z</published>
    <updated>2022-04-17T09:30:56.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式—-创建型模式之简单工厂设计模式"><a href="#设计模式—-创建型模式之简单工厂设计模式" class="headerlink" title="设计模式—-创建型模式之简单工厂设计模式"></a>设计模式—-创建型模式之简单工厂设计模式</h1><h2 id="1-1-模式动机"><a href="#1-1-模式动机" class="headerlink" title="1.1. 模式动机"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id15">1.1. 模式动机</a></h2><p>考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。</p><hr><h2 id="1-2-模式定义"><a href="#1-2-模式定义" class="headerlink" title="1.2. 模式定义"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id16">1.2. 模式定义</a></h2><p>简单工厂模式(<code>Simple Factory Pattern</code>)：又称为<strong>静态工厂方法</strong>(<code>Static Factory Method</code>)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><hr><h2 id="1-3-模式结构"><a href="#1-3-模式结构" class="headerlink" title="1.3. 模式结构"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id17">1.3. 模式结构</a></h2><p>简单工厂模式包含如下角色：</p><ul><li><p><code>Factory</code>：工厂角色</p><p>工厂角色负责实现创建所有实例的内部逻辑</p></li><li><p><code>Product</code>：抽象产品角色</p><p>抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</p></li><li><p><code>ConcreteProduct</code>：具体产品角色</p><p>具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</p></li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/SimpleFactory.jpg" alt="../_images/SimpleFactory.jpg"></p><hr><h2 id="1-4-时序图"><a href="#1-4-时序图" class="headerlink" title="1.4. 时序图"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id18">1.4. 时序图</a></h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/seq_SimpleFactory.jpg" alt="../_images/seq_SimpleFactory.jpg"></p><hr><h2 id="1-5-代码分析"><a href="#1-5-代码分析" class="headerlink" title="1.5. 代码分析"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id19">1.5. 代码分析</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VehiclesGenerator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CAR</span> <span class="operator">=</span> <span class="string">&quot;Car&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BIKE</span> <span class="operator">=</span> <span class="string">&quot;Bike&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TRAIN</span> <span class="operator">=</span> <span class="string">&quot;Train&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">AIRPLANE</span> <span class="operator">=</span> <span class="string">&quot;Airplane&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方式一 交通工具生成器</span></span><br><span class="line"><span class="comment">     * 使用if 判断字段来生成实例</span></span><br><span class="line"><span class="comment">     * 返回值为抽象类类型 根据继承的知识我们知道 父类只能拥有子类重写的方法</span></span><br><span class="line"><span class="comment">     * 所以如果子类有额外的方法时需要向下转型.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vehiclesType 交通工具的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的交通工具</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Vehicles <span class="title function_">getInstance</span><span class="params">(String vehiclesType)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vehiclesType.equals(CAR))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vehiclesType.equals(TRAIN))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Train</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vehiclesType.equals(BIKE))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bike</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vehiclesType.equals(AIRPLANE))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Airplane</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">VehiclesGenerator</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-6-模式分析"><a href="#1-6-模式分析" class="headerlink" title="1.6. 模式分析"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id20">1.6. 模式分析</a></h2><ul><li>将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。</li><li>在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。</li><li>简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。</li><li>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</li></ul><hr><h2 id="1-7-实例"><a href="#1-7-实例" class="headerlink" title="1.7. 实例"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id21">1.7. 实例</a></h2><p><a href="https://github.com/Devildyw/design-patterns/tree/master/DesignPatterns-Java/SimpleFactoryPattern">简单工厂设计模式实例</a></p><hr><h2 id="1-8-简单工厂模式的优点"><a href="#1-8-简单工厂模式的优点" class="headerlink" title="1.8. 简单工厂模式的优点"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id22">1.8. 简单工厂模式的优点</a></h2><ul><li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。</li><li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li><li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li></ul><hr><h2 id="1-9-简单工厂模式的缺点"><a href="#1-9-简单工厂模式的缺点" class="headerlink" title="1.9. 简单工厂模式的缺点"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id23">1.9. 简单工厂模式的缺点</a></h2><ul><li>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</li><li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</li><li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li><li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li></ul><hr><h2 id="1-10-适用环境"><a href="#1-10-适用环境" class="headerlink" title="1.10. 适用环境"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id24">1.10. 适用环境</a></h2><p><strong>在以下情况下可以使用简单工厂模式：</strong></p><ul><li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li><li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li></ul><hr><h2 id="1-11-模式应用"><a href="#1-11-模式应用" class="headerlink" title="1.11. 模式应用"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id25">1.11. 模式应用</a></h2><ol><li><code>JDK</code>类库中广泛使用了简单工厂模式，如工具类<code>java.text.DateFormat</code>，它用于格式化一个本地日期或者时间。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title function_">getDateInstance</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title function_">getDateInstance</span><span class="params">(<span class="type">int</span> style)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title function_">getDateInstance</span><span class="params">(<span class="type">int</span> style,Locale</span></span><br><span class="line"><span class="params">locale)</span>;</span><br></pre></td></tr></table></figure><ol><li><code>Java</code>加密技术</li></ol><p>获取不同加密算法的密钥生成器:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">KeyGenerator keyGen=KeyGenerator.getInstance(<span class="string">&quot;DESede&quot;</span>);</span><br></pre></td></tr></table></figure><p>创建密码器:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cipher cp=Cipher.getInstance(<span class="string">&quot;DESede&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="1-12-总结"><a href="#1-12-总结" class="headerlink" title="1.12. 总结"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id26">1.12. 总结</a></h2><ul><li>创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。</li><li>简单工厂模式又称为静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</li><li>简单工厂模式包含三个角色：工厂角色负责实现创建所有实例的内部逻辑；抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</li><li>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</li><li>简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。</li><li>简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。</li></ul><hr><p><strong>摘自:</strong><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html"> 简单工厂模式( Simple Factory Pattern ) — Graphic Design Patterns (design-patterns.readthedocs.io)</a></p><h1 id="End"><a href="#End" class="headerlink" title="-End-"></a>-End-</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式—-创建型模式之简单工厂设计模式&quot;&gt;&lt;a href=&quot;#设计模式—-创建型模式之简单工厂设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式—-创建型模式之简单工厂设计模式&quot;&gt;&lt;/a&gt;设计模式—-创建型模式之简单工厂设计模式&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devildyw.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Developer" scheme="https://devildyw.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>restTemplate</title>
    <link href="https://devildyw.github.io/2022/04/16/restTemplate/"/>
    <id>https://devildyw.github.io/2022/04/16/restTemplate/</id>
    <published>2022-04-16T08:50:04.000Z</published>
    <updated>2022-04-16T09:04:44.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h1><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/wallhaven-8oky1j.jpg" alt="General 1920x1080 Gordon Zuchhold (Artstation) digital art science fiction pixel art city cyberpunk animation futuristic city ArtStation artwork futuristic"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><code>RestTemplate</code>是由<code>Spring</code>框架提供的一个可用于应用中调用<code>rest</code>服务的类它简化了与<code>http</code>服务的通信方式，统一了<code>RESTFul</code>的标准，封装了<code>http</code>连接，我们只需要传入<code>url</code>及其返回值类型即可。相较于之前常用的<code>HttpClient</code>，<code>RestTemplate</code>是一种更为优雅的调用<code>RESTFul</code>服务的方式。</li><li>在<code>Spring</code>应用程序中访问第三方<code>REST服务</code>与使用<code>Spring RestTemplate</code>类有关。<code>RestTemplate</code>类的设计原则与许多其他<code>Spring</code>的模板类(例如<code>JdbcTemplate</code>)相同，为执行复杂任务提供了一种具有默认行为的简化方法。</li><li><code>RestTemplate</code>默认依赖JDK提供了<code>http</code>连接的能力（<code>HttpURLConnection</code>），如果有需要的话也可以通过<code>setRequestFactory</code>方法替换为例如<code>Apache HttpCompoent、Netty或OKHttp</code>等其他<code>Http libaray</code>。</li><li>考虑到了<code>RestTemplate</code>类是为了调用REST服务而设计的，因此它的主要方法与<code>REST</code>的基础紧密相连就不足为奇了，后者时<code>HTTP</code>协议的方法：<code>HEAD、GET、POST、PUT、DELETE、OPTIONS</code>例如，<code>RestTemplate</code>类具有<code>headForHeaders()、getForObject()、putForObject()，put()和delete()</code>等方法。</li></ul><h2 id="创建RestTemplate"><a href="#创建RestTemplate" class="headerlink" title="创建RestTemplate"></a>创建<code>RestTemplate</code></h2><p>​    因为<code>RestTemplate</code>是<code>Spirng</code>框架提供的所以只要是一个<code>Springboot</code>项目就不用考虑导包的问题，这些都是提供好的。</p><p>​    但是<code>Spring</code>并没有将其加入<code>SpringBean</code>容器中，需要我们手动加入，因为我们首先创建一个<code>Springboot</code>配置类，再在配置类中将我们的<code>RestTemlate</code>注册到<code>Bean</code>容器中</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​    使用<code>Springboot</code>提供的<code>RestTemplateBuilder</code>构造类来构造一个<code>RestTemplate</code>，可以自定义一些连接参数，如：连接超时时间，读取超时时间，还有认证信息等</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415202710768.png" alt="image-20220415202710768"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">(RestTemplateBuilder builder)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">                <span class="comment">//设置连接超时时间</span></span><br><span class="line">                .setConnectTimeout(Duration.ofSeconds(<span class="number">5000</span>))</span><br><span class="line">                <span class="comment">//设置读取超时时间</span></span><br><span class="line">                .setReadTimeout(Duration.ofSeconds(<span class="number">5000</span>))</span><br><span class="line">                <span class="comment">//设置认证信息</span></span><br><span class="line">                .basicAuthentication(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                <span class="comment">//设置根路径</span></span><br><span class="line">                .rootUri(<span class="string">&quot;https://api.test.com/&quot;</span>)</span><br><span class="line">                <span class="comment">//构建</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加自定义的拦截器"><a href="#添加自定义的拦截器" class="headerlink" title="添加自定义的拦截器"></a>添加自定义的拦截器</h4><p>​    自定义拦截器示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomClientHttpRequestInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ClientHttpRequestInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ClientHttpResponse <span class="title function_">intercept</span><span class="params">(HttpRequest request, <span class="type">byte</span>[] body, ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印请求明细</span></span><br><span class="line">        logRequestDetails(request,body);</span><br><span class="line">        <span class="type">ClientHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> execution.execute(request, body);</span><br><span class="line">        <span class="comment">//打印响应明细</span></span><br><span class="line">        logResponseDetails(response);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logRequestDetails</span><span class="params">(HttpRequest request, <span class="type">byte</span>[] body)</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Headers:&#123;&#125;&quot;</span>,request.getHeaders());</span><br><span class="line">        log.debug(<span class="string">&quot;body:&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>(body, StandardCharsets.UTF_8));</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>,request.getMethod(),request.getMethodValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logResponseDetails</span><span class="params">(ClientHttpResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Status code : &#123;&#125;&quot;</span>,response.getStatusCode());</span><br><span class="line">        log.debug(<span class="string">&quot;Status text : &#123;&#125;&quot;</span>,response.getStatusText());</span><br><span class="line">        log.debug(<span class="string">&quot;Headers : &#123;&#125;&quot;</span>,response.getHeaders());</span><br><span class="line">        log.debug(<span class="string">&quot;Response body: &#123;&#125;&quot;</span>, StreamUtils.copyToString(response.getBody(),StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    使用<code>RestTemplateBuilder</code>构造类，添加自定义拦截器，构造带有自定义拦截器的<code>RestTemplate</code>实例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">(RestTemplateBuilder builder)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">                .additionalInterceptors(<span class="keyword">new</span> <span class="title class_">CustomClientHttpRequestInterceptor</span>())</span><br><span class="line">                <span class="comment">//构建</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    测试请求确实经过了拦截器，注册成功（注意请求和响应的流只会被读取一次，这里我们读取了response后返回的response就读取不到刚刚读过的内容了）</p><p>​    <img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415204816204.png" alt="image-20220415204816204"></p><hr><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​    使用<code>RestTemplate</code>构造方法构造一个<code>RestTemlate</code>，虽然不能像<code>RestTemplate</code>构造类那样更详细、更多样的配置参数，但是<code>RestTemplate</code>构造方法在一般情况是够用的。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415195208601.png" alt="image-20220415195208601"></p><ul><li>无参构造 全部参数默认</li><li>指定<code>ClientHttpRequestFactory</code> 的构造方法可以指定自己实现的<code>ClientHttpRequestFactory</code>（客户端<code>http</code>请求工厂）其他的与无参构造相同。<ul><li><code>ClientHttpRequestFactory</code></li></ul></li><li>指定<code>List&lt;HttpMessageConverter&lt;?&gt;&gt;</code>的构造方法可以指定自己是实现的<code>HttpMessageConverter</code>（<code>Http</code>消息转换器）传入其他与无参构造相同。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>​    两者方法都可使用，前者提供了多样的自定义参数的选择，可以将<code>RestTemplate</code>配置的更为完善，后者则简化了配置虽然配置多样性不如前者，但是日常使用调用些<code>API</code>还是足以使用</p><h2 id="RestTemplate-API使用"><a href="#RestTemplate-API使用" class="headerlink" title="RestTemplate API使用"></a><code>RestTemplate API</code>使用</h2><p>​    在使用<code>RestTemplate</code>前先让我们看看<code>RestTemplate</code>有哪些<code>API</code></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415205801633.png" alt="image-20220415205801633"><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415205831801.png" alt="image-20220415205831801"></p><p>​    相信大家看到这么多方法，一定很头大，但是我们仔细看上述的方法，我们可以提取出主要的几种方法是(这里只讨论Http请求的)：</p><ul><li><strong><code>GET</code></strong></li><li><strong><code>POST</code></strong></li><li><strong><code>PUT</code></strong></li><li><strong><code>DELETE</code></strong></li><li><strong><code>HEAD</code></strong></li><li><strong><code>OPTIONS</code></strong></li><li><strong><code>EXCHANGE</code></strong></li><li><strong><code>EXECUTE</code></strong></li></ul><p>​    <strong>这里我给大家安利一个一个网站，它提供免费的RESTFul api的样例测试。</strong><a href="http://httpbin.org/">httpbin A simple HTTP Request &amp; Response Service.</a></p><hr><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>​    通过上图我们可以发现<code>RestTemlate</code>发送<code>GET</code>请求的方法有两种</p><blockquote><ul><li><code>public &lt;T&gt; T getForObject(...)</code></li><li><code>public &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(...)</code></li></ul></blockquote><h4 id="getForEntity"><a href="#getForEntity" class="headerlink" title="getForEntity()"></a><strong><code>getForEntity()</code></strong></h4><p>​    后缀带有<code>Entity</code>的方法都代表返回一个<code>ResponseEntity&lt;T&gt;</code>，<code>ResponseEntity&lt;T&gt;</code>是Spring对<code>HTTP</code>请求响应的封装，包括了几个重要的元素，如响应码，<code>contentType、contentLength</code>、响应消息体等</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415211830207.png" alt="image-20220415211830207"></p><p>​    通过它继承父类(<code>HttpEntity&lt;T&gt;</code>)的<code>getHeader()</code>方法我们可以获取<code>contentType、contentLength</code>、响应消息体等。比如下面这个例子。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryWeather</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        ResponseEntity&lt;Object&gt; forEntity = restTemplate.getForEntity(<span class="string">&quot;https://restapi.amap.com/v3/weather/weatherInfo?city=510100&amp;key=e7a5fa943f706602033b6b329c49fbc6&quot;</span>, Object.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;状态码:&quot;</span>+forEntity.getStatusCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;状态码内容:&quot;</span>+forEntity.getStatusCodeValue());</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> forEntity.getHeaders();</span><br><span class="line">        System.out.println(<span class="string">&quot;响应头:&quot;</span>+headers);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">body</span> <span class="operator">=</span> forEntity.getBody();</span><br><span class="line">        System.out.println(<span class="string">&quot;响应内容:&quot;</span>+body);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    该例子中<code>getForEntity()</code>方法的第一个参数为我要调用服务的<code>URL</code>，第二个参数则为响应内容的类的类型（Java嘛 万物皆对象）还可以添加第三个参数，第三个参数为一个可变参数 代表着调用服务时的传参。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415212800839.png" alt="image-20220415212800839">    <strong>第三个参数可以使用key-value的map来传入参数</strong></p><p>​    <strong>get请求也可通过向在url上添加查询参数来发送带有请求的参数</strong></p><hr><h4 id="getForObject"><a href="#getForObject" class="headerlink" title="getForObject()"></a><strong><code>getForObject()</code></strong></h4><p>​    相比于前者<code>getForEntity()</code>该方法则是，更偏向于直接获取响应内容的，因为他直接返回响应实体的<code>body</code>（响应内容），。比如下面这个例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryWeather</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Object</span> <span class="variable">body</span> <span class="operator">=</span> restTemplate.getForObject(<span class="string">&quot;https://restapi.amap.com/v3/weather/weatherInfo?city=510100&amp;key=e7a5fa943f706602033b6b329c49fbc6&quot;</span>, Object.class);</span><br><span class="line">        System.out.println(body);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><pre><code> 方法参数签名与`getForEntity()`基本一致。</code></pre><hr><p>​    当你只需要返回的响应内容时，使用<code>getForObject()</code>是一个很好的选择，但当你需要获得更详细的响应信息，如响应头中的信息，你就只能选择<code>getForEntity()</code>了。</p><hr><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>​    <code>POST</code>请求有如下三种方法</p><blockquote><ul><li><code>public URI postForLocation(...)</code></li><li><code>public &lt;T&gt; T postForObject(...)</code></li><li><code>public &lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(...)</code></li></ul></blockquote><p>​    后两种用法与<code>GET</code>基本一致不做详细介绍，这里着重介绍<code>postForLocation()</code></p><hr><h4 id="postForEntity"><a href="#postForEntity" class="headerlink" title="postForEntity()"></a><code>postForEntity()</code></h4><p>​    该方法有三个参数，第一个为调用服务的地址（URL）</p><p>​    第二个参数表示上传的参数(json格式提交)</p><p>​    第三个表示返回响应内容的具体类型</p><p>​    第四个参数也用于指定参数（在URL中添加）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryWeather</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;鲁大师&quot;</span>);</span><br><span class="line">        ResponseEntity&lt;Object&gt; objectResponseEntity = restTemplate.postForEntity(<span class="string">&quot;https://restapi.amap.com/v3/weather/weatherInfo?city=510100&amp;key=e7a5fa943f706602033b6b329c49fbc6&quot;</span>, user, Object.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息响应内容:&quot;</span>+objectResponseEntity.getBody());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h4 id="postForObject"><a href="#postForObject" class="headerlink" title="postForObject()"></a><code>postForObject()</code></h4><p>​    使用方法与<code>getForObject</code>类似只是多了一个传入对象参数（传入方式与<code>postForEntity()</code>相同）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryWeather</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;鲁大师&quot;</span>);</span><br><span class="line">        ResponseEntity&lt;Object&gt; objectResponseEntity = restTemplate.postForEntity(<span class="string">&quot;https://httpbin.org/post&quot;</span>, user, Object.class);</span><br><span class="line">        <span class="type">MediaType</span> <span class="variable">contentType</span> <span class="operator">=</span> objectResponseEntity.getHeaders().getContentType();</span><br><span class="line">        System.out.println(contentType);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息响应内容:&quot;</span>+objectResponseEntity.getBody());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h4 id="postForLocation"><a href="#postForLocation" class="headerlink" title="postForLocation()"></a><code>postForLocation()</code></h4><p>​    <code>postForLocation</code>传参用法与前两者一致，只不过返回从实体变成了一个<code>URL</code>，因此它不需要指定返回响应内容的类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryWeather</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;鲁大师&quot;</span>);</span><br><span class="line">        <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> restTemplate.postForLocation(<span class="string">&quot;https://httpbin.org/post&quot;</span>, user);</span><br><span class="line">        System.out.println(uri);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个只需要服务提供者返回一个 URI 即可，该<code>URI</code>返回值体现的是：用于提交完成数据之后的页面跳转，或数据提交完成之后的下一步数据操作<code>URI</code>。</p><h4 id="使用POST以表单方式提交"><a href="#使用POST以表单方式提交" class="headerlink" title="使用POST以表单方式提交"></a>使用POST以表单方式提交</h4><p>​    这里我们着重说一下，如何自己封装一个请求体。</p><p>​    我们需要用到如下几个类</p><blockquote><ul><li><code>HttpHeaders</code></li><li><code>MultiValueMap&lt;K,V&gt;</code></li><li><code>HttpEntity&lt;T&gt;</code></li></ul></blockquote><h5 id="HttpHeaders"><a href="#HttpHeaders" class="headerlink" title="HttpHeaders"></a><code>HttpHeaders</code></h5><p>​    故名思意，就是用来封装Http请求的请求头的，这里我们要设置他的<code>ContentType</code>为**<code>MediaType.APPLICATION_FORM_URLENCODED</code>**以使得我们提交的参数是以Form(表单)的形式提交。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置请求头, x-www-form-urlencoded格式的数据</span></span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        <span class="comment">//这里指定参数以UTF-8编码格式传输</span></span><br><span class="line">        <span class="type">MediaType</span> <span class="variable">mediaType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaType</span>(MediaType.APPLICATION_FORM_URLENCODED, UTF_8);</span><br><span class="line">        httpHeaders.setContentType(mediaType);</span><br><span class="line">        <span class="comment">//提交参数设置</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">        map.add(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;鲁大师&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h5 id="MultiValueMap-lt-K-V-gt"><a href="#MultiValueMap-lt-K-V-gt" class="headerlink" title="MultiValueMap&lt;K,V&gt;"></a><code>MultiValueMap&lt;K,V&gt;</code></h5><p>​    该类是用来封装请求参数的，是以<code>key-value</code>的形式封装但是以单个key对应多个value的格式传输(也就是是以单个<code>key:[value...]</code>的格式传输的)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提交参数设置</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">        map.add(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;鲁大师&quot;</span>);</span><br></pre></td></tr></table></figure><p>​    <strong>如果像传输单个<code>key</code>对应单个<code>value</code>使用普通的<code>Map</code>传参即可</strong></p><hr><h5 id="HttpEntity-lt-T-gt"><a href="#HttpEntity-lt-T-gt" class="headerlink" title="HttpEntity&lt;T&gt;"></a><code>HttpEntity&lt;T&gt;</code></h5><p>​    该类是用来封装请求的，主要作用就是将请求头和请求体封装在一起成为一个请求实体 T用来指定用来封装参数的容器的类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组装请求体</span></span><br><span class="line">        HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; request = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(map, httpHeaders);</span><br></pre></td></tr></table></figure><hr><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>通过上述介绍后，我们就可以自己封装一个以form形式提交参数的<code>POST</code>请求了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//请求地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://httpbin.org/post&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置请求头, x-www-form-urlencoded格式的数据</span></span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        httpHeaders.setContentType(MediaType.APPLICATION_FORM_URLENCODED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交参数设置</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">        map.add(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;鲁大师&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//组装请求体</span></span><br><span class="line">        HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; request = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(map, httpHeaders);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送post请求并打印结果 以String类型接收响应结果JSON字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> restTemplate.postForObject(url, request, String.class);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416124128856.png" alt="image-20220416124128856"></p><p>​    通过拦截器拦截了请求并对请求头进行拆包，可以发现<code>ContentType</code>已经被修改成了<code>x-www-form-urlencoded</code>格式了。</p><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>​    <code>PUT</code>请求的方法只有一类</p><blockquote><ul><li><code>void put()</code></li></ul></blockquote><h4 id="PUT-1"><a href="#PUT-1" class="headerlink" title="PUT()"></a><code>PUT()</code></h4><p>​    使用方法与<code>postForEntity()</code>参数基本一致，只是<code>put</code>方法没有返回值（也就不必去设置响应内容的类型了）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//请求地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/put&quot;</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;鲁大师&quot;</span>);</span><br><span class="line">        restTemplate.put(url,user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>​    与<code>PUT</code>一样，<code>DELETE</code>方法只有一类</p><blockquote><ul><li><code>void delete()</code></li></ul></blockquote><h4 id="delete"><a href="#delete" class="headerlink" title="delete()"></a><code>delete()</code></h4><p>​    <code>delete()</code>可以指定<code>url</code>中的中的参数，但是<code>RestTemplate</code>的<code>delete()</code>方法是不支持上传<code>requestBody</code>的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/delete&quot;</span>;</span><br><span class="line">    restTemplate.delete(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="HEADER"><a href="#HEADER" class="headerlink" title="HEADER"></a>HEADER</h3><p>​    <code>HEADER</code>也只有一类方法</p><blockquote><ul><li><code>public HttpHeaders headForHeaders()</code></li></ul></blockquote><p>​    主要用来发送请求获取响应头部信息，但是像<code>DELETE</code>、<code>PUT</code>这类没有响应的方法，是不能使用该方法的（因为没有响应也就没有响应头了）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//请求地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/get&quot;</span>;</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> restTemplate.headForHeaders(url);</span><br><span class="line">        System.out.println(httpHeaders);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416151836372.png" alt="image-20220416151836372"></p><hr><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><blockquote><ul><li><code>public Set&lt;HttpMethod&gt; optionsForAllow()</code></li></ul></blockquote><p>​    该方法的主要用来判断该服务地址，能够使用那种方法去执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//请求地址</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/get&quot;</span>;</span><br><span class="line">       Set&lt;HttpMethod&gt; httpMethods = restTemplate.optionsForAllow(url);</span><br><span class="line">       System.out.println(httpMethods);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416152755753.png" alt="image-20220416152755753"></p><hr><h3 id="EXCHANGE"><a href="#EXCHANGE" class="headerlink" title="EXCHANGE"></a>EXCHANGE</h3><blockquote><ul><li><code>&lt;T&gt; ResponseEntity&lt;T&gt; exchange()</code></li></ul></blockquote><p>​    该接口与其他接口不同</p><blockquote><ul><li>该方法允许用户指定请求的方法（<code>get,post,put</code>等）</li><li>可以在请求中增加body以及头信息，其内容通过参数<code>HttpEntity&lt;?&gt; requestEntity</code>描述</li><li><code>exchange</code>支持’含参数的类型(即泛型)’作为返回类型，该特性通过<code>ParameterizedTypeReferenceresponseType</code> 描述</li></ul></blockquote><p>​    该方法支持五个参数</p><blockquote><ul><li>第一个是服务地址</li><li>第二个是请求方法</li><li>第三个是写入的请求实体</li><li>第四个是响应内容的类型</li><li>第五个是扩展模板的变量或包含<code>URI</code>模板变量的映射</li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/post&quot;</span>;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;彭于晏&quot;</span>);</span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    httpHeaders.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">    HttpEntity&lt;User&gt; userHttpEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(user, httpHeaders);</span><br><span class="line">    ResponseEntity&lt;Object&gt; exchange = restTemplate.exchange(url, HttpMethod.POST, userHttpEntity, Object.class);</span><br><span class="line">    System.out.println(exchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    上述代码模拟了一个简单的<code>POST</code>请求 <strong>可以理解为可以动态的指定请求方法和请求实体的一个方法。</strong></p><p> <strong>响应实体</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416154441113.png" alt="image-20220416154441113"></p><hr><h3 id="EXECUTE"><a href="#EXECUTE" class="headerlink" title="EXECUTE"></a>EXECUTE</h3><blockquote><ul><li><code>&lt;T&gt; T execute()</code></li></ul></blockquote><p>​    该方法就是执行请求的方法，我们可以发现上述的所有方法的最后执行都是调用的该方法执行，所以他在<code>RestTemplate</code>中十分重要</p><p>​    该方法有五个参数</p><blockquote><ul><li>服务地址</li><li>请求的方法</li><li>准备请求的对象（<code>requestCallback</code>）</li><li>从响应中提取返回值的对象</li><li>扩展模板的变量或包含<code>URI</code>模板变量的映射</li></ul></blockquote><p><code>execute()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">execute</span><span class="params">(String url, HttpMethod method, <span class="meta">@Nullable</span> RequestCallback requestCallback,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> ResponseExtractor&lt;T&gt; responseExtractor, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">URI</span> <span class="variable">expanded</span> <span class="operator">=</span> getUriTemplateHandler().expand(url, uriVariables);</span><br><span class="line"><span class="keyword">return</span> doExecute(expanded, method, requestCallback, responseExtractor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    通过上述源码我们可以发现<code>execute()</code>方法只是将我们传入的<code>String</code>类型的<code>URL</code>转换为了<code>URL</code>类型，最后执行请求是由<code>doExecute()</code>方法</p><hr><h4 id="doExecute"><a href="#doExecute" class="headerlink" title="doExecute()"></a><code>doExecute()</code></h4><p>​    这里需要了解两个类：<code>RequestCallback</code>和<code>ResPonseExtractor</code></p><p>​    <code>RequestCallback</code>: <strong>用于操作请求头和body，在请求发出前执行。不需要关心关闭请求或处理错误：这都将由RestTemplate处理。</strong></p><p>​    该接口有两个实现类：</p><p>​    <img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/v2-6761e212c99b46b5b24de7784c5f6c44_720w.jpg" alt="img"></p><p>​    <code>ResPonseExtractor</code>: <strong>解析HTTP响应的数据，而且不需要担心异常和资源的关闭。</strong></p><p>​    该接口在<code>RestTemplate</code>中同样有两个实现类：</p><table><thead><tr><th><code>HeadersExtractor</code></th><th>提取响应<code>HttpHeaders</code>的响应提取器。直接提取响应体中的响应头</th><th></th></tr></thead><tbody><tr><td><code>ResponseEntityResponseExtractor&lt;T&gt;</code></td><td><code>HttpEntity</code><strong>的响应提取器。可以获取响应实体里面包括响应头，响应体等。具体请查看</strong><code>HttpEntity</code></td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/post&quot;</span>;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;彭于晏&quot;</span>);</span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    httpHeaders.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">    HttpEntity&lt;User&gt; userHttpEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(user, httpHeaders);</span><br><span class="line">    ResponseEntity&lt;Object&gt; execute = restTemplate.execute(url, HttpMethod.POST, restTemplate.httpEntityCallback(userHttpEntity), restTemplate.responseEntityExtractor(Object.class));</span><br><span class="line">    System.out.println(execute);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416161653708.png" alt="image-20220416161653708"></p><hr><h2 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h2><ul><li>前面我们介绍方法的时候发现有个一个可变参数，那个参数被描述成了<strong>扩展模板的变量或是包含<code>URI</code>模板变量的映射</strong></li></ul><p>我们来简单看一下这个参数，我们知道请求传参可以通过<code>url</code>拼接参数的方式传参，拼接参数也分为两种：</p><blockquote><ul><li>路径中嵌入占位的格式（<code>http://httpbin.org/&#123;1&#125;/post</code>）也叫模板映射</li><li>末尾添加<code>Key-value</code>格式（<code>http://httpbin.org/post?name=&quot;彭于晏&quot;</code>）即扩展模板的变量</li></ul></blockquote><ul><li>当我们最后一参数传入map时会以<code>key-value</code>的格式拼接在<code>URL</code>后（通俗的说就是这样设置的变量会跟着<code>URL</code>路径后面）</li></ul><p>​    <code>http://httpbin.org/post?name=&quot;彭于晏&quot;</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/get&quot;</span>;</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;彭于晏&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">forObject</span> <span class="operator">=</span> restTemplate.getForObject(url, Object.class, map);</span><br><span class="line">    System.out.println(forObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当我们传入简单的对象如String，Integer时且路径中有嵌入的占位符时就会代替调用URL中占位符</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/&#123;2&#125;/get&quot;</span>;</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">forObject</span> <span class="operator">=</span> restTemplate.getForObject(url, Object.class, <span class="number">99</span>);</span><br><span class="line">    System.out.println(forObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416163605771.png" alt="image-20220416163605771"></p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u012843361/article/details/79893638">spring cloud 做微服务时关于RestTemplate中的各种请求方法的使用总结_DWT_CCFK的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/31681913">RestTemplate 详解 - 知乎 (zhihu.com)</a></p><p><a href="https://www.jianshu.com/p/35aca2e31f06">RestTemplate使用教程 - 简书 (jianshu.com)</a></p><hr><h1 id="End"><a href="#End" class="headerlink" title="-End-"></a>-End-</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RestTemplate&quot;&gt;&lt;a href=&quot;#RestTemplate&quot; class=&quot;headerlink&quot; title=&quot;RestTemplate&quot;&gt;&lt;/a&gt;RestTemplate&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://ding-blog.os</summary>
      
    
    
    
    <category term="分布式" scheme="https://devildyw.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HttpClient</title>
    <link href="https://devildyw.github.io/2022/04/11/HttpClient/"/>
    <id>https://devildyw.github.io/2022/04/11/HttpClient/</id>
    <published>2022-04-11T09:53:07.000Z</published>
    <updated>2022-04-16T08:52:08.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Apache-HttpClient"><a href="#Apache-HttpClient" class="headerlink" title="Apache HttpClient"></a>Apache HttpClient</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>HttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。HttpClient 已经应用在很多的项目中，比如 Apache Jakarta 上很著名的另外两个开源项目 Cactus 和 <strong>HTMLUnit</strong> 都使用了 HttpClient。</p></blockquote><p>​    使用HttpClient、可以灵活地发送HTTP请求，并且Apache HttpClient提供了很多自定义的请求内容的API（包括连接超时时间设置等）。方便了开发人员测试接口（基于HTTP协议的），既提高了开发效率，也方便了提高代码的健壮性。（后续的RestTemplate的底层也是HttpClient）因此熟悉掌握HttpClient是很重要的必修内容，掌握了HttpClient后，对于HTTP的协议的了解也会更加深刻。</p><hr><h2 id="Apache-HttpClient特性"><a href="#Apache-HttpClient特性" class="headerlink" title="Apache HttpClient特性"></a>Apache HttpClient特性</h2><ul><li>基于标准，纯净的Java语言。实现了HTTP1.0和HTTP1.1</li><li>以可扩展的面向对象的结构实现了 HTTP 全部的方法（<code>GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE</code>）。</li><li>支持 HTTPS 协议。</li><li>通过 HTTP 代理建立透明的连接。</li><li>利用 CONNECT 方法通过 HTTP 代理建立隧道的 HTTPS 连接。</li><li><code>Basic,Digest,NTLMv1,NTLMv2,NTLM2Session,SNPNEGO/Kerberos </code>认证方案。</li><li>插件式的自定义认证方案。</li><li>便携可靠的套接字工厂使它更容易的使用第三方解决方案。</li><li>连接管理器支持多线程应用。支持设置最大连接数，同时支持设置每个主机的最大连接数，发现并关闭过期的连接。</li><li>自动处理 Set-Cookie 中的 Cookie。</li><li>插件式的自定义 Cookie 策略。</li><li>Request 的输出流可以避免流中内容直接缓冲到 Socket 服务器。</li><li>Response 的输入流可以有效的从 Socket 服务器直接读取相应内容。</li><li>在 HTTP 1.0 和 HTTP 1.1 中利用 KeepAlive 保持持久连接。</li><li>直接获取服务器发送的 response code 和 headers。</li><li>设置连接超时的能力。</li><li>实验性的支持 HTTP 1.1 response caching。</li></ul><h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><ul><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpmime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建<code>HttpClient</code>对象（http客户端对象）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();<span class="comment">//方式一</span></span><br><span class="line"><span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClients.createDefault();<span class="comment">//方式二</span></span><br></pre></td></tr></table></figure><p>两种方式相同，因为方式二的底层就是方式一。</p></li><li><p>创建请求方法的实例，并指定<code>URL</code>。因为<code>HttpClient</code>是实现了所有<code>Http</code>请求方法，我们只需要创建请求方法实例（Httpxxx），在方法实例中指定URL即可，例如我们要发送Get请求，就创建<code>HttpGet</code>对象。</p></li><li><p>如果需要发送带有参数的请求，可调用<code>HttpGet、HttpPost</code>共同的<code>setParam（HttpParams params）</code>来添加参数（该方法已经过时&#x2F;弃用了）；<code>HttpGet</code>推荐使用单独创建uri，构建自己的带参数的get请求的uri。<code>HttpPost</code>请求则是调用<code>setEntity(HttpEntity entity)</code>方法来设置请求参数（可以设置对象）。</p></li><li><p>发送请求则是<code>HttpClient</code>的工作，调用<code>HttpClient</code>的<code>execute(HttpUriRequeset request)</code>发送请求，该方法会返回一个<code>HttpResponse</code>（响应模板）</p></li><li><p>调用<code>HttpResponse</code>的<code>getAllHeader()</code>、<code>getHeaders(Sring name)</code>等方法可以获取服务器的响应头，除此之外还可以获取状态码等。通过<code>HttpResponse</code>的<code>getEntity()</code>方法可以获取响应的响应实体，该对象包装了服务器的响应内容，程序可以通过该对象获取服务器的响应内容。</p></li><li><p>最后需要释放资源，关闭<code>HttpClient</code>和<code>reseponse</code>的资源连接</p></li></ul><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p><code>GET请求</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * GET---无参测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGetTestOne</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获得http客户端</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line">        <span class="comment">//创建get请求</span></span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;https://www.cuit.edu.cn/&quot;</span>);</span><br><span class="line">        <span class="comment">//响应模型</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//有客户端指定get请求</span></span><br><span class="line">            response = client.execute(httpGet);</span><br><span class="line">            <span class="comment">//从响应模型中获取响应体</span></span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">responseEntity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;响应状态为:&quot;</span>+response.getStatusLine());</span><br><span class="line">            <span class="keyword">if</span> (responseEntity!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容长度为:&quot;</span>+responseEntity.getContentLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容为:&quot;</span>+ EntityUtils.toString(responseEntity));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//释放资源</span></span><br><span class="line">                <span class="keyword">if</span>(client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * GET--有参测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGetTestWayOne</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获得http客户端</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//参数</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            params.append(<span class="string">&quot;name=&quot;</span>).append(URLEncoder.encode(<span class="string">&quot;&amp;&quot;</span>,<span class="string">&quot;utf-8&quot;</span>)).append(<span class="string">&quot;&amp;&quot;</span>).append(<span class="string">&quot;age=24&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Get请求</span></span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;https://www.cuit.edu.cn/?&quot;</span> + params);</span><br><span class="line">        <span class="comment">//响应模型</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//配置信息</span></span><br><span class="line">            <span class="type">RequestConfig</span> <span class="variable">config</span> <span class="operator">=</span> RequestConfig.custom()</span><br><span class="line">                    <span class="comment">//设置连接超时时间</span></span><br><span class="line">                    .setConnectTimeout(<span class="number">5000</span>)</span><br><span class="line">                    <span class="comment">//设置请求超时时间</span></span><br><span class="line">                    .setConnectionRequestTimeout(<span class="number">5000</span>)</span><br><span class="line">                    <span class="comment">//socket读写超时时间</span></span><br><span class="line">                    .setSocketTimeout(<span class="number">5000</span>)</span><br><span class="line">                    <span class="comment">//设置是否允许重定向(默认为true)</span></span><br><span class="line">                    .setRedirectsEnabled(<span class="literal">true</span>)</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="comment">//将上面的配置信息配入Get请求中</span></span><br><span class="line">            httpGet.setConfig(config);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//由客户端执行Get请求</span></span><br><span class="line">            response = client.execute(httpGet);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从响应模型中获取响应实体</span></span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">responseEntity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;响应状态为:&quot;</span>+response.getStatusLine());</span><br><span class="line">            <span class="keyword">if</span> (responseEntity!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容长度为:&quot;</span>+responseEntity.getContentLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容为:&quot;</span>+ EntityUtils.toString(responseEntity,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientProtocolException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGetTestWayTwo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line">        <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ArrayList&lt;NameValuePair&gt; params = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            params.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;10&quot;</span>));</span><br><span class="line">            params.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>));</span><br><span class="line">            <span class="comment">//这里设置uri信息,并将参数集合放入uri;</span></span><br><span class="line">            <span class="comment">//注: 这里也支持一个键值对一个键值对地往里面方setParameter(String key, String value)</span></span><br><span class="line">            uri = <span class="keyword">new</span> <span class="title class_">URIBuilder</span>().setScheme(<span class="string">&quot;http&quot;</span>).setHost(<span class="string">&quot;www.cuit.edu.cn&quot;</span>)</span><br><span class="line"><span class="comment">//                    .setPort(12345).setPath(&quot;/xw&quot;)</span></span><br><span class="line">                    .setParameters(params).build();</span><br><span class="line">            System.out.println(uri);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建httpGet请求</span></span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(uri);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建响应模型</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">RequestConfig</span> <span class="variable">config</span> <span class="operator">=</span> RequestConfig.custom()</span><br><span class="line">                    .setConnectTimeout(<span class="number">5000</span>)</span><br><span class="line">                    .setConnectionRequestTimeout(<span class="number">5000</span>)</span><br><span class="line">                    .setSocketTimeout(<span class="number">5000</span>)</span><br><span class="line">                    .setRedirectsEnabled(<span class="literal">true</span>).build();</span><br><span class="line"></span><br><span class="line">            httpGet.setConfig(config);</span><br><span class="line">            response = client.execute(httpGet);</span><br><span class="line"></span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;响应状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容长度:&quot;</span>+entity.getContentLength());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容:&quot;</span>+EntityUtils.toString(entity,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientProtocolException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//new GetClient().doGetTestOne();</span></span><br><span class="line">        <span class="comment">//new GetClient().doGetTestWayOne();</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GetClient</span>().doGetTestWayTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>POST请求</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * POST 无参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPostTestOne</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获得http客户端</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line">        <span class="comment">//创建Post请求</span></span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://www.cuit.edu.cn/index.htm&quot;</span>);</span><br><span class="line">        <span class="comment">//创建响应模型</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            response = client.execute(httpPost);</span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;响应状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容长度:&quot;</span>+entity.getContentLength());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容:&quot;</span>+ EntityUtils.toString(entity,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * POST 有参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPostTestFour</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获的http客户端</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//参数</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//字符数据最好encoding; 这样一来, 某些特殊字符才嗯那个传过去(如:某人的名字就是&quot;&amp;&quot;,不encoding,传不过去)</span></span><br><span class="line">            params.append(<span class="string">&quot;phone=&quot;</span>).append(URLEncoder.encode(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            params.append(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">            params.append(<span class="string">&quot;password=admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建post请求</span></span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://www.cuit.edu.cn/?&quot;</span> + params);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置ContentType(注:如果只是传入普通参数的话,ContentType不一定非要用application/json)</span></span><br><span class="line">        httpPost.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//响应模型</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            response = client.execute(httpPost);</span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容长度: &quot;</span>+entity.getContentLength());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容: &quot;</span>+entity);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * POST---有参测试(对象参数)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPostTestTwo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获取Http客户端</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Post请求</span></span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://www.cuit.edu.cn/index.htm&quot;</span>);</span><br><span class="line">        <span class="comment">//User user = new User();</span></span><br><span class="line">        <span class="comment">//user.setName(&quot;潘晓婷&quot;);</span></span><br><span class="line">        <span class="comment">//user.setAge(18);</span></span><br><span class="line">        <span class="comment">//user.setGender(&quot;女&quot;);</span></span><br><span class="line">        <span class="comment">//user.setMotto(&quot;姿势要优雅~&quot;);</span></span><br><span class="line">        <span class="comment">// 我这里利用阿里的fastjson，将Object转换为json字符串;</span></span><br><span class="line">        <span class="comment">// (需要导入com.alibaba.fastjson.JSON包)</span></span><br><span class="line">        <span class="comment">//String jsonString = JSON.toJSONString(user);</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">StringEntity</span> <span class="variable">stringEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringEntity</span>(jsonString, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        httpPost.setEntity(stringEntity);</span><br><span class="line">        httpPost.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=utf8&quot;</span>);</span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            response = client.execute(httpPost);</span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容长度:&quot;</span>+entity.getContentLength());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容:&quot;</span>+EntityUtils.toString(entity,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//new PostClient().doPostTestOne();</span></span><br><span class="line">        <span class="comment">//new PostClient().doPostTestFour();</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">PostClient</span>().doPostTestTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>上传文件</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送文件</span></span><br><span class="line"><span class="comment">     注:如果想要灵活方便的传输文件的话，</span></span><br><span class="line"><span class="comment">     *    除了引入org.apache.httpcomponents基本的httpclient依赖外</span></span><br><span class="line"><span class="comment">     *    再额外引入org.apache.httpcomponents的httpmime依赖。</span></span><br><span class="line"><span class="comment">     *    追注:即便不引入httpmime依赖，也是能传输文件的，不过功能不够强大。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://www.cuit.edu.cn/file&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">MultipartEntityBuilder</span> <span class="variable">multipartEntityBuilder</span> <span class="operator">=</span> MultipartEntityBuilder.create();</span><br><span class="line">            <span class="comment">//第一个文件</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileKey</span> <span class="operator">=</span> <span class="string">&quot;files&quot;</span>;</span><br><span class="line">            <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\图片\\《Valorant》3440x1440带鱼屏游戏壁纸_彼岸图网.jpg&quot;</span>);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            防止服务端收到的文件名乱码. 我们这里可以先将文件名URLEncode, 然后服务端拿到文件后URLDecode</span></span><br><span class="line"><span class="comment">            文件名其实是放在请求头的Content-Disposition中 如其值form-data; name=&quot;files&quot;; filename=&quot;头像.jpg&quot;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            multipartEntityBuilder.addBinaryBody(fileKey,file1, ContentType.DEFAULT_BINARY, URLEncoder.encode(file1.getName(),<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//其他参数(注:自定义contentType,设置UTF-8是为了防止服务端拿到的参数出现乱码)</span></span><br><span class="line">            <span class="type">ContentType</span> <span class="variable">contentType</span> <span class="operator">=</span> ContentType.create(<span class="string">&quot;text/plain&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">            multipartEntityBuilder.addTextBody(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;等沙利文&quot;</span>,contentType);</span><br><span class="line">            multipartEntityBuilder.addTextBody(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;25&quot;</span>,contentType);</span><br><span class="line"></span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">httpEntity</span> <span class="operator">=</span> multipartEntityBuilder.build();</span><br><span class="line">            httpPost.setEntity(httpEntity);</span><br><span class="line">            response = client.execute(httpPost);</span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            <span class="keyword">if</span> (entity!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容长度:&quot;</span>+entity.getContentLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容:&quot;</span>+ EntityUtils.toString(entity,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            File file1 = new File(&quot;D:\\图片\\XXX.jpg&quot;);</span></span><br><span class="line"><span class="comment">            multipartEntityBuilder.addBinaryBody(fileKey,file1);</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileClient</span>().test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Stream请求</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://www.cuit.edu.cn/index.htm&quot;</span>);</span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(<span class="string">&quot;流啊流~&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            <span class="type">InputStreamEntity</span> <span class="variable">ise</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamEntity</span>(is);</span><br><span class="line">            httpPost.setEntity(ise);</span><br><span class="line"></span><br><span class="line">            response = client.execute(httpPost);</span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;响应状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line">            <span class="keyword">if</span> (entity!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容长度:&quot;</span>+entity.getContentLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容:&quot;</span>+ EntityUtils.toString(entity,StandardCharsets.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StreamClient</span>().test5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="END"><a href="#END" class="headerlink" title="-END-"></a>-END-</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Apache-HttpClient&quot;&gt;&lt;a href=&quot;#Apache-HttpClient&quot; class=&quot;headerlink&quot; title=&quot;Apache HttpClient&quot;&gt;&lt;/a&gt;Apache HttpClient&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="分布式" scheme="https://devildyw.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>事务的嵌套</title>
    <link href="https://devildyw.github.io/2022/04/09/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B5%8C%E5%A5%97/"/>
    <id>https://devildyw.github.io/2022/04/09/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B5%8C%E5%A5%97/</id>
    <published>2022-04-09T09:47:42.000Z</published>
    <updated>2022-04-09T09:50:51.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务的嵌套"><a href="#事务的嵌套" class="headerlink" title="事务的嵌套"></a>事务的嵌套</h1><p><strong>什么是嵌套事务？</strong><br>       嵌套是子事务在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。</p><p><strong>可以通过下述的问答进一步去熟悉嵌套事务？</strong></p><ol><li>如果子事务回滚，会发生什么？<br>      父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。</li><li>如果父事务回滚，会发生什么？<br>      父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。</li><li>事务的提交，是什么情况？<br>      父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。</li></ol><p>原文链接：<a href="https://blog.csdn.net/javashareauthor/article/details/82842177">https://blog.csdn.net/javashareauthor/article/details/82842177</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事务的嵌套&quot;&gt;&lt;a href=&quot;#事务的嵌套&quot; class=&quot;headerlink&quot; title=&quot;事务的嵌套&quot;&gt;&lt;/a&gt;事务的嵌套&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;什么是嵌套事务？&lt;/strong&gt;&lt;br&gt;       嵌套是子事务在父事务中执行，子事务是父事务的</summary>
      
    
    
    
    <category term="数据库" scheme="https://devildyw.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="database" scheme="https://devildyw.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Annotation</title>
    <link href="https://devildyw.github.io/2022/04/07/Annotation/"/>
    <id>https://devildyw.github.io/2022/04/07/Annotation/</id>
    <published>2022-04-07T14:09:56.000Z</published>
    <updated>2022-04-16T08:52:19.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    <code>Annotation</code>（注解）是JDK5开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类，方法或者变量，在框架中大量使用（如 Spring、Mybatis等）</p><blockquote><p>注解是一种能被添加到java代码中的元数据，类、方法、变量、参数和包都可以用注解来修饰。注解对于它所修饰的代码并没有直接的影响。</p></blockquote><p>​    下面是我简单写的一个自定义注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">msg</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;Hi&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    通过对上述文件的字节码（.class）的反编译（javap - p xxx.class）可以得到<code>@interface</code>其实就是一个继承了<code>Annotation</code>的一个接口</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javap -p Test.class</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">com</span>.dyw.annotation.Test <span class="keyword">extends</span> <span class="title class_">java</span>.lang.annotation.Annotation &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> java.lang.String <span class="title function_">msg</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期间直接扫描：</strong>编译器在编译Java代码的时候扫描对于的注解并处理，比如某个方法使用了<code>@Override</code>，编译器在编译的时候就会检测当前的方法是否重写了父类对于的方法。</li><li><strong>运行期间通过反射处理：</strong>这个经常在Spring框架中看到，例如Spring的<code>@Value</code>注解，就是通过反射来进行处理的。</li></ul><h2 id="注解详细介绍"><a href="#注解详细介绍" class="headerlink" title="注解详细介绍"></a>注解详细介绍</h2><p>我们通过上述的例子可以看到我们的注解上面还有着其他的注解例如<code>@Retention</code>、<code>@Target</code>（这些都统称为元注解）.</p><p>所以一个注解是由以下成分组成</p><blockquote><ul><li>元注解</li><li><code>public @interface 注解名称</code></li></ul></blockquote><hr><h3 id="元注解介绍"><a href="#元注解介绍" class="headerlink" title="元注解介绍"></a>元注解介绍</h3><p>​    JDK1.8版本为我们提供了6个标准的用来<strong>对注解类型进行注解的注解类</strong>（1.8之前只有四个），我们称之为<code>meta-annotation</code>（元注解）.</p><p>​    <strong>元注解只能用在注解之上（自定义注解时可用）</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407175816207.png" alt="image-20220407175816207"></p><blockquote><p><code>@Target</code></p><p><code>@Retention</code></p><p><code>@Documented</code></p><p><code>@Inherited</code></p><p><code>@Native</code>（1.8新增）</p><p><code>@Repeatable</code>（1.8新增）</p></blockquote><hr><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a><code>@Target</code></h4><p>官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">指示注解类型适用的上下文。注解类型可能适用的声明上下文和类型上下文在 JLS 9.6.4.1 中指定，并在源代码中由java.lang.annotation.ElementType的枚举常量表示。</span><br><span class="line">如果注解类型T上不存在@Target元注解，则类型T的注解可以写为除类型参数声明之外的任何声明的修饰符。</span><br><span class="line">如果存在@Target元注解，编译器将强制执行ElementType枚举常量指示的使用限制，符合 JLS 9.7.4。</span><br></pre></td></tr></table></figure><ul><li><strong>它指明了它所修饰的注解使用的范围 如果自定义的注解为含有@Target元注解修饰，那么默认可以是在（除类型参数之外的）任何项之上使用，若有@Target元注解修饰那么根据Value（ElementType枚举常量）的指定的目标进行规定。</strong></li></ul><h5 id="ElementType"><a href="#ElementType" class="headerlink" title="ElementType"></a><code>ElementType</code></h5><p><code>ElementType.class</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span> &#123;</span><br><span class="line">    <span class="comment">/** 类、接口（包括注解类型）或枚举声明 */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 字段声明（包括枚举常量） */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 方法声明 */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 参数声明 */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 构造函数声明 */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 局部变量声明 */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 注解类型声明 */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 包装声明 */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型参数声明 类型参数即Map&lt;String,Integer&gt;中的String和Integer这里是作为类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用类型 对应于 JLS 4.11 中的 15 个类型上下文，以及两个声明上下文：类型声明（包括注解类型声明）和类型参数声明。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>ElementType的枚举常量指明了注解可以使用的目标。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span><span class="comment">//可修饰在方法之上</span></span><br></pre></td></tr></table></figure><hr><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a><code>@Retention</code></h4><p>官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">指示要保留带注解类型的注解多长时间。如果注释类型声明中不存在保留注释，则保留策略默认为RetentionPolicy.CLASS 。</span><br><span class="line">仅当元注释类型直接用于注释时，保留元注释才有效。如果将元注释类型用作另一个注释类型中的成员类型，则它没有效果。</span><br></pre></td></tr></table></figure><ul><li>即<code>@Retention</code>用来约束注解的生命周期，分别有三个值，源码级别（source）、类文件级别（class）或者运行时级别（runtime）可以通过指定<code>@Retention</code>中的值来实现（值为<code>RetentionPolicy</code>枚举常量）。</li></ul><h5 id="RetentionPolicy-class"><a href="#RetentionPolicy-class" class="headerlink" title="RetentionPolicy.class"></a><code>RetentionPolicy.class</code></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RetentionPolicy</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解将被编译器丢弃。(该类型的注解信息指挥保留在源码中，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class文件中)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解将由编译器记录在类文件中，但不需要在运行时由 VM 保留。这是默认行为.(该类型的注解信息会保留在源码里和class文件里，在执行的时候，不会加载到虚拟机中) 该类型也是未指定<span class="doctag">@Retention</span>值的缺省值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解将由编译器记录在类文件中，并在运行时由 VM 保留，因此可以反射性地读取它们。(源码，class文件和执行时(VM)都保留注解的信息)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>注意：</strong>生命周期大小排序为<code>SOURCE &lt; CLASS &lt; RUNTIME</code>，范围依次增大，前者能使用的地方后者一定能使用。如果需要在运行时去动态获取注解信息，那只能使用<code>RUNTIME</code>；如果要在编译时进行一些预处理操作，比如生成一些辅助代码，就是用<code>CLASS</code>；如果只是做一些检查性的操作，比如<code>@Override和@SupperssWarning</code>，可选择<code>SOURCE</code></p><hr><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a><code>@Documented</code></h4><p>官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">表示默认情况下，带有类型的注释将由 javadoc 和类似工具记录。这种类型应该用于注解类型的声明，这些类型的注释会影响其客户对注释元素的使用。如果使用 Documented 对类型声明进行注释，则其注释将成为注释元素的公共 API 的一部分。</span><br></pre></td></tr></table></figure><ul><li>带上该注解后的注解表明，在默认情况下这个注解是由JavaDoc和类似工具记录的，即带上了该文档化的注解被使用再生成文档时，会称为API的一部分。（默认情况下JavaDoc是不包含注解的，除非声明注解的时候使用了<code>@Documented</code>）</li></ul><p><code>Person.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Person &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="meta">@Person(name = &quot;ding&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//@Person(name = &quot;ding&quot;)</span></span><br><span class="line">    <span class="meta">@Person(name = &quot;yang&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>生成的文档</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407193958620.png" alt="image-20220407193958620"></p><ul><li>不带<code>@Documented</code>注解生成的文档</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407194037553.png" alt="image-20220407194037553"></p><hr><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a><code>@Inherited</code></h4><p>官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">指示注解类型是自动继承的。如果注解类型声明中存在 Inherited 元注解，并且用户在类声明中查询注解类型，并且类声明没有该类型的注解，则将自动查询该类的超类以获取注解类型。将重复此过程，直到找到此类型的注释，或到达类层次结构（对象）的顶部。如果没有超类具有此类型的注释，则查询将指示所讨论的类没有此类注释。</span><br><span class="line">请注意，如果注释类型用于注释类以外的任何内容，则此元注释类型无效。另请注意，此元注释仅导致注释从超类继承；已实现接口上的注解无效。</span><br></pre></td></tr></table></figure><ul><li>被该元注解修饰的自定义注解再使用后会自动继承，如果使用了该自定义注解去修饰一个class那么这个注解也会作用于该class的子类。就是说如果某个类使用了被<code>@Inherited</code>修饰的注解，则其子类将会自动具有该注释</li></ul><p>​    <strong>注意：</strong> <code>@Inherited annotation</code>类型是被标注过的<code>class</code>的子类所继承。类并不从它所实现的接口继承<code>annotation</code>，方法并不从它所重载的方法继承<code>annotation</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span> <span class="comment">//使用@Inherited修饰的自定义注解</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Person &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>main.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Father.class.getAnnotation(Person.class));</span><br><span class="line">        System.out.println(Son.class.getAnnotation(Person.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">com</span>.dyw.annotation.obj.Father &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407204033473.png" alt="image-20220407204033473"></p><hr><h4 id="Native"><a href="#Native" class="headerlink" title="@Native"></a><code>@Native</code></h4><p>官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">表示可以从本机代码引用定义常量值的字段。注释可以被生成本机头文件的工具用作提示，以确定是否需要头文件，如果需要，它应该包含哪些声明。</span><br></pre></td></tr></table></figure><ul><li>使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可。</li></ul><hr><h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a><code>@Repeatable</code></h4><p>官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">注释类型java.lang.annotation.Repeatable用于指示它（元）注释其声明的注释类型是可重复的。 @Repeatable的值表示可重复注解类型的包含注解类型。</span><br></pre></td></tr></table></figure><blockquote><p><code>@Repeatable</code>允许在相同的程序元素中重复注解（不报错）。在需要对同一种注解多次使用时，往往需要借助 @Repeatable 注解。Java 8 版本以前，同一个程序元素前最多只能有一个相同类型的注解，如果需要在同一个元素前使用多个相同类型的注解，则必须使用注解“容器”。</p></blockquote><p>​    <strong>不使用<code>@Repeatable</code>修饰的自定义注解完成重复注解</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Persons &#123;</span><br><span class="line">    Person[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Person &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Persons(value = &#123;@Person(name = &quot;ding&quot;),@Person(name = &quot;yang&quot;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>使用<code>@Repeatable</code>修饰的自定义注解</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Persons &#123;</span><br><span class="line">    Person[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable(Persons.class)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Person &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Person(name = &quot;ding&quot;)</span></span><br><span class="line"><span class="meta">@Person(name = &quot;yang&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>两种方法不同的地方是，创建重复注解Person时加上了<code>@Repeatable</code>注解，指向存储注解Persons，这样使用时就可以直接重复使用Person注解。从上述例子可以看出使用<code>@Repeatable</code>注解更符合常规思维，可读性强。</p></li><li><p>但两种方法的效果相同，只是使用了<code>@Repeatable</code>注解简化了写法，这种简化的底层依旧是多个重复注解使用了一个被称作“容器”注解的value的成员的数组元素处理。</p></li></ul><hr><h3 id="JDK基本注解介绍"><a href="#JDK基本注解介绍" class="headerlink" title="JDK基本注解介绍"></a>JDK基本注解介绍</h3><p>​    基本注解包括</p><blockquote><ul><li><p><code>@Override</code></p></li><li><p><code>@Deprecated</code></p></li><li><p><code>@SuppressWarnings</code></p></li><li><p><code>@SafeVarargs </code></p></li><li><p><code>@FunctionalInterface</code></p></li></ul></blockquote><h4 id="Override"><a href="#Override" class="headerlink" title="@Override"></a><code>@Override</code></h4><p>​    官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">指示方法声明旨在覆盖超类型中的方法声明。如果使用此注解类型对方法进行注解，则编译器需要生成错误消息，除非至少满足以下条件之一：</span><br><span class="line">该方法确实覆盖或实现了在超类型中声明的方法。</span><br><span class="line">该方法的签名与Object中声明的任何公共方法的签名等效。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">msg</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">msg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果将子类中方法名<code>msg</code>改为<code>mg</code>会发生如下编译错误</li></ul><blockquote><p>java: 方法不会覆盖或实现超类型的方法</p></blockquote><ul><li>所以<code>@Override</code>的作用告诉编译器检查这个方法，保证父类要包含一个被该方法重写的方法，否者就会出错，这样可以帮助程序员避免一些低级错误。</li></ul><hr><h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a><code>@Deprecated</code></h4><p>​    官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">@Deprecated 注释的程序元素是不鼓励程序员使用的程序元素，通常是因为它很危险，或者因为存在更好的替代方案。当在非弃用代码中使用或覆盖弃用的程序元素时，编译器会发出警告。</span><br></pre></td></tr></table></figure><ul><li>通俗的说被该注解修饰的目标项是已经过时的了，不推荐使用的。**</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">msg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>@Deprecated</code>修饰了Son中的<code>msg</code>方法后，调用该方法会出现<strong>删除线</strong>和编译警告。</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407210522333.png" alt="image-20220407210522333"></p><hr><h4 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a><code>@SuppressWarnings</code></h4><p>​    官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">指示应在带注释的元素（以及带注释的元素中包含的所有程序元素）中抑制命名的编译器警告。请注意，给定元素中抑制的警告集是所有包含元素中抑制的警告的超集。例如，如果您注释一个类以抑制一个警告并注释一个方法以抑制另一个警告，则两个警告都将在方法中被抑制。</span><br><span class="line">作为风格问题，程序员应该始终在最有效的嵌套元素上使用此注释。如果您想在特定方法中抑制警告，您应该注释该方法而不是它的类。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *编译器要在带注​​释的元素中抑制的一组警告。允许重复名称。名称的第二次和连续出现将被忽略。存在无法识别的警告名称不是错误：编译器必须忽略它们无法识别的任何警告名称。但是，如果注释包含无法识别的警告名称，它们可以自由发出警告。</span></span><br><span class="line"><span class="comment">字符串&quot;unchecked&quot;用于抑制未经检查的警告。编译器供应商应结合此注释类型记录他们支持的其他警告名称。鼓励他们合作以确保相同的名称在多个编译器中工作。</span></span><br><span class="line"><span class="comment">回报：</span></span><br><span class="line"><span class="comment">要抑制的警告集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Java中的<code>@SuppressWarnings</code> 注解指示被该注解修饰的程序元素（以及该程序元素中的所有子元素）取消显示指定的编译器警告，且会一直作用于该程序元素的所有子元素。</p></li><li><p>如果你对于代码的规范不做要求又对编译器的警告感到烦躁那么你可以使用<code>@SuppressWarnings</code>（仅仅只是取消显示，并没有消除），它可以让你免去这些烦恼，当然编译器报错他是无法帮你取消显示的。</p></li><li><p>添加前：</p></li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407211856114.png" alt="image-20220407211856114"></p><ul><li>添加后：</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407212004111.png" alt="image-20220407212004111"></p><ul><li><p>注解的使用有以下三种：</p><ul><li>抑制单类型的警告：<code>@SuppressWarnings(&quot;unchecked&quot;)</code></li><li>抑制多类型的警告：<code>@SuppressWarnings(&quot;unchecked&quot;,&quot;rawtypes&quot;)</code></li><li>抑制所有类型的警告：<code>@SuppressWarnings(&quot;unchecked&quot;)</code></li></ul></li><li><p>抑制警告的关键字如下表所示：</p><table><thead><tr><th>关键字</th><th>用途</th></tr></thead><tbody><tr><td>all</td><td>抑制所有警告</td></tr><tr><td>boxing</td><td>抑制装箱、拆箱操作时候的警告</td></tr><tr><td>cast</td><td>抑制映射相关的警告</td></tr><tr><td>dep-ann</td><td>抑制启用注释的警告</td></tr><tr><td>deprecation</td><td>抑制过期方法警告</td></tr><tr><td>fallthrough</td><td>抑制在 switch 中缺失 breaks 的警告</td></tr><tr><td>finally</td><td>抑制 finally 模块没有返回的警告</td></tr><tr><td>hiding</td><td>抑制相对于隐藏变量的局部变量的警告</td></tr><tr><td>incomplete-switch</td><td>忽略不完整的 switch 语句</td></tr><tr><td>nls</td><td>忽略非 nls 格式的字符</td></tr><tr><td>null</td><td>忽略对 null 的操作</td></tr><tr><td>rawtypes</td><td>使用 generics 时忽略没有指定相应的类型</td></tr><tr><td>restriction</td><td>抑制禁止使用劝阻或禁止引用的警告</td></tr><tr><td>serial</td><td>忽略在 serializable 类中没有声明 serialVersionUID 变量</td></tr><tr><td>static-access</td><td>抑制不正确的静态访问方式警告</td></tr><tr><td>synthetic-access</td><td>抑制子类没有按最优方法访问内部类的警告</td></tr><tr><td>unchecked</td><td>抑制没有进行类型检查操作的警告</td></tr><tr><td>unqualified-field-access</td><td>抑制没有权限访问的域的警告</td></tr><tr><td>unused</td><td>抑制没被使用过的代码的警告</td></tr></tbody></table></li></ul><hr><h4 id="SafeVarargs"><a href="#SafeVarargs" class="headerlink" title="@SafeVarargs "></a><code>@SafeVarargs </code></h4><p>​    官方解释：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">程序员断言带注释的方法或构造函数的主体不会对其 varargs 参数执行潜在的不安全操作。将此注释应用于方法或构造函数会抑制有关不可具体化的变量 arity (vararg) 类型的未经检查的警告，并抑制有关在调用站点创建参数化数组的未经检查的警告。</span><br><span class="line">除了<span class="meta">@Target</span>元注解施加的使用限制外，编译器还需要对该注解类型实施额外的使用限制；如果使用<span class="meta">@SafeVarargs</span>注释对方法或构造函数声明进行注释，则这是编译时错误，并且：</span><br><span class="line">声明是一个固定的arity方法或构造函数</span><br><span class="line">声明是一个既不是<span class="keyword">static</span>也不是<span class="keyword">final</span>的变量 arity 方法。</span><br><span class="line">鼓励编译器在将此注释类型应用于方法或构造函数声明时发出警告，其中：</span><br><span class="line">变量 arity 参数具有可具体化的元素类型，包括原始类型、 Object和String 。 （对于可具体化的元素类型，此注释类型抑制的未经检查的警告已经不会出现。）</span><br><span class="line">方法或构造函数声明的主体执行潜在的不安全操作，例如对变量 arity 参数数组的元素的赋值会生成未经检查的警告。一些不安全的操作不会触发未经检查的警告。例如，别名在</span><br><span class="line">   <span class="meta">@SafeVarargs</span> <span class="comment">// 实际上并不安全！</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(List&lt;String&gt;... stringLists)</span> &#123;</span><br><span class="line">     Object[] array = stringLists;</span><br><span class="line">     List&lt;Integer&gt; tmpList = Arrays.asList(<span class="number">42</span>);</span><br><span class="line">     array[<span class="number">0</span>] = tmpList; <span class="comment">// 语义上无效，但可以编译</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringLists[<span class="number">0</span>].get(<span class="number">0</span>); <span class="comment">// 哦不，运行时的 ClassCastException！</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">在运行时导致ClassCastException 。</span><br><span class="line">该平台的未来版本可能会要求此类不安全操作出现编译器错误。</span><br></pre></td></tr></table></figure><p>在学习<code>@SafeVarargs</code>之前先来看看下面有一段代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        display(<span class="string">&quot;10&quot;</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(T ...array)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (T arg : array)&#123;</span><br><span class="line">            System.out.println(arg.getClass().getName()+<span class="string">&quot;:&quot;</span>+arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这段代码中我设计了一个接收可变参数的方法<code>public static &lt;T&gt; void display(T ...array)&#123;&#125;</code>可变参数方法中的参数类型相同，为此声明参数是需要指定泛型。</p><p>​    但是调用可变参数方法时，应该提供相同类型的参数，但是代码中传入了不同类型的参数集合，此时可以看到display签名处有如下警告</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407213806123.png" alt="image-20220407213806123"></p><p>​    翻译过来就是<code>参数化可变参数类型可能造成的堆污染</code>并且提示添加<code>@SafeVarargs</code>注解（仅仅起一个取消显示的作用，某种方面上来说是和 <code>@SuppressWarnings</code> 作用相同的）。</p><p>​    这个警告是 unchecked（未检查不安全代码），就是因为将非泛型变量赋值给泛型变量所发生的。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407214116091.png" alt="image-20220407214116091"></p><p>​    可以发现加上了<code>@SafeVarargs</code>注解后编译器警告没有显示了，你肯定会说我使用<code>@SuppressWarnings</code>效果也是一样的，效果虽然一样，但是两者相较来说这里使用<code>@SafeVarargs</code>注解更合适</p><p>​    <strong>注意：</strong><code>@SafeVarargs</code>注解<strong>不适用于非 <code>static</code> 或非 <code>final</code> 声明的方法</strong>，对于未声明为 <code>static</code> 或 <code>final</code> 的方法，如果要抑制 <code>unchecked</code> 警告，<strong>可以使用 <code>@SuppressWarnings</code> 注解。</strong></p><hr><h4 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a><code>@FunctionalInterface</code></h4><p>​    官方解释：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">一种信息性注解类型，用于指示接口类型声明旨在成为 Java 语言规范定义的功能接口。从概念上讲，函数式接口只有一个抽象方法。由于默认方法有一个实现，它们不是抽象的。如果接口声明了一个覆盖java.lang.Object的公共方法之一的抽象方法，这也不会计入接口的抽象方法计数，因为接口的任何实现都将具有来自java.lang.Object或其他地方的实现(接口的实现是类,所有类的父类都是Object)。</span><br><span class="line">请注意，函数式接口的实例可以使用 lambda 表达式、方法引用或构造函数引用来创建。</span><br><span class="line">如果使用此注解类型对类型进行注解，则编译器需要生成错误消息，除非：</span><br><span class="line">该类型是接口类型，而不是注解类型、枚举或类。</span><br><span class="line">带注解的类型满足功能接口的要求。</span><br><span class="line">但是，无论接口声明中是否存在FunctionalInterface注释，编译器都会将满足功能接口定义的任何接口视为功能接口。</span><br></pre></td></tr></table></figure><p>​    在学习Lambda表达式时，我们了解过函数式接口（接口中只有个一个抽象方法可以存在多个默认方法或多个static方法）。</p><ul><li><p><code>@FunctionalInterface</code>作用就是用来指定某一个接口必须是函数式接口的，所以<code>@FunctionalInterface</code>只能修饰接口。</p></li><li><p>这里我写了两个抽象方法出现了编译器报错</p></li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407214859347.png" alt="image-20220407214859347"></p><ul><li>这里我只写了一个抽象方法 一个static方法和一个默认方法 符合要求没有报错</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407215038533.png" alt="image-20220407215038533"></p><p>​    <strong>注意：</strong>如果接口声明了一个覆盖<code>java.lang.Object</code>的公共方法之一的抽象方法，这也不会计入接口的抽象方法计数</p><p>得出结论：<code>@FunctionalInterface</code>只是告诉编译器去检查这个接口是不是函数式接口，保证该接口只能包含一个抽象方法，否者就会出现编译错误。</p><hr><h2 id="写一个自己的注解"><a href="#写一个自己的注解" class="headerlink" title="写一个自己的注解"></a>写一个自己的注解</h2><p>注解的格式就是</p><blockquote><ul><li>元注解</li><li><code>public @interface 注解名</code></li><li>注解内容体</li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span> <span class="comment">//这里我希望我的注解能够生成在JavaDoc生成的文档中</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span> <span class="comment">//这里我希望我的注解能够在字节码文件中保留</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span> <span class="comment">//这里我希望我的注解可以修饰于类、接口、抽象类和方法上</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123; <span class="comment">//我声明了一个名为MyAnnotation的注解</span></span><br><span class="line">    <span class="comment">//定义带两个成员变量的注解</span></span><br><span class="line">    <span class="comment">//注解中的成员以方法的形式命名（注解的本质是接口） 并且可以带有默认值</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    想要获取注解中的成员变量需要使用反射的知识、首先需要获取类的Class对象，我们就可以通过的这个Class对象反射得到注解的成员变量了。</p><p>​    反射相关的可以参考这篇博客<a href="https://blog.csdn.net/D1842501760/article/details/120714043?spm=1001.2014.3001.5502">反射</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test</span>().testMyAnnotation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="meta">@MyAnnotation(name = &quot;dyw&quot;,age = 20)</span><span class="comment">//这里我们使用了我们刚才自定义的注解</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMyAnnotation</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">        <span class="comment">//这里获取Test类的Class对象 当类被编译后会当jvm加载时会生成该class文件的Class对象 通过这个Class对象可以完成反射相关的操作</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">testMyAnnotation</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getMethod(<span class="string">&quot;testMyAnnotation&quot;</span>);</span><br><span class="line">        <span class="comment">//通过Class对象的getAnnotation()方法反射得到我们的MyAnnotation对象</span></span><br><span class="line">        <span class="type">MyAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> testMyAnnotation.getAnnotation(MyAnnotation.class);</span><br><span class="line">        <span class="comment">//通过该对象可以获取注解类的成员</span></span><br><span class="line">        System.out.println(<span class="string">&quot;name :&quot;</span>+annotation.name());</span><br><span class="line">        System.out.println(<span class="string">&quot;age :&quot;</span>+annotation.age());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220408151357416.png" alt="image-20220408151357416"></p><p>​    这里只介绍了自定义注解类的简单用法，但是却完美展现了注解搭配反射可以碰撞出的巨大火花。熟悉掌握注解与反射后就有一定能力去学习那些大佬开发的框架的底层代码了。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://c.biancheng.net/java/java/135/">Java注解 (biancheng.net)</a></p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/package-summary.html">java.lang.annotation (Java Platform SE 8 ) (oracle.com)</a></p><p><a href="https://juejin.cn/post/6844903776088752141">理解注解中的@Inherited - 掘金 (juejin.cn)</a></p><p><a href="https://blog.csdn.net/qq_34576220/article/details/105731364">java元注解@Native &amp;&amp; @Repeatable （java8 新增）_似火似水的博客-CSDN博客_native注解</a></p><p><a href="%5D(https://blog.csdn.net/qq_34576220/article/details/105731364">反射</a></p><h1 id="END"><a href="#END" class="headerlink" title="-END-"></a>-END-</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Annotation&quot;&gt;&lt;a href=&quot;#Annotation&quot; class=&quot;headerlink&quot; title=&quot;Annotation&quot;&gt;&lt;/a&gt;Annotation&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="JavaSE" scheme="https://devildyw.github.io/categories/JavaSE/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API</title>
    <link href="https://devildyw.github.io/2022/04/06/RESTful%20API/"/>
    <id>https://devildyw.github.io/2022/04/06/RESTful%20API/</id>
    <published>2022-04-06T12:58:54.000Z</published>
    <updated>2022-04-16T08:52:43.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h1><p>正式学习RESTful API之前,我们需要把什么是API搞懂.</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/v2-1564b88f4461d69b90cd1ab50411f61b_b.jpg" alt="查看源图像"></h2><h2 id="什么是API"><a href="#什么是API" class="headerlink" title="什么是API?"></a>什么是API?</h2><p><strong>API（Application Programming Interface）</strong> 翻译过来是应用程序编程接口的意思。</p><p>相信大家对于API这个此已经不陌生了, 比如”我调用了某某的API”等 又比如我们在进行后端开发的时候，主要的工作就是为前端或者其他后端服务提供 API 比如查询用户数据的 API. </p><ul><li><p>API不仅仅代表了后端系统暴露出的接口, 像框架中提供的方法也属于是API的范畴.</p><p>例如: </p><ul><li>你写的程序需要由支付功能,需要微信支付,就需要去调用微信提供支付的相关API</li><li>使用JDK开发Java程序, 需要获取当前系统时间,需要使用JDK提供的Date相关的API</li><li>….</li></ul></li><li><p>API可以理解为程序与程序之间通信的桥梁, 其本质就是一个函数或者一个方法(函数和方法还是不同的)而已. 另外, API的使用也不是没有章法了, 它的相关规则或是使用协议由API的提供者制订.</p></li></ul><hr><h2 id="什么是RESTful-API"><a href="#什么是RESTful-API" class="headerlink" title="什么是RESTful API?"></a>什么是RESTful API?</h2><p><strong>RESTful API</strong> 经常也被叫做 <strong>REST API</strong>，它是基于 REST 构建的 API.</p><p>举个例子，如果我给你下面两个 API 你是不是立马能知道它们是干什么用的！这就是 RESTful API 的强大之处！</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">GET  /XXXX/classes: 查询列出所有班级</span><br><span class="line">POST  /XXXX/classes: 创建一个新的班级</span><br></pre></td></tr></table></figure><ul><li>由上述例子可以看出 RESTful API可以让人很清楚的知道每个API的目的与作用(前提是它有一定的基础 这个似乎不是什么问题).</li><li><strong>RESTful API</strong>可以让人看到URL+Http Method 就知道这个方法是干什么的, 让你看到HTTP状态码(status code)就知道请求结果如何</li></ul><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">http动作(请求方式) + url [动作+url合起来保证唯一性]</span><br></pre></td></tr></table></figure><p>我们在开发过程中设计API时也应当满足RESTful API的最基本要求(RESTful API 不是协议</p><p>规定, 但是提倡这样设计) <strong>接口中尽量使用名词</strong>, 例如<code>GET /notes/id</code>：获取某个指定 id 的笔记的信息）毕竟是使用Http Method(动词)操作的应当是名词才对.</p><h2 id="解读REST-了解内容"><a href="#解读REST-了解内容" class="headerlink" title="解读REST(了解内容)"></a>解读REST(了解内容)</h2><p><strong>REST</strong> 是 <code>REpresentational State Transfer</code> 的缩写。这个词组的翻译过来就是“<strong>表现层状态转化</strong>”。</p><p>实际上 REST 的全称是 <strong>Resource Representational State Transfer</strong> ，直白地翻译过来就是 <strong>“资源”在网络传输中以某种“表现形式”进行“状态转移”</strong> 。</p><ul><li><strong>资源(Resource):</strong> 任何东西都可以是资源, 图片,甚至是对象, 资源可以是一个集合,也可以是一个个体. 每一种资源都有特定的URL(统一资源标识符)与之对应, 如果我们需要访问这个资源只需要访问这个URI就可以访问.</li><li><strong>表现形式(Representational):</strong>“资源”是一个信息实体,它可以有多种外在表现形式.通常我们把资源具体呈现出来的形式有:<code>json</code>、<code>xml</code>、<code>image</code>、<code>txt</code>等等叫做它的**”表现形式”**。</li><li>**状态转移(State Transfer):**指的就是你的行为对于资源的操作(通过HTTP动词实现)引起资源的状态发生了变化.(ps:互联网通讯协议HTTP协议，是一个无状态协议，所有的资源状态都保存在服务器端.)</li></ul><p>综合总结:</p><blockquote><ul><li>每一个URI代表一种资源；</li><li>客户端与服务器之间,传递这种资源的某种表现形式比如<code>json</code>、<code>xml</code>、 <code>txt</code>、 <code>image</code>等；</li><li>客户端通过特定的HTTP动词，对服务器资源进行操作，实现”表现层状态转化”。</li></ul></blockquote><h2 id="RESTful-API-规范"><a href="#RESTful-API-规范" class="headerlink" title="RESTful API 规范"></a>RESTful API 规范</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6db537c4f5274fc098ed9bf710b41cc4~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.awebp" alt="RESTful API 设计规范"></p><p><strong>动作：</strong></p><blockquote><ul><li><strong><code>GET</code>：</strong>请求从服务器获取特定资源。举个例子：<code>GET /classes</code>（获取所有班级）</li><li><strong><code>POST</code> ：</strong>在服务器上创建一个新的资源。举个例子：<code>POST /classes</code>（创建班级）</li><li><strong><code>PUT</code> ：</strong>更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：<code>PUT /classes/12</code>（更新编号为 12 的班级）</li><li><strong><code>DELETE</code> ：</strong>从服务器删除特定的资源。举个例子：<code>DELETE /classes/12</code>（删除编号为 12 的班级）</li><li><code>PATCH</code> ：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，这里就不举例子了。</li></ul></blockquote><p><strong>路劲(接口命名)：</strong></p><p>路劲又称”终点”(endpoint), 表示API的具体网址。实际开发中的常见规范如下：</p><blockquote><ul><li><strong>网址中不能出现动词，只能都是名词，API中的名词也应该使用复数。</strong> 因为REST中的资源往往和数据库中的表相对应，而数据库中的表都是同种记录的”集合”（collection）。<strong>如果API调用并不涉及资源（如登录、运算等操作）可以使用动词。</strong>比如：**<code>GET /sign-login</code>**</li><li><strong>不用大写，建议用中杠<code>-</code>而不用下划线<code>_</code></strong> 。比如：**<code>GET /signLogin</code>**</li><li><strong>善用版本化API。</strong>当我们的API发生了重大改变而不兼容前期版本的时候，我们可以通过URL来实现版本化，比如**<code>/github.com/kataras/iris/v12</code>**。版本不必非要数字，只是数字使用最多，日期、季节都可以作为版本的标识符，项目团队达成共识即可。</li><li><strong>接口尽量使用名词，避免使用名词。</strong>RESTful API操作(HTTP Method)的是资源（名词）而不是动作（动词）。</li></ul></blockquote><p>现在有这样的一个API提供班级大学班级（class）的信息，还包括学生、老师的信息，则应该设计呈现吗这样。</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">GET    /classes：列出所有班级</span><br><span class="line">POST   /classes：新建一个班级</span><br><span class="line">GET   /classes/&#123;classId&#125;:获取某个指定班级的信息</span><br><span class="line">PUT   /classes/&#123;classId&#125;:更新某个指定班级的信息(一般倾向于整体更新)</span><br><span class="line">PATCH  /classes/&#123;classId&#125;：更新某个指定班级的信息（一般倾向部分更新）</span><br><span class="line">GET    /classes/&#123;classId&#125;/teachers：列出某个指定班级的所有老师的信息</span><br><span class="line">GET    /classes/&#123;classId&#125;/students：列出某个指定班级的所有学生的信息</span><br><span class="line">DELETE /classes/&#123;classId&#125;/teachers/&#123;ID&#125;：删除某个指定班级下的指定的老师的信息</span><br></pre></td></tr></table></figure><p><strong>反例:</strong></p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">/getAllclasses</span><br><span class="line">/createNewclass</span><br><span class="line">/deleteAllActiveclasses</span><br></pre></td></tr></table></figure><p>清理资源的层次结构,比如业务针对的范围是学校,那么学校会是一级资源:<code>/schools</code>、老师：<code>/shcools/teachers</code>、学生：<code>/shcools/students</code>就是二级资源。</p><h3 id="信息过滤"><a href="#信息过滤" class="headerlink" title="信息过滤"></a>信息过滤</h3><p>如果我们在查询的时候需要添加特定的条件的话，建议使用url中添加参数的形式。比如我们要查询state状态位active并且name为guideege的班级：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">GET/classes?state=active<span class="built_in">&amp;</span>name=guigege</span><br></pre></td></tr></table></figure><p>如果要实现分页查询：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">GET/classes?page=1<span class="built_in">&amp;</span>size=10 //指定第几页，每页十条数据</span><br></pre></td></tr></table></figure><h3 id="状态码（Status-Codes）"><a href="#状态码（Status-Codes）" class="headerlink" title="状态码（Status Codes）"></a>状态码（Status Codes）</h3><p><strong>状态码范围：</strong></p><table><thead><tr><th>2xx：成功</th><th>3xx：重定向</th><th>4xx：客户端错误</th><th>5xx：服务器错误</th><th></th><th align="right"></th></tr></thead><tbody><tr><td>200 成功</td><td>301 永久重定向</td><td>400 错误请求</td><td>500 服务器错误</td><td></td><td align="right"></td></tr><tr><td>201 创建</td><td>304 资源未修改</td><td>401 未授权</td><td>502 网关错误</td><td></td><td align="right"></td></tr><tr><td></td><td></td><td>403 禁止访问</td><td>504 网关超时</td><td></td><td align="right"></td></tr><tr><td></td><td></td><td>404 未找到</td><td></td><td></td><td align="right"></td></tr><tr><td></td><td></td><td>405 请求方法不对</td><td></td><td></td><td align="right"></td></tr></tbody></table><h2 id="RESTful-的极致-HATEOAS"><a href="#RESTful-的极致-HATEOAS" class="headerlink" title="RESTful 的极致 HATEOAS"></a>RESTful 的极致 HATEOAS</h2><blockquote><p>RESTful的极致是hateoas，但是这个基本不会在实际项目中用到。</p></blockquote><p>在 Spring 中有一个叫做 HATEOAS 的 API 库，通过它我们可以更轻松的创建出符合 HATEOAS 设计的 API。相关文章(可以参考)：</p><ul><li><a href="https://blog.aisensiy.me/2017/06/04/spring-boot-and-hateoas/">在 Spring Boot 中使用 HATEOASopen in new window</a></li><li><a href="https://spring.io/guides/tutorials/rest/">Building REST services with Springopen in new window</a> (Spring 官网 )</li><li><a href="https://www.baeldung.com/spring-hateoas-tutorial">An Intro to Spring HATEOASopen in new window</a></li><li><a href="https://github.com/spring-projects/spring-hateoas-examples/tree/master/hypermedia">spring-hateoas-examplesopen in new window</a></li><li><a href="https://spring.io/projects/spring-hateoas#learn">Spring HATEOASopen in new window</a> (Spring 官网)</li></ul><p>参考：</p><blockquote><p><a href="https://javaguide.cn/system-design/basis/RESTfulAPI.html#%E4%BD%95%E4%B8%BA-api">RestFul API | JavaGuide</a></p></blockquote><h1 id="END"><a href="#END" class="headerlink" title="-END-"></a>-END-</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RESTful-API&quot;&gt;&lt;a href=&quot;#RESTful-API&quot; class=&quot;headerlink&quot; title=&quot;RESTful API&quot;&gt;&lt;/a&gt;RESTful API&lt;/h1&gt;&lt;p&gt;正式学习RESTful API之前,我们需要把什么是API搞懂.&lt;/</summary>
      
    
    
    
    <category term="开发规范" scheme="https://devildyw.github.io/categories/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="Developer" scheme="https://devildyw.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>雪花算法</title>
    <link href="https://devildyw.github.io/2022/04/04/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/"/>
    <id>https://devildyw.github.io/2022/04/04/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-04T09:34:54.000Z</published>
    <updated>2022-04-06T13:52:37.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h1><p><strong>简介:</strong></p><ul><li>雪花算法是Twitter开源的分布式ID生成算法 <a href="https://github.com/twitter-archive/snowflake.git">Github仓库地址</a></li><li>雪花算法主要用于分布式系统中,数据库的ID生成</li><li>在自然界中并不存在两片完全一样的雪花,每一片雪花都拥有自己漂亮独特的形状,独一无二.雪花算法也表示生成的分布式id如雪花般独一无二.</li></ul><span id="more"></span><h2 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h2><p>随着业务被使用的人越来越多, 单机的数据库已经很难保证业务能够流畅稳定的运行了, 这是我们需要对数据库进行分库分表存储, 使用分布式集群, 但是这样每个表的数据怎么保证ID唯一呢? 如果使用主键递增肯定发生ID不唯一的冲突情况, 所以急需一种可以生成全局唯一ID的算法来解决这个囧境.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/v2-6d694779c7d47e3573939f21993318df_720w.jpg" alt="img"></p><hr><h3 id="分布式ID需要满足的要求"><a href="#分布式ID需要满足的要求" class="headerlink" title="分布式ID需要满足的要求"></a><strong>分布式ID需要满足的要求</strong></h3><h4 id="全局唯一"><a href="#全局唯一" class="headerlink" title="全局唯一:"></a>全局唯一:</h4><ul><li>这是最基本的要求</li></ul><h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能:"></a>高性能:</h4><ul><li>不能为了全局唯一就去生成一大长串,肯定需要考虑性能,既要考虑生成的效率,又要考虑查询的效率(即存储的效率).</li></ul><h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用:"></a>高可用:</h4><ul><li>生成分布式ID的服务要保证可用性高,无限接近100%</li></ul><h4 id="方便易用"><a href="#方便易用" class="headerlink" title="方便易用:"></a>方便易用:</h4><ul><li>拿来即用，使用方便，快速接入！</li></ul><hr><h4 id="安全"><a href="#安全" class="headerlink" title="安全:"></a>安全:</h4><ul><li>分布式ID中不应含有敏感信息,否则了解算法的不怀好意之人解码可能会获取到这些敏感信息.</li></ul><h4 id="有序递增"><a href="#有序递增" class="headerlink" title="有序递增:"></a>有序递增:</h4><ul><li>如果要把 ID 存放在数据库的话，<strong>ID 的有序性可以提升数据库写入速度</strong>。并且，很多时候 ，我们还很有可能会直接通过 ID 来进行排序。</li></ul><h4 id="要求具体的业务含义"><a href="#要求具体的业务含义" class="headerlink" title="要求具体的业务含义:"></a>要求具体的业务含义:</h4><ul><li>生成的ID如果能有具体的业务含义,可以让定位问题以及开发更透明化(例如根据ID就能确定是哪个业务)</li></ul><h4 id="独立部署"><a href="#独立部署" class="headerlink" title="独立部署:"></a>独立部署:</h4><ul><li>也就是分布式系统单独有一个发号器服务，专门用来生成分布式 ID。这样就生成 ID 的服务可以和业务相关的服务解耦。不过，这样同样带来了网络调用消耗增加的问题。总的来说，如果需要用到分布式 ID 的场景比较多的话，独立部署的发号器服务还是很有必要的。(企业级的大型项目中十分有必要)</li></ul><hr><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>雪花算法生成的ID是一个<strong>64bit</strong>的<strong>long</strong>型的数字且<strong>按时间趋势递增</strong>.大致有首位符号位(无效位), 时间戳插值, 机器编码, 序列号四部分组成.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/22531124-e47b04a4e5b26623.png" alt="img"></p><p>如图: </p><ul><li><strong>首位无效符:</strong> 主要用做为符号位,因为一般都是生成正数,所以符号位统一都是0</li><li>**时间戳:**占用41bit,精确到毫秒. 41bit位最好可以表示2^41-1毫秒, 转化成单位年为69年.</li><li><strong>机器编码:</strong> 占用10bit,其中高位5bit是数据中心ID,低位5bit是工作节点ID,最多可以容纳1024个节点.</li><li>**序列号:**占用12bit,每个节点每毫秒0开始不断累加,最多可以累加到2^12-1,一共可以生成4096个ID(包括了0)</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a><strong>Java代码实现</strong></h3><p><code>snowFlake</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dyw.snowFlake;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-04-04 14:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDWorker</span> &#123;</span><br><span class="line">    <span class="comment">//十位的工作机器码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> workerId; <span class="comment">//工作id 五位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> datacenterId; <span class="comment">//数据中心id 五位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//12位序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">sequence</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">twEpoch</span> <span class="operator">=</span> <span class="number">1288834974657L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//长度为5位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">workerIdBits</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">datacenterIdBits</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line">    <span class="comment">//最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">maxWorkerId</span> <span class="operator">=</span> ~(-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">maxDatacenterId</span> <span class="operator">=</span> ~(-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列号id长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">sequenceBits</span> <span class="operator">=</span> <span class="number">12L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">sequenceMask</span> <span class="operator">=</span> ~(-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//工作id需要左移的位数, 12位(序列号的位长)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">workerIdShift</span> <span class="operator">=</span> sequenceBits;</span><br><span class="line">    <span class="comment">//数据中心id需要左移的位数 序列号长+工作id长</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">datacenterIdShift</span> <span class="operator">=</span> sequenceBits + workerIdBits;</span><br><span class="line">    <span class="comment">//时间戳左移位数 = 序列号长+工作id长+工作位长</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">timestampLeftShift</span> <span class="operator">=</span> sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上次时间戳, 初始值位负值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastTimestamp</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workerId 工作节点id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> datacenterId 数据中心id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IDWorker</span><span class="params">(<span class="type">long</span> workerId, <span class="type">long</span> datacenterId)</span> &#123;</span><br><span class="line">        <span class="comment">//检查参数的合法性</span></span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;</span>,</span><br><span class="line">                timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId);</span><br><span class="line">        <span class="built_in">this</span>.workerId = workerId;</span><br><span class="line">        <span class="built_in">this</span>.datacenterId = datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getWorkerId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> workerId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDatacenterId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getSequence</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * //下一个ID生成算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> snowflakeId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//先获取当前系统时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> timeGen();</span><br><span class="line">        <span class="comment">//如果当前系统时间比上次获取id时间戳小就抛出异常 时钟往后移动可能会出现同样id所以这里必须抛异常结束执行</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            System.err.printf(<span class="string">&quot;clock is moving backwards.  Rejecting requests until %d.&quot;</span>,lastTimestamp);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(String.format(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>,</span><br><span class="line">                    lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前时间戳如果等于上次时间戳(同一毫秒内),则在序列号加一,否则序列号赋值为0, 从零开始</span></span><br><span class="line">        <span class="keyword">if</span>(timestamp==lastTimestamp)&#123;</span><br><span class="line">            <span class="comment">//这是使用&amp;sequenceMask是为了防止sequence溢出12位(前面要求了sequence的长度只能是12位)</span></span><br><span class="line">            sequence = (sequence+<span class="number">1</span>)&amp;sequenceMask;</span><br><span class="line">            <span class="comment">//如果防止刚好移除经过&amp;sequenceMask后 会变成0 可能会发生重复的情况</span></span><br><span class="line">            <span class="comment">//所以此时需要再次获取时间戳,并于上次时间戳作比较 直到与上次时间戳不一致返回当前时间戳避免重复</span></span><br><span class="line">            <span class="keyword">if</span>(sequence==<span class="number">0</span>)&#123;</span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//如果不在同一个时间戳中 代表该序列刚开始计数所以初始为0</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sequence = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将上次时间戳值更新</span></span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 返回结果：</span></span><br><span class="line"><span class="comment">         * (timestamp - TwEpoch) &lt;&lt; timestampLeftShift) 表示将时间戳减去初始时间戳，再左移相应位数</span></span><br><span class="line"><span class="comment">         * (datacenterId &lt;&lt; datacenterIdShift) 表示将数据id左移相应位数</span></span><br><span class="line"><span class="comment">         * (workerId &lt;&lt; workerIdShift) 表示将工作id左移相应位数</span></span><br><span class="line"><span class="comment">         * | 是按位或运算符，例如：x | y，只有当x，y都为0的时候结果才为0，其它情况结果都为1。</span></span><br><span class="line"><span class="comment">         * 因为个部分只有相应位上的值有意义，其它位上都是0，所以将各部分的值进行 | 运算就能得到最终拼接好的id</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - twEpoch)&lt;&lt;timestampLeftShift) |</span><br><span class="line">                (datacenterId&lt;&lt;datacenterIdShift) |</span><br><span class="line">                (workerId&lt;&lt;workerIdShift)|</span><br><span class="line">                sequence;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取时间戳,并于上次时间戳作比较</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastTimestamp 上一次获取的时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> timestamp 更新后的系统时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">tilNextMillis</span><span class="params">(<span class="type">long</span> lastTimestamp)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> timeGen();</span><br><span class="line">        <span class="keyword">while</span>(timestamp&lt;=lastTimestamp)&#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取系统时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 系统时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">timeGen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Go语言实现"><a href="#Go语言实现" class="headerlink" title="Go语言实现"></a><strong>Go语言实现</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> al</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutex = sync.Mutex&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">//初始时间戳</span></span><br><span class="line">twEpoch <span class="type">int64</span> = <span class="number">1288834974657</span></span><br><span class="line"><span class="comment">//长度为5位</span></span><br><span class="line">workerIdBits     <span class="type">int64</span> = <span class="number">5</span></span><br><span class="line">datacenterIdBits <span class="type">int64</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最大值</span></span><br><span class="line">maxWorkerId     <span class="type">int64</span> = <span class="number">-1</span> ^ (<span class="number">-1</span> &lt;&lt; workerIdBits)</span><br><span class="line">maxDatacenterId <span class="type">int64</span> = <span class="number">-1</span> ^ (<span class="number">-1</span> &lt;&lt; datacenterIdBits)</span><br><span class="line"></span><br><span class="line"><span class="comment">//序列号id长度</span></span><br><span class="line">sequenceBits <span class="type">int64</span> = <span class="number">12</span></span><br><span class="line">sequenceMask       = <span class="number">-1</span> ^ (<span class="number">-1</span> &lt;&lt; sequenceBits)</span><br><span class="line"></span><br><span class="line"><span class="comment">//工作id需要左移的位数, 12位(序列号的位长)</span></span><br><span class="line">workerIdShift = sequenceBits</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据中心id需要左移的位数 序列号长+工作id长</span></span><br><span class="line">datacenterIdShift = sequenceBits + workerIdBits</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间戳左移位数 = 序列号长+工作id长+工作位长</span></span><br><span class="line">timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//上次时间戳, 初始值位负值</span></span><br><span class="line"><span class="keyword">var</span> lastTimestamp <span class="type">int64</span> = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IDWorker <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//十位的工作机器码</span></span><br><span class="line">workerId     <span class="type">int64</span> <span class="comment">//工作id 五位</span></span><br><span class="line">datacenterId <span class="type">int64</span> <span class="comment">//数据中心id 五位</span></span><br><span class="line"><span class="comment">//12位序列号</span></span><br><span class="line">sequence <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitIDWorker</span><span class="params">(workerId, datacenterId <span class="type">int64</span>)</span></span> (*IDWorker, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">//检查参数合法性</span></span><br><span class="line"><span class="keyword">if</span> workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">var</span> err = errors.New(fmt.Sprintf(<span class="string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">var</span> err = errors.New(fmt.Sprintf(<span class="string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;</span>,</span><br><span class="line">timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId)</span><br><span class="line"><span class="keyword">return</span> &amp;IDWorker&#123;</span><br><span class="line">datacenterId: datacenterId,</span><br><span class="line">workerId:     workerId,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">下一个ID生成算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *IDWorker)</span></span> NextId() (id <span class="type">int64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">//上锁</span></span><br><span class="line">mutex.Lock()</span><br><span class="line"><span class="comment">//程序结束 释放锁</span></span><br><span class="line"><span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line"><span class="comment">//先获取当前系统时间</span></span><br><span class="line"><span class="keyword">var</span> timestamp = timeGen()</span><br><span class="line"><span class="comment">//如果当前系统时间比上次获取id时间戳小就抛出异常 时钟往后移动可能会出现同样id所以这里必须抛异常结束执行</span></span><br><span class="line"><span class="keyword">if</span> timestamp &lt; lastTimestamp &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;clock is moving backwards.  Rejecting requests until %d.&quot;</span>, lastTimestamp)</span><br><span class="line">err = errors.New(fmt.Sprintf(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>,</span><br><span class="line">lastTimestamp-timestamp))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取当前时间戳如果等于上次时间戳(同一毫秒内),则在序列号加一,否则序列号赋值为0, 从零开始</span></span><br><span class="line"><span class="keyword">if</span> timestamp == lastTimestamp &#123;</span><br><span class="line"><span class="comment">//这是使用&amp;sequenceMask是为了防止sequence溢出12位(前面要求了sequence的长度只能是12位)</span></span><br><span class="line">i.sequence = (i.sequence + <span class="number">1</span>) &amp; sequenceMask</span><br><span class="line"><span class="comment">//如果防止刚好移除经过&amp;sequenceMask后 会变成0 可能会发生重复的情况</span></span><br><span class="line"><span class="comment">//所以此时需要再次获取时间戳,并于上次时间戳作比较 直到与上次时间戳不一致返回当前时间戳避免重复</span></span><br><span class="line"><span class="keyword">if</span> i.sequence == <span class="number">0</span> &#123;</span><br><span class="line">timestamp = tilNextMillis(lastTimestamp)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果不在同一个时间戳中 代表该序列刚开始计数所以初始为0</span></span><br><span class="line">i.sequence = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将上次时间戳值更新</span></span><br><span class="line">lastTimestamp = timestamp</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回雪花算法生成的id</span></span><br><span class="line">id = ((timestamp - twEpoch) &lt;&lt; timestampLeftShift) |</span><br><span class="line">(i.datacenterId &lt;&lt; datacenterIdShift) |</span><br><span class="line">(i.workerId &lt;&lt; workerIdShift) |</span><br><span class="line">i.sequence</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i IDWorker)</span></span> WorkerId() <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i.workerId</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i IDWorker)</span></span> DatacenterId() <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i.datacenterId</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i IDWorker)</span></span> Sequence() <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i.sequence</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取系统时间戳</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeGen</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> time.Now().UnixMilli()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取时间戳,并于上次时间戳作比较</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tilNextMillis</span><span class="params">(lastTimestamp <span class="type">int64</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">var</span> timestamp = timeGen()</span><br><span class="line"><span class="keyword">for</span> timestamp &lt;= lastTimestamp &#123;</span><br><span class="line">timestamp = timeGen()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> timestamp</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;雪花算法&quot;&gt;&lt;a href=&quot;#雪花算法&quot; class=&quot;headerlink&quot; title=&quot;雪花算法&quot;&gt;&lt;/a&gt;雪花算法&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;简介:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;雪花算法是Twitter开源的分布式ID生成算法 &lt;a href=&quot;https://github.com/twitter-archive/snowflake.git&quot;&gt;Github仓库地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;雪花算法主要用于分布式系统中,数据库的ID生成&lt;/li&gt;
&lt;li&gt;在自然界中并不存在两片完全一样的雪花,每一片雪花都拥有自己漂亮独特的形状,独一无二.雪花算法也表示生成的分布式id如雪花般独一无二.&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://devildyw.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="算法" scheme="https://devildyw.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://devildyw.github.io/2022/03/28/Redis/"/>
    <id>https://devildyw.github.io/2022/03/28/Redis/</id>
    <published>2022-03-28T12:58:54.000Z</published>
    <updated>2022-04-09T09:49:02.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><a href="https://www.bilibili.com/video/BV1cr4y1671t?p=63&spm_id_from=pageDriver">Redis</a></h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p><strong>Redis是一种NOSQL型数据库,即一种非关系型数据库</strong></p><p>我们常见的Mysql是一种SQL型数据库,是一种关系型数据库</p><span id="more"></span><h3 id="SQL型数据库"><a href="#SQL型数据库" class="headerlink" title="SQL型数据库"></a><strong>SQL型数据库</strong></h3><h4 id="结构化-Structured"><a href="#结构化-Structured" class="headerlink" title="结构化 Structured"></a>结构化 <strong>Structured</strong></h4><ul><li>下面这张图,我们创建这张表之初就对表的字段做了指定与规定,比如下面这张表只有三个字段,每个字段我们都加上了不同的约束,并且规定了字段的类型和长度,就使得这张表具有很强的结构体系,后续插入修改的数据都必须遵守表的结构</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307174510020.png" alt="image-20220307174510020"></p><h4 id="关联的-Relational"><a href="#关联的-Relational" class="headerlink" title="关联的(Relational)"></a>关联的(Relational)</h4><ul><li><p>比如一个表中的某个字段被其他表中的字段所关联(外键) 这样表中的数据就会自动维护,当删除某个字段时,就会提示无法删除的情况,除此之外,关联的优点还有可以节省存储空间,不需要记录数据的全部信息,只需要记录一个数据的主键即可.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307175758165.png" alt="image-20220307175758165"></p><h4 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h4><ul><li><p>优点:语法固定</p></li><li><p>缺点:需要去学习大量的语法 </p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307180551365.png" alt="image-20220307180551365"></p></li></ul><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><ul><li><strong>满足ACID(原子性, 一致性, 隔离性, 持久性) 对关系性要求较高的业务采用SQL</strong></li></ul><h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><ul><li><strong>磁盘</strong></li></ul><h4 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h4><ul><li><strong>垂直</strong>(即一主多从 数据存储的大小没有改变 只是增强了数据的存储效率(读写分离))</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>数据结构稳定</li><li>相关业务对数据安全性,一致性较高.(ACID)</li></ul><hr></li></ul><h3 id="NOSQL"><a href="#NOSQL" class="headerlink" title="NOSQL"></a><strong>NOSQL</strong></h3><h4 id="非结构化"><a href="#非结构化" class="headerlink" title="非结构化"></a>非结构化</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307174959275.png" alt="image-20220307174959275"></p><ul><li>NoSQL有三种数据存储格式 分别为<strong>key-value型, Document型, 还有Graph型</strong> 没有SQL那种有很强的结构性 比如<strong>key-value型的存储格式中</strong> 不需要指定数据的类型, 只要是NoSQL支持的数据格式 都可以填入. 对于<strong>Document型中 数据的字段数量也可以不同可以任意增添数据字段</strong> 不需要上一条数据有四个字段 这次就可以只有三种</li></ul><h4 id="无关系的"><a href="#无关系的" class="headerlink" title="无关系的"></a>无关系的</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307175732140.png" alt="image-20220307175732140"></p><ul><li>一般通过json(Document)的形式存储,缺点就是这种的数据格式不能自己维护,需要程序员自己通过业务逻辑维护 ,并且可能会出现数据的冗余,比如同一个商品多个用户下单,多个用户的信息的存储中都有相同的订单数据,这需要程序员自己根据不同的业务逻辑来维护.</li></ul><h4 id="非SQL"><a href="#非SQL" class="headerlink" title="非SQL"></a>非SQL</h4><ul><li><p>优点: 不需要去学习大量的语法</p></li><li><p>缺点: 不同的NoSQL语句的格式用法可能不同</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307180601578.png" alt="image-20220307180601578"></p><h4 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h4><ul><li><strong>BASE(基本一致或者无事务 无法完全满足ACID) 业务对安全性要求较低的可以采用NoSQL</strong></li></ul><h4 id="存储方式-1"><a href="#存储方式-1" class="headerlink" title="存储方式"></a>存储方式</h4><ul><li><strong>内存</strong></li></ul><h4 id="扩展性-1"><a href="#扩展性-1" class="headerlink" title="扩展性"></a>扩展性</h4><ul><li><strong>水平</strong>(即多主多从 数据存储的大小增加 也增强了数据的存储效率(读写分离))</li></ul><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>数据结构不稳定</li><li>对一致性,安全性要求不高</li><li>对性能要求高</li></ul><hr><h2 id="认识Redis"><a href="#认识Redis" class="headerlink" title="认识Redis"></a><strong>认识Redis</strong></h2><p>Redis诞生与2009年全程时<strong>Remote Dictionary Server(远程词典服务器)</strong>,是一个基于内存的键值型NoSQL数据库.</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a><strong>特征</strong></h3></li><li><p>键值型(key-value)型, value支持多种不同的数据类型,功能丰富</p></li><li><p>单线程,每个命令具有原子性</p></li><li><p>低延迟,速度快(<strong>基于内存</strong>,IO多路复用,良好的编码)</p></li><li><p>支持数据持久化(持久化到磁盘)</p></li><li><p>支持主从集群,分片集群(将数据分部分存储到多个master中 增加数据存储的上限)</p></li><li><p>支持多语言客户端</p></li></ul><hr><h2 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a><strong>Redis常见命令</strong></h2><h3 id="Redis数据结构介绍"><a href="#Redis数据结构介绍" class="headerlink" title="Redis数据结构介绍"></a><strong>Redis数据结构介绍</strong></h3><p>Redis是一个key-value的数据库,key一般是String类型,不过value的类型多种多样</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307191247016.png" alt="image-20220307191247016"></p><p>基本类型: String, Hash, List, Set. SortedSet</p><p>特殊类型: GEO(主要用于存储地理位置信息), BitMap, HyperLog(用来做基数统计的算法), Stream(主要用于消息队列)</p><h3 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a><a href="http://www.redis.cn/commands.html"><strong>Redis通用命令</strong></a></h3><p>通用指令是部分数据类型的,都可以使用的指令,常见的有 用法详情可以官网查看:</p><ul><li><strong>keys</strong>:查看符合模板的所有key,不建议在生产设备上使用(因为Redis是单线程的 使用keys *命令查看会占用很大资源 导致线程堵塞)</li><li>DEL: 删除可以删除一个或多个key (del key1 key2)</li><li>EXISTS: 判断key是否存在</li><li>EXPIRE: 给一个key设置有效期,有效期到时该key会被自动删除</li><li>TTL: 查看一个key剩余有效期</li></ul><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a><strong>String类型</strong></h3><p>String类型,也就是字符串类型,是Redis中最简单的存储类型.</p><p>其value是字符串,不过根据字符串的格式不同,又可以分为3类</p><ul><li>String:普通字符串</li><li>int: 整数类型,可以做自增,自减操作</li><li>float: 浮点类型,可以做自增,自减操作</li></ul><p>不管是哪种格式,底层都是字节数组形式存储,只不过是编码方式不同,字符串类型的最大的空间不能超过512m(可以存储图片 只需要将图片转为字节数组的格式存储 但这样会耗很大空间 一般不这样用)</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220308233257985.png" alt="img">&#x2F;image-20220308233257985.png</p><h4 id="String类型的常见指令"><a href="#String类型的常见指令" class="headerlink" title="String类型的常见指令"></a>String类型的常见指令</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220308233444257.png" alt="image-20220308233444257"></p><p><strong>SETEX</strong>用法比较特殊: <strong><code>set name jack ex 20(存活时间 单位秒)</code></strong></p><h3 id="key的结构"><a href="#key的结构" class="headerlink" title="key的结构"></a><strong>key的结构</strong></h3><p>Redis的key允许有多个单词形成<strong>层级结构</strong>,多个单词之间用**<code>&#39;:&#39;</code>**隔开,格式如下:</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220308235659340.png" alt="image-20220308235659340"></p><p>这个格式并非固定,也可以根据自己的需求来删除或添加词条</p><p>例如 一个项目下有user和product两种不同类型的数据,我们可以这样定义key:</p><ul><li>user相关的key: project:user:1</li><li>product相关的key: project:producet:1</li></ul><p>这样的格式实际上是以层级结构的形式存储的**(主要是为了区分不同项目中相同的数据 用户的id可以为1 商品的id也可以为1)**</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309000908161.png" alt="image-20220309000908161"></p><p>如果value是一个java对象,例如要给User对象,则可以将对象序列化为JSON字符串后存储</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220308235948333.png" alt="image-20220308235948333"></p><p>​                    <strong><code>set project:user:1 &#39;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;ding&quot;&#125;&#39;</code></strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309000302102.png" alt="image-20220309000302102"></p><hr><h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a><strong>Hash类型</strong></h3><p>Hash类型,也叫散列,其value是一个无序字典,类似于java中的HashMap结构.</p><p>String结构是将对象序列化为JSON字符串后存储,当需要修改对象某个字段时很不方便:</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309191057489.png" alt="image-20220309191057489"></p><p>Hash结构可以将对象中的每个字段独立存储,可以针对单个字段做CRUD: 相对于String类型较为灵活</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309191148786.png" alt="image-20220309191148786"></p><h4 id="Hash类型的常见命令"><a href="#Hash类型的常见命令" class="headerlink" title="Hash类型的常见命令:"></a>Hash类型的常见命令:</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309191557981.png" alt="image-20220309191557981"></p><hr><h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a><strong>List类型</strong></h3><p>Redis中的List类型于Java中的LinkedList类似,可以看作是一个双向链表结构.既可以支持正向检索也可以支持反向检索.</p><p>特征也与LinkedList类似</p><ul><li><strong>有序</strong></li><li><strong>元素可以重复</strong></li><li><strong>插入和删除块</strong></li><li><strong>查询速度一般</strong></li></ul><p>常用来存储一个有序数据,例如:朋友圈点赞列表,批量列表等.</p><h4 id="List的常见命令"><a href="#List的常见命令" class="headerlink" title="List的常见命令"></a>List的常见命令</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309194126739.png" alt="image-20220309194126739"></p><hr><h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a><strong>Set类型</strong></h3><p>Redis的Set结构与Java的中HashSet类似,可以看做是一个value为null的HashMap.因为也是一个Hash表,因此具备与HashSet类似的特征</p><ul><li><strong>无序</strong></li><li><strong>元素不可重复</strong></li><li><strong>查找块</strong></li><li><strong>支持交集 并集 差集等功能</strong></li></ul><h4 id="Set类型的常见命令"><a href="#Set类型的常见命令" class="headerlink" title="Set类型的常见命令"></a><strong>Set类型的常见命令</strong></h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309195325392.png" alt="image-20220309195325392"></p><hr><h3 id="SortedSet类型-有序集合"><a href="#SortedSet类型-有序集合" class="headerlink" title="SortedSet类型(有序集合)"></a><strong>SortedSet类型(有序集合)</strong></h3><p>Redis的SortedSet是一个可排序的set集合,与Java中的TreeSet有些类似,但底层数据结构却差别很大.SortedSet中的每一个元素都带有一个score属性,可以基于score属性对元素排序,底层的实现是一个跳表(SkipList)加hash表.SortedSet具备下列特性:</p><ul><li><strong>可排序</strong></li><li><strong>元素不重复</strong></li><li><strong>查询速度快</strong></li></ul><p>因为SortedSet的可排序特性,经常被用来实现排行榜这样的功能</p><h4 id="SortedSet类型的常见命令"><a href="#SortedSet类型的常见命令" class="headerlink" title="SortedSet类型的常见命令"></a>SortedSet类型的常见命令</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309201610780.png" alt="image-20220309201610780"></p><h2 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a><strong>Redis的Java客户端</strong></h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309203536114.png" alt="image-20220309203536114"></p><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a><strong>Jedis</strong></h3><ul><li><p><strong>创建Maven工程</strong></p></li><li><p><strong>引入Jedis依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>建立连接</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@BeforeEach</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//建立连接</span></span><br><span class="line">       jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;81.68.186.20&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">       <span class="comment">//设置密码</span></span><br><span class="line">       jedis.auth(<span class="string">&quot;ffdd2021@&quot;</span>);</span><br><span class="line">       <span class="comment">//选择库</span></span><br><span class="line">       jedis.select(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>存取数据</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//存入数据</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;12&quot;</span>);</span><br><span class="line">       System.out.println(name);</span><br><span class="line">       <span class="comment">//获取数据</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">       System.out.println(name1);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//插入hash数据</span></span><br><span class="line">       <span class="type">long</span> <span class="variable">name</span> <span class="operator">=</span> jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">       System.out.println(name);</span><br><span class="line">       <span class="comment">//取出</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> jedis.hget(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">       System.out.println(name1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>关闭连接</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//关闭连接</span></span><br><span class="line">       <span class="keyword">if</span>(jedis!=<span class="literal">null</span>)&#123;</span><br><span class="line">           jedis.close();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>Jedis中数据的存储命令是与命令行一致的</strong></p><hr></li></ul></li></ul><h4 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h4><p>Jedis本身是线程不安全的,并且频繁的创建和销毁连接会有性能损耗,因此我们推荐大家使用Jedis连接池代替Jedis直连的方式.</p><p>类似SQL型的数据库连接池 不会直接关闭连接而是归还到连接池</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        <span class="comment">//连接总数</span></span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//最大连接数量</span></span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//最小连接数量</span></span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//最大等待时间</span></span><br><span class="line">        jedisPoolConfig.setMaxWait(Duration.ofMillis(<span class="number">10000</span>));</span><br><span class="line">        <span class="comment">//创建连接池对象</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jedisPoolConfig,<span class="string">&quot;81.68.186.20&quot;</span>,<span class="number">6379</span>,<span class="number">1000</span>,<span class="string">&quot;ffdd2021@&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个获取连接的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a><a href="https://spring.io/projects/spring-data-redis"><strong>SpringDataRedis</strong></a></h3><p>SpringData是Spring中数据操作的模板,包含对各种数据库的集成,其中对Redis的集成模板就叫做SpringDataRedis </p><ul><li><strong>提供了对不同Redis客户端的整合(Lettuce和Jedis)</strong></li><li><strong>提供了RedisTemplate统一API来操作Redis</strong></li><li><strong>支持Redis的发布订阅模型</strong></li><li><strong>支持Redis哨兵和Redis集群</strong></li><li><strong>支持基于Lettuce的响应式编程</strong></li><li><strong>支持JDK,JSON,字符串,Spring对象的数据序列化及反序列化</strong>(方便地将上述数据格式 转化为字节数组 更方便地去存储在Redis中)</li><li><strong>支持基于Redis的JDKCollection实现</strong></li></ul><p>SpringDataRedis中提供了RedisTemplate工具类,其中封装了各种对Redis的操作.并且将不同数据类型的操作API封装到了不同的类型中:</p><h4 id="RedisTemplate工具类"><a href="#RedisTemplate工具类" class="headerlink" title="RedisTemplate工具类"></a>RedisTemplate工具类</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309234553190.png" alt="image-20220309234553190"></p><h4 id="RedisTemplate使用"><a href="#RedisTemplate使用" class="headerlink" title="RedisTemplate使用"></a>RedisTemplate使用</h4><ul><li><p>导入依赖</p><ul><li><p>SpringDataRedis依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>连接池依赖(Jedis和Lettuce都是依赖于commons-pool2实现)</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置文件</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">81.68</span><span class="number">.186</span><span class="number">.20</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">ffdd2021@</span></span><br><span class="line">    <span class="comment"># 选择数据库 database: 1</span></span><br><span class="line">    <span class="comment"># pool SpringDataRedis默认使用的客户端是Lettuce 可以导入其他依赖来使用其他连接池</span></span><br><span class="line">    <span class="comment"># 必须要配置了连接池 连接池才能生效</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br></pre></td></tr></table></figure></li><li><p>注入RedisTemplate工具类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Redis01RedisTemplateApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;丁杨维&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310000959983.png" alt="image-20220310000959983"></p></li></ul><h4 id="SpringDataRedis的序列化方式"><a href="#SpringDataRedis的序列化方式" class="headerlink" title="SpringDataRedis的序列化方式"></a>SpringDataRedis的序列化方式</h4><p>RedisTemplate可以接收任意Object作为值写入Redis,只不过吸入人前会把Object序列化为字节形式,默认是采用的JDK序列化,得到的结果是这样的:(及使用RedisTemplate时没有指定泛型)</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220310185259667.png" alt="image-20220310185259667"></p><p><strong>缺点:</strong></p><ul><li><strong>可读性差</strong></li><li><strong>内存占用较大</strong></li></ul><hr><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h4><ul><li><p>如果key-value都是String类型 直接指定泛型为String即可 但如果value或者key为Object时就需要自己配置了.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310190944166.png" alt="image-20220310190944166"></p><p>Redis提供了设置key-value序列化方式的接口</p></li><li><p>首先导入Jackson的依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>最新版<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置类 <code>RedisConfig</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">//创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String,Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//创建JSON序列化工具  注意这里使用的时Jackson需要导入Jackson的相关依赖才行</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">genericJackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">//设置key的序列化</span></span><br><span class="line">        template.setKeySerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashKeySerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//设置value的序列化</span></span><br><span class="line">        template.setValueSerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实体类 <code>User</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Redis01RedisTemplateApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,Object&gt; redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;丁杨维&quot;</span>, <span class="number">19</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;user1&quot;</span>,user);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1=&quot;</span>+user1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310191828636.png" alt="image-20220310191828636"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310191838617.png" alt="image-20220310191838617"></p><p>通过配置使用了Jackson序列化对象对JSON字符串格式存储,在取出时也可以将JSON字符串反系列化为对象.</p><hr><h4 id="JSON序列化的问题"><a href="#JSON序列化的问题" class="headerlink" title="JSON序列化的问题"></a>JSON序列化的问题</h4><p>如上图 我们会发现使用JSON序列化存储value时,会默认带上全类名名称 这样会造成额外的内存开销. (<strong>为了在反序列化时知道对象的类型,JSON序列化器会将类的class类型写入json结果中,存入Redis.</strong> )而如果想使用JSON序列化器序列化对象,这一步又是必不可少的.</p><p><strong>解决方案:</strong></p><ul><li>为了节省内存空间, 我们并不会使用JSON序列化器来处理value, <strong>而是统一使用String序列化器</strong>, 要求只能存储String类型的Key和value. <strong>当需要存储Java对象时, 手动完成对象的序列化和反序列化</strong>.</li><li>Spring默认提供了一个StringRedisTemplate类,他的key和value的序列化方式默认就是String方式.省去了我们自定义RedisTemplate的过程.</li></ul><hr><h4 id="StringRedisTemplate类"><a href="#StringRedisTemplate类" class="headerlink" title="StringRedisTemplate类"></a>StringRedisTemplate类</h4><ul><li><p>Jackson的ObjectMapper提供了将Java对象序列化为Json字符串和反序列化为Java对象的API</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Redis01RedisTemplateApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTest</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;彭芳姐&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ObjectMapper提供了将对象转化为Json串的API</span></span><br><span class="line">        <span class="comment">//手动序列化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userString</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user2&quot;</span>,userString);</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动反序列化</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> mapper.readValue(userJson, User.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310194423995.png" alt="image-20220310194423995"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310194441788.png" alt="image-20220310194441788"></p><h3 id="RedisTemplate对Hash的操作"><a href="#RedisTemplate对Hash的操作" class="headerlink" title="RedisTemplate对Hash的操作"></a><strong>RedisTemplate对Hash的操作</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void doTest2()&#123;</span><br><span class="line">    stringRedisTemplate.opsForHash().put(&quot;key&quot;,&quot;hashKey&quot;,&quot;value&quot;);</span><br><span class="line">    stringRedisTemplate.opsForHash().put(&quot;key&quot;,&quot;hashKey1&quot;,&quot;value1&quot;);</span><br><span class="line"></span><br><span class="line">    Map&lt;Object, Object&gt; key = stringRedisTemplate.opsForHash().entries(&quot;key&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作习惯上更偏向于java的HashMap之类的.</p><p>stringRedisTemplate.opsForHash().entries(String key)会获得hash类型中的某个key的全部key-value信息.</p><p>剩余操作或其他类型操作可以参考官方文档.<a href="https://docs.spring.io/spring-data/redis/docs/current/api/">RedisAPI文档</a></p><hr><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a><strong>项目实战</strong></h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310200358089.png" alt="image-20220310200358089"></p><hr><h3 id="Session共享问题"><a href="#Session共享问题" class="headerlink" title="Session共享问题:"></a><strong>Session共享问题:</strong></h3><p>多台TomCat并不共享session存储空间,当请求切换到不同的tomcat服务时,导致数据丢失的问题</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310213458462.png" alt="image-20220310213458462"></p><p>session的代替方案应该满足:</p><ul><li><strong>数据共享</strong></li><li><strong>内存存储</strong></li><li><strong>key-value结构</strong></li></ul><p><strong>以上的要求Redis都满足, 可以使用Redis来代替Session存储,但也不是简单的存储.</strong></p><h3 id="基于Redis实现共享Session登陆"><a href="#基于Redis实现共享Session登陆" class="headerlink" title="基于Redis实现共享Session登陆"></a><strong>基于Redis实现共享Session登陆</strong></h3><p><strong>Redis要实现共享Session登陆, 需要满足key唯一性.</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310214224767.png" alt="image-20220310214224767"></p><ul><li>如果使用用户登陆存储一定的用户信息在Redis中时,一般使用token作为key,而value使用Hash类型.</li><li>学习Hash类型的时候我们学过 Hash类型的存储可以将对象的字段分别存储,可以针对单个字段进行crud,不需要每次改的是否传全部信息进行更改.</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309191148786.png" alt="image-20220309191148786"></p><p>使用token存储用户的非敏感信息,传到前端,前端利用浏览器的缓存存储</p><p><strong>注意</strong>:</p><ul><li>使用token存储到Redis时一定要设置过期时间,因为会耗费内存空间(如果存储的token太多 有没有及时清楚 可能会造成堆栈溢出)</li><li>使用 RedisTemplate.expire可以指定指定key-value的存活时间</li><li>在登陆拦截器中,验证了token后需要刷新token存活时间,及再执行一遍第二步.</li><li>常量等可以专门编写一个类来记录 <code>static final constant</code>防止自己写出错.</li><li>对于一些不需要登陆拦截的Controller当用户访问时,也是需要刷新token的,设置一个全局刷新的token的拦截器,将其优先级设置为最高,所有请求都由他拦截,后续的登录拦截只需要从,全局拦截器中的存储到ThreadLocal的用户信息取到验证即可.</li></ul></li></ul></li></ul><h3 id="全局请求拦截器"><a href="#全局请求拦截器" class="headerlink" title="全局请求拦截器"></a><strong>全局请求拦截器</strong></h3><p>作用:</p><ul><li>用于拦截所有请求,获取如果有token就获取token中的数据,并且刷新token,并且将数据存入ThreadLocal中,如果没有就直接放行.(后续可能会被登陆拦截器拦截 检查是否有用户信息, 如果没有就返回false)</li><li>全局请求拦截器的主要作用就是为了防止用户登陆后,访问一些不需要登陆拦截器的接口token无法刷新的情况.</li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><strong>缓存</strong></h2><p><strong>缓存</strong>就是数据交换的缓存区(称作Cache), 是存储数据的临时地方,一般读写性能较高</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311151533133.png" alt="image-20220311151533133"></p><h3 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h3><ul><li>降低后端负载</li><li>提高读写效率,降低响应时间.</li></ul><h3 id="缓存的成本"><a href="#缓存的成本" class="headerlink" title="缓存的成本"></a>缓存的成本</h3><ul><li>数据一致性成本</li><li>代码维护成本</li><li>运维成本</li></ul><h3 id="添加Redis缓存"><a href="#添加Redis缓存" class="headerlink" title="添加Redis缓存"></a>添加Redis缓存</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311152211102.png" alt="image-20220311152211102"></p><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311153346059.png" alt="image-20220311153346059"></p><p>对于经常修改的数据,可以采用主动更新策略,在修改数据库的同时,更新缓存,这样的数据一致性较好,相应的维护成本较高. 对于不经常修改的数据,采用默认策略即可.</p><h4 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h4><h5 id="Cache-Aside-Pattern-常用"><a href="#Cache-Aside-Pattern-常用" class="headerlink" title="Cache Aside Pattern*(常用)"></a>Cache Aside Pattern*(常用)</h5><ul><li>由缓存的调用者,在更新数据库同时更新缓存.</li></ul><h5 id="Read-x2F-Write-Through-Pattern"><a href="#Read-x2F-Write-Through-Pattern" class="headerlink" title="Read&#x2F;Write Through Pattern"></a>Read&#x2F;Write Through Pattern</h5><ul><li>缓存与数据库整合为一个服务, 有服务来维护一致性. 调用者调用该服务, 无需关心缓存的一致性.</li></ul><h5 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h5><ul><li>调用者只是操作缓存,有其他线程异步地将缓存数据持久化到数据库,保证最终一致性</li></ul><h3 id="操作缓存和数据库时的三个问题考虑-For-Cache-Aside-Pattern"><a href="#操作缓存和数据库时的三个问题考虑-For-Cache-Aside-Pattern" class="headerlink" title="操作缓存和数据库时的三个问题考虑(For Cache Aside Pattern)"></a>操作缓存和数据库时的三个问题考虑(For Cache Aside Pattern)</h3><ol><li><p>删除缓存还是更新缓存 ?</p><ul><li>更新缓存: 每次更新数据库都更新缓存, 无效写操作较多(<strong>×</strong>)</li><li>删除缓存: 更新数据库时让缓存失效, 查询时在更新缓存(<strong>√</strong>)</li></ul></li><li><p>如何保证数据与数据库的同时成功或失败 ?</p><ul><li>单体系统, 将缓存与数据库操作防止一个事务</li><li>分布式系统,利用TTC等分布式事务方案</li></ul></li><li><p>先操作缓存还是先操作数据库 ?</p><ul><li>对于先操作缓存,可能会出现在删除缓存后将要操作数据库时, 另一个线程在查询缓存, 此时缓存中已无数据, 缓存未命中查询数据库写入缓存的情况,然后才去更新我们的数据库 造成读到脏数据的线程安全问题.</li><li>对于先操作数据库,也可能出现(刚好一个缓存过期)一个线程想要来查询缓存,缓存未命中,查询数据库的情况,此时数据库还没有更新,在要进行吸入缓存之前数据库才更新,这就造成读取到脏数据的情况.</li><li>但是对于先操作数据库的情况,实际上写入缓存的时间是非常快的,是远远快于操作数据库的情况,所以基本上不会出现在写入缓存之前,还能操作数据库的情况,所以一般采用先操作数据库的情况. 相比于第一种安全性更高.</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311160417480.png" alt="image-20220311160417480"></p></li></ol><h3 id="缓存更新的最佳实践方案"><a href="#缓存更新的最佳实践方案" class="headerlink" title="缓存更新的最佳实践方案:"></a><strong>缓存更新的最佳实践方案:</strong></h3><ol><li>低一致性需求: 使用Redis自带的淘汰机制</li><li>高一致性需求: 主动更新,并以超时作为兜底<ul><li>读操作:<ul><li>缓存命中则直接返回</li><li>缓存 未命中则查询数据库,并写入缓存,设定超时时间</li></ul></li><li>写操作:<ul><li>先写入数据库,再删除缓存</li><li>要确保数据的于缓存操作的原子性</li></ul></li></ul></li></ol><hr><h2 id="缓存未命中"><a href="#缓存未命中" class="headerlink" title="缓存未命中"></a><strong>缓存未命中</strong></h2><p>当CPU在缓存中找到有用的数据时，称为命中。当缓存中没有CPU需要的数据时（这称为未命中）</p><hr><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><strong>缓存穿透</strong></h2><p><strong>缓存穿透</strong>是指客户端请求的数据在缓存中和数据库中都不存在,这样的缓存永远都不会生效,这些请求都会打到数据库.</p><p>一些不坏好意的人可能会利用这里点来多线程发送多次请求导致数据库崩坏. 不存在的数据在数据库中查询对于数据库来说是会遍历全部数据然后返回NULL这对数据库的压力很大.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311161920235.png" alt="image-20220311161920235"></p><p><strong>常见的解决方案</strong>:</p><ul><li><p><strong>缓存空对象</strong>*</p><ul><li>优点: 实现简单,维护方便</li><li>缺点:<ul><li>额外的内存消耗(一般设置过期时间,且过期时间较短)</li><li>可能造成短期的不一致(此时新增一条该key对应的数据,但是在TTL结束前,查询到的都是NULL 造成短期不一致)</li></ul></li></ul></li><li><p><strong>布隆过滤</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311162648729.png" alt="image-20220311162648729"></p><ul><li>优点: 内存占用较少, 没有多余key</li><li>缺点:<ul><li>实现复杂</li><li>存在误判</li></ul></li></ul></li></ul><p><strong>除此之外缓存穿透的解决方案还有:</strong></p><ul><li>增强id的复杂度,避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流(也可以减小数据库压力)</li></ul><hr><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h2><p><strong>缓存雪崩</strong>是指在同一时间段大量的缓存key同时失效或者Redis服务宕机,导致大量请求到达数据库,带来巨大压力.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311163954070.png" alt="image-20220311163954070"></p><p><strong>解决方案</strong>:</p><ul><li>给不同的key的TTL添加随机值(防止大量的缓存Key同时失效)</li><li>利用Redis集群提高服务的可用性(防止单机宕机的情况)</li><li>给缓存业务添加降级限流策略(待学)</li><li>给业务添加多级缓存</li></ul><hr><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><strong>缓存击穿</strong></h2><p><strong>缓存击穿问题</strong>也叫热点Key问题,就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务比较复杂</strong>的key突然失效了,无数的请求访问会在瞬间给数据库带来巨大的冲击.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311165255394.png" alt="image-20220311165255394"></p><p><strong>常见解决方案</strong>:</p><ul><li><p><strong>互斥锁</strong></p><ul><li><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311165723072.png" alt="image-20220311165723072"></li><li>加锁,性能低.</li></ul></li><li><p><strong>逻辑过期</strong></p><ul><li>设置逻辑过期时间 而非TTL</li><li>获取互斥锁 开启新线程,去查询数据库重建缓存数据.</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311170401649.png" alt="image-20220311170401649"></p></li></ul><p><strong>两种方案的比较</strong>:</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311170545184.png" alt="image-20220311170545184"></p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁实现原理是通过Redis中的String类型的SETNX(插入一个不存在的数据)方法.这样别人就无法修改了.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311172926169.png" alt="image-20220311172926169"></p><p>RedisTemplate中的api是 opsForValue.setIfAbsent()</p><h3 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h3><p>使用逻辑过期 需要给数据设置一个逻辑过期时间, 一般会创建一个RedisData类 将逻辑过期时间和业务数据封装在一起,避免了在原有的业务基础上修改代码(指在实体类上新增逻辑过期字段).</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="comment">//业务数据</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LocalDateTime.After(LocalDateTime time),如果时间过期那么返回</p><h2 id="封装Redis工具"><a href="#封装Redis工具" class="headerlink" title="封装Redis工具"></a><strong>封装Redis工具</strong></h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311180308032.png" alt="image-20220311180308032"></p><h2 id="全局ID生成器"><a href="#全局ID生成器" class="headerlink" title="全局ID生成器"></a><strong>全局ID生成器</strong></h2><p>当用户抢购时,就会生成订单数据保存到订单表中,而订单表如果使用数据库自增ID就存在一些问题:</p><ul><li><strong>id的规律性太明显</strong></li><li><strong>受单表数据量的限制</strong></li></ul><p>全局ID生成器,是一种在分布式系统下用来生成全局唯一ID的工具,一般满足下列特性:</p><ul><li><strong>唯一性</strong></li><li><strong>高可用</strong></li><li><strong>递增性</strong></li><li><strong>安全性</strong></li><li><strong>高性能</strong></li></ul><p>为了增加ID的安全性,我们可以不直接使用Redis自增的数值,而是拼接一些其他的信息.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311210845236.png" alt="image-20220311210845236">ID的组成部分:</p><blockquote><ul><li>符号位: 1bit, 永远为0</li><li>时间戳: 31bit,以秒为单位</li><li>序列号: 32bit,秒内的计数器, 支持每秒产生2^32个不同的ID</li></ul></blockquote><p>全局唯一ID生成策略:</p><blockquote><ul><li>UUID</li><li><strong>Redis自增</strong>*</li><li><strong>snowflake算法(雪花算法)</strong>*</li><li>数据库自增</li></ul></blockquote><p><strong>Redis自增策略</strong>:</p><ul><li>每天一个key, 方便统计订单量</li><li>ID构造是 时间戳 + 计数器</li></ul><h2 id="优惠券秒杀下单功能"><a href="#优惠券秒杀下单功能" class="headerlink" title="优惠券秒杀下单功能"></a>优惠券秒杀下单功能</h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312123558073.png" alt="image-20220312123558073"></p><h3 id="超卖问题-线程安全问题"><a href="#超卖问题-线程安全问题" class="headerlink" title="超卖问题(线程安全问题)"></a>超卖问题(线程安全问题)</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312131903889.png" alt="image-20220312131903889"></p><p><strong>解决方案: 加锁</strong></p><ul><li><strong>悲观锁</strong></li><li><strong>乐观锁</strong></li></ul><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>认为线程安全问题一定会发生,因此在操作数据之前先获取锁,确保线程串行执行.</p><blockquote><ul><li>例如Synchronized, Lock都属于悲观锁</li><li>优点: 简单粗暴</li><li>缺点: 性能一般</li></ul></blockquote><hr><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>认为线程安全问题不一定会发生,因此不加锁,只是在更新数据时去判断有没有其他线程对数据进行了修改</p><blockquote><ul><li>如果没有修改则认为是安全的, 自己才更新数据</li><li>如果已经被其他线程修改说明发生了线程安全问题,此时可以重试或异常.</li><li>优点: 性能好</li><li>缺点存在成功率低的问题</li></ul></blockquote><p>乐观锁的关键是判断之前查询到的数据是否被修改过,常见的方式有两种:</p><ul><li><p>版本号法</p><p>设置一个用于悲观锁修改是判断的字段(版本号),每次修改后都会被修改</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312132808463.png" alt="image-20220312132808463"></p></li><li><p>CAS法</p><p>利用本身的数据作为判断依据(不新增任何字段 用自身数据代替版本)</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312133142933.png" alt="image-20220312133142933"></p></li></ul><h3 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h3><p>同一张优惠券一个用户只能下一单</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312135825445.png" alt="image-20220312135825445"></p><h4 id="集群下的一人一单问题"><a href="#集群下的一人一单问题" class="headerlink" title="集群下的一人一单问题"></a>集群下的一人一单问题</h4><p>JVM中有一个锁监视器 单机情况下可以实现锁的监视,但是在集群模式下 多个的JVM有不同的锁监视器, 即集群模式下的悲观锁失效了(它只能保证单个JVM下的线程安全问题)</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312142218951.png" alt="image-20220312142218951"></p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><strong>分布式锁</strong></h3><p>**分布式锁:**满足分布式系统或集群模式下多进程可见并且互斥的锁.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312142754987.png" alt="image-20220312142754987"></p><blockquote><ul><li><strong>多线程可见</strong>*</li><li><strong>互斥</strong>*</li><li><strong>高可用</strong>*</li><li><strong>高性能(指获得锁的性能)</strong>*</li><li><strong>安全性</strong>*</li><li>…</li></ul></blockquote><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312143720266.png" alt="image-20220312143720266"></p><h3 id="实现分布式锁-此处的是实现都是基于一人一单的情况下"><a href="#实现分布式锁-此处的是实现都是基于一人一单的情况下" class="headerlink" title="实现分布式锁(此处的是实现都是基于一人一单的情况下)"></a><strong>实现分布式锁</strong>(此处的是实现都是基于一人一单的情况下)</h3><p>实现分布式锁需要实现两个基本方法</p><ul><li>获取锁</li><li>释放锁</li></ul><h3 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a><strong>基于Redis的分布式锁</strong></h3><p>利用SETNX的互斥机制 和DEL的删除机制</p><p>为了防止Redis异常宕机的情况下锁的安全性问题(需要设置锁的过期时间)</p><ul><li><p>获取锁:</p><ul><li><p>互斥: 确保只能有一个线程获取锁</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">添加锁, NX是互斥 EX是设置超时时间</span></span><br><span class="line">set lock thread1 NX EX 10</span><br></pre></td></tr></table></figure></li></ul></li><li><p>释放锁:</p><ul><li><p>手动释放</p></li><li><p>超时释放: 获取锁时添加一个超时时间</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">释放锁, 删除即可</span></span><br><span class="line">DEL key</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312145523204.png" alt="image-20220312145523204"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">//获取线程表示</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">//获取锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的分布式锁的线程安全问题</p><p>业务堵塞导致锁的时间到期释放, 第二个线程此时获取到锁,在执行业务中,一号线程业务堵塞完毕此时释放锁 就导致线程二的锁被释放了.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312152342991.png" alt="image-20220312152342991"></p><p>改进后</p><p>通过新增UUID+ThreadID作为锁标识 在释放锁之前判断锁标识是否一致(同一个线程的锁标识一致,这样就不会出现业务堵塞导致释放了其他线程的锁的情况)</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312152522311.png" alt="image-20220312152522311"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312152710464.png" alt="image-20220312152710464"></p><h4 id="改进Redis的分布式锁"><a href="#改进Redis的分布式锁" class="headerlink" title="改进Redis的分布式锁"></a>改进Redis的分布式锁</h4><p>修改之前的分布式锁实现,满足</p><ol><li><p>在获取锁时存入线程表示(可用UUID表示)</p></li><li><p>在释放锁时先获取锁中的线程标识,判断是否与当前线程标识一致</p><blockquote><ul><li><p>如果不一致则不释放锁</p></li><li><p>如果一致则释放锁</p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取线程标识</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX+Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">//获取锁中的标识</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="comment">//判断是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(threadId.equals(id))&#123;</span><br><span class="line">        <span class="comment">//一致就释放锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX+name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则就不释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>改良后的Redis分布式锁 依旧存在如下问题就是在 删除锁的时候发生了堵塞 导致超时释放锁 此时二号线程进入获得锁执行业务,但是刚好一号线程堵塞完毕就将二号线程的锁释放了.</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312173903547.png" alt="image-20220312173903547"></p><h3 id="Redis的Lua脚本"><a href="#Redis的Lua脚本" class="headerlink" title="Redis的Lua脚本"></a>Redis的Lua脚本</h3><p>释放锁业务的Lua脚本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- 比较线程标示与锁中的标示是否一致</span><br><span class="line">if(redis.call(&#x27;get&#x27;, KEYS[1]) ==  ARGV[1]) then</span><br><span class="line">    -- 释放锁 del key</span><br><span class="line">    return redis.call(&#x27;del&#x27;, KEYS[1])</span><br><span class="line">end</span><br><span class="line">return 0</span><br></pre></td></tr></table></figure><h3 id="Java中调用Lua脚本"><a href="#Java中调用Lua脚本" class="headerlink" title="Java中调用Lua脚本"></a>Java中调用Lua脚本</h3><p>RedisTemplate可以直接调用Lua脚本</p><p>使用静态代码块初始化lua脚本</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">    UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将原来java中的两行代码,变为了一行代码, 就不会出现上述的情况</p><p>改良后的unlock方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX+name),</span><br><span class="line">            ID_PREFIX+Thread.currentThread().getId());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于Redis的分布式锁优化"><a href="#基于Redis的分布式锁优化" class="headerlink" title="基于Redis的分布式锁优化"></a>基于Redis的分布式锁优化</h3><p>基于SETNX实现的分布式锁存在下面的问题:</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312184555611.png" alt="image-20220312184555611"></p><p><a href="https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95"><strong>Redission官方文档</strong></a></p><p>Redission是一个在Redis的基础上实现的java驻内存数据网络(In-Memory Data Grid). 它不仅提供了一系列的分布式java常用对象,还提供了许多分布式服务,其中就包含了各种分布式锁的实现</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312200824948.png" alt="image-20220312200824948"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1cr4y1671t?p=63&amp;spm_id_from=pageDriver&quot;&gt;Redis&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Redis是一种NOSQL型数据库,即一种非关系型数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们常见的Mysql是一种SQL型数据库,是一种关系型数据库&lt;/p&gt;</summary>
    
    
    
    <category term="NoSQL" scheme="https://devildyw.github.io/categories/NoSQL/"/>
    
    
    <category term="database" scheme="https://devildyw.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Git分布式版本控制工具</title>
    <link href="https://devildyw.github.io/2022/02/28/Git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"/>
    <id>https://devildyw.github.io/2022/02/28/Git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-04-16T08:53:06.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git分布式版本控制工具"><a href="#Git分布式版本控制工具" class="headerlink" title="Git分布式版本控制工具"></a><a href="D:\BaiduNetdiskDownload\Git讲义.pdf">Git分布式版本控制工具</a></h1><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220127230403996.png" alt="image-20220127230403996"></p><p><strong>命令如下：</strong></p><ol><li><strong>clone（克隆）</strong>: 从远程仓库中克隆代码到本地仓库</li><li><strong>checkout （检出）</strong>:从本地仓库中检出一个仓库分支然后进行修订</li><li><strong>add（添加）</strong>: 在提交前先将代码提交到暂存区</li><li><strong>commit（提交）</strong>: 提交到本地仓库。本地仓库中保存修改的各个历史版本</li><li><strong>fetch (抓取)</strong> ： 从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。</li><li><strong>pull (拉取)</strong> ： 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于fetch+merge</li><li><strong>push（推送）</strong> : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库</li></ol><span id="more"></span><hr><p><strong>备注：</strong></p><p><strong>Git GUI</strong>：Git提供的图形界面工具</p><p><strong>Git Bash</strong>：Git提供的命令行工具</p><p>当安装Git后首先要做的事情是<strong>设置用户名称</strong>和<strong>email</strong>地址。这是非常重要的，因为每次Git提交都会使用该用户信息</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;itcast&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;hello@qq.com&quot;</span></span><br></pre></td></tr></table></figure><p>查看配置信息</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git confifig --global user.name</span><br><span class="line">git confifig --global user.email</span><br></pre></td></tr></table></figure><hr><h2 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a><strong>本地仓库</strong></h2><p>要使用Git对我们的代码进行版本控制，首先需要获得本地仓库</p><ol><li><p>在电脑的任意位置创建一个空目录（例如test）作为我们的本地Git仓库</p></li><li><p>进入这个目录中，点击右键打开Git bash窗口</p></li><li><p>执行命令<strong>git init</strong> (初始化本文件为本地仓库)</p></li><li><p>如果创建成功后可在文件夹下看到隐藏的.git目录。</p></li></ol><hr><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a><strong>命令</strong></h2><ul><li><strong>git touch</strong> 文件名 可以创建文件</li></ul><hr><p>Git工作目录下对于文件的<strong>修改</strong>(增加、删除、更新)会存在几个状态，这些<strong>修改</strong>的状态会随着我们执行Git的命令而发生变化。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220127231451204.png" alt="image-20220127231451204"></p><ul><li><p><strong>git add</strong> (工作区 –&gt; 暂存区) (<strong>git add . 将所有修改加入暂存区</strong>)</p></li><li><p><strong>git commit</strong> (暂存区 –&gt; 本地仓库) (<strong>git commit -m ‘注释内容’</strong> 将暂存区中的内容提交到本地仓库)</p></li><li><p><strong>git status</strong>:<strong>查看修改的状态</strong></p></li></ul><hr><p><strong>查看提交日志</strong></p><ul><li><p><strong>git log</strong> [option]</p></li><li><p>options</p><ul><li><p><strong>all</strong> 显示所有分支</p></li><li><p><strong>pretty&#x3D;oneline</strong> 将提交信息显示为一行</p></li><li><p><strong>abbrev-commit</strong> 使得输出的commitId更简短</p></li><li><p><strong>graph</strong> 以图的形式显示</p></li></ul></li></ul><p><strong>对log的格式进行自定义 并且对该操作使用alias起了一个别名</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global alias.lg <span class="string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span></span><br></pre></td></tr></table></figure><hr><p><strong>版本回退</strong></p><ul><li>作用: 版本切换</li><li>命令: <strong>git reset –hard commitID</strong><ul><li><strong>commitID</strong> 可以使用 <strong>git lg</strong> 或 <strong>git log</strong> 指令查看</li></ul></li></ul><p><strong>如何查看已经删除的记录？</strong></p><ul><li><p><strong>git reflflog</strong></p></li><li><p>这个指令可以看到已经删除的提交记录</p></li></ul><hr><p><strong>添加文件至忽略列表</strong></p><p>一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以在工作目录中创建一个名为 <strong>.gitignore 的文件（文件名称固定）</strong>，列出要忽略的文件模式。</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">HELP.md</span><br><span class="line">target/</span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar</span><br><span class="line">!**/src/main/**/target/</span><br><span class="line">!**/src/test/**/target/</span><br><span class="line"></span><br><span class="line"><span class="params">###</span> STS <span class="params">###</span></span><br><span class="line">.apt<span class="built_in">_</span>generated</span><br><span class="line">.classpath</span><br><span class="line">.factorypath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.springBeans</span><br><span class="line">.sts4-cache</span><br><span class="line"></span><br><span class="line"><span class="params">###</span> IntelliJ IDEA <span class="params">###</span></span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line"></span><br><span class="line"><span class="params">###</span> NetBeans <span class="params">###</span></span><br><span class="line">/nbproject/private/</span><br><span class="line">/nbbuild/</span><br><span class="line">/dist/</span><br><span class="line">/nbdist/</span><br><span class="line">/.nb-gradle/</span><br><span class="line">build/</span><br><span class="line">!**/src/main/**/build/</span><br><span class="line">!**/src/test/**/build/</span><br><span class="line"></span><br><span class="line"><span class="params">###</span> VS Code <span class="params">###</span></span><br><span class="line">.vscode/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a><strong>分支</strong></h2><p><strong>查看本地分支</strong></p><ul><li><strong>git branch</strong></li></ul><hr><p><strong>创建本地分支</strong></p><ul><li><strong>git branch 分支名</strong></li></ul><hr><p><strong>切换分支</strong></p><ul><li><strong>git checkout 分支名</strong></li><li><strong>git checkout -b 分支名 (创建并切换)</strong></li></ul><hr><p><strong>合并分支</strong></p><ul><li><strong>git merge 分支名称</strong></li></ul><hr><p><strong>删除分支</strong></p><ul><li><strong>git branch -d 分支名 (删除分支时，需要做各种检查)</strong></li><li><strong>git branch -D 分支名 (不做任何检查，强制删除)</strong></li></ul><hr><p><strong>解决冲突</strong></p><p>当两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解决冲突，解决冲突步骤如下：</p><ol><li><p>处理文件中冲突的地方</p></li><li><p>将解决完冲突的文件加入暂存区(add)</p></li><li><p>提交到仓库(commit)</p></li></ol><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220127233455735.png" alt="image-20220127233455735"></p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a><strong>远程仓库</strong></h2><ul><li><p><strong>注册gitee(码云)</strong></p></li><li><p><strong>创建仓库</strong></p></li></ul><p><strong>配置SSH公钥</strong></p><ul><li><p><strong>生成SSH公钥</strong></p><ul><li><strong>ssh-keygen -t rsa</strong></li></ul></li><li><p><strong>Gitee设置账户共公钥</strong></p><ul><li><p>上面我们以及生成了SSH公钥 这里我们要获取</p></li><li><p><strong>cat ~&#x2F;.ssh&#x2F;id_rsa.pub</strong> </p></li><li><p>复制这个SSH公钥</p></li><li><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220128220100844.png" alt="image-20220128220100844"></p></li><li><p>验证是否配置成功 <strong>ssh -T <a href="mailto:&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#101;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#101;&#101;&#x2e;&#99;&#x6f;&#x6d;</a></strong></p></li></ul><h4 id="操作远程仓库"><a href="#操作远程仓库" class="headerlink" title="操作远程仓库"></a>操作远程仓库</h4><ul><li><p><strong>添加远程仓库</strong> (此操作是先初始化本地仓库,然后与一创建的远程仓库进行对接)</p><ul><li><p><strong>命令: git remote add &lt;远端名称(别名)&gt; &lt;仓库路径(url)&gt;</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote add origin git@gitee.com:Devildyw/spring-mvc.git</span><br></pre></td></tr></table></figure></li><li><p><strong>命令: git remote</strong>(查看已添加的远程仓库)</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220128221118298.png" alt="image-20220128221118298"></p></li></ul></li></ul></li></ul><hr><ul><li><p><strong>推送到远程仓库</strong></p><ul><li><p><strong>命令: git push [-f] [–set-upstream] [远端名称[本地分支名 [:远端分支名]]</strong></p><ul><li><pre><code class="sh">git push origin master<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* **-f** 表示强制覆盖</span><br><span class="line"></span><br><span class="line">* **--set-upstream**: 推送到远端的同时并且建立起和远端分支的关联关系</span><br><span class="line"></span><br><span class="line">* ```sh</span><br><span class="line">  git push --set-upstream origin master</span><br></pre></td></tr></table></figure></code></pre></li><li><p>如果当前分支已经和远端分支建立关联,则可以省略分支名和远端名 <strong>(git push)</strong></p></li></ul></li><li><p><strong>查看本地分支与远程分支的关联关系</strong></p><ul><li><strong>命令: git brach -vv</strong></li></ul></li></ul></li></ul><hr><ul><li><strong>从远程仓库克隆(一般只有一开始会做一次 后续都会使用pull拉取)</strong><ul><li><strong>命令: git clone &lt;仓库路径&gt; [本地目录]</strong><ul><li>本地目录可以省略,会自动生成一个目录</li></ul></li></ul></li><li><strong>从远程仓库中抓取和拉取</strong><ul><li>远程分支和本地的分支一样，我们可以进行merge操作，只是需要先把远端仓库里的更新都下载到本地，再进行操作。<ul><li><strong>抓取 命令: git fetch [remote name] [branch name]</strong><ul><li><strong>抓取指令就是将仓库里的更新都抓取到本地，不会进行合并</strong></li><li>如果不指定远端名称和分支名，则抓取所有分支。</li></ul></li><li><strong>拉取 命令: git pull [remote name] [branch name]</strong><ul><li>**拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于 ** <strong>fetch+merge</strong></li><li>如果不指定远端名称和分支名，则抓取所有并更新当前分支。</li></ul></li></ul></li></ul></li></ul><hr><ul><li><p><strong>解决合并冲突</strong></p><ul><li><p>在一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突。A用户在本地修改代码后优先推送到远程仓库，此时B用户在本地修订代码，提交到本地仓库后，也需要推送到远程仓库，此时B用户晚于A用户，<strong>故需要先拉取远程仓库的提交，经过合并后才能推送到远端分支</strong></p></li><li><p>在B用户拉取代码时，因为A、B用户同一段时间修改了同一个文件的相同位置代码，故会发生合并冲突。<strong>远程分支也是分支，所以合并时冲突的解决方式也和解决本地分支冲突相同相同</strong></p></li><li><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220128223521930.png" alt="image-20220128223521930"></p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Git分布式版本控制工具&quot;&gt;&lt;a href=&quot;#Git分布式版本控制工具&quot; class=&quot;headerlink&quot; title=&quot;Git分布式版本控制工具&quot;&gt;&lt;/a&gt;&lt;a href=&quot;D:\BaiduNetdiskDownload\Git讲义.pdf&quot;&gt;Git分布式版本控制工具&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220127230403996.png&quot; alt=&quot;image-20220127230403996&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;clone（克隆）&lt;/strong&gt;: 从远程仓库中克隆代码到本地仓库&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;checkout （检出）&lt;/strong&gt;:从本地仓库中检出一个仓库分支然后进行修订&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;add（添加）&lt;/strong&gt;: 在提交前先将代码提交到暂存区&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;commit（提交）&lt;/strong&gt;: 提交到本地仓库。本地仓库中保存修改的各个历史版本&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fetch (抓取)&lt;/strong&gt; ： 从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pull (拉取)&lt;/strong&gt; ： 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于fetch+merge&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;push（推送）&lt;/strong&gt; : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="开发工具" scheme="https://devildyw.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Developer" scheme="https://devildyw.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="https://devildyw.github.io/2022/02/28/ThreadLocal/"/>
    <id>https://devildyw.github.io/2022/02/28/ThreadLocal/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-04-16T08:53:20.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal-ThreadLocal-简书-jianshu-com"><a href="#ThreadLocal-ThreadLocal-简书-jianshu-com" class="headerlink" title="[ThreadLocal](ThreadLocal - 简书 (jianshu.com))"></a>[ThreadLocal](<a href="https://www.jianshu.com/p/3c5d7f09dfbd">ThreadLocal - 简书 (jianshu.com)</a>)</h1><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>threadlocal使用方法很简单</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;T&gt; sThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;T&gt;();</span><br><span class="line">sThreadLocal.set()</span><br><span class="line">sThreadLocal.get()</span><br></pre></td></tr></table></figure><p>threadlocal而是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据，官方解释如下。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220211183419286.png" alt="image-20220211183419286"></p><p>大致意思就是ThreadLocal提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。通过get和set方法就可以得到当前线程对应的值。</p><p>做个不恰当的比喻，从表面上看ThreadLocal相当于维护了一个map，key就是当前的线程，value就是需要存储的对象。</p><p><strong>这里的这个比喻是不恰当的，实际上是ThreadLocal的静态内部类ThreadLocalMap为每个Thread都维护了一个数组table，ThreadLocal确定了一个数组下标，而这个下标就是value存储的对应位置。</strong></p><span id="more"></span><p>作为一个存储数据的类，关键点就在get和set方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**源码**/</span></span><br><span class="line"><span class="comment">//set 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">      <span class="comment">//获取当前线程</span></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">      <span class="comment">//实际存储的数据结构类型</span></span><br><span class="line">      <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">      <span class="comment">//如果存在map就直接set，没有则创建map并set</span></span><br><span class="line">      <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">          map.set(<span class="built_in">this</span>, value);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          createMap(t, value);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//getMap方法</span></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">      <span class="comment">//thred中维护了一个ThreadLocalMap</span></span><br><span class="line">      <span class="keyword">return</span> t.threadLocals;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//createMap</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">      <span class="comment">//实例化一个新的ThreadLocalMap，并赋值给线程的成员变量threadLocals</span></span><br><span class="line">      t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出<strong>每个线程持有一个ThreadLocalMap对象</strong>。每一个新的线程Thread都会实例化一个ThreadLocalMap并赋值给成员变量threadLocals，使用时若已经存在threadLocals则直接使用已经存在的对象。</p><hr><h2 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/9e256d87362c4d9295589e3d72e69211.png" alt="在这里插入图片描述"></p><p><strong>实线代表强引用,虚线代表弱引用</strong></p><ul><li><p>每一个Thread维护一个ThreadLocalMap, key为使用弱引用的ThreadLocal实例，value为线程变量的副本。</p></li><li><p>强引用，使用最普遍的引用，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。</p></li><li><p>如果想取消强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样可以使JVM在合适的时间就会回收该对象。</p></li><li><p>弱引用，JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>简单来说就是 ThreadLocal为每个线程提供了一个ThreadLocalMap对象 这样就避免了线程安全问题 实际开发中可以用于存储用户信息代替session</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ThreadLocal-ThreadLocal-简书-jianshu-com&quot;&gt;&lt;a href=&quot;#ThreadLocal-ThreadLocal-简书-jianshu-com&quot; class=&quot;headerlink&quot; title=&quot;[ThreadLocal](ThreadLocal - 简书 (jianshu.com))&quot;&gt;&lt;/a&gt;[ThreadLocal](&lt;a href=&quot;https://www.jianshu.com/p/3c5d7f09dfbd&quot;&gt;ThreadLocal - 简书 (jianshu.com)&lt;/a&gt;)&lt;/h1&gt;&lt;h4 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h4&gt;&lt;p&gt;threadlocal使用方法很简单&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; ThreadLocal&amp;lt;T&amp;gt; sThreadLocal = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ThreadLocal&lt;/span&gt;&amp;lt;T&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sThreadLocal.set()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sThreadLocal.get()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;threadlocal而是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据，官方解释如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220211183419286.png&quot; alt=&quot;image-20220211183419286&quot;&gt;&lt;/p&gt;
&lt;p&gt;大致意思就是ThreadLocal提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。通过get和set方法就可以得到当前线程对应的值。&lt;/p&gt;
&lt;p&gt;做个不恰当的比喻，从表面上看ThreadLocal相当于维护了一个map，key就是当前的线程，value就是需要存储的对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里的这个比喻是不恰当的，实际上是ThreadLocal的静态内部类ThreadLocalMap为每个Thread都维护了一个数组table，ThreadLocal确定了一个数组下标，而这个下标就是value存储的对应位置。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="开发规范" scheme="https://devildyw.github.io/categories/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？</title>
    <link href="https://devildyw.github.io/2022/02/28/%E5%8E%9F%E5%AD%90%E2%80%BB%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7/"/>
    <id>https://devildyw.github.io/2022/02/28/%E5%8E%9F%E5%AD%90%E2%80%BB%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-04-16T08:55:20.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java原子性是什么-中级Java应该清楚的概念：原子性、可见性、有序性是什么？"><a href="#java原子性是什么-中级Java应该清楚的概念：原子性、可见性、有序性是什么？" class="headerlink" title="java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？"></a>java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？</h1><p>原子性、可见性、有序性是多线程编程中最重要的几个知识点，由于多线程情况复杂，如何让每个线程能看到正确的结果，这是非常重要的，下面和千锋广州小编一起来看看吧！</p><p><a href="%5B(4%E6%9D%A1%E6%B6%88%E6%81%AF">原网站</a> java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？…_我才是Guido的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_42460182/article/details/114101352">https://blog.csdn.net/weixin_42460182/article/details/114101352</a>))</p><span id="more"></span><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性是指一个线程的操作是不能被其他线程打断，同一时间只有一个线程对一个变量进行操作。在多线程情况下，每个线程的执行结果不受其他线程的干扰，比如说多个线程同时对同一个共享成员变量n++100次，如果n初始值为0，n最后的值应该是100，所以说它们是互不干扰的，这就是传说的中的原子性。但n++并不是原子性的操作，要使用AtomicInteger保证原子性。</p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性是指某个线程修改了某一个共享变量的值，而其他线程是否可以看见该共享变量修改后的值。在单线程中肯定不会有这种问题，单线程读到的肯定都是最新的值，而在多线程编程中就不一定了。</p><p>每个线程都有自己的工作内存，线程先把共享变量的值从主内存读到工作内存，形成一个副本，当计算完后再把副本的值刷回主内存，从读取到最后刷回主内存这是一个过程，当还没刷回主内存的时候这时候对其他线程是不可见的，所以其他线程从主内存读到的值是修改之前的旧值。</p><p>像CPU的缓存优化、硬件优化、指令重排及对JVM编译器的优化，都会出现可见性的问题。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>我们都知道程序是按代码顺序执行的，对于单线程来说确实是如此，但在多线程情况下就不是如此了。为了优化程序执行和提高CPU的处理性能，JVM和操作系统都会对指令进行重排，也就说前面的代码并不一定都会在后面的代码前面执行，即后面的代码可能会插到前面的代码之前执行，只要不影响当前线程的执行结果。所以，指令重排只会保证当前线程执行结果一致，但指令重排后势必会影响多线程的执行结果。</p><p>虽然重排序优化了性能，但也是会遵守一些规则的，并不能随便乱排序，只是重排序会影响多线程执行的结果。</p><p>以上就是原子性、可见性、有序性的概念解释，希望对大家有帮助哦！</p><p><strong>相关资源：</strong><a href="https://download.csdn.net/download/weixin_38575456/12793647?spm=1001.2101.3001.5697"><em>Java</em>高并发三:<em>Java</em>内存模型和线程安全详解_<em>java</em>高并发模型-其它*.<strong>.</strong>.*</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;java原子性是什么-中级Java应该清楚的概念：原子性、可见性、有序性是什么？&quot;&gt;&lt;a href=&quot;#java原子性是什么-中级Java应该清楚的概念：原子性、可见性、有序性是什么？&quot; class=&quot;headerlink&quot; title=&quot;java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？&quot;&gt;&lt;/a&gt;java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？&lt;/h1&gt;&lt;p&gt;原子性、可见性、有序性是多线程编程中最重要的几个知识点，由于多线程情况复杂，如何让每个线程能看到正确的结果，这是非常重要的，下面和千锋广州小编一起来看看吧！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;%5B(4%E6%9D%A1%E6%B6%88%E6%81%AF&quot;&gt;原网站&lt;/a&gt; java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？…_我才是Guido的博客-CSDN博客](&lt;a href=&quot;https://blog.csdn.net/weixin_42460182/article/details/114101352&quot;&gt;https://blog.csdn.net/weixin_42460182/article/details/114101352&lt;/a&gt;))&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE" scheme="https://devildyw.github.io/categories/JavaSE/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据库(mysql)</title>
    <link href="https://devildyw.github.io/2022/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://devildyw.github.io/2022/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-03-06T16:00:04.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 展示所有数据库</span><br><span class="line">show databases;</span><br><span class="line"># 展示创建数据库的一些详细操作 以及数据库的字符集 等其他信息 可以用来查看已经创建的数据库的一些详细信息</span><br><span class="line">show create database mysql;</span><br><span class="line"># 创建数据库时指定字符集</span><br><span class="line">create database db2 character set gbk;</span><br><span class="line"></span><br><span class="line">show create database db2;</span><br><span class="line"># 删除数据库 如果数据库存在</span><br><span class="line">drop database if exists db2;</span><br><span class="line"># 创建数据库 如果数据库不存在</span><br><span class="line">create database if not exists db2;</span><br><span class="line"># 修改数据库的字符集</span><br><span class="line">alter database db2 character set gb2312;</span><br><span class="line"># 查询正在使用的数据库</span><br><span class="line">select database();</span><br><span class="line"># 查看数据库中的所有表</span><br><span class="line">show tables;</span><br><span class="line"># 使用数据库（选择） </span><br><span class="line">use world;</span><br><span class="line"># 查看表的结构</span><br><span class="line">desc city;</span><br><span class="line"></span><br><span class="line">use my_db;</span><br><span class="line"># 创建表</span><br><span class="line">create table student(</span><br><span class="line">id int,</span><br><span class="line">    name varchar(32),</span><br><span class="line">    age int,</span><br><span class="line">    score double(4,1),</span><br><span class="line">    birthday date,</span><br><span class="line">    insert_time timestamp default current_timestamp);</span><br><span class="line">    </span><br><span class="line">desc student;</span><br><span class="line"># 删除表</span><br><span class="line">drop table student;</span><br><span class="line"></span><br><span class="line">show tables;</span><br><span class="line"># 删除表如果表存在</span><br><span class="line">drop table if exists student;</span><br><span class="line"># 修改表的名字</span><br><span class="line">alter table student rename to stu;</span><br><span class="line"># 修改表的字符集</span><br><span class="line">alter table stu character set gbk;</span><br><span class="line"></span><br><span class="line">drop table if exists stu;</span><br><span class="line">#查看创建表的操作 与一些详细信息</span><br><span class="line">show create table stu;</span><br><span class="line"># 增加新的一列并指定类型</span><br><span class="line">alter table stu add gender varchar(10);</span><br><span class="line"></span><br><span class="line">desc stu;</span><br><span class="line"></span><br><span class="line">alter table stu change gender sex varchar(20);</span><br><span class="line"># 修改执行列的类型</span><br><span class="line">alter table stu modify sex varchar(10);</span><br><span class="line"># 插入一行 如果没有指定插入那些元素 则你默认全部修改</span><br><span class="line">insert into stu (id,name,age) values(1,&quot;肖明桓&quot;,19);</span><br><span class="line"># 查询表中的全部信息</span><br><span class="line">select* from stu;</span><br><span class="line"># where条件语句 查询指定条件的行</span><br><span class="line">delete from stu where id = 2;</span><br><span class="line"></span><br><span class="line">create table stu(</span><br><span class="line">id int,</span><br><span class="line">name varchar(32),</span><br><span class="line">age int,</span><br><span class="line">score double(4,1),</span><br><span class="line">birthday date,</span><br><span class="line">insert_time timestamp default CURRENT_TIMESTAMP);</span><br><span class="line"></span><br><span class="line">drop table stu;</span><br><span class="line"></span><br><span class="line">insert into stu (id,name,age) values(2,&quot;张敏&quot;,19);</span><br><span class="line"></span><br><span class="line">insert into stu (id,name,age) values(3,&quot;丁杨维&quot;,19);</span><br><span class="line"></span><br><span class="line"># truncate  在创建一个空表</span><br><span class="line">truncate stu;</span><br><span class="line"></span><br><span class="line">#delete from 表名 9[where语句] 删除指定的多少条记录</span><br><span class="line">delete from stu where id = 2;</span><br><span class="line"></span><br><span class="line"># updata from 表名 set 列名 = 值 [where条件] 修改指定元组中的列的值 如不加条件则会将列的所有值都修改</span><br><span class="line">update stu set age = 20 where id = 1;</span><br><span class="line"></span><br><span class="line">update stu set age = 20; </span><br><span class="line"></span><br><span class="line">update stu set score = 70 where id = 2;</span><br><span class="line"></span><br><span class="line">update stu set score = 88 where id = 3;</span><br><span class="line"></span><br><span class="line">update stu set age = 19 where id = 3;</span><br><span class="line">update stu set age = 21 where id = 2;</span><br><span class="line"></span><br><span class="line">update stu set score = 99;</span><br><span class="line"></span><br><span class="line"># 排序 asc 升序 desc 降序 </span><br><span class="line">select* from stu order by score asc; </span><br><span class="line"></span><br><span class="line"># 排序 如果数学成绩一样 则按年龄排序</span><br><span class="line">select* from stu order by score asc, age asc;</span><br></pre></td></tr></table></figure><blockquote><p><strong>聚合函数</strong> 计算会排除null值</p><ol><li>count：计算个数</li></ol><p>  一般以主键作为计数标记 一般不用count(*)(只要一列中有一个不为null那么count就加一);</p><ol start="2"><li><p>max</p></li><li><p>min</p></li><li><p>sum</p></li><li><p>avg</p></li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(ifnull(english,0)) from student;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<strong>聚合函数</strong> 计算会排除null值 </p><p>解决方案：</p><ol><li><p>选择不为空的列进行计算</p></li><li><p>使用ifnull 函数 </p><blockquote><p>select count(ifnull(english,0)) from student; 将english为null的值按0计数</p></blockquote></li></ol><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>操作数据库database 的关键字： create 创建 drop删除 alter 修改 show展示</p><p>table表的关键字 create创建 drop删除 alter修改 desc展示表的结构 </p><p>table中的行的插入 insert into 修改 update 删除 delete 查询 select。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM my_db.stu;</span><br><span class="line"># 主键就是 既非空又唯一的特殊约束 primary key </span><br><span class="line"></span><br><span class="line">#添加主键 方式一</span><br><span class="line">alter table stu modify id int primary key;</span><br><span class="line"># 添加主键 方式二 建表的时候定义</span><br><span class="line"></span><br><span class="line"># 删除主键 alter table 表名 drop primary key 一张表只有一个主键;</span><br><span class="line">alter table stu drop primary key;</span><br><span class="line"></span><br><span class="line"># 非空约束 NOT NULL;</span><br><span class="line"># 创建方式一</span><br><span class="line">alter table stu modify name varchar(32) not null;</span><br><span class="line">#创建方式二 创建表时定义</span><br><span class="line"></span><br><span class="line"># 删除非空约束</span><br><span class="line">alter table stu modify name varchar(32);</span><br><span class="line"></span><br><span class="line"># 唯一约束 unique</span><br><span class="line">#创建方式一 创建表时定义</span><br><span class="line">#创建方式二  </span><br><span class="line">alter table stu modify name varchar(32) unique;</span><br><span class="line">#删除 唯一约束</span><br><span class="line"># 错误方式 alter table stu modify name varchar(32);</span><br><span class="line">alter table stu drop index name ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除外键</span><br><span class="line">alter table stu1 drop foreign key c_key;</span><br><span class="line"># 添加外键方式一:</span><br><span class="line">alter table stu1 add constraint c_key foreign key(cid) references course(id);</span><br><span class="line"># 添加外键方式二: 创建时就定义 一般格式 constraint 外键名 foreign key(列名) references 表名 (列名);</span><br><span class="line"></span><br><span class="line"># 复制表的结构方式一用 like 模板 create table 新表 like 旧表 会将约束关系一同复制;</span><br><span class="line">create table stu2 like stu1;</span><br><span class="line"></span><br><span class="line"># 复制表的结构方式二用 create table 新表 select* from 旧表 where 1 = 2 但不会将约束关系一同复制;</span><br><span class="line">create table stu3 select * from stu1 where 1 = 2;</span><br><span class="line"># 复制表的结构与数据 create table 新表 select* from 旧表 但不会将约束关系一同复制;</span><br><span class="line">create table stu4 select* from stu1;</span><br><span class="line"></span><br><span class="line"># 主键约束自动增长 不给主键定值的情况下主键会按照主键的上一个值加一</span><br><span class="line"># 添加方式一: alter table 表名 modify 列名 类型 主键约束 auto_increment;</span><br><span class="line"># 添加方式二: 创建表的时候定义;</span><br><span class="line">alter table stu2 modify id int primary key auto_increment;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h1&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://devildyw.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="database" scheme="https://devildyw.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务</title>
    <link href="https://devildyw.github.io/2022/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <id>https://devildyw.github.io/2022/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-03-06T16:00:15.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><h3 id="事务的基本要素-4大性质"><a href="#事务的基本要素-4大性质" class="headerlink" title="事务的基本要素 4大性质"></a><strong>事务的基本要素 4大性质</strong></h3><blockquote><ol><li>原子性:事务开始后的所有操作,要么全部成功,要么全部失败回滚,不可能停滞在中间环节.事务执行过程中出错,会回滚到事务开始之前的状态,所有操作就像没有发生一样.也就是说事务是一个不可分割的整体,就像化学中学过的原子,是事务构成的基本单位.</li><li>一致性:事务开始前和结束后,数据库的完整性约束没有被破坏,如A向B转张,不可能出现A扣了钱而B却没有加的情况</li><li>隔离性:同一时间,只允许一个事务请求同一数据,不同事务之间彼此没有任何干扰,如A正在从一张银行卡中取钱,在A取钱的过程结束前,B不能向这张卡转账.</li><li>持久性:事务完成之后,事务对数据库更新将会被保存写在数据库上,不能回滚.</li></ol></blockquote><span id="more"></span><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p> <strong>隔离级别定义了一个事务可能受其他并发事务影响的程度。</strong></p><blockquote><p><strong>脏读（Dirty reads）</strong>—— 事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。</p><p><strong>不可重复读（Nonrepeatable read）</strong>—— 事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</p><p><strong>幻读（Phantom read）</strong>—— 系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p></blockquote><p>不可重复读是指在原本有个数据上进行修改导致一个事务一致都是读到不同的数据, 而幻读则是在原来的数据中的插入,删除等操作导致的.<strong>解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</strong></p><hr><p><strong>串行化</strong>隔离规则类型在开发中很少用到。举个很简单的例子。咱们使用了ISOLATION_SERIALIZABLE规则。A,B两个事务操作同一个数据表并发过来了。A先执行。A事务这个时候会把表给锁住，B事务执行的时候直接报错。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据库事务&quot;&gt;&lt;a href=&quot;#数据库事务&quot; class=&quot;headerlink&quot; title=&quot;数据库事务&quot;&gt;&lt;/a&gt;数据库事务&lt;/h1&gt;&lt;h3 id=&quot;事务的基本要素-4大性质&quot;&gt;&lt;a href=&quot;#事务的基本要素-4大性质&quot; class=&quot;headerlink&quot; title=&quot;事务的基本要素 4大性质&quot;&gt;&lt;/a&gt;&lt;strong&gt;事务的基本要素 4大性质&lt;/strong&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;原子性:事务开始后的所有操作,要么全部成功,要么全部失败回滚,不可能停滞在中间环节.事务执行过程中出错,会回滚到事务开始之前的状态,所有操作就像没有发生一样.也就是说事务是一个不可分割的整体,就像化学中学过的原子,是事务构成的基本单位.&lt;/li&gt;
&lt;li&gt;一致性:事务开始前和结束后,数据库的完整性约束没有被破坏,如A向B转张,不可能出现A扣了钱而B却没有加的情况&lt;/li&gt;
&lt;li&gt;隔离性:同一时间,只允许一个事务请求同一数据,不同事务之间彼此没有任何干扰,如A正在从一张银行卡中取钱,在A取钱的过程结束前,B不能向这张卡转账.&lt;/li&gt;
&lt;li&gt;持久性:事务完成之后,事务对数据库更新将会被保存写在数据库上,不能回滚.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://devildyw.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="database" scheme="https://devildyw.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>每日一记--synchronized关键字</title>
    <link href="https://devildyw.github.io/2022/02/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0--synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://devildyw.github.io/2022/02/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0--synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-04-16T08:53:36.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每日一记–synchronized关键字"><a href="#每日一记–synchronized关键字" class="headerlink" title="每日一记–synchronized关键字"></a>每日一记–synchronized关键字</h1><h2 id="synchronized关键字（隐式的获取和释放锁）"><a href="#synchronized关键字（隐式的获取和释放锁）" class="headerlink" title="synchronized关键字（隐式的获取和释放锁）"></a>synchronized关键字（隐式的获取和释放锁）</h2><p>作用于静态方法：</p><p><strong>对象锁</strong>给对象加锁（可以理解为这个对象的内存上锁，<strong>注意：只是这块内存，其他同类对象都会有各自的内存锁</strong>）这时候在其他一个以上线程中执行该对象的这个同步方法（<strong>注意：是该对象</strong>）就会产生互斥）</p><p>作用于静态方法：</p><p><strong>类锁</strong>：相当于在类上枷锁（*.class位于代码区，静态方法位于静态区域，这个类产生的对象公用这个静态方法，所以这块内存，N个对象来竞争），这时候，只要是这个类产生的对象，在调用这个静态方法时都会产生互斥</p><p><strong>对象锁与类锁区别</strong>：主要就在于内存区域不同 <strong>对象锁</strong>只作用与同类的单个对象的内存区域 <strong>类锁</strong>则作用于同类的所有对象的内存区域 </p><span id="more"></span><p>Java线程内存模型：每个线程都用拥有自己的栈、堆内存共享、如下图所示。锁是线程间内存和信息沟通的载体。<img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/491378-20160720152209982-808156316.png" alt="img"></p><p>Java中为了保证每个线程中的原子操作，引入了内置锁或者称监视器锁，其中，每个Java对象都可以作为实现锁的对象。</p><p>synchronized关键字修饰的代码块被称为同步代码块 ，线程进入同步代码块自动获取内置锁，退出同步代码块则释放锁，不需要调用者考虑它的创建以及消除而别的线程此时无法获得这把锁，就无法调用这个方法。一个线程想要获得这个锁只能等上一个线程执行结束这个方法将锁释放，下一个线程才能有机会调用这个方法获得该对象的锁（即synchronized关键字可以获得内置锁，同一时间只允许一个线程获得某个锁）。</p><blockquote><p>java的每个对象都有一个锁，不需要显示地去创建。</p><p><strong>java的内置锁</strong>：每个java对象都可以用做一个实现同步的锁，这些锁称为<strong>内置锁</strong>。<strong>线程</strong>进入同步代码块或方法的时候会<strong>自动获得该锁</strong>，在<strong>退出</strong>同步代码块或方法时会<strong>释放</strong>该锁。获得内置锁的<strong>唯一途径就是进入这个锁的保护的同步代码块或方法</strong>。</p><p><strong>java内置锁</strong>是一个<strong>互斥锁</strong>，这就意味着同一时间最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，线程A必须<strong>等待或者阻塞</strong>，直到线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。</p></blockquote><p><strong>1.同步方法（粗粒度锁）</strong>：</p><p>即有<strong>synchronized</strong>关键字修饰的方法。</p><p><strong>由于java中每个对象都有一个内置锁，当使用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.<strong>同步代码块（细粒度锁）</strong>：</p><p>即有<strong>synchronized</strong>关键字修饰的语句块。</p><p>被该关键字修饰的语句块会被自动加上内置锁，从而实现同步。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object)&#123; </span><br><span class="line">代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：同步是一种高开销的操作，因此应该尽量减少同步的内容。 通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。</strong> 同步会影响一定的多线程性能</p><p><strong>synchronized的缺陷</strong>：当某个线程进入同步方法获得对象锁，那么其他线程访问这里对象的同步方法时，必须等待或者阻塞，这对高并发的系统是致命的，这很容易导致系统的崩溃。如果某个线程在同步方法里面发生了死循环，那么它就永远不会释放这个对象锁，那么其他线程就要永远的等待。这是一个致命的问题。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;每日一记–synchronized关键字&quot;&gt;&lt;a href=&quot;#每日一记–synchronized关键字&quot; class=&quot;headerlink&quot; title=&quot;每日一记–synchronized关键字&quot;&gt;&lt;/a&gt;每日一记–synchronized关键字&lt;/h1&gt;&lt;h2 id=&quot;synchronized关键字（隐式的获取和释放锁）&quot;&gt;&lt;a href=&quot;#synchronized关键字（隐式的获取和释放锁）&quot; class=&quot;headerlink&quot; title=&quot;synchronized关键字（隐式的获取和释放锁）&quot;&gt;&lt;/a&gt;synchronized关键字（隐式的获取和释放锁）&lt;/h2&gt;&lt;p&gt;作用于静态方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象锁&lt;/strong&gt;给对象加锁（可以理解为这个对象的内存上锁，&lt;strong&gt;注意：只是这块内存，其他同类对象都会有各自的内存锁&lt;/strong&gt;）这时候在其他一个以上线程中执行该对象的这个同步方法（&lt;strong&gt;注意：是该对象&lt;/strong&gt;）就会产生互斥）&lt;/p&gt;
&lt;p&gt;作用于静态方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类锁&lt;/strong&gt;：相当于在类上枷锁（*.class位于代码区，静态方法位于静态区域，这个类产生的对象公用这个静态方法，所以这块内存，N个对象来竞争），这时候，只要是这个类产生的对象，在调用这个静态方法时都会产生互斥&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象锁与类锁区别&lt;/strong&gt;：主要就在于内存区域不同 &lt;strong&gt;对象锁&lt;/strong&gt;只作用与同类的单个对象的内存区域 &lt;strong&gt;类锁&lt;/strong&gt;则作用于同类的所有对象的内存区域 &lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE" scheme="https://devildyw.github.io/categories/JavaSE/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>每日一记--多线程（续）</title>
    <link href="https://devildyw.github.io/2022/02/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0--%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%BB%AD%EF%BC%89/"/>
    <id>https://devildyw.github.io/2022/02/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0--%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%BB%AD%EF%BC%89/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-04-16T08:53:43.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每日一记–多线程（续）"><a href="#每日一记–多线程（续）" class="headerlink" title="每日一记–多线程（续）"></a>每日一记–多线程（续）</h1><hr><p>今天看了看书 更了解了多线程。</p><h2 id="Java中的线程"><a href="#Java中的线程" class="headerlink" title="Java中的线程"></a>Java中的线程</h2><p><strong>程序</strong>：程序是一段静态的代码，他是应用软件执行的蓝本。</p><p><strong>进程</strong>：进程是程序的一次动态执行过程，它对应了从代码加载、执行至完毕的一个完整过程，这个过程也是进程本身从产生、发展至消亡的过程。</p><p><strong>线程</strong>：线程是比进程更小的执行单位。线程之间可以共享相同的内存单元（即内存中的堆区 包括代码和数据）并利用这些共享单元来实现数据交换、实时通信与必要的同步操作。</p><p><strong>进程与线程的关系</strong>：一个进程在其执行的过程中可以产生多个线程，形成多条执行线索，每条线索，即没有线程都有它自身的产生、存在与消亡的过程，也是一个动态的概念。</p><p><strong>多线程原理</strong>：我们知道，操作系统分时管理各个进程，按时间片轮流执行每个进程。Java的多线程就是在操作系统每次分时给Java程序一个时间片的cpu时间内，在若干个独立的可控制的线程之间进行切换。如果机器能有多个cpu处理器，那么JVM就能充分利用这些cpu，使得Java程序在同一时刻能获得多个时间片，Java程序就可以获得真实的线程并发执行效果。</p><p><strong>主线程</strong>：每个Java程序都有一个默认的主线程，这个线程就是当执行主类main方法开始执行时，当JVM加载代码发现main方法之后，就会启动一个线程，这个线程就被称为<strong>“主线程”</strong>，该线程负责执行main方法，如果在main方法的执行过程中再创建的线程 就称为<strong>其他线程</strong>。如果main方法中没有创建其他线程，那么当main方法执行完最后一个语句，JVM就会结束Java应用程序。如果main方法中有创建了其他线程，那么JVM就要在主线程和其他线程之间轮流切换，以保证每个线程都能有机会使用cpu资源。</p><p><strong>注</strong>：main方法即使执行完最后的语句（主线程结束），JVM也不会结束程序，JVM会等待程序中其他线程都结束才会结束Java应用程序。</p><span id="more"></span><hr><h3 id="线程的状态与生命周期"><a href="#线程的状态与生命周期" class="headerlink" title="线程的状态与生命周期"></a>线程的状态与生命周期</h3><p><strong>新建状态</strong>：当一个Thread类或其子类的对象被声明并创建时，新生的线程处于NEW状态。此时它已经有了相应的内存空间和其他资源，即此时线程已准备但尚未启动（未调用**start()**方法），此时JVM管理的线程中还没有这个线程。</p><p><strong>可运行状态</strong>：当处于NEW状态的线程调用了Thread类提供的**start()**方法，此时线程就会进入RUNNABLE状态，称为可运行状态，此时JVM就会知道有一个新的线程在等待切换了。</p><p><strong>中断状态</strong>：<strong>BOLOCKED、WAITING、TIMED_WAITING</strong>状态都属于中断状态，当中断的线程重新进入RUNNABLE状态后，一旦JVM将cpu使用权切换给该线程，<strong>run()<strong>方法将</strong>从中断出继续执行</strong>。</p><ul><li>JVM将从cpu资源从当前RUNNABLE线程切换给其他线程，是本线程让出cpu的使用权进入BLOCKED状态，进入BOLOCKED状态的线程必须等待JVM解除它的BLOCKED状态，再次进入RUNNABLE状态，并从中断处继续执行。</li><li>线程使用cpu资源期间，执行了<strong>sleep(int millsecond)</strong>,使得当前线程进入休眠状态。<strong>sleep(int millsecond)<strong>方法是Thread类的类方法，一个线程一旦执行了这个方法，就立刻让出cpu使用权，使当前线程处于</strong>TIMED_WAITING</strong>状态。经过至多参数<strong>millsecond</strong>指定的毫秒数之后，该线程再次进入RUNNABLE状态。</li><li>线程使用cpu资源期间，执行了wait()方法，使得当前线程进入<strong>WAITING</strong>状态。该状态的线程不会主动进入RUNNABLE状态，必须由其他线程调用**notify()**方法通知它，使得它进入RUNNABLE状态。</li></ul><p><strong>死亡状态</strong>：当一个线程执行完<strong>run()<strong>方法，该线程就完成了它的全部工作进入</strong>TERMINATED状态</strong>。</p><p><strong>注</strong>：只有处于NEW状态的线程才可以调用<strong>start()<strong>方法，处于其他状态的线程都不可以调用该方法，否则将会触发</strong>IllegalThreadStateException</strong>异常</p><hr><p>例：用继承Thread的子类创建两个线程，这两个线程在控制台分别输出五句“老虎”和“小猫”；主线程控制台输出6句主人。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DEVIL.多线程;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil(丁杨维)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-14-22:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E_06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;<span class="comment">//主线程</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">//通过Thread类子类创建一个线程 此时出NEW状态</span></span><br><span class="line">        <span class="type">Tiger</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tiger</span>();<span class="comment">//创建另一个线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Tiger线程的状态&quot;</span>+ t1.getState());<span class="comment">//获取线程的状态</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Cat线程的状态&quot;</span>+ t2.getState());</span><br><span class="line">        t1.start();<span class="comment">//启动线程 是现成进入RUNNABLE状态</span></span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;\n%s&quot;</span>,<span class="string">&quot;Tiger线程的状态&quot;</span>+ t1.getState());<span class="comment">//获取线程执行时状态</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;\n%s&quot;</span>,<span class="string">&quot;Cat线程的状态&quot;</span>+t2.getState());</span><br><span class="line">            System.out.printf(<span class="string">&quot;\n%s&quot;</span>,<span class="string">&quot;主人&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;\nTiger线程的状态&quot;</span>+ t1.getState());<span class="comment">//获取线程执行结束时状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Cat线程的状态&quot;</span>+ t2.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;|小猫&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;|老虎&quot;</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//延时1秒 使其进入TIMED_WAITING状态</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tiger线程的状态NEW</span><br><span class="line">Cat线程的状态NEW</span><br><span class="line">Tiger线程的状态RUNNABLE|老虎1|小猫1|小猫2|小猫3|小猫4|小猫5</span><br><span class="line"></span><br><span class="line">Cat线程的状态BLOCKED</span><br><span class="line">主人1</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">主人2</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">主人3</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">主人4</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">主人5</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">主人6</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">|老虎2|老虎3|老虎4|老虎5</span><br></pre></td></tr></table></figure><p><strong>注</strong>：程序在不同的计算机运行或在同一台计算机上反复运行的结果不尽相同，输出结果依赖于当前cpu使用情况。当其他线程的<strong>run()<strong>方法都结束了，线程进入</strong>死亡状态</strong>，只留下一个线程时，<strong>JVM</strong>不再将cpu资源切给主线程，等到最后一个线程也结束了，<strong>JVM</strong>就将java程序退出虚拟机，即java程序的结束。</p><hr><h3 id="线程的调度与优先级"><a href="#线程的调度与优先级" class="headerlink" title="线程的调度与优先级"></a>线程的调度与优先级</h3><blockquote><p>处于就绪状态的线程首先进入就绪队列排队等候cpu资源，同一时刻再就绪队列中的线程可能由多个。Java虚拟机（JVM）中的<strong>线程调度器</strong>负责管理线程，调度器把线程的的优先级分为了10个级别，分别用<strong>Thread类</strong>中的类常量表示。每个Java线程的优先级都为常数1~10，即<strong>Thread.MIN_PRIORITY和Thread.MAX_PRIORITY</strong>之间。<em><strong>如果没有明确第设置线程的优先级别，每个线程的优先级都默认为常数5</strong></em>，即<strong>Thread.NORM_PRIORITY</strong>。</p><p>线程的优先级可以通过<strong>setPriority(int grade)<strong>方法调整，该方法需要一个int参数代表设置线程的等级，如果该参数不在1~10的范围内，那么</strong>setPriority</strong>便会产生一个<strong>IllegalArgumentException</strong>异常。如果参数正常该方法会返回所设置的线程的优先级。（ <strong>注</strong>：有些操作系统只能识别3个级别，即1、5和10。）</p><p><strong>java线程调度器</strong>的任务就是使高优先级的线程能始终运行，一旦时间片有空闲，则使具有同等优先级的线程以轮流D这四个线程，且A和B的级别高于C和D，那么，Java调度器首先以轮流的方式执行A和B，一直等到A、B都执行完毕进入死亡状态，才会再C、D之间轮流切换。）</p><p><strong>注</strong>：在实际编程时，不提倡使用线程的优先级来保证算法的正确执行。如果要编写正确、跨平台的多线程代码，必须假设线程在任何时刻都有可能被剥夺cpu资源的使用权</p></blockquote><hr><h2 id="Java程序内存的简单分析"><a href="#Java程序内存的简单分析" class="headerlink" title="Java程序内存的简单分析"></a>Java程序内存的简单分析</h2><ul><li><strong>栈：</strong>一般来说，<strong>基本数据类型</strong>直接在栈中分配空间，<strong>局部变量</strong>（在方法代码段中定义的变量）也在栈中直接分配空间，<strong>当局部变量所在方法执行完成之后该空间便立刻被JVM回收</strong>，还有一种是<strong>引用数据类型</strong>，即我们通常所说的需要用<strong>关键字new创建出来的对象所对应的引用</strong>也是在栈空间中，此时，JVM在栈空间中给对象引用分配了一个地址空间（相当于一个门牌号，通过这个门牌号就可以找到你家），在堆空间中给该引用的对象分配一个空间，栈空间中的地址引用指向了堆空间中的对象区（通过门牌号找住址）；</li><li><strong>堆：</strong>一般用来存放用<strong>关键字new出来的数据</strong>。</li></ul><hr><h1 id="end"><a href="#end" class="headerlink" title="-end-"></a>-end-</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;每日一记–多线程（续）&quot;&gt;&lt;a href=&quot;#每日一记–多线程（续）&quot; class=&quot;headerlink&quot; title=&quot;每日一记–多线程（续）&quot;&gt;&lt;/a&gt;每日一记–多线程（续）&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;今天看了看书 更了解了多线程。&lt;/p&gt;
&lt;h2 id=&quot;Java中的线程&quot;&gt;&lt;a href=&quot;#Java中的线程&quot; class=&quot;headerlink&quot; title=&quot;Java中的线程&quot;&gt;&lt;/a&gt;Java中的线程&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;程序&lt;/strong&gt;：程序是一段静态的代码，他是应用软件执行的蓝本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;：进程是程序的一次动态执行过程，它对应了从代码加载、执行至完毕的一个完整过程，这个过程也是进程本身从产生、发展至消亡的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;：线程是比进程更小的执行单位。线程之间可以共享相同的内存单元（即内存中的堆区 包括代码和数据）并利用这些共享单元来实现数据交换、实时通信与必要的同步操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程与线程的关系&lt;/strong&gt;：一个进程在其执行的过程中可以产生多个线程，形成多条执行线索，每条线索，即没有线程都有它自身的产生、存在与消亡的过程，也是一个动态的概念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多线程原理&lt;/strong&gt;：我们知道，操作系统分时管理各个进程，按时间片轮流执行每个进程。Java的多线程就是在操作系统每次分时给Java程序一个时间片的cpu时间内，在若干个独立的可控制的线程之间进行切换。如果机器能有多个cpu处理器，那么JVM就能充分利用这些cpu，使得Java程序在同一时刻能获得多个时间片，Java程序就可以获得真实的线程并发执行效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主线程&lt;/strong&gt;：每个Java程序都有一个默认的主线程，这个线程就是当执行主类main方法开始执行时，当JVM加载代码发现main方法之后，就会启动一个线程，这个线程就被称为&lt;strong&gt;“主线程”&lt;/strong&gt;，该线程负责执行main方法，如果在main方法的执行过程中再创建的线程 就称为&lt;strong&gt;其他线程&lt;/strong&gt;。如果main方法中没有创建其他线程，那么当main方法执行完最后一个语句，JVM就会结束Java应用程序。如果main方法中有创建了其他线程，那么JVM就要在主线程和其他线程之间轮流切换，以保证每个线程都能有机会使用cpu资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：main方法即使执行完最后的语句（主线程结束），JVM也不会结束程序，JVM会等待程序中其他线程都结束才会结束Java应用程序。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE" scheme="https://devildyw.github.io/categories/JavaSE/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>每日一记</title>
    <link href="https://devildyw.github.io/2022/02/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    <id>https://devildyw.github.io/2022/02/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-04-16T08:53:30.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h1><hr><h2 id="栈简单应用之符号匹配"><a href="#栈简单应用之符号匹配" class="headerlink" title="栈简单应用之符号匹配"></a>栈简单应用之符号匹配</h2><p><strong>关键：</strong>读括号时，如果时括号的左半部分（正常情况下，括号的左半部分总是先读到）,如果遇到括号的右半部分，获取栈顶元素，如果匹配则弹出栈，如果不匹配依旧弹栈且哨兵flag记为FALSE,最后如果flag为TRUE且栈不为空或是flag为FALSE且栈为空则符号不匹配，如果栈为空且flag为TRUE则符号匹配。</p><span id="more"></span><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DEVIL.泛型与集合框架.堆栈;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil(丁杨维)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-12-18:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">栈应用之符号匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E_04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//先创建一个栈的对象</span></span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//设置哨兵 将他初始化为true</span></span><br><span class="line">        String str;</span><br><span class="line">        <span class="comment">//输入一行字符串其中包含符号(如&#x27;(&#x27; &#x27;)&#x27; &#x27;[&#x27; &#x27;]&#x27; &#x27;&#123;&#x27; &#x27;&#125;&#x27;);</span></span><br><span class="line">        str = sc.nextLine();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;str.length();i++)&#123;<span class="comment">//筛选已输入字符串中符合条件的符号</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&#x27;(&#x27;</span>||ch==<span class="string">&#x27;&#123;&#x27;</span>||ch==<span class="string">&#x27;[&#x27;</span>)&#123;<span class="comment">//如果字符为符合条件且为符号的左半部分则压入栈中</span></span><br><span class="line">                stack.push(ch);<span class="comment">//压栈操作</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果字符为符号的右半部分则获取栈顶元素进行匹配</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;)&#x27;</span>&amp;&amp; !stack.empty())&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.peek() == <span class="string">&#x27;(&#x27;</span>)&#123;<span class="comment">//栈不为空获取栈顶元素进行匹配 匹配成功 弹栈;</span></span><br><span class="line">                    stack.pop();<span class="comment">//弹栈</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;<span class="comment">//除此之外则匹配失败</span></span><br><span class="line">                    stack.pop();<span class="comment">//弹栈</span></span><br><span class="line">                    flag = <span class="literal">false</span>;<span class="comment">//哨兵赋值为false</span></span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//跳出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;&#125;&#x27;</span>&amp;&amp; !stack.empty())&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.peek() == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;]&#x27;</span>&amp;&amp; !stack.empty())&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.peek() == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后如果栈为空且哨兵值为true 则字符串中的符号完全匹配</span></span><br><span class="line">        <span class="keyword">if</span>(flag&amp;&amp;stack.empty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果栈不为空或是哨兵值为false抑或是两者都不满足 则字符串中符号匹配失败</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sc.close();<span class="comment">//最后关闭io流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输入样例1：</p><blockquote><p>{(1+2)*3+4&#x2F;(3-1)</p></blockquote><p>控制台输出：</p><blockquote><p>NO</p></blockquote><p>输入样例2：</p><blockquote><p>(1+2)*3+4&#x2F;(3-1)</p></blockquote><p>控制台输出：</p><blockquote><p>YES</p></blockquote><h2 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h2><hr><p><em><em>对称矩阵可以将一个n * n存储空间的数组压缩成一个n</em>(n+1)&#x2F;2大小的数组</em>* 一般拿一维数组存储。</p><p>接下来代码将展示一般对称矩阵压缩以及还原输出</p><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习题;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil(丁杨维)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-12-20:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对称矩阵</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E_21</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n;<span class="comment">//矩阵的行列数(对称矩阵的前提是行列数都相等)</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;=======================输入数据==============================&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入一个n*n的矩阵的n:&quot;</span>);</span><br><span class="line">        n = sc.nextInt();<span class="comment">//从键盘输入n</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入n*n矩阵的元素:&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[][] Array = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;Array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;Array[i].length; j++)&#123;</span><br><span class="line">                Array[i][j]=sc.nextInt();<span class="comment">//读入矩阵数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSymmetricMatrix(Array))&#123;<span class="comment">//判断是否是对称矩阵</span></span><br><span class="line">            System.out.println(<span class="string">&quot;输入的矩阵是对称矩阵&quot;</span>);</span><br><span class="line">            <span class="type">int</span>[] SymmetricMatrix = <span class="keyword">new</span> <span class="title class_">int</span>[n*(n+<span class="number">1</span>)/<span class="number">2</span>];<span class="comment">//初始化压缩矩阵</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//压缩矩阵下标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;Array.length; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i+<span class="number">1</span>; j++)&#123;</span><br><span class="line">                    SymmetricMatrix[index++] = Array[i][j];<span class="comment">//装载数据</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;=======================输出压缩后的矩阵==============================&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> symmetricMatrix : SymmetricMatrix) &#123;</span><br><span class="line">                System.out.print(symmetricMatrix+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">&quot;=========================还原对阵矩阵============================&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">                        <span class="comment">//上三角元素下标与压缩矩阵元素下标满足关系k = (j*(j+1)/2+i) k为压缩矩阵元素下标</span></span><br><span class="line">                        System.out.print(SymmetricMatrix[j*(j+<span class="number">1</span>)/<span class="number">2</span>+i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//下三角以及对角线元素下标与压缩矩阵元素下标满足关系k = (j*(j+1)/2+i)</span></span><br><span class="line">                        System.out.print(SymmetricMatrix[i*(i+<span class="number">1</span>)/<span class="number">2</span>+j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是对称矩阵的函数;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSymmetricMatrix</span><span class="params">(<span class="type">int</span>[][] Array)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;Array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt;Array[i].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Array[i][j]!=Array[j][i])&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还原对称矩阵时上三角部分：<em><em>上三角部分的元素下标与压缩矩阵元素下标满足关系k &#x3D; (j</em>(j+1)&#x2F;2+i) k为压缩矩阵元素下标</em>*</p><p>还原对称矩阵时上三角部分：<em><em>下三角以及对角线元素下标与压缩矩阵元素下标满足关系k &#x3D; (j</em>(j+1)&#x2F;2+i)</em>*</p><p>输入样例；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=======================输入数据==============================</span><br><span class="line">请输入一个n*n的矩阵的n:2</span><br><span class="line">请输入n*n矩阵的元素:</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">输入的矩阵是对称矩阵</span><br><span class="line">=======================输出压缩后的矩阵==============================</span><br><span class="line">121</span><br><span class="line">=========================还原对阵矩阵============================</span><br><span class="line">12</span><br><span class="line">21</span><br></pre></td></tr></table></figure><hr><p>接下来将展示输入一个已经压缩的对称矩阵将其还原输出</p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习题;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil(丁杨维)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-12-20:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E_22</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n, row;<span class="comment">//用于储存压缩矩阵的大小 和还原矩阵的大小</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;=======================输入数据==============================&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入压缩的对称矩阵的大小n:&quot;</span>);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请给出矩阵元素:&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[] SymmetricMatrix = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">//录入数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            SymmetricMatrix[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出压缩的对称矩阵</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n======================输出压缩的对称矩阵======================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            System.out.print(SymmetricMatrix[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取还原矩阵的行列数</span></span><br><span class="line">        <span class="keyword">for</span>(row = <span class="number">0</span>; row&lt;n; row++)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((row*(row+<span class="number">1</span>)/<span class="number">2</span>)==n)&#123;<span class="comment">//还原矩阵的行列数与压缩矩阵的长度 关系为n*(n+1)/2</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n======================还原输出对称矩阵======================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;row; j++)&#123;<span class="comment">//还原</span></span><br><span class="line">                <span class="keyword">if</span>(i&lt;j)&#123;<span class="comment">//上三角</span></span><br><span class="line">                    <span class="comment">//上三角元素下标与压缩矩阵元素下标满足关系k = (j*(j+1)/2+i) k为压缩矩阵元素下标</span></span><br><span class="line">                    System.out.print(SymmetricMatrix[j*(j+<span class="number">1</span>)/<span class="number">2</span>+i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;<span class="comment">//下三角以及对角线</span></span><br><span class="line">                    <span class="comment">//下三角以及对角线元素下标与压缩矩阵元素下标满足关系k = (j*(j+1)/2+i)</span></span><br><span class="line">                    System.out.print(SymmetricMatrix[i*(i+<span class="number">1</span>)/<span class="number">2</span>+j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输入样例：</p><blockquote><p>10</p><p>1 2 3 4 5 6 7 8 9 10</p></blockquote><p>控制台输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=======================输入数据==============================</span><br><span class="line">请输入压缩的对称矩阵的大小n:10</span><br><span class="line">请给出矩阵元素:</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line"></span><br><span class="line">======================输出压缩的对称矩阵======================</span><br><span class="line">12345678910</span><br><span class="line">======================还原输出对称矩阵======================</span><br><span class="line">1247</span><br><span class="line">2358</span><br><span class="line">4569</span><br><span class="line">78910</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="end"><a href="#end" class="headerlink" title="-end-"></a>-end-</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;栈简单应用之符号匹配&quot;&gt;&lt;a href=&quot;#栈简单应用之符号匹配&quot; class=&quot;headerlink&quot; title=&quot;栈简单应用之符号匹配&quot;&gt;&lt;/a&gt;栈简单应用之符号匹配&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;关键：&lt;/strong&gt;读括号时，如果时括号的左半部分（正常情况下，括号的左半部分总是先读到）,如果遇到括号的右半部分，获取栈顶元素，如果匹配则弹出栈，如果不匹配依旧弹栈且哨兵flag记为FALSE,最后如果flag为TRUE且栈不为空或是flag为FALSE且栈为空则符号不匹配，如果栈为空且flag为TRUE则符号匹配。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://devildyw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo</title>
    <link href="https://devildyw.github.io/2022/02/28/DUBBO/"/>
    <id>https://devildyw.github.io/2022/02/28/DUBBO/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-04-16T08:55:10.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DUBBO"><a href="#DUBBO" class="headerlink" title="DUBBO"></a>DUBBO</h1><h2 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a><a href="https://github.com/guangxush/SpringBoot_GRPC">RPC框架</a></h2><h3 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h3><p>RPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。</p><span id="more"></span><p>比较正式的描述是：一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p><p>那么我们至少从这样的描述中挖掘出几个要点：</p><ul><li>RPC是协议：既然是协议就只是一套规范，那么就需要有人遵循这套规范来进行实现。目前典型的RPC实现包括：Dubbo、Thrift、GRPC、Hetty等。</li><li>网络协议和网络IO模型对其透明：既然RPC的客户端认为自己是在调用本地对象。那么传输层使用的是TCP&#x2F;UDP还是HTTP协议，又或者是一些其他的网络协议它就不需要关心了。</li><li>信息格式对其透明：我们知道在本地应用程序中，对于某个对象的调用需要传递一些参数，并且会返回一个调用结果。至于被调用的对象内部是如何使用这些参数，并计算出处理结果的，调用方是不需要关心的。那么对于远程调用来说，这些参数会以某种信息格式传递给网络上的另外一台计算机，这个信息格式是怎样构成的，调用方是不需要关心的。</li><li>应该有跨语言能力：为什么这样说呢？因为调用方实际上也不清楚远程服务器的应用程序是使用什么语言运行的。那么对于调用方来说，无论服务器方使用的是什么语言，本次调用都应该成功，并且返回值也应该按照调用方程序语言所能理解的形式进行描述。</li></ul><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/640.png" alt="640"></p><hr><h3 id="为什么要用RPC"><a href="#为什么要用RPC" class="headerlink" title="为什么要用RPC"></a>为什么要用RPC</h3><p>其实这是应用开发到一定的阶段的强烈需求驱动的。如果我们开发简单的单一应用，逻辑简单、用户不多、流量不大，那我们用不着。当我们的系统访问量增大、业务增多时，我们会发现一台单机运行此系统已经无法承受。此时，我们可以将业务拆分成几个互不关联的应用，分别部署在各自机器上，以划清逻辑并减小压力。此时，我们也可以不需要RPC，因为应用之间是互不关联的。</p><p>当我们的业务越来越多、应用也越来越多时，自然的，我们会发现有些功能已经不能简单划分开来或者划分不出来。此时，可以将公共业务逻辑抽离出来，将之组成独立的服务Service应用 。而原有的、新增的应用都可以与那些独立的Service应用 交互，以此来完成完整的业务功能。</p><p>所以此时，我们急需一种高效的应用程序之间的通讯手段来完成这种需求，所以你看，RPC大显身手的时候来了！</p><p>其实描述的场景也是服务化 、微服务和分布式系统架构的基础场景。即RPC框架就是实现以上结构的有力方式。</p><h3 id="常用的RPC框架"><a href="#常用的RPC框架" class="headerlink" title="常用的RPC框架"></a>常用的RPC框架</h3><ul><li>Thrift：thrift是一个软件框架，用来进行可扩展且跨语言的服务的开发。它结合了功能强大的软件堆栈和代码生成引擎，以构建在 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml 这些编程语言间无缝结合的、高效的服务。</li><li>gRPC：一开始由 google 开发，是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。</li><li><strong>Dubbo</strong>：Dubbo是一个分布式服务框架，以及SOA治理方案。其功能主要包括：高性能NIO通讯及多协议集成，服务动态寻址与路由，软负载均衡与容错，依赖分析与降级等。Dubbo是阿里巴巴内部的SOA服务化治理方案的核心框架，Dubbo自2011年开源后，已被许多非阿里系公司使用。</li><li><strong>Spring Cloud</strong>：Spring Cloud由众多子项目组成，如Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Consul 等，提供了搭建分布式系统及微服务常用的工具，如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性token、全局锁、选主、分布式会话和集群状态等，满足了构建微服务所需的所有解决方案。Spring Cloud基于Spring Boot, 使得开发部署极其简单。</li></ul><h2 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h2><h3 id="RPC调用流程"><a href="#RPC调用流程" class="headerlink" title="RPC调用流程"></a>RPC调用流程</h3><p>要让网络通信细节对使用者透明，我们需要对通信细节进行封装，我们先看下一个RPC调用的流程涉及到哪些通信细节：</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220306235426986.png" alt="image-20220306235426986"></p><ol><li>服务消费方（client）调用以本地调用方式调用服务；</li><li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li><li>client stub找到服务地址，并将消息发送到服务端；</li><li>server stub收到消息后进行解码；</li><li>server stub根据解码结果调用本地的服务；</li><li>本地服务执行并将结果返回给server stub；</li><li>server stub将返回结果打包成消息并发送至消费方；</li><li>client stub接收到消息，并进行解码；</li><li>服务消费方得到最终结果。</li></ol><p>RPC的目标就是要2~8这些步骤都封装起来，让用户对这些细节透明。</p><p>下面是网上的另外一幅图，感觉一目了然：</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220306235500320.png" alt="image-20220306235500320"></p><h3 id="如何做到透明化远程服务调用"><a href="#如何做到透明化远程服务调用" class="headerlink" title="如何做到透明化远程服务调用"></a>如何做到透明化远程服务调用</h3><p>怎么封装通信细节才能让用户像以本地调用方式调用远程服务呢？对java来说就是使用代理！java代理有两种方式：1） jdk 动态代理；2）字节码生成。尽管字节码生成方式实现的代理更为强大和高效，但代码维护不易，大部分公司实现RPC框架时还是选择动态代理方式。</p><blockquote><p>其实就是通过动态代理模式，在执行该方法的前后对数据进行封装和解码等，让用于感觉就像是直接调用该方法一样，殊不知，我们对方法前后都经过了复杂的处理。(通过代理实现在调用方法前后进行编码和译码)</p></blockquote><h3 id="如何对消息进行编码和解码"><a href="#如何对消息进行编码和解码" class="headerlink" title="如何对消息进行编码和解码"></a>如何对消息进行编码和解码</h3><h4 id="确定消息数据结构"><a href="#确定消息数据结构" class="headerlink" title="确定消息数据结构"></a>确定消息数据结构</h4><p>客户端的请求消息结构一般需要包括以下内容：</p><ul><li>接口名称：在我们的例子里接口名是“HelloWorldService”，如果不传，服务端就不知道调用哪个接口了；</li><li>方法名：一个接口内可能有很多方法，如果不传方法名服务端也就不知道调用哪个方法；</li><li>参数类型&amp;参数值：参数类型有很多，比如有bool、int、long、double、string、map、list，甚至如struct等，以及相应的参数值；</li><li>超时时间 + requestID（标识唯一请求id）</li></ul><p>服务端返回的消息结构一般包括以下内容：</p><ul><li>状态code + 返回值</li><li>requestID(<strong>可以根据requestID去查验调用结果</strong>)</li></ul><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>一旦确定了消息的数据结构后，下一步就是要考虑序列化与反序列化了。</p><p>什么是序列化？序列化就是将数据结构或对象转换成二进制串的过程，也就是编码的过程。</p><p>什么是反序列化？将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。</p><p>为什么需要序列化？转换为二进制串后才好进行网络传输嘛！</p><p>为什么需要反序列化？将二进制转换为对象才好进行后续处理！</p><p>现如今序列化的方案越来越多，每种序列化方案都有优点和缺点，它们在设计之初有自己独特的应用场景，那到底选择哪种呢？从RPC的角度上看，主要看三点：</p><ul><li>通用性：比如是否能支持Map等复杂的数据结构；</li><li>性能：包括时间复杂度和空间复杂度，由于RPC框架将会被公司几乎所有服务使用，如果序列化上能节约一点时间，对整个公司的收益都将非常可观，同理如果序列化上能节约一点内存，网络带宽也能省下不少；</li><li>可扩展性：对互联网公司而言，业务变化飞快，如果序列化协议具有良好的可扩展性，支持自动增加新的业务字段，而不影响老的服务，这将大大提供系统的灵活度。</li></ul><p>目前互联网公司广泛使用Protobuf、Thrift、Avro等成熟的序列化解决方案来搭建RPC框架，这些都是久经考验的解决方案。</p><h3 id="如何发布自己的服务"><a href="#如何发布自己的服务" class="headerlink" title="如何发布自己的服务"></a>如何发布自己的服务</h3><p>通过注册中心将生产者和消费者联系起来,将生产者(消息的提供者)注册到注册中心,消费者通过与注册中心的长连接获得生产者的ip去获得服务. <strong>java常用的是zookeeper</strong></p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220306235517192.png" alt="image-20220306235517192"></p><hr><h2 id="Dubbo-Architecture"><a href="#Dubbo-Architecture" class="headerlink" title="Dubbo Architecture"></a><a href="https://dubbo.apache.org/zh/docs/">Dubbo Architecture</a></h2><p>Dubbo 提供了构建云原生微服务业务的一站式解决方案，可以使用 Dubbo 快速定义并发布微服务组件，同时基于 Dubbo 开箱即用的丰富特性及超强的扩展能力，构建运维整个微服务体系所需的各项服务治理能力，如 Tracing、Transaction 等，Dubbo 提供的基础能力包括：</p><ul><li>服务发现</li><li>流式通信</li><li>负载均衡</li><li>流量治理</li><li>…..</li></ul><p>Dubbo 计划提供丰富的多语言客户端实现，其中 Java、Golang 版本是当前稳定性、活跃度最好的版本，其他多语言客户端[]正在持续建设中。</p><p><strong>Dubbo的优点</strong>:</p><blockquote><ul><li>开箱即用<ul><li>易用性高，如 Java 版本的面向接口代理特性能实现本地透明调用</li><li>功能丰富，基于原生库或轻量扩展即可实现绝大多数的微服务治理能力</li></ul></li><li>超大规模微服务集群实践<ul><li>高性能的跨进程通信协议</li><li>地址发现、流量治理层面，轻松支持百万规模集群实例</li></ul></li><li>企业级微服务治理能力<ul><li>服务测试</li><li>服务Mock</li></ul></li></ul></blockquote><p>Dubbo3 是在云原生背景下诞生的，使用 Dubbo 构建的微服务遵循云原生思想，能更好的复用底层云原生基础设施、贴合云原生微服务架构。这体现在：</p><ul><li>服务支持部署在容器、Kubernetes平台，服务生命周期可实现与平台调度周期对齐；</li><li>支持经典 Service Mesh 微服务架构，引入了 Proxyless Mesh 架构，进一步简化 Mesh 的落地与迁移成本，提供更灵活的选择；</li><li>作为桥接层，支持与 SpringCloud、gRPC 等异构微服务体系的互调互通</li></ul><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>服务发现，即消费端自动发现服务地址列表的能力，是微服务框架需要具备的关键能力，借助于自动化的服务发现，微服务之间可以在无需感知对端部署位置与 IP 地址的情况下实现通信。</p><p>Dubbo提供的是一种Client-Based的服务发现机制,通常还需要部署第三方的注册中心来实现,例如Nacos,Consul,Zookeeper等,Dubbo自身也提供了对多种注册中心组件的对接,用户可以灵活选择.</p><p>Dubbo 基于消费端的自动服务发现能力，其基本工作原理如下图：</p><p><img src="https://dubbo.apache.org/imgs/architecture.png" alt="//imgs/architecture.png"></p><p><img src="https://dubbo.apache.org/imgs/v3/concepts/threecenters.png" alt="//imgs/v3/concepts/threecenters.png"></p><p>服务发现的一个核心组件是注册中心,Provider注册ip地址到注册中心,Consumer从注册中心读取和订阅Provider地址列表,因此要启用服务发现需要为Dubbo增加注册中心的配置</p><p><code>dubbo-spring-boot-starter</code>使用方式 增加registry配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"><span class="string">dubbo</span></span><br><span class="line"> <span class="string">registry</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">zookeeper://127.0.0.1:2181</span></span><br></pre></td></tr></table></figure><h3 id="Dubbo的协议-RPC-通信协议-Apache-Dubbo"><a href="#Dubbo的协议-RPC-通信协议-Apache-Dubbo" class="headerlink" title="]Dubbo的协议](RPC 通信协议 | Apache Dubbo)"></a>]Dubbo的协议](<a href="https://dubbo.apache.org/zh/docs/concepts/rpc-protocol/">RPC 通信协议 | Apache Dubbo</a>)</h3><ul><li><p><strong>Triple</strong></p><blockquote><p><strong>Triple</strong>是一种兼容 gRPC ，以 HTTP2 作为传输层构建新的协议.</p></blockquote></li></ul><h3 id="Dubbo-服务流量管理-服务流量管理-Apache-Dubbo"><a href="#Dubbo-服务流量管理-服务流量管理-Apache-Dubbo" class="headerlink" title="[Dubbo 服务流量管理](服务流量管理 | Apache Dubbo)"></a>[Dubbo 服务流量管理](<a href="https://dubbo.apache.org/zh/docs/concepts/traffic-management/">服务流量管理 | Apache Dubbo</a>)</h3><h4 id="流量管理"><a href="#流量管理" class="headerlink" title="流量管理"></a>流量管理</h4><p>流量管理的本质是将请求根据制定好的路由规则分发到应用服务上，如下图所示：</p><p><img src="https://dubbo.apache.org/imgs/v3/concepts/what-is-traffic-control.png" alt="What is traffic control"></p><ul><li>路由规则可以有多个，不同的路由规则之间存在优先级。如：<strong>Router(1) -&gt; Router(2) -&gt; …… -&gt; Router(n)</strong></li><li>一个路由规则可以路由到多个不同的应用服务。如：Router(2)既可以路由到Service(1)也可以路由到Service(2)</li><li>多个不同的路由规则可以路由到同一个应用服务。如：Router(1)和Router(2)都可以路由到Service(2)</li><li>路由规则也可以不路由到任何应用服务。如：Router(m)没有路由到任何一个Service上，所有命中Router(m)的请求都会因为没有对应的应用服务处理而导致报错</li><li>应用服务可以是单个的实例，也可以是一个应用集群。</li></ul><h3 id="Dubbo的配置"><a href="#Dubbo的配置" class="headerlink" title="Dubbo的配置"></a>Dubbo的配置</h3><h4 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h4><p>即采用xml格式的配置文件 配置Dubbo 详情参数和配置参考官方文档</p><p><a href="https://dubbo.apache.org/zh/docs/references/xml/">Schema 配置参考手册 | Apache Dubbo</a></p><h4 id="注解配置-注解配置-Apache-Dubbo"><a href="#注解配置-注解配置-Apache-Dubbo" class="headerlink" title="[注解配置](注解配置 | Apache Dubbo)"></a>[注解配置](<a href="https://dubbo.apache.org/zh/docs/references/configuration/annotation/#%E5%A2%9E%E5%8A%A0%E5%BA%94%E7%94%A8%E5%85%B1%E4%BA%AB%E9%85%8D%E7%BD%AE">注解配置 | Apache Dubbo</a>)</h4><h5 id="服务提供方"><a href="#服务提供方" class="headerlink" title="服务提供方"></a>服务提供方</h5><p>**<code>@DubboService</code>**注解暴露服务</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DubboService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AnnotationService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;annotation: hello, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="增加应用共享配置"><a href="#增加应用共享配置" class="headerlink" title="增加应用共享配置"></a>增加应用共享配置</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dubbo-provider.properties</span></span><br><span class="line"><span class="attr">dubbo.application.name</span>=<span class="string">annotation-provider</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="attr">dubbo.protocol.name</span>=<span class="string">dubbo</span></span><br><span class="line"><span class="attr">dubbo.protocol.port</span>=<span class="string">20880</span></span><br></pre></td></tr></table></figure><h5 id="增加spring扫描路径"><a href="#增加spring扫描路径" class="headerlink" title="增加spring扫描路径"></a>增加spring扫描路径</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableDubbo(scanBasePackages = &quot;org.apache.dubbo.samples.simple.annotation.impl&quot;)</span><span class="comment">//也可以在启动类上配置 启动类本身也就是一个配置类</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/spring/dubbo-provider.properties&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderConfiguration</span> &#123;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="服务消费方"><a href="#服务消费方" class="headerlink" title="服务消费方"></a>服务消费方</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;annotationAction&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationAction</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DubboReference</span></span><br><span class="line">    <span class="keyword">private</span> AnnotationService annotationService;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doSayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> annotationService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="增加应用共享配置-1"><a href="#增加应用共享配置-1" class="headerlink" title="增加应用共享配置"></a>增加应用共享配置</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dubbo-consumer.properties</span></span><br><span class="line"><span class="attr">dubbo.application.name</span>=<span class="string">annotation-consumer</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="attr">dubbo.consumer.timeout</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure><h5 id="指定Spring扫描路径"><a href="#指定Spring扫描路径" class="headerlink" title="指定Spring扫描路径"></a>指定Spring扫描路径</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableDubbo(scanBasePackages = &quot;org.apache.dubbo.samples.simple.annotation.action&quot;)</span><span class="comment">//同样可以在启动类中配置 也可在配置文件中配置</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/spring/dubbo-consumer.properties&quot;)</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &#123;&quot;org.apache.dubbo.samples.simple.annotation.action&quot;&#125;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用服务"><a href="#调用服务" class="headerlink" title="调用服务"></a>调用服务</h4><p>配置完一切就可以(先启动生产者 在启动消费者)像调用本地方法一样去调用远程服务了(不用去考虑底层的传输协议 编码解码之类的繁琐的东西)</p><hr><h3 id="Dubbo的使用"><a href="#Dubbo的使用" class="headerlink" title="Dubbo的使用"></a>Dubbo的使用</h3><p>对于Dubbo而言一个完整的简单的Dubbo项目应该有如下三个模块 生产者(服务的提供者) 消费者(服务的消费者) API(暴露的接口名称和公共可用的信息)</p><ul><li><p>创建一个简单的Demo Maven工程</p></li><li><p>创建三个子工程分别是**<code>consumer provider dubbo-api</code>**</p></li><li><p>首先编写dubbo-api编写其中的service接口和需要用的其他信息(consumer和provider都能用到的信息 比如实体类 访问的param对象等)注意: 类应当实现序列化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MailUserService</span> &#123;</span><br><span class="line">    Result <span class="title function_">save</span><span class="params">(MailUser mailUser)</span>;</span><br><span class="line"></span><br><span class="line">    Result&lt;MailUser&gt; <span class="title function_">selectUserById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    Result&lt;MailUser&gt; <span class="title function_">selectUserByInfo</span><span class="params">(MailUser mailUser)</span>;</span><br><span class="line"></span><br><span class="line">    Result&lt;List&lt;MailUser&gt;&gt; <span class="title function_">selectUserList</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Result&lt;String&gt; <span class="title function_">sendMail</span><span class="params">(MailDTO mailDTO)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220306214920772.png" alt="image-20220306214920772"></p><p><strong>然后将其打包上传到本地仓库或是远程仓库供生产者和消费者使用</strong></p></li><li><p>在provider 和 consumer中都加入 </p><blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--这个是dubbo的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这个是注册中心的依赖 这里使用的是zookeeper--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-dependencies-zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这个是公用的api依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dyw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Demo-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.2-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>在provider中实现dubbo-api中的编写的接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@DubboService</span> <span class="comment">//使用该注解可以将该服务注册到注册中心 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailUserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MailUserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(MailUser mailUser)</span> &#123;</span><br><span class="line">        userMapper.insert(mailUser);</span><br><span class="line">        <span class="keyword">return</span> R.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;MailUser&gt; <span class="title function_">selectUserById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;MailUser&gt; mailUserLambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        mailUserLambdaQueryWrapper.eq(MailUser::getId, id).last(<span class="string">&quot;last 1&quot;</span>);</span><br><span class="line">        <span class="type">MailUser</span> <span class="variable">mailUser</span> <span class="operator">=</span> userMapper.selectOne(mailUserLambdaQueryWrapper);</span><br><span class="line">        <span class="keyword">return</span> R.success(mailUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;MailUser&gt; <span class="title function_">selectUserByInfo</span><span class="params">(MailUser mailUser)</span> &#123;</span><br><span class="line">        <span class="type">MailUser</span> <span class="variable">mailUser1</span> <span class="operator">=</span> userMapper.selectById(mailUser);</span><br><span class="line">        <span class="keyword">return</span> R.success(mailUser1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;MailUser&gt;&gt; <span class="title function_">selectUserList</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;MailUser&gt; mailUsers = userMapper.selectList(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> R.success(mailUsers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">sendMail</span><span class="params">(MailDTO mailDTO)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; idList = mailDTO.getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sendTime</span> <span class="operator">=</span> mailDTO.getSendTime();</span><br><span class="line">        <span class="type">String</span> <span class="variable">subject</span> <span class="operator">=</span> mailDTO.getSubject();</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> mailDTO.getContent();</span><br><span class="line">        List&lt;MailUser&gt; userList = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(subject) || StringUtils.isBlank(content)) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.fail(<span class="string">&quot;参数有误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idList.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            userList = userMapper.selectList(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            userList = userMapper.selectBatchIds(idList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(sendTime)) &#123;</span><br><span class="line">            sendTime = <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        mailDTO.setUserList(userList);</span><br><span class="line">        mailDTO.setSendTime(sendTime);</span><br><span class="line"></span><br><span class="line">        rocketMQTemplate.asyncSend(<span class="string">&quot;notice:mail&quot;</span>, mailDTO, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;发送信息成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;发送失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> R.success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>编写实现完所有的接口后 记得将服务注册到注册中心 这里需要配置dubbo 和 服务中心的信息</p><blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">&gt;dubbo:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Demo-provider</span> <span class="comment">#应用名称</span></span><br><span class="line"><span class="attr">registry:</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">zookeeper://localhost:2181</span> <span class="comment">#注册中心地址</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">6000</span> <span class="comment">#获取配置的超时时间</span></span><br><span class="line"><span class="attr">protocol:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">20880</span> <span class="comment">#服务端口</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dubbo</span> <span class="comment">#协议名称</span></span><br><span class="line"><span class="attr">scan:</span></span><br><span class="line">  <span class="attr">base-packages:</span> <span class="string">com.dyw.demoprovider.service.Impl</span> <span class="comment"># 扫描服务实现的包的位置 使用注解时才使用</span></span><br></pre></td></tr></table></figure><p>紧接着就是配置需要注册到注册中心的服务的信息(可以使用注解)如果使用spring-config配置服务的信息</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">     http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;demo-provider&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20890&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.dubbo.samples.basic.impl.DemoServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;org.apache.dubbo.samples.basic.api.DemoService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;demoService&quot;</span>/&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>在consumer中也需要配置注册中心的信息 来获取远端信息</p><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;dubbo:</span><br><span class="line">registry:</span><br><span class="line">  address: zookeeper:<span class="comment">//localhost:2181</span></span><br><span class="line">application:</span><br><span class="line">  name: Demo-Consumer</span><br></pre></td></tr></table></figure><p>完成上述配置后 就可以进行接口的调用了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">@RestController</span></span><br><span class="line">&gt;<span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="meta">@DubboReference</span></span><br><span class="line">  MailUserService mailUserService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span></span><br><span class="line">  <span class="keyword">public</span> Result&lt;List&lt;MailUser&gt;&gt; <span class="title function_">selectUserList</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mailUserService.selectUserList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span></span><br><span class="line">  <span class="keyword">public</span> Result&lt;MailUser&gt; <span class="title function_">addUser</span><span class="params">(<span class="meta">@RequestBody</span> MailUser mailUser)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mailUserService.save(mailUser);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Result&lt;MailUser&gt; <span class="title function_">selectUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mailUserService.selectUserById(id);</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">@RestController</span></span><br><span class="line">&gt;<span class="meta">@RequestMapping(&quot;mail&quot;)</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailController</span> &#123;</span><br><span class="line">  <span class="meta">@DubboReference</span></span><br><span class="line">  MailUserService mailUserService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span></span><br><span class="line">  <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">sendMail</span><span class="params">(<span class="meta">@RequestBody</span> MailDTO mailDTO)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mailUserService.sendMail(mailDTO);</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><p>你会发现一个有意思的事情 比如 我的mybatis log配置在生产者端 但是确实我的消费端看到了日志信息. 这也说明了服务是在消费者端实现的 证明了上述RPC框架的图</p></li></ul><h2 id="Dubbo高级用法"><a href="#Dubbo高级用法" class="headerlink" title="Dubbo高级用法"></a>Dubbo高级用法</h2><p>参考官方文档 用法很多</p><p><a href="https://dubbo.apache.org/zh/docs/advanced/">高级用法 | Apache Dubbo</a></p><h1 id="—-END—"><a href="#—-END—" class="headerlink" title="—-END—-"></a>—-END—-</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;DUBBO&quot;&gt;&lt;a href=&quot;#DUBBO&quot; class=&quot;headerlink&quot; title=&quot;DUBBO&quot;&gt;&lt;/a&gt;DUBBO&lt;/h1&gt;&lt;h2 id=&quot;RPC框架&quot;&gt;&lt;a href=&quot;#RPC框架&quot; class=&quot;headerlink&quot; title=&quot;RPC框架&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/guangxush/SpringBoot_GRPC&quot;&gt;RPC框架&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;什么是RPC&quot;&gt;&lt;a href=&quot;#什么是RPC&quot; class=&quot;headerlink&quot; title=&quot;什么是RPC&quot;&gt;&lt;/a&gt;什么是RPC&lt;/h3&gt;&lt;p&gt;RPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。&lt;/p&gt;</summary>
    
    
    
    <category term="中间件" scheme="https://devildyw.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ</title>
    <link href="https://devildyw.github.io/2022/02/28/RocketMQ/"/>
    <id>https://devildyw.github.io/2022/02/28/RocketMQ/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-04-16T08:55:31.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/concept.md">RocketMQ</a></h1><p><strong>MQ(Message Queue)</strong>:消息队列</p><span id="more"></span><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="消息模型（Message-Model）"><a href="#消息模型（Message-Model）" class="headerlink" title="消息模型（Message Model）:"></a>消息模型（Message Model）:</h3><p>RocketMQ主要由 <strong>Producer、Broker、Consumer 三部分组成</strong>，其中Producer 负责生产消息，Consumer 负责消费消息，<strong>Broker 负责存储消息</strong>。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。</p><h3 id="消息生产者（Producer）"><a href="#消息生产者（Producer）" class="headerlink" title="消息生产者（Producer）:"></a>消息生产者（Producer）:</h3><p>负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，<strong>同步发送、异步发送、顺序发送、单向发送</strong>。<strong>同步和异步方式均需要Broker返回确认信息，单向发送不需要。</strong></p><h3 id="消息消费者（Consumer）"><a href="#消息消费者（Consumer）" class="headerlink" title="消息消费者（Consumer）:"></a>消息消费者（Consumer）:</h3><p>负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。</p><h3 id="主题（Topic）"><a href="#主题（Topic）" class="headerlink" title="主题（Topic）:"></a>主题（Topic）:</h3><p>表示一类消息的集合，<strong>每个主题包含若干条消息，每条消息只能属于一个主题</strong>，(topic)<strong>是RocketMQ进行消息订阅的基本单位。</strong></p><h3 id="代理服务器（Broker-Server）"><a href="#代理服务器（Broker-Server）" class="headerlink" title="代理服务器（Broker Server）:"></a>代理服务器（Broker Server）:</h3><p><strong>消息中转角色，负责存储消息、转发消息。</strong>代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p><h3 id="名字服务（Name-Server）"><a href="#名字服务（Name-Server）" class="headerlink" title="名字服务（Name Server）:"></a>名字服务（Name Server）:</h3><p>名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/2ms3i8hm3a.jpg" alt="2ms3i8hm3a"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220222203606812.png" alt="image-20220222203606812"></p><p>由上图可知 Broker集群,producer集群,consumer集群都要与NameServer集群进行通信.</p><h3 id="拉取式消费（Pull-Consumer）"><a href="#拉取式消费（Pull-Consumer）" class="headerlink" title="拉取式消费（Pull Consumer）:"></a>拉取式消费（Pull Consumer）:</h3><p>Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、<strong>主动权由应用控制</strong>。一旦获取了批量消息，应用就会启动消费过程。</p><h3 id="推动式消费（Push-Consumer）"><a href="#推动式消费（Push-Consumer）" class="headerlink" title="推动式消费（Push Consumer）:"></a>推动式消费（Push Consumer）:</h3><p>Consumer消费的一种类型，<strong>该模式下Broker收到数据后会主动推送给消费端</strong>，该消费模式一般实时性较高。</p><h3 id="生产者组（Producer-Group）"><a href="#生产者组（Producer-Group）" class="headerlink" title="生产者组（Producer Group）:"></a>生产者组（Producer Group）:</h3><p><strong>同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。</strong>如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p><h3 id="消费者组（Consumer-Group）"><a href="#消费者组（Consumer-Group）" class="headerlink" title="消费者组（Consumer Group）:"></a>消费者组（Consumer Group）:</h3><p><strong>同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。</strong>消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，<strong>消费者组的消费者实例必须订阅完全相同的Topic。</strong>RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p><h3 id="集群消费（Clustering）"><a href="#集群消费（Clustering）" class="headerlink" title="集群消费（Clustering）:"></a>集群消费（Clustering）:</h3><p>集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</p><h3 id="广播消费（Broadcasting）"><a href="#广播消费（Broadcasting）" class="headerlink" title="广播消费（Broadcasting）:"></a>广播消费（Broadcasting）:</h3><p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。</p><h3 id="普通顺序消息（Normal-Ordered-Message）"><a href="#普通顺序消息（Normal-Ordered-Message）" class="headerlink" title="普通顺序消息（Normal Ordered Message）:"></a>普通顺序消息（Normal Ordered Message）:</h3><p>普通顺序消费模式下，消费者通过同一个消息队列（ Topic 分区，称作 Message Queue） 收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。</p><h3 id="严格顺序消息（Strictly-Ordered-Message）"><a href="#严格顺序消息（Strictly-Ordered-Message）" class="headerlink" title="严格顺序消息（Strictly Ordered Message）:"></a>严格顺序消息（Strictly Ordered Message）:</h3><p>严格顺序消息模式下，消费者收到的所有消息均是有顺序的。</p><h3 id="消息（Message）"><a href="#消息（Message）" class="headerlink" title="消息（Message）:"></a>消息（Message）:</h3><p><strong>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。</strong>RocketMQ中<strong>每个消息拥有唯一的Message ID</strong>，且<strong>可以携带具有业务标识的Key</strong>。系统提供了<strong>通过Message ID和Key查询消息</strong>的功能。</p><h3 id="标签（Tag）"><a href="#标签（Tag）" class="headerlink" title="标签（Tag）:"></a>标签（Tag）:</h3><p><strong>为消息设置的标志，用于同一主题下区分不同类型的消息。</strong>来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。<strong>标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统</strong>。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p><h3 id="MQ-Messages-Queue-三大优点"><a href="#MQ-Messages-Queue-三大优点" class="headerlink" title="MQ(Messages Queue)三大优点:"></a>MQ(Messages Queue)三大优点:</h3><ul><li>应用解耦: <strong>提高系统的容错性和可维护性</strong></li><li>削峰填谷: <strong>提升用户体验和系统的吞吐量</strong></li><li>异步提速:<strong>提高系统的稳定性</strong></li></ul><h3 id="通常的MQ-三大缺点"><a href="#通常的MQ-三大缺点" class="headerlink" title="通常的MQ 三大缺点:"></a>通常的MQ 三大缺点:</h3><ul><li><p>应用可用性降低</p><blockquote><p>系统引入的外部依赖越多, 系统的稳定性越差,一旦MQ宕机,就会对业造成影响.</p></blockquote></li><li><p>系统的复杂度提高</p><blockquote><p>MQ的加入大大增加了系统的复杂度,以前系统间是同步的远程调用,现在是通过MQ进行异步调用.</p></blockquote></li><li><p>一致性的问题(A B系统正常 但是C系统处理失败 会发生事务问题)</p><blockquote><p>A系统处理完业务,通过MQ给BCD三个系统发送消息数据,如果B系统,C系统处理成功,D系统处理失败.</p></blockquote></li></ul><hr><h2 id="单对单模式-初始RocketMQ"><a href="#单对单模式-初始RocketMQ" class="headerlink" title="单对单模式(初始RocketMQ)"></a>单对单模式(初始RocketMQ)</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><blockquote><ul><li>谁来发</li><li>发给谁</li><li>启动连接</li><li>发什么</li><li>怎么发</li><li>发的结果是?</li><li>关闭连接</li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQBrokerException, RemotingException, InterruptedException, MQClientException &#123;</span><br><span class="line">        <span class="comment">//1. 谁来发?</span></span><br><span class="line">        <span class="comment">//创建一个生产者</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="comment">/*可以在这里设置名称*/</span><span class="string">&quot;group1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.发给谁</span></span><br><span class="line">        <span class="comment">//发送给命名服务器 通过Name Server分配Brokerip 再由生产者发送给broker</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动连接</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.怎么发</span></span><br><span class="line">        <span class="comment">//发送Message apache包下的 网络传输都是字节流传输</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic1&quot;</span>,<span class="string">&quot;Tag1&quot;</span>,(<span class="string">&quot;Hello World&quot;</span>).getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.发什么</span></span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.发的结果是什么</span></span><br><span class="line">        <span class="comment">//SendResult 就是发送后的结果</span></span><br><span class="line">        System.out.println(sendResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.打扫战场</span></span><br><span class="line">        <span class="comment">//生产者是与name Server建立了一个长连接进行发送消息 所以发送完毕后 关闭连接</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><blockquote><ul><li>谁来收</li><li>从哪里收</li><li>监听那个消息队列</li><li>处理业务流程</li><li>启动连接</li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.谁来收</span></span><br><span class="line">        <span class="comment">//消费者有两种模式 一种是拉去(需要消费者自己去拉去) 一种是推送(消息主动推送给消费者)</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">pushConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.从哪里收</span></span><br><span class="line">        <span class="comment">//与生产者一样 消费者 也许要去name Server中获得对应broker的地址去获得消息</span></span><br><span class="line">        pushConsumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.监听那个消息队列</span></span><br><span class="line">        <span class="comment">//设置监听队列 subscribe:订阅 指定主题 和订阅表达式 &quot;*&quot;表示订阅主题中的所有</span></span><br><span class="line">        pushConsumer.subscribe(<span class="string">&quot;Topic1&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.处理业务流程</span></span><br><span class="line">        <span class="comment">//注册一个监听器 去监听是否有消息被生产 一有就立刻接收</span></span><br><span class="line">        pushConsumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                <span class="comment">//接收到的消息就是 List&lt;MessageExt&gt; msgs 这时我们就能写我们的业务逻辑</span></span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//启动连接</span></span><br><span class="line">        pushConsumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消费者启动起来了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意不要关闭消费者(如果还有对应主题的生产者的情况下 关闭就无法监听消息 就无法收到消息了)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一对多-单生产者-多消费者模式"><a href="#一对多-单生产者-多消费者模式" class="headerlink" title="一对多(单生产者 多消费者模式)"></a>一对多(单生产者 多消费者模式)</h2><h3 id="多消费者都在同一组中时"><a href="#多消费者都在同一组中时" class="headerlink" title="多消费者都在同一组中时"></a>多消费者都在同一组中时</h3><p><strong>消息会被分配到该组的不同消费者手中(当一个组中的消费者为偶数时平分)</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220223173114990.png" alt="image-20220223173114990"></p><h3 id="多消费者在不同组时"><a href="#多消费者在不同组时" class="headerlink" title="多消费者在不同组时"></a>多消费者在不同组时</h3><p><strong>每个组都会有完整的消息数目和消息信息(广播式 消息先被复制到不同的消费者组)</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220223173349238.png" alt="image-20220223173349238"></p><p>**特别的:**如果想在同一组中实现广播模式 可以在接收消息前设置消息的模式</p><blockquote><p><code>Consumer.setMessageModel(消息模式);</code></p><p>默认是CLUSTERING 负载均衡模式</p><p>可以设置为BROADCASTING 就是广播模式</p></blockquote><h2 id="多对多-多生产者-多消费者模式"><a href="#多对多-多生产者-多消费者模式" class="headerlink" title="多对多(多生产者 多消费者模式)"></a>多对多(多生产者 多消费者模式)</h2><p>对于生产者生产的消息而言</p><hr><h2 id="消息类别"><a href="#消息类别" class="headerlink" title="消息类别"></a>消息类别</h2><h3 id="同步消息"><a href="#同步消息" class="headerlink" title="同步消息"></a>同步消息</h3><p><strong>特征:</strong> 即时性较强,重要的消息,且必须有回执的消息,例如短息,通知(转账成功)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;Devilsproducer&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicTest&quot;</span>,<span class="string">&quot;TagA&quot;</span>,(<span class="string">&quot;Hello RocketMq &quot;</span>+ i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s%n&quot;</span>,sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步消息"><a href="#异步消息" class="headerlink" title="异步消息"></a>异步消息</h3><p><strong>特征:</strong> 即时性较弱,但需要有回执的消息,例如订单中的某些信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group3&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic3&quot;</span>, <span class="string">&quot;tag1&quot;</span>, msg.getBytes());</span><br><span class="line">            <span class="comment">//异步消息 Callback也是一个多线的接口</span></span><br><span class="line">            producer.send(message, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">                <span class="comment">//发送成功的回调方法a</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">                    System.out.println(sendResult);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//发送失败的回调方法</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                    System.out.println(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;异步发送完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单向消息"><a href="#单向消息" class="headerlink" title="单向消息"></a>单向消息</h3><p><strong>特征:</strong> 不需要有回执的信息,例如日志类消息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneWayProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group3&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//单项消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>+i;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic1&quot;</span>, <span class="string">&quot;tag1&quot;</span>, msg.getBytes());</span><br><span class="line">            <span class="comment">//发送单项消息 没有回执消息</span></span><br><span class="line">            producer.sendOneway(message);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送完成了&quot;</span>);</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h3><p><strong>特征:</strong> 消息发送时并不直接发送到消息服务器,而是根据设定等待的时间到达,起到延时到达的缓冲作用</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220223203009432.png" alt="image-20220223203009432"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//延时消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>+i;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic1&quot;</span>, <span class="string">&quot;tag1&quot;</span>, msg.getBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置延时 能分别设置每一条消息的延时等级 数字对应等级 而不是真正的时间</span></span><br><span class="line">            message.setDelayTimeLevel(<span class="number">4</span>);</span><br><span class="line">            <span class="comment">//发送延时消息</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line">            System.out.println(sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送成功了&quot;</span>);</span><br><span class="line">        <span class="comment">//断开连接</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h3><p><strong>特征:</strong> 一次发送多条消息,节约网络开销</p><p>原理就是通过producer可以通过send方法发送Collection(集合)的缘故 这样我们就可以将Message对象封装到一个集合中 通过send方法完成批量消息的发送</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过producer的send方法可以传输Collection的机制 我们只需要将消息封装到一个集合中 我们就能发送批量消息了</span></span><br><span class="line">        ArrayList&lt;Message&gt; messages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>+i;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic1&quot;</span>, <span class="string">&quot;tag1&quot;</span>, msg.getBytes());</span><br><span class="line">            messages.add(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//批量发送</span></span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">send</span> <span class="operator">=</span> producer.send(messages);</span><br><span class="line">        System.out.println(send);</span><br><span class="line">        System.out.println(<span class="string">&quot;批量消息发送成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><blockquote><ul><li><p>这些批量消息应该有相同的topic</p></li><li><p>相同的waitStoreMsgOK</p></li><li><p>不能是延时消息</p></li><li><p>消息内容的总长度不能超过4M</p></li><li><p>消息内容总长度包含如下:</p><blockquote><ol><li>topic(字符串字节数)</li><li>body(字节数组长度)</li><li>消息追加的属性(key与value对应的字符串字节数)</li><li>日志(固定20字节)</li></ol></blockquote></li></ul></blockquote><h2 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h2><p>语法过滤(属性过滤&#x2F;语法过滤&#x2F;SQL过滤):按照消息的某些属性过滤;</p><p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220223210153476.png" alt="image-20220223210153476"></p><p>针对消费者而言在设置订阅消息的模式时, 可以设置主题(Topic) 还可以设置订阅表达式 该订阅表示就是用来过滤你要接收的消息的</p><hr><h3 id="Tag过滤"><a href="#Tag过滤" class="headerlink" title="Tag过滤"></a>Tag过滤</h3><p><strong><code>pushConsumer.subscribe(&quot;Topic1&quot;,MessageSelector.byTag(&quot;Tag1 || vip&quot;));</code></strong></p><p>表示只接收标签为Tag1 或者 vip的消息(默认不指定也是以Tag执行)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.谁来收</span></span><br><span class="line">        <span class="comment">//消费者有两种模式 一种是拉去(需要消费者自己去拉去) 一种是推送(消息主动推送给消费者)</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">pushConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.从哪里收</span></span><br><span class="line">        <span class="comment">//与生产者一样 消费者 也许要去name Server中获得对应broker的地址去获得消息</span></span><br><span class="line">        pushConsumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.监听那个消息队列</span></span><br><span class="line">        <span class="comment">//设置监听队列 subscribe:订阅 指定主题 和订阅表达式 &quot;*&quot;表示订阅主题中的所有</span></span><br><span class="line">        pushConsumer.subscribe(<span class="string">&quot;Topic1&quot;</span>,<span class="string">&quot;Tag1 || vip&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.处理业务流程</span></span><br><span class="line">        <span class="comment">//注册一个监听器 去监听是否有消息被生产 一有就立刻接收</span></span><br><span class="line">        pushConsumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                <span class="comment">//接收到的消息就是 List&lt;MessageExt&gt; msgs 这时我们就能写我们的业务逻辑</span></span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//启动连接</span></span><br><span class="line">        pushConsumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消费者启动起来了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意不要关闭消费者(如果还有对应主题的生产者的情况下 关闭就无法监听消息 就无法收到消息了)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SQL过滤"><a href="#SQL过滤" class="headerlink" title="SQL过滤"></a>SQL过滤</h3><p>要是使用sql过滤首先生产者方在发送消息时需要给消息添加参数 <strong><code>message.putUserProperty(&quot;key&quot;,&quot;value&quot;);</code></strong>(因为这不是Tag过滤 并且tag也无法搭载过多的信息)</p><p>使用SQL过滤之前需要在broker.conf添加</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开启对 propertyfilter的支持</span><br><span class="line">enablePropertyFilter = true</span><br><span class="line">filterSupportRetry = true</span><br></pre></td></tr></table></figure><p>然后再调用**<code>pushConsumer.subscribe(&quot;Topic1&quot;,MessageSelector.bySql(&quot;age&gt;18&quot;));</code>**</p><p><code>producer</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic1&quot;</span>,<span class="string">&quot;vip&quot;</span>,(<span class="string">&quot;Hello World&quot;</span>).getBytes());</span><br><span class="line"></span><br><span class="line">message.putUserProperty(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">message.putUserProperty(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.发什么</span></span><br><span class="line"><span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br></pre></td></tr></table></figure><p><code>consumer</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.谁来收</span></span><br><span class="line">        <span class="comment">//消费者有两种模式 一种是拉去(需要消费者自己去拉去) 一种是推送(消息主动推送给消费者)</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">pushConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.从哪里收</span></span><br><span class="line">        <span class="comment">//与生产者一样 消费者 也许要去name Server中获得对应broker的地址去获得消息</span></span><br><span class="line">        pushConsumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.监听那个消息队列</span></span><br><span class="line">        <span class="comment">//设置监听队列 subscribe:订阅 指定主题 和订阅表达式 &quot;*&quot;表示订阅主题中的所有</span></span><br><span class="line">        pushConsumer.subscribe(<span class="string">&quot;Topic1&quot;</span>, MessageSelector.bySql(<span class="string">&quot;age &gt; 16&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.处理业务流程</span></span><br><span class="line">        <span class="comment">//注册一个监听器 去监听是否有消息被生产 一有就立刻接收</span></span><br><span class="line">        pushConsumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                <span class="comment">//接收到的消息就是 List&lt;MessageExt&gt; msgs 这时我们就能写我们的业务逻辑</span></span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                    Map&lt;String, String&gt; properties = msg.getProperties();</span><br><span class="line">                    Iterator&lt;Map.Entry&lt;String,String&gt;&gt; iter = properties.entrySet().iterator();</span><br><span class="line">                    <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">                        Map.Entry&lt;String, String&gt; next = iter.next();</span><br><span class="line">                        System.out.println(next.getKey()+<span class="string">&quot; = &quot;</span>+next.getValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//启动连接</span></span><br><span class="line">        pushConsumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消费者启动起来了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意不要关闭消费者(如果还有对应主题的生产者的情况下 关闭就无法监听消息 就无法收到消息了)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Springboot整合RocketMQ"><a href="#Springboot整合RocketMQ" class="headerlink" title="Springboot整合RocketMQ"></a>Springboot整合RocketMQ</h2><ul><li>导入Springboot与RocketMQ整合starter</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>可以在application中配置rocketmq name-server的ip地址 和生产者的信息 或是消费者的信息</li></ul><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="attr">name-server:</span> <span class="string">localhost:9876</span></span><br><span class="line">  <span class="attr">consumer:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">group1</span></span><br><span class="line">  <span class="attr">producer:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">group1</span></span><br></pre></td></tr></table></figure><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><ul><li><p>在使用时 我们需要将springboot容器中的RocketMQTemplate(使用@Autowired)注册到我们的类中</p></li><li><p><strong>RocketMQTemplate:RocketMQ模板类 : 建立连接 断开连接</strong></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;<span class="comment">//RocketMQ模板类: 建连接 短链接</span></span><br></pre></td></tr></table></figure><ul><li><p>Springboot中传输的消息是Springboot框架提供的 <strong><code>org.springframework.messaging.Message&lt;T&gt;</code></strong></p></li><li><p>可以使用 <strong><code>org.springframework.messaging.support.MessageBuilder</code><strong>的</strong>静态方法withPayload(T payload)新建一个消息构建器 再调用build()方法</strong> 就可以将<strong>payload转换为一个Message对象</strong></p></li><li><p>上述都是使用send方法发送信息的需要做的 我们可以使用rocketMQTemplate的其他方法 例如 **<code>converAndSend()</code><strong>该方法由名字就知道它可以转化并且发送 它可以将java对象转化为</strong><code>org.springframework.messaging.Message&lt;T&gt;</code>**发送</p></li><li><p>除了上述两种方法 还有**<code>syncSend(), asyncSend(), sendOneWay() </code><strong>分别对应着同步,异步,单向消息 还可以在方法的参数上添加</strong><code>timeout delayLevel</code>**等参数以达到延时效果</p></li></ul><p><strong>注意:</strong> 这里不再是单纯的填入Topic了而是<strong>destination</strong> 并且格式是 <strong><code>topicName:tags</code></strong> </p><p>RocketMQ获取destination的源码</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220224202331947.png" alt="image-20220224202331947"></p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><ul><li><p>Consumer方面我们使用了监听器的方式来接收消息 实现RocketMQ自带的**<code>RocketMQListener&lt;T&gt;</code>** T指的**<code>withpayload</code>**中的消息类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span> <span class="comment">//注册到容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConsumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收成功的回调方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(User message)</span> &#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>设置了接收的监听器 我们还要设置监听的消息的主题 消息过滤 还有消费者组的名称 才能满足RocketMQ的规范</p><ul><li>这里我们使用**<code>rocketmq-spring-boot-starter</code><strong>的注解</strong><code>@RocketMQMessageListener</code>**设置参数 因为name-server在application.yml中我们已经设置了 springboot会自动识别并且设置.</li></ul></li><li><p>@RocketMQMessageListener</p><blockquote><ul><li>topic:主题</li><li>selectorExpression:过滤表达式</li><li>selectorType:设置过滤类型(Tag or Sql)</li><li>consumerGroup: 消费者组的名称</li><li>messageModel:消息的模式(广播或是集群)</li></ul></blockquote></li></ul></li></ul><p><strong><code>Producer</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;<span class="comment">//RocketMQ模板类: 建连接 短链接</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/send&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Devil&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        rocketMQTemplate.convertAndSend(<span class="string">&quot;Topic2&quot;</span>,user);<span class="comment">//convert: 消息转换为字节数组 甚至可以自动将对象转化为字节数组 但必须实现序列化</span></span><br><span class="line"></span><br><span class="line">        rocketMQTemplate.syncSend(<span class="string">&quot;Topic2&quot;</span>,user);<span class="comment">//发送同步消息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送异步消息</span></span><br><span class="line">        rocketMQTemplate.asyncSend(<span class="string">&quot;Topic2&quot;</span>, user, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">            <span class="comment">//发送成功的回调方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//发送失败的回调方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送单项消息</span></span><br><span class="line">        rocketMQTemplate.sendOneWay(<span class="string">&quot;Topic2&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送延时消息</span></span><br><span class="line">        rocketMQTemplate.syncSend(<span class="string">&quot;Topic2:tag1&quot;</span>, MessageBuilder.withPayload(user).build(),<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>Consumer</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(topic = &quot;Topic2&quot;,selectorExpression = &quot;tag1 || tag2&quot;,consumerGroup = &quot;$&#123;rocketmq.producer.group&#125;&quot;,</span></span><br><span class="line"><span class="meta">        selectorType = SelectorType.TAG,messageModel = MessageModel.BROADCASTING)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConsumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收成功的回调方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(User message)</span> &#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="消息顺序"><a href="#消息顺序" class="headerlink" title="消息顺序"></a>消息顺序</h2><p> <strong>消息错乱的原因:</strong></p><blockquote><p>默认消息的发送是每条消息按照 依次按照queue的顺序进入queue 即:<strong>队列内无序,队列外有序</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220224214903923.png" alt="image-20220224214903923"></p><p><strong><code>Producer</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这样发送会导致消息错乱</span></span><br><span class="line"><span class="keyword">for</span> (OrderStep orderStep : orderSteps) &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;topic3&quot;</span>, <span class="string">&quot;tag1&quot;</span>, orderStep.toString().getBytes());</span><br><span class="line">    <span class="type">SendResult</span> <span class="variable">send</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line"></span><br><span class="line">    System.out.println(send);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Consumer</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这样接收会导致消息错乱</span></span><br><span class="line">pushConsumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">        <span class="comment">//接收到的消息就是 List&lt;MessageExt&gt; msgs 这时我们就能写我们的业务逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><p><strong>纠正消息错乱:</strong></p><blockquote><p>修改消息的顺序,即指定消息进入的队列, 完整的顺序(订单的完整流程 创建 支付 完成)应当进入同一个消息队列. 即:<strong>队列内有序,队列外无序</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220224214826242.png" alt="image-20220224214826242"></p><p>为了使得生产的消息有序可以在producer中发送消息时指定消息进入的消息队列</p><p><strong><code>producer.send(message, new MessageQueueSelector() &#123;...&#125;,null);</code></strong> 其中的**<code>MessageQueueSelector()</code>**接口的select方法就可以指定消息填充的队列的队列id 更具这个id就可以获得这个队列 再通过send方法 发送到这个队列中</p><p><strong><code>Producer</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正确的发送</span></span><br><span class="line"><span class="keyword">for</span> (OrderStep orderStep : orderSteps) &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;topic3&quot;</span>, <span class="string">&quot;tag1&quot;</span>, orderStep.toString().getBytes());</span><br><span class="line">    <span class="type">SendResult</span> <span class="variable">send</span> <span class="operator">=</span> producer.send(message, <span class="keyword">new</span> <span class="title class_">MessageQueueSelector</span>() &#123;</span><br><span class="line">        <span class="comment">//这个方法就是队列悬着的方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> MessageQueue <span class="title function_">select</span><span class="params">(List&lt;MessageQueue&gt; mqs<span class="comment">/*消息队里额*/</span>, Message msg, Object arg)</span> &#123;</span><br><span class="line">            <span class="comment">//队列数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> mqs.size();</span><br><span class="line">            <span class="comment">//确定的orderId对应确定的队列 取模运算</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">orderId</span> <span class="operator">=</span> (<span class="type">int</span>) (orderStep.getOrderId());</span><br><span class="line">            <span class="type">int</span> <span class="variable">queueId</span> <span class="operator">=</span> orderId % size;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//根据 计算出的queueId 从List&lt;MessageQueue&gt; mqs中获取消息队列</span></span><br><span class="line">            <span class="keyword">return</span> mqs.get(queueId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(send);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于Consumer需要注册<strong>顺序的监听器</strong> 作用就是一个线程只监听一个MessageQueue 这样就可以接收一个queue中的消息了</p><p>而一个queue中都是producer生产的顺序的消息.</p><blockquote><p> <strong><code>new MessageListenerOrderly()&#123;...&#125;</code></strong></p></blockquote><p><strong><code>Consumer</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消费者注册一个顺序的监听器 作用就是一个线程只监听一个MessageQueue</span></span><br><span class="line">pushConsumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerOrderly</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeOrderlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(context.getMessageQueue().getQueueId());</span><br><span class="line">        <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><h3 id="RocketMQ事务流程概要"><a href="#RocketMQ事务流程概要" class="headerlink" title="RocketMQ事务流程概要"></a>RocketMQ事务流程概要</h3><p>RocketMQ实现事务主要分为两个阶段: 正常事务的发送及提交、事务信息的补偿流程(都是针对生产者 因为事务只出现在DataBase中 有些情况需要将消息存储在数据库中 如果发生事务问题….)</p><p><strong>整体流程为:</strong></p><blockquote><ul><li>正常事务发送与提交阶段<ol><li>生产者发送一个半消息给broker(半消息是指的暂时不能消费的消息)</li><li>服务端响应消息写入结果,半消息发送成功</li><li>开始执行本地事务</li><li>根据本地事务的执行情况执行Commit或者Rollback</li></ol></li><li>事务信息的补偿流程<ol><li>如果broker长时间没有收到本地事务的执行状态,会向生产者发起一个确认会查的操作请求</li><li>生产者收到确认会查请求后,检查本地事务的执行状态</li><li>根据检查后的结果执行Commit或者Rollback操作 补偿阶段主要是用于解决生产者在发送Commit或者Rollbacke操作时发生超时或失败的情况</li></ol></li></ul><p><img src="https://pic3.zhimg.com/80/v2-325e5949a667b144f2684caac49dd41a_720w.png" alt="img"></p></blockquote><h3 id="RocketMQ事务流程关键"><a href="#RocketMQ事务流程关键" class="headerlink" title="RocketMQ事务流程关键"></a>RocketMQ事务流程关键</h3><ul><li><p><strong>事务消息在一阶段对用户不可见</strong> </p><p>事务消息相对普通消息最大的特点就是一阶段发送的消息对用户是不可见的,也就是说消费者不能直接消费.这里RocketMQ实现方法是原消息的主题与消息消费队列,然后把主题改成**<code>RMQ_SYS_TRANS_HALF_TOPIC</code>**.这样由于消费者没有订阅这个主题,所以不会消费.</p></li><li><p><strong>如何处理第二阶段的发送消息?</strong></p><p>在本地事务执行完成后回向Broker发送Commit或者Rollback操作,此时如果在发送消息的时候生产者出故障了,要保证这条消息最终被消费,broker就会向服务端发送回查请求,确认本地事务的执行状态.当然RocketMQ并不会无休止的发送事务状态回查请求,<strong>默认是15次</strong>,如果15次回查还是无法得知事务的状态,RocketMQ默认回滚消息(broker就会将这条半消息删除)</p></li><li><p>事务的三种状态:</p><blockquote><ul><li><strong>TransactionStatus.CommitTransaction</strong>：提交事务消息，消费者可以消费此消息</li><li><strong>TransactionStatus.RollbackTransaction</strong>：回滚事务，它代表该消息将被删除，不允许被消费。</li><li><strong>TransactionStatus.Unknown</strong> ：中间状态，它代表需要检查消息队列来确定状态。</li></ul></blockquote></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>创建生产者时我们不在简单地创建**<code>DefaultMQProducer</code>** 而是RocketMQ事务专属的 <strong><code>TransactionMQProducer</code></strong> 并且不再简单地发送消息了 而是设置一个事务监听器 <strong><code>setTransactionListener(new TransactionListener()&#123;...&#125;);</code></strong> 实现接口方法 并且由于监听器需要等待本地事务的执行情况我们不能再生产者发送完消息后关闭</p><p><strong><code>Producer</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TransactionMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionMQProducer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置事务监听</span></span><br><span class="line">        producer.setTransactionListener(<span class="keyword">new</span> <span class="title class_">TransactionListener</span>() &#123;</span><br><span class="line">            <span class="comment">//执行本地事务 这就是正常事务过程</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> &#123;</span><br><span class="line">                <span class="comment">//消息保存到数据库中</span></span><br><span class="line">                <span class="comment">//sql代码</span></span><br><span class="line">                <span class="comment">//根据数据库事务状态 返回事务状态</span></span><br><span class="line">                System.out.println(<span class="string">&quot;正常执行的过程&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//LocalTransactionState.ROLLBACK_MESSAGE 表示事务回滚 这时broker就会删除掉half消息 消费者接收不到</span></span><br><span class="line">                <span class="comment">//如果是LocalTransactionState.COMMIT_MESSAGE 表示提交消息 这时broker就会提交half消息 消费能接收</span></span><br><span class="line">                <span class="comment">//LocalTransactionState.UNKNOW 事务结果未知 执行事务补偿过程 即broker主动询问生产者事务结果</span></span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//检查本地事务 这就是事务补偿过程</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> LocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行事务补偿过程&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello Transaction&quot;</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;topic4&quot;</span>, <span class="string">&quot;tag1&quot;</span>, msg.getBytes());</span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">send</span> <span class="operator">=</span> producer.sendMessageInTransaction(message,<span class="literal">null</span>);</span><br><span class="line">        System.out.println(send);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消息生产完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能关闭 涉及事务的提交和回滚 以及事务与broker的交互过程 不能一发出消息就关闭</span></span><br><span class="line">        <span class="comment">//producer.shutdown();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Consumer</code></strong> 整个事务消息环节与Consumer相关不大,所以不用对原来的Consumer进行修改 正常接收消息即可.</p><h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><h3 id="集群分类"><a href="#集群分类" class="headerlink" title="集群分类"></a>集群分类</h3><ul><li><strong>单机</strong><ul><li>一个broker提供服务(宕机后服务瘫痪)</li></ul></li><li><strong>集群</strong><ul><li>多个broker提供服务(单机宕机后消息无法及时被消费)</li><li>多个master和多个slave<ul><li>master到slave消息同步方式为同步(较异步方式性能略低,消息无延迟)</li><li>master到slave消息同步方式为异步(较同步方式性能略高,数据略有延迟)</li></ul></li></ul></li><li><strong>根据配置文件中的信息来设置主从集群</strong></li></ul><h3 id="RocketMQ集群工作流程"><a href="#RocketMQ集群工作流程" class="headerlink" title="RocketMQ集群工作流程"></a>RocketMQ集群工作流程</h3><ul><li>NameServer启动,开启监听,等待broker,producer与consumer连接</li><li>broker启动,根据配置信息,连接所有的NameServer,并保持长连接 <ul><li>如果broker中现存数据,NameServer将保存topic与broker关系</li></ul></li><li>producer发送信息,连接某个NameServer,并建立长连接</li><li>producer发送消息<ul><li>如果topic存在,由NameServer直接分配</li><li>如果topic不存在,由NameServer创建topic与broker关系,并分配</li></ul></li><li>producer与broker的topic选择一个消息队列(从列表中选择)</li><li>producer与broker建立长连接,用于发送消息</li><li>producer发送消息</li></ul><p><strong><code>Consumer</code><strong>工作流程同</strong><code>Producer</code></strong></p><hr><h2 id="RocketMQ高级特性"><a href="#RocketMQ高级特性" class="headerlink" title="RocketMQ高级特性"></a>RocketMQ高级特性</h2><p><strong>RocketMQ消息发送底层</strong></p><ol><li><p>消息的生产者发送消息到MQ</p></li><li><p>MQ返回ACK给生产者</p></li><li><p>MQ push消息给对于的消费者</p></li><li><p>消息消费者返回ACK给MQ</p></li></ol><p>说明: ACK(Acknowledge character)</p><p>注意: <strong>如果broker出现问题不能发送和接收ACK  生产者就会接收不到broker发送的ACK 就会导致生产者一直发送同一条消息 也会导致消费者一直消费同一条消息</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225203843889.png" alt="image-20220225203843889"></p><h3 id="消息的存储"><a href="#消息的存储" class="headerlink" title="消息的存储"></a>消息的存储</h3><ol><li><p>消息生产者发送消息到MQ</p></li><li><p>MQ接收到消息,将消息持久化,存储该消息</p></li><li><p>MQ返回ACK给生产者</p></li><li><p>MQpush消息给对应的消费者</p></li><li><p>消息消费者返回ACK给MQ</p></li><li><p>MQ删除消息</p></li></ol><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225204155340.png" alt="image-20220225204155340"></p><p><strong>注意:</strong></p><blockquote><ul><li>第5步 MQ在指定时间接收到消息消费者返回ACK, MQ认定消息消费成功,执行6</li><li>第5步 MQ在指定时间未接收到消息消费者返回ACK,MQ认定消费失败,重新执行456</li></ul></blockquote><h3 id="消息的存储介质"><a href="#消息的存储介质" class="headerlink" title="消息的存储介质"></a>消息的存储介质</h3><p>为了防止数据库出现故障和数据库I&#x2F;O降低性能(数据库最后也是将数据存储再磁盘上(文件系统))</p><p><strong>所以我们直接绕过数据库 直接将消息存在本地的文件系统上</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225204909019.png" alt="image-20220225204909019"></p><p><strong>数据库:</strong></p><ul><li>ActiveMQ使用</li><li>缺点: 数据库瓶颈将成为MQ瓶颈</li></ul><p><strong>文件系统:</strong></p><ul><li>RocketMQ&#x2F;Kafka&#x2F;RabbitMQ</li><li>解决方案: 采用消息刷盘的机制进行数据的存储</li><li>缺点:硬盘损坏的问题无法避免</li></ul><h3 id="高效的消息存储与读写方式"><a href="#高效的消息存储与读写方式" class="headerlink" title="高效的消息存储与读写方式"></a>高效的消息存储与读写方式</h3><ul><li><strong>SSD(Solid State Disk): 固态硬盘</strong><ul><li>随机写 100kb&#x2F;s</li><li>顺序写 600-3000m&#x2F;s</li></ul></li><li>由上可知 顺序写的速度是远远快于随机写的</li></ul><hr><ul><li><p><strong>RocketMQ中向文件系统预先申请了一定大小的磁盘空间 用于顺序读写</strong>(这就是RocketMQ高速读写的第一个原因)</p></li><li><p>Linux系统发送数据的方式</p><blockquote><p>“零拷贝”技术</p><ul><li>数据传输由传统的4次复制简化成3次复制,减少1次复制过程</li><li>java语言中使用MappedByteBuffer类实现了该技术</li><li>要求:预留存储空间,用于保存数据(1G存储空间起步)</li></ul></blockquote><p>传统模式</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225211130484.png" alt="image-20220225211130484"></p></li></ul><p>“零拷贝模式”</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225211155810.png" alt="image-20220225211155810"></p><p><strong>总结(RocketMQ高速读写的原因):</strong></p><blockquote><ul><li>磁盘读写方式</li><li>“零拷贝”技术</li></ul></blockquote><h3 id="消息存储的结构"><a href="#消息存储的结构" class="headerlink" title="消息存储的结构"></a>消息存储的结构</h3><p>MQ数据存储区域包括如下内容</p><ul><li><p>消息数据存储区域</p><ul><li>topic</li><li>queueId</li><li>message</li></ul></li><li><p>消费逻辑队列(会记录每一个队列被每一个消费者消费到了什么(多少偏移量))</p><ul><li>minOffset</li><li>maxOffset</li><li>consumerOffset</li></ul></li><li><p>索引</p><ul><li>key索引</li><li>创建时间索引</li><li>……</li></ul></li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225212158831.png" alt="image-20220225212158831"></p><h3 id="刷盘机制"><a href="#刷盘机制" class="headerlink" title="刷盘机制"></a>刷盘机制</h3><h4 id="同步刷盘"><a href="#同步刷盘" class="headerlink" title="同步刷盘:"></a>同步刷盘:</h4><ol><li>生产者发送消息到MQ,MQ接到消息数据</li><li>MQ挂起生产者发送消息的线程</li><li>MQ将消息数据写入内存</li><li>内存数据写入硬盘</li><li>磁盘存储后返回SUCCESS</li><li>MQ回复挂起的生产者线程</li><li>发送ACK到生产者</li></ol><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225212521664.png" alt="image-20220225212521664"></p><h4 id="异步刷盘"><a href="#异步刷盘" class="headerlink" title="异步刷盘"></a>异步刷盘</h4><ol><li><p>生产者发送消息到MQ,MQ接收到消息数据</p></li><li><p>MQ将消息写入内存</p></li><li><p>发送ACK到生产者</p></li><li><p>待到内存中的消息数据积累到一定量 就将消息数据写入硬盘</p></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><blockquote><ul><li>同步刷盘: 安全性高,效率低,速度慢(适用于对数据安全性要求较高的业务)</li><li>异步刷盘:安全性低,效率高,速度块(使用与对数据处理速度要求较高的业务)</li></ul></blockquote><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225213018812.png" alt="image-20220225213018812"></p><hr><h3 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h3><ul><li>NameServer<ul><li>无状态(相互之间无联系)+全服务器注册</li></ul></li><li>消息服务器<ul><li>主从框架(2M-2S)</li></ul></li><li>消息生产<ul><li>生产者将相同的topic绑定到多个group组,保障master挂掉后,其他master仍可以正常进行消息接收</li></ul></li><li>消息消费<ul><li>RocketMQ自身会根据master的压力确认是否由master承担消息读取的功能,当master繁忙的时候,自动切换slave成单数据读取的工作(主从分离 当压力过大时 master只写入 因为slave中的数据与master实时更新 所以这时slave可以承担读的功能)</li></ul></li></ul><p><strong>主从数据复制</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225213710132.png" alt="image-20220225213710132"></p><hr><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul><li>**<code>Producer</code>**负载均衡</li></ul><blockquote><ul><li>内部实现了不同broker集群中对同一个topic对应消息队列的负载均衡</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225214232482.png" alt="image-20220225214232482"></p></blockquote><ul><li>**<code>Consumer</code>**负载均衡(针对相同的消费者组间)</li></ul><blockquote><ul><li>平均分配</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225214249237.png" alt="image-20220225214249237"></p><ul><li>循环平均分配(解决宕机问题)</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225214305341.png" alt="image-20220225214305341"></p></blockquote><hr><h3 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h3><p>当消息消费后未正常返回消费成功的消息将启动消息重试机制</p><p><strong>消息重试机制</strong></p><blockquote><ul><li><p><strong>顺序消息重试</strong></p><blockquote><p>当消费者消费失败后,RocketMQ会自动进行消息重试(每次间隔为1s)</p><p><strong>注意:</strong> 应用会出现消息消费被堵塞的情况,因此要对顺序消息的消费情况进行监控,避免阻塞的现象发生</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225214842367.png" alt="image-20220225214842367"></p></blockquote></li><li><p><strong>无序消息重试</strong></p><blockquote><ul><li>无序消息包括普通消息、定时消息、延时消息、事务消息</li><li>无序消息重试仅适用于负载均衡（集群）模型下的消息消费，不适用于广播模式下的消息</li><li>消费为保障无序消息的消费，MQ设定了合理的消息重试间隔时长</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225215028265.png" alt="image-20220225215028265"></p></blockquote></li></ul></blockquote><hr><h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p><strong>死信队列就是那些重试无果的消息存在的队列</strong></p><ul><li><p><strong>死信队列特征</strong></p><blockquote><ul><li>归属某一个组（Gourp Id)，而不归属Topic，也不归属消费者。</li><li>一个死信队列中可以包含同一个组下的多个Topic中的死信消息</li><li>死信队列不会进行默认初始化，当第一个死信出现后，此队列首次初始化</li></ul></blockquote></li><li><p><strong>死信队列中消息特征</strong></p><blockquote><ul><li><p>不会被再次重复消费</p></li><li><p>死信队列中的消息有效期为3天，达到时限后将被清除</p></li></ul></blockquote></li><li><p><strong>死信处理</strong></p><blockquote><p>在监控平台中,通过查找死信,获取死信的messageId,然后通过id对死信进行精准消费</p></blockquote></li></ul><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h4><ul><li><p>死信</p><blockquote><ul><li><p>死信队列与死信</p></li><li><p>死信处理方式</p></li></ul></blockquote></li></ul><hr><h3 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h3><h4 id="消息重复发送的原因"><a href="#消息重复发送的原因" class="headerlink" title="消息重复发送的原因"></a>消息重复发送的原因</h4><ul><li>生产者发送了重复的消息<ul><li>网络闪断(例如: 消息服务器没有发送ACK给生产者)</li><li>生产者宕机</li></ul></li><li>消息服务器投递了重复的消息<ul><li>网络闪断(例如: 消费者没有发送ACK给消息服务器)</li></ul></li><li>动态的负载均衡过程<ul><li>网络闪断&#x2F;抖动</li><li>broker重启</li><li>订阅方应用重启(消费者)</li><li>客户端扩容</li><li>客户端缩容</li></ul></li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225220215976.png" alt="image-20220225220215976"></p><h4 id="消息幂等"><a href="#消息幂等" class="headerlink" title="消息幂等"></a>消息幂等</h4><ul><li><p>对于同一条消息,无论消费了多少次,结果保持一致,称为<strong>消息幂等性</strong></p></li><li><p>解决方案</p><ul><li>使用业务id作为消息的key</li><li>在消费消息时,客户端对key做判定,未使用过放行,使用过抛弃</li></ul></li><li><p>注意: <strong>messageId由RocketMQ产生,MessageId并不具有唯一性,不能作用幂等判定条件</strong></p></li><li><p><strong>常见的幂等方法示例</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225220811978.png" alt="image-20220225220811978"></p></li></ul><h1 id="——End——"><a href="#——End——" class="headerlink" title="——End——"></a>——End——</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RocketMQ&quot;&gt;&lt;a href=&quot;#RocketMQ&quot; class=&quot;headerlink&quot; title=&quot;RocketMQ&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/apache/rocketmq/blob/master/docs/cn/concept.md&quot;&gt;RocketMQ&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;MQ(Message Queue)&lt;/strong&gt;:消息队列&lt;/p&gt;</summary>
    
    
    
    <category term="中间件" scheme="https://devildyw.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Java" scheme="https://devildyw.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot</title>
    <link href="https://devildyw.github.io/2022/02/28/Springboot/"/>
    <id>https://devildyw.github.io/2022/02/28/Springboot/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-04-16T08:56:33.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><ol><li>SpringBoot 相当于是一个Spring 和 SpringMVC的集成 又在其上增加了其他功能 对其他主流框架的支持也是非常好, 所以SpringBoot更新的非常频繁,需要时常关注它更新的内容</li><li>微服务架构<br> 　Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。<br> 　该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。　　<br> 　通过这种方式，Spring Boot 致力于在蓬勃发展的快速应用开发领域（rapidapplication development）成为领导者。</li></ol><span id="more"></span><h4 id="SpringBoot优点"><a href="#SpringBoot优点" class="headerlink" title="SpringBoot优点"></a>SpringBoot优点</h4><ul><li>Create stand-alone Spring applications</li></ul><ul><li><ul><li>创建独立Spring应用</li></ul></li><li><p>Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)</p></li><li><ul><li>内嵌web服务器</li></ul></li><li><p>Provide opinionated ‘starter’ dependencies to simplify your build configuration</p></li><li><ul><li>自动starter依赖，简化构建配置</li></ul></li><li><p>Automatically configure Spring and 3rd party libraries whenever possible</p></li><li><ul><li>自动配置Spring以及第三方功能</li></ul></li><li><p>Provide production-ready features such as metrics, health checks, and externalized configuration</p></li><li><ul><li>提供生产级别的监控、健康检查及外部化配置</li></ul></li><li><p>Absolutely no code generation and no requirement for XML configuration</p></li><li><ul><li><strong>无代码生成、无需编写XML</strong></li></ul></li></ul><blockquote><p>SpringBoot是整合Spring技术栈的一站式框架</p><p>SpringBoot是简化Spring技术栈的快速开发脚手架</p></blockquote><p>SpringBoot最大的特点就是 无需编写大量的配置文件 需要什么功能模块 只需要导入相应的starter即可 &lt; parent&gt;中也几乎包含所有需要用到的功能依赖的版本号</p><h4 id="SpringBoot缺点"><a href="#SpringBoot缺点" class="headerlink" title="SpringBoot缺点"></a>SpringBoot缺点</h4><ul><li>人称版本帝，迭代快，需要时刻关注变化</li><li>封装太深，内部原理复杂，不容易精通</li></ul><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a><strong>微服务</strong></h2><ul><li><p>微服务是一种架构风格</p></li><li><p>一个应用拆分为一组小型服务</p></li><li><p>每个服务运行在自己的进程内，也就是可独立部署和升级</p></li><li><p>服务之间使用轻量级HTTP交互</p></li><li><p>服务围绕业务功能拆分</p></li><li><p>可以由全自动部署机制独立部署</p></li><li><p>去中心化，服务自治。服务可以使用不同的语言、不同的存储技术</p></li></ul><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a><strong>分布式</strong></h2><p>就是把一个一个的服务细分为不同功能的微服务 再将这些服务部署到不同的服务器上 以达到性能能效最大化 同时也避免了一台服务器出现问题 整个系统业务完全瘫痪</p><p><strong>分布式的困难</strong></p><ul><li><p>远程调用</p></li><li><p>服务发现</p></li><li><p>负载均衡</p></li><li><p>服务容错</p></li><li><p>配置管理</p></li><li><p>服务监控</p></li><li><p>链路追踪</p></li><li><p>日志管理</p></li><li><p>任务调度</p></li><li><p>……</p></li></ul><p>分布式的解决: SpringBoot+SpringCloud</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/1599799119457-841ef47a-6585-4ca4-8e3d-8298e796012c.png" alt="img"></p><h2 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a><strong>云原生</strong></h2><p>原生应用如何上云。 Cloud Native</p><h4 id="上云的困难"><a href="#上云的困难" class="headerlink" title="上云的困难"></a><strong>上云的困难</strong></h4><ul><li><p>服务自愈</p></li><li><p>弹性伸缩</p></li><li><p>服务隔离</p></li><li><p>自动化部署</p></li><li><p>灰度发布</p></li><li><p>流量治理</p></li><li><p>……</p></li></ul><h4 id="上云的解决"><a href="#上云的解决" class="headerlink" title="上云的解决"></a>上云的解决</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/1599563498261-8b0b4d86-bd9b-49a3-aefc-89696a375dcb.png" alt="img"></h4><h2 id="学习SpringBoot"><a href="#学习SpringBoot" class="headerlink" title="学习SpringBoot"></a><strong>学习SpringBoot</strong></h2><ol><li><p>查看官方文档:<strong><a href="https://spring.io/">Spring官方 所有Spring的框架 包括分布式的解决方案</a></strong></p></li><li><p>查看SpringBoot官方文档 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/"><strong>Spring Boot官方文档</strong></a></p></li><li><p>查看版本新特性: <a href="https://github.com/spring-projects/spring-boot/wiki#release-notes"><strong>SpringBoot迭代更新文档</strong></a></p></li></ol><h2 id="SpringBoot2入门"><a href="#SpringBoot2入门" class="headerlink" title="SpringBoot2入门"></a><strong>SpringBoot2入门</strong></h2><h4 id="一-基础要求"><a href="#一-基础要求" class="headerlink" title="一: 基础要求"></a>一: 基础要求</h4><p><strong>系统要求</strong></p><ul><li><p><a href="https://www.java.com/">Java 8</a> &amp; 兼容java14 .</p></li><li><p>Maven 3.3+</p></li><li><p>idea 2019.1.2</p></li></ul><h4 id="二-开始步骤"><a href="#二-开始步骤" class="headerlink" title="二: 开始步骤"></a>二: 开始步骤</h4><h5 id="方式一-直接使用Maven创建SpringBoot项目"><a href="#方式一-直接使用Maven创建SpringBoot项目" class="headerlink" title="方式一:直接使用Maven创建SpringBoot项目"></a>方式一:直接使用Maven创建SpringBoot项目</h5><ol><li>需要导入&lt; parent&gt;&lt;&#x2F; parent&gt; 依赖 里面包含了几乎开发要用到的所用依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>开始一个web项目,就加入spring-boot-starter-web依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>加入插件 该插件可以简化部署</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该插件可以将 Spring Boot应用打包为可执行的jar或war文件，然后以通常的方式运行Spring Boot应用。</p><ol start="4"><li>如果想更改SpringBoot内置服务器的端口号 就创建一个application.properties</li></ol><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8888</span></span><br></pre></td></tr></table></figure><p>这样SpringBoot就能识别出了并修改了</p><ol start="5"><li>创建主程序类 (也是SpringBoot的核心)</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主程序类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@SpringBootApplication</span>: 这是一个SpringBoot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="6"><li>编写一个控制器 和 处理器方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-01-11-20:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handler01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello,Spring Boot2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="7"><li>运行主程序类 并测试</li></ol><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120140741819.png" alt="image-20220120140741819"></p><h5 id="方式二-使用idea自带的模板创建-spring-initializr"><a href="#方式二-使用idea自带的模板创建-spring-initializr" class="headerlink" title="方式二: 使用idea自带的模板创建(spring initializr)"></a>方式二: 使用idea自带的模板创建(spring initializr)</h5><p>选择spring initalizr 填入相应的信息 然后点击next</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120141041583.png" alt="image-20220120141041583"></p><p>因为我们是做web应用 所以这里选择springweb 如果是其他项目 选择相应的模块即可</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120141138907.png" alt="image-20220120141138907"></p><p>然后等待创建 最后创建相应的Controller等 运行即可(剩下于方式一相同)</p><h5 id="方式三-spring官网创建-同样使用的是spring-initializr"><a href="#方式三-spring官网创建-同样使用的是spring-initializr" class="headerlink" title="方式三:spring官网创建(同样使用的是spring initializr)"></a>方式三:spring官网创建(同样使用的是spring initializr)</h5><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120141750951.png" alt="image-20220120141750951"></p><p><strong>官网找到 project 点击SpringBoot 拉到最后</strong></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120141836152.png" alt="image-20220120141836152"></p><p><strong>点击Spring initializr</strong></p><p>界面如图</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120141947001.png" alt="image-20220120141947001"></p><p>方式于idea创建相同 只是创建后的形式不同 创建后是以压缩包的形式下载 下载后要导入idea 这种方式是用来应付idea无法联网的情况 </p><h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><ol><li>SpringBoot的配置文件一定要写到 resources目录下 且尽量以application为文件名 这样才能识别</li><li>所有的Controller类 等业务类都要写道SpringBootApplication(主程序类)的同级或是子级目录下 否则会报<strong>404</strong></li><li><strong>常用的方式是 一 和 二</strong></li></ol><h2 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a><strong>自动配置原理</strong></h2><h4 id="一-yin-yang-依赖管理"><a href="#一-yin-yang-依赖管理" class="headerlink" title="一:yin_yang:依赖管理"></a>一:yin_yang:依赖管理</h4><ul><li>SpringBoot使用了父项目做为项目管理</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">依赖管理    </span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">他的父项目</span><br><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">几乎声明了所有开发中常用的依赖的版本号,自动版本仲裁机制</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>开发只需要导入starter场景启动器(<strong>Starter就是一个包含了若干个坐标定义的pom管理文件, 即包含了若干个依赖的信息</strong>)</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1、见到很多 spring-boot-starter-* ： *就某种场景</span><br><span class="line">2、只要引入starter，这个场景的所有常规需要的依赖我们都自动引入</span><br><span class="line">3、SpringBoot所有支持的场景</span><br><span class="line">https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter</span><br><span class="line">4、见到的  *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。</span><br><span class="line">5、所有场景启动器最底层的依赖</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>无需关注版本号，自动版本仲裁</li></ul><blockquote><p>1、引入依赖默认都可以不写版本<br>2、引入非版本仲裁的jar，要写版本号。</p></blockquote><p>修改默认版本号 是使用依赖覆盖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1、查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。</span><br><span class="line">2、在当前项目里面重写配置</span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.43<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">也可以直接在pom.xml中重写依赖来覆盖</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之所以在配置了&lt; parent&gt;之后不需要填写版本号 是因为 &lt; parent&gt;中使用了&lt; dependencyManagement&gt;管理</p><h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意:"></a>注意:</h5><ol><li>当导入一个Starter时又想导入一些其他技术 又不想直接导入其他的Starter 可以直接导入该技术的依赖 而且只需要写GAV中的GA而不需要写V 但是如果&lt; Parent&gt;中没有该依赖时 就需要完整写上GAV</li></ol><h4 id="二-first-quarter-moon-自动配置"><a href="#二-first-quarter-moon-自动配置" class="headerlink" title="二:first_quarter_moon:自动配置:"></a>二:first_quarter_moon:自动配置:</h4><ul><li><p>自动配好Tomcat</p></li><li><ul><li>引入Tomcat依赖。</li><li>配置Tomcat</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>自动配好SpringMVC</p></li><li><ul><li>引入SpringMVC全套组件</li><li>自动配好SpringMVC常用组件（功能）</li></ul></li><li><p>自动配好Web常见功能，如：字符编码问题</p></li><li><ul><li>SpringBoot帮我们配置好了所有web开发的常见场景</li></ul></li><li><p>默认的包结构</p></li><li><ul><li><strong>主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来</strong>(所以一般将组件都写在主程序的同级或是子级目录)</li><li>无需以前的包扫描配置</li></ul></li><li><ul><li>想要改变扫描路径，</li><li>@SpringBootApplication(scanBasePackages&#x3D;<strong>“com.atguigu”</strong>)</li></ul></li><li><ul><li>或者@ComponentScan 指定扫描路径(更改方式)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">等同于</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.boot&quot;)</span></span><br></pre></td></tr></table></figure><ul><li><p>各种配置拥有默认值</p></li><li><ul><li>默认配置最终都是映射到某个类上，如：MultipartProperties</li><li>配置文件的值最终会绑定每个类上，这个类会在容器中创建对象</li></ul></li><li><p>按需加载所有自动配置项</p></li><li><ul><li>非常多的starter</li><li>引入了哪些场景这个场景的自动配置才会开启</li></ul></li><li><ul><li>SpringBoot所有的自动配置功能都在 spring-boot-autoconfigure 包里面</li></ul></li><li><p>….</p></li></ul><hr><h4 id="容器中的注解的功能"><a href="#容器中的注解的功能" class="headerlink" title="容器中的注解的功能"></a>容器中的注解的功能</h4><h5 id="一-question-Configuration-配置类"><a href="#一-question-Configuration-配置类" class="headerlink" title="一:question:@Configuration(配置类):"></a>一:question:@Configuration(配置类):</h5><p><strong>使用:</strong></p><ol><li>用在类的上方 表示该类为配置类 可以与@Bean标签一起使用 作用类似于Spring.xml文件中&lt; bean&gt;创建对象</li></ol><p><strong>告诉springboot这个是一个配置类 &#x3D;&#x3D; 配置文件</strong></p><ul><li><p>配置类里面使用@Bean标注在方法的上面给容器注册组件,默认也是单实例的</p></li><li><p>配置类本身也是组件</p></li><li><p>proxyBeanMethods()方法:代理bean的方法</p></li><li><p>当@Configuration中的参数proxyBeanMethods 的值为true时为代理模式 Cglib代理 会在原来的方法上增加功能 判断容器中是否已有对象 单例模式</p></li><li><p>当@Configuration中的参数proxyBeanMethods 的值为false时为非代理模式 就是非单例模式</p></li><li><p>Full模式(proxyBeanMethods &#x3D; true)(保证每个@Bean方法被调用多少次返回的组件都是单实例的)</p></li><li><p>Lite模式(proxyBeanMethods &#x3D; false)(每个@Bean方法被调用多少次返回的组件都是新创建的)</p><blockquote><ul><li>配置 类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断</li><li>配置类组件之间有依赖关系，方法会被调用得到之前单实例组件，用Full模式</li></ul></blockquote></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 外部无论对配置类中的这个组件注解方法调用多少次,获取的都是之前注册容器中的单实例对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * //给容器中添加组件.以方法名作为组件的id,返回类型的,就是组件在容器中的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Cat</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span> 方法名就是实例的名称</span><br><span class="line">    <span class="keyword">public</span> Cat <span class="title function_">cat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;彭芳姐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试发现 Full模式(proxyBea+nMethods &#x3D; true) 使用的是Cglib代理模式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.dyw.application.config.MyConfig$$EnhancerBySpringCGLIB$$c5874a7@120d3fd</span><br></pre></td></tr></table></figure><p>Lite(proxyBeanMethods &#x3D; true)则是没有被代理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.dyw.application.config.MyConfig@29fa6b65</span><br></pre></td></tr></table></figure><h6 id="1-1-Import"><a href="#1-1-Import" class="headerlink" title="1. 1 @Import"></a>1. 1 @Import</h6><p><code> @Import(&#123;Cat.class&#125;)</code> 给容器中自动创建出这个类型的组件  默认组件的名字为全类名</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;User.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">bean</span> <span class="operator">=</span> context.containsBean(<span class="string">&quot;com.dyw.springboot.entity.User&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h6 id="1-2-Conditional"><a href="#1-2-Conditional" class="headerlink" title="1.2 @Conditional"></a>1.2 @Conditional</h6><ul><li>条件装配: 满足Conditional指定的条件,则进行组件注入</li><li>@ConditionalOnBean</li><li>@ConditionalOnMissingBean</li><li>@ConditionalOnMissingClass</li><li>@ConditionalOnResource</li><li>@ConditionalOnJava</li><li>@ConditionalOnWebApplication</li><li>@ConditionalOnNotWebApplication</li><li>@ConditionalOnClass</li></ul><p>使用在@Configuration注解类中的@Bean标签下 根据注解条件判断是否注入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(Cat.class)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setCat(cat());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h5 id="二-SpringBootApplication-主程序类或引导类"><a href="#二-SpringBootApplication-主程序类或引导类" class="headerlink" title="二: @SpringBootApplication(主程序类或引导类)"></a>二: @SpringBootApplication(主程序类或引导类)</h5><ol><li>类上加上@SpringBootApplication 表示该类为主程序类 </li><li>在类中写上主方法(main) 调用 SpringApplication.run(主程序类.class, args);即可开始SpringBoot程序</li><li>注意 组件都要写到主程序类的同级或是子级目录</li><li>SpringApplication.run()方法会返回SpringBoot的容器 可以根据容器的getBean(“组件名”,类名.class)获取组件</li><li><strong>SpringApplication.run(主程序类.class, args)方法会返回一个Context上下文对象(容器), 里面包含了DispatcherServlet等对象, 这也是问什么运行此方法就可以达到实现web应用的功能. 通过内嵌的TomCat服务器核心就可以读取这个容器的组件</strong>.</li><li>SpringBoot内嵌的服务器核心同样也是通过组件的方式存在SpringBoot的Context上下文对象中.(因为TomCat是java写的 运行原理就是执行java对象 所以把Tomcat的对象的创建和管理交给了SpringBoot);</li></ol><hr><h5 id="三-Bean"><a href="#三-Bean" class="headerlink" title="三: @Bean"></a>三: @Bean</h5><ol><li><p>用于配置类的方法上 用来注册组件 使得组件管理的主权在容器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cat <span class="title function_">cat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;彭芳姐&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法名就是组件的名称 也可以在@Bean中设置组件的名称 @Bean(“组件名”)</p></li><li><p>创建组件的方法有两种 </p><ol><li><p>一种是利用有参构造创建组件 可以利用有参构造注入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cat <span class="title function_">cat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;彭芳姐&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>另一种是利用无参构造 需要后续使用set方法注入 或是利用spring中的注解注入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cat <span class="title function_">cat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><hr><h5 id="四-RestController"><a href="#四-RestController" class="headerlink" title="四: @RestController"></a>四: @RestController</h5><ul><li><strong>@RestController &#x3D; @Controller + @ResponseBody</strong></li></ul><p>即**@RestController<strong>在</strong>@Controller<strong>的基础上 集成了</strong>@ResponseBody**的特性 即将java对象转换为json数据或是其他数据</p><ul><li><strong>@ResponseBody</strong> 注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是<a href="https://so.csdn.net/so/search?q=XML&spm=1001.2101.3001.7020">XML </a>数据。</li></ul><blockquote><p>注意：在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。</p></blockquote><ul><li>@ResponseBody是作用在方法上(可使用在类上表示整个类中的方法都受@ResponseBody的影响)的，@ResponseBody 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】。</li><li>注意：<strong>在使用 @RequestMapping后</strong>，<strong>返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。</strong> 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据。@RequestBody 将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。</li></ul><hr><h5 id="五-eagle-RequstMapping"><a href="#五-eagle-RequstMapping" class="headerlink" title="五:eagle:@RequstMapping"></a>五:eagle:@RequstMapping</h5><p>在SpringMVC的学习中我们知道 被它标注的方法称为<strong>处理器方法</strong> , 它可以标注一个处理器方法的请求路径, 被他修饰的处理器方法, 默认返回值通常解析为跳转路径</p><p>在SpringBoot中 它的功能被细分了</p><p>原本的**@RequestMapping**在不指定请求方法时,会接收任意请求方法的请求</p><p>但是SpringBoot中推荐不直接在方法而是使用功能更细的**@请求方法名Mapping** 例如**@GetMapping<strong>或是</strong>@PostMapping**</p><p>而把@RequstMapping用在类上 用来当访问路径的前缀</p><p><a href="http://localhost:8088/dyw/cat">http://localhost:8088/dyw/cat</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/dyw&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/cat&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doCat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="六：-PathVariable（常用于REST风格）"><a href="#六：-PathVariable（常用于REST风格）" class="headerlink" title="六：@PathVariable（常用于REST风格）"></a>六：@PathVariable（常用于REST风格）</h5><ul><li>绑定路径参数于处理器方法形参间的关系，要求路径参数名于形参名一一对应</li><li>使用： 用在SpringMVC控制器方法形参定义前面</li><li>@PathVariable常用于RESTful中且 请求路径参数只有较少数量时 如一个</li></ul><p><strong>注意</strong>：<strong>参数是在路径上的</strong>使用{参数名称}描述路径参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String delete(@PathVariable Integer id)&#123;</span><br><span class="line">        System.out.println(&quot;user delete...&quot;+id);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:user delete&#125;&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120201849092.png" alt="image-20220120201849092"></p><h5 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h5><ul><li>用来接收Josn请求</li></ul><p>json请求传参方式</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">12</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>使用键值对的方式传参 **键名+”:”+值 ** 键值放在{}中</p><h5 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h5><ul><li>用于接收url地址传来的参数 或是表单提交的参数 但路径传参的格式相对于RESTful的**@PathVariable**麻烦一点</li></ul><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">@RequestParam</span><br><span class="line">http://localhost:0000/users?id=1 </span><br><span class="line">=====================================================</span><br><span class="line">@PathVariable</span><br><span class="line">http://localhost:0000/users/1</span><br></pre></td></tr></table></figure><h5 id="RequestBody、-RequestParam和-PathVariable总结"><a href="#RequestBody、-RequestParam和-PathVariable总结" class="headerlink" title="@RequestBody、@RequestParam和@PathVariable总结"></a>@RequestBody、@RequestParam和@PathVariable总结</h5><ul><li>应用<ul><li>后期开发中，发送请求参数超过一个时 ，以json格式为主，@RequestBody应用较广</li><li>如果发送非json格式数据，选用@RequestParam接收参数</li><li>采用RESTful进行开发，当参数数量较少时，例如一个可以采用@PathVariable接收请求路径变量，通常用于传递id值</li></ul></li></ul><hr><h5 id="七-ImportResource"><a href="#七-ImportResource" class="headerlink" title="七:@ImportResource"></a>七:@ImportResource</h5><ul><li><p>该注解可以导入原生的配置文件 例如Spring中的Bean.xml配置文件 让其生效</p></li><li><p>使用在任意配置类上</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;Cat.class&#125;)</span></span><br><span class="line"><span class="meta">@ImportResource(&quot;classpath:Bean.xml&quot;)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    Bean.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.springboot.entity.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;cat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.springboot.entity.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><hr></li></ul><h5 id="八-ConfigurationProperties"><a href="#八-ConfigurationProperties" class="headerlink" title="八: @ConfigurationProperties"></a>八: @ConfigurationProperties</h5><ul><li><p>配置绑定 使用该注解 可以使用java读取到的配置文件(xml properties yml)中的内容,并且把它封装到JavaBean中,以供随时使用</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">mycar.name</span>=<span class="string">BYD</span></span><br><span class="line"><span class="attr">mycar.price</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure></li><li><p>方式一: 在JavaBean上加上@Component(将其注册到springboot容器)和@ConfigurationPropertes注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式二:在JavaBean上只用加上@ConfigurationPropertes注解 并且在配置类(@Configuration)上加上@EnableConfigurationPropertes(Class&lt;?&gt;[])</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(Car.class)</span></span><br><span class="line"><span class="comment">//1. 开启Car配置绑定功能</span></span><br><span class="line"><span class="comment">//2. 把这个Car这个组件自动注册到容器中</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="REST风格"><a href="#REST风格" class="headerlink" title="REST风格"></a><strong>REST风格</strong></h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介:"></a>简介:</h4><ul><li><p>按照REST风格访问资源时使用<strong>行为动作</strong>区分对资源进行了何种操作</p><ul><li><a href="http://localhost:0/users">http://localhost:0000/users</a>                           查询全部用户信息  GET(查询)</li><li><a href="http://localhost:0/users/1">http://localhost:0000/users/1</a>                           查询指定用户信息  GET(查询)</li><li><a href="http://localhost:0/users">http://localhost:0000/users</a>                           添加用户信息  POST(新增&#x2F;保存)</li><li><a href="http://localhost:0/users">http://localhost:0000/users</a>                           修改用户信息  PUT(修改&#x2F;更新)</li><li><a href="http://localhost:0/users/1">http://localhost:0000/users/1</a>                           删除用户信息  DELETE(删除)</li></ul></li><li><p>根据REST风格对资源进行访问称为<strong>RESTful</strong></p></li><li><p>RESTful通常要使用四种访问的请求方法 如GET、POST、PUT、DELETE。</p></li></ul><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>隐藏资源的访问行为，无法通过地址得知资源是何种操作</li><li>书写简化</li></ul><h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意:"></a>注意:</h4><ul><li>上述行为是约定方式，约定方式不是规范，可以打破，所以称为REST风格，而不是REST规范 但是由于使用REST风格的公司越来越多，也就慢慢都认为它是一种规范（都去遵守它了）。</li><li>描述模块名称通常使用复数，也就是加s的格式描述，表示此类资源，而非单个资源，例如users、books….。</li></ul><h4 id="实例步骤："><a href="#实例步骤：" class="headerlink" title="实例步骤："></a>实例步骤：</h4><ol><li>设定http请求动作（动词）</li><li>设定请求参数（路径变量）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="comment">//保存用户</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user save...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:user save&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除用户</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user delete...&quot;</span>+id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:user delete&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改用户</span></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user update...&quot;</span>+user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:user update&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取指定用户</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getById</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user getById...&quot;</span>+id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:user getById&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取全部用户</span></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAll</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user getAll...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:user getAll&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a><strong>配置文件</strong></h2><p>配置文件（application.properties）前面提到可以修改Springboot内置的端口号 </p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br></pre></td></tr></table></figure><p>还可以修改banner、log等配置信息</p><p>更多的、详细的配置信息都在<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties%E4%B8%AD">https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties中</a> </p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120211025873.png" alt="image-20220120211025873"></p><p><strong>注意：</strong></p><ul><li>配置文件中的内容要与你导入的依赖相关，如果你没有导入相关的依赖那么配置的内容是不会生效的，例如没有导入tomcat的依赖，那么配置文件中修改server.port是不会有高亮提示的也不生效。</li></ul><h4 id="配置文件的格式"><a href="#配置文件的格式" class="headerlink" title="配置文件的格式"></a>配置文件的格式</h4><ul><li><strong>.properties(传统格式&#x2F;默认格式)</strong></li><li>.yaml</li><li>.<strong>yml(主流)</strong></li></ul><p>上述三种配置文件同时存在的执行的优先级（会加载覆盖） </p><p>是properties &gt;&gt; yml &gt;&gt; yaml</p><p>但上述情况一般不会出现</p><hr><h5 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h5><ul><li><p>YAML（YAML Ain’t Markup Language）,一种数据序列化格式</p></li><li><p><strong>优点：</strong></p><ul><li>容易阅读</li><li>容易与脚本语言交互</li><li>以数据为核心，重数据格式</li></ul></li><li><p><strong>YAML文件扩展名</strong></p><ul><li>.yaml</li><li><strong>.yml（主流）</strong></li></ul></li><li><p><strong>语法规则</strong></p><ul><li>大小写敏感</li><li>属性层级关系使用多行描述，每行结尾使用冒号结束</li><li>使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）</li><li>属性值前面添加空格（属性名与属性之间使用冒号+空格作为分隔）</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">country:</span> <span class="string">china</span></span><br></pre></td></tr></table></figure><ul><li><p>#表示注释</p></li><li><p>更多语法<a href="https://www.runoob.com/w3cnote/yaml-intro.html">YAML 入门教程 | 菜鸟教程 (runoob.com)</a></p><hr><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4></li></ul><h4 id="Java程序读取"><a href="#Java程序读取" class="headerlink" title="Java程序读取"></a><strong>Java程序读取</strong></h4><ul><li><p>使用Spring的IOC机制使用@Value注入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;country&#125;&quot;)</span><span class="comment">//读取键值对中的值</span></span><br><span class="line"><span class="keyword">private</span> String Country;</span><br></pre></td></tr></table></figure><ul><li>使用java类读取 （YAML类）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> YamlReader.class.getClassLoader().getResourceAsStream(<span class="string">&quot;application.yml&quot;</span>);) &#123;</span><br><span class="line">properties = yaml.loadAs(in, HashMap.class);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">&quot;Init yaml failed !&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>使用环境变量对象来存储yaml配置文件中的键值对（使用@Autowire注入赋值）<strong>用来应对当yaml配置文件中对象过多的情况</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line">    </span><br><span class="line">System.out.println(env.getProperty(<span class="string">&quot;server.port&quot;</span>));</span><br><span class="line">System.out.println(env.getProperty(<span class="string">&quot;Country&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li><p><strong>使用自定义类封装yaml配置文件中的数据</strong></p><p>​    application.yaml</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">User:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">丁杨维</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>自定义User类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span><span class="comment">//将对象的生命周期交给容器管理 也为了容器将配置文件中的信息赋值给该对象</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Controller.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getById</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120224222972.png" alt="image-20220120224222972"></p></li><li><p>yaml文件中值的相互引用 直接使用${键名}即可</p></li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">BaseDir:</span> <span class="string">c\windows</span></span><br><span class="line"><span class="attr">TempDir:</span> <span class="string">$&#123;BaseDir&#125;\temp</span></span><br><span class="line"><span class="comment">#如果有转义字符想要显示出来 就加上双引号 如这里\t就是一个转义字符</span></span><br><span class="line"><span class="attr">TempDir:</span> <span class="string">&quot;$&#123;BaseDir&#125;\temp&quot;</span></span><br></pre></td></tr></table></figure><hr><p><strong>注意：</strong></p><ul><li><p>虽然配置文件格式多 单文件名可不是乱取的 名字一定是<strong>application.xxx</strong>才行</p></li><li><p>如果idea没有识别你的yaml文件或是yml文件为springboot配置文件（前提是文件名是applicaiton.xxx） 可以在Project Struct中设置</p></li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120213544643.png" alt="image-20220120213544643"></p><p>选择Facts 选择Configuration Files 在点击那个绿叶标志</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120213633139.png" alt="image-20220120213633139"></p><p>点击+号找到你的文件</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120213807493.png" alt="image-20220120213807493"></p><h2 id="SpringBoot整合第三方技术"><a href="#SpringBoot整合第三方技术" class="headerlink" title="SpringBoot整合第三方技术"></a>SpringBoot整合第三方技术</h2><p><strong>注意：</strong>如果使用的第三方技术无法在Spring Initializr中勾选到 则需要手动添加（maven中央仓库中查找）</p><h4 id="SpringBoot整合Junit"><a href="#SpringBoot整合Junit" class="headerlink" title="SpringBoot整合Junit"></a>SpringBoot整合Junit</h4><p>使用Spring Initializr创建一个普通的SpringBoot程序（啥都不选） 会自动导入test依赖</p><p><strong>这是因为maven创建的项目，生命周期中离不开test的原因，所以不用我们导入它会自动引入。</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">&lt;/dependenc</span><br></pre></td></tr></table></figure><p>BookDao.java接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BookImpl.java实现类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book save&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Springboot05ApplicationTests.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Springboot05ApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookImpl book;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        book.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试类获得结果</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120230704919.png" alt="image-20220120230704919"></p><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>使用测试类时要将测试类放在与classes目录下引导类的路径呈同级或子级关系 否则测试类会找不到**@SpringBootConfiguration**而出现异常，而引导类的注解中包含@SpringBootConfiguration 所以引导类也是一个SpringBootConfiguration。</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ol><li><strong>将测试类放在classes目录下与引导类的路径呈同级或是子级关系的包下。</strong></li><li>使用@ContextConfiguration(classes&#x3D;…)注解指定引导类</li><li><strong>使用@SpringBootTest(classes&#x3D;…)注解指定引导类</strong></li></ol><h4 id="SpringBoot整合Mybatis"><a href="#SpringBoot整合Mybatis" class="headerlink" title="SpringBoot整合Mybatis"></a>SpringBoot整合Mybatis</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><ol><li>使用Spring Initializr创建，<strong>需要勾选SQL中的MySQL Driver和MyBatis Framework，根据需要勾选WEB。</strong></li></ol><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120232906258.png" alt="image-20220120232906258"></p><p>Mybatis与SpringBoot整合的依赖以及JDBC的依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置数据库连接信息</li></ol><p>application.yml</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/my_db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">devil</span></span><br></pre></td></tr></table></figure><ol start="3"><li>写实体类</li></ol><p>Student.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dyw.springboot06mybatis.Domain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Devil</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-01-20-23:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>写StudentDao接口 写入相关操作</li></ol><p>StudentDao.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentDao</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select id,name,age from student order by id&quot;)</span></span><br><span class="line">    List&lt;Student&gt; <span class="title function_">selectStudents</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不适用配置文件那么则加入**@Mapper**注解 就类似于配置文件 自动代理 在里面使用@Select注解（查找）配置操作 @Update（修改&#x2F;更新）….</p><p>执行测试类</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120234846000.png" alt="image-20220120234846000"></p><h5 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h5><p>如果出现了serverTimezone异常 需要在配置文件URL后加入?serverTimezone&#x3D;UTC（时区任意）</p><h4 id="SpringBoot整合Mybatis-Plus"><a href="#SpringBoot整合Mybatis-Plus" class="headerlink" title="SpringBoot整合Mybatis-Plus"></a>SpringBoot整合Mybatis-Plus</h4><p>直接导入相应的依赖mybatis-plus-boot-starter即可</p><p>并且在配置文件中写上数据库相关配置即可</p><hr><h4 id="SpringBoot整合Mybatis-Druid"><a href="#SpringBoot整合Mybatis-Druid" class="headerlink" title="SpringBoot整合Mybatis+Druid"></a>SpringBoot整合Mybatis+Druid</h4><p>需要导入druid的依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.yml配置数据源类型</p><p>方式一: 在spring.datasource中配置type为DruidDataSource</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/my_db?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">devil</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br></pre></td></tr></table></figure><p>方式二: 直接在spring.datasource.druid中配置数据源信息</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/my_db?serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">devil</span></span><br></pre></td></tr></table></figure><p>推荐第二种</p><h2 id="SSMP-SpringBoot-Mybatis-Plus-综合案例"><a href="#SSMP-SpringBoot-Mybatis-Plus-综合案例" class="headerlink" title="SSMP(SpringBoot+Mybatis-Plus)综合案例"></a>SSMP(SpringBoot+Mybatis-Plus)综合案例</h2><blockquote><ol><li><strong>pom.xml</strong>  配置起步依赖</li><li><strong>application.yml</strong> 设置数据源 端口 框架技术相关配置等</li><li><strong>dao</strong> 继承BaseMapper, 设置@Mapper</li><li><strong>dao 测试类</strong></li><li><strong>service</strong> 调用数据层接口或Mybatis-Plus提供的接口(ServiceImpl&lt;BookMapper,Book&gt;)快速开发</li><li><strong>service测试类</strong></li><li><strong>controller</strong> 基于Restful开发, 使用Postman测试跑通功能</li><li><strong>页面</strong> 放置在resources目录下的static目录中</li></ol></blockquote><p>使用<strong>Spring Initializr</strong>创建项目 勾选<strong>Spring web</strong> 和 <strong>Mysql Driver</strong> 额外加入依赖<strong>Druid Mybatis-Plus</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建数据库表 创建实体类</p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220123202528206.png" alt="image-20220123202528206"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="comment">//@TableName(&quot;tbl_book&quot;)(这里可以选择在application.yml文件中配置mybaits-plus中的table_prefix=tbl_)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(value = &quot;id&quot;,type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/my_db?serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">devil</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">tbl_</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># mybatis-plus 日志配置    </span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><h3 id="表现层消息一致性处理"><a href="#表现层消息一致性处理" class="headerlink" title="表现层消息一致性处理"></a><strong>表现层消息一致性处理</strong></h3><ul><li>设计表现层返回结果的模型类,用于后端与前端进行数据格式的同意, 也称为<strong>前后端数据协议</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean flag;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Boolean flag)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Boolean flag, Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Boolean flag,String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>设计同一个返回值结果类型便于前端开发读取数据</li><li>返回值结果类型可以根据需求自行设定,没有固定格式</li><li>返回值结果模型类用于后端与前端进行数据格式同意, 也称为前后端数据协议</li></ol><h3 id="异常消息处理"><a href="#异常消息处理" class="headerlink" title="异常消息处理"></a><strong>异常消息处理</strong></h3><p>根据前文我们定义的<strong>前后端数据协议</strong> 如果遇到程序出现<strong>异常</strong> 会给前端返回一个异常数据 这并不在前后端数据协议定义范围 如果要进行消息处理 就必须进行<strong>异常消息处理</strong></p><ol><li><p>这里就要使用注解**@RestControllerAdvice**(控制器增强)定义SpringMVC异常处理器来处理异常的</p></li><li><p><strong>@ExceptionHandler</strong>(异常处理器)必须被扫描加载,否则无法生效</p></li><li><p>表现层返回结果中模型类中添加消息属性用来传递消息到页面</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作为springmvc异常处理</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//拦截所有的异常信息</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">doException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        <span class="comment">//记录日志</span></span><br><span class="line">        <span class="comment">//通知运维</span></span><br><span class="line">        <span class="comment">//通知开发</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="string">&quot;服务器故障,请稍后再试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="运维部分"><a href="#运维部分" class="headerlink" title="运维部分"></a><a href="D:\BaiduNetdiskDownload\运维实用篇-资料\PPT\SpringBoot运维实用篇（发布版）.pdf"><strong>运维部分</strong></a></h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220124205028879.png" alt="image-20220124205028879"></p><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220124205017270.png" alt="image-20220124205017270"></p><h3 id="临时属性"><a href="#临时属性" class="headerlink" title="临时属性"></a>临时属性</h3><ol><li>使用命令行dos命令运行springboot工程是可以使用临时属性替换配置文件中的属性</li><li>临时属性添加方式: java -jar 工程名.jar –属性名&#x3D;值</li><li>多个临时属性之间使用空格分隔</li><li>临时属性必须是当前boot工程支持的属性,否则设置无效</li></ol><h3 id="配置文件的四级分类"><a href="#配置文件的四级分类" class="headerlink" title="配置文件的四级分类"></a>配置文件的四级分类</h3><ul><li>SpringBoot中4级配置文件(级别越高 优先级越高)</li></ul><blockquote><p>1级： file ：config&#x2F;application.yml  <strong>【最高】</strong> </p><p>2级： file ：application.yml</p><p>3级：classpath：config&#x2F;application.yml</p><p>4级：classpath：application.yml  <strong>【最低】</strong></p></blockquote><ul><li>作用：</li></ul><blockquote><p>1级与2级留做系统打包后设置通用属性，1级常用于运维经理进行线上整体项目部署方案调控</p><p>3级与4级用于系统开发阶段设置通用属性，3级常用于项目经理进行整体项目属性调控</p></blockquote><h3 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h3><ul><li>通过启动参数加载配置文件（无需书写配置文件扩展名)</li><li><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220125222425964.png" alt="image-20220125222425964"></li><li>通过启动参数加载指定文件路径下的配置文件</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220125222635339.png" alt="image-20220125222635339"></p><ul><li>通过启动参数加载指定文件路径下的配置文件时可以加载多个配置</li></ul><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220125222709306.png" alt="image-20220125222709306"></p><h4 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h4><blockquote><ul><li><p>单服务器项目：使用自定义配置文件需求较低</p></li><li><p>多服务器项目：使用自定义配置文件需求较高，将所有配置放置在一个目录中，统一管理</p></li><li><p>基于SpringCloud技术，所有的服务器将不再设置配置文件，而是通过配置中心进行设定，动态加载配置信息</p></li></ul></blockquote><h3 id="多环境开发-YAML版"><a href="#多环境开发-YAML版" class="headerlink" title="多环境开发(YAML版)"></a>多环境开发(YAML版)</h3><h4 id="单配置文件版本"><a href="#单配置文件版本" class="headerlink" title="单配置文件版本"></a>单配置文件版本</h4><ul><li><p>多环境开发需要设置若干种常用环境,例如开发 生产 测试环境</p></li><li><p>yaml格式中设置多环境使用<code>&quot;---&quot;</code>区分环境设置边界</p></li><li><p>每种环境的区别在于加载的配置属性不同</p></li><li><p>启用某种环境时需要指定启动时使用该环境</p></li><li><pre><code class="yml">#生成环境spring:  config:    activate:      on-profile: pro</code></pre></li><li><p>&#96;&#96;&#96;yml<br>#指定环境<br>spring:<br>  profiles:<br>active: test</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  实例</span><br><span class="line"></span><br><span class="line">```yml</span><br><span class="line">#应用环境</span><br><span class="line">#公共配置</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: test</span><br><span class="line">---</span><br><span class="line">#设置环境</span><br><span class="line">#生成环境</span><br><span class="line">spring:</span><br><span class="line">  config:</span><br><span class="line">    activate:</span><br><span class="line">      on-profile: pro</span><br><span class="line">server:</span><br><span class="line">  port: 81</span><br><span class="line">---</span><br><span class="line">#开发环境</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">server:</span><br><span class="line">  port: 82</span><br><span class="line">---</span><br><span class="line">#测试环境</span><br><span class="line">spring:</span><br><span class="line">  config:</span><br><span class="line">    activate:</span><br><span class="line">      on-profile: test</span><br><span class="line">server:</span><br><span class="line">  port: 83</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="多配置文件版本"><a href="#多配置文件版本" class="headerlink" title="多配置文件版本"></a>多配置文件版本</h4><ol><li>主启动配置文件 application.yml</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><ol start="2"><li>环境分类配置文件application-pro.yml</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">82</span></span><br></pre></td></tr></table></figure><ol start="3"><li>环境分类配置文件application-dev.yml</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">81</span></span><br></pre></td></tr></table></figure><ol start="4"><li>环境分类配置文件application-dev.yml</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">83</span></span><br></pre></td></tr></table></figure><p>环境的分类多配置文件其实就是在application后加上<code>-环境名称</code>即可</p><ul><li>可以独立配置文件定义环境属性</li><li>独立配置文件便于线上系统维护更新并保障系统安全性</li></ul><h3 id="多环境开发-Properties"><a href="#多环境开发-Properties" class="headerlink" title="多环境开发(Properties)"></a><strong>多环境开发(Properties)</strong></h3><p>步骤与yml版一致 只是由于与yml文件的格式不同导致两者的格式不同 </p><ul><li>但properties版本支支持多文件模式 不支持单一配置文件多环境模式</li></ul><h3 id="多环境分组管理"><a href="#多环境分组管理" class="headerlink" title="多环境分组管理"></a><strong>多环境分组管理</strong></h3><ul><li><p>根据功能对配置文件中的信息进行拆分,并制作成独立的配置文件,命名规则如下(实际开发中)</p><ul><li>applicaiton-devDB.yml</li><li>applicaiton-devRedis.yml</li><li>applicaiton-devMVC.yml</li></ul></li><li><p>使用include属性在激活指定环境的情况下,同时对多个环境进行加载使其生效,多个环境间使用逗号分隔(引入一个环境配置文件组)</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">    <span class="attr">include:</span> <span class="string">devDB,devRedis,devMVC</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 当主环境有相同属性时,当主环境生效;其他环境中有相同属性时,最后加载的环境属性生效</p></li></ul><hr><ul><li>从SpringBoot2.4版本开始使用group替代了include属性,降低了配置书写量</li><li>使用group属性定义多种主环境与子环境的包含关系</li></ul><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">    <span class="attr">group:</span> </span><br><span class="line">      <span class="attr">&quot;dev&quot;:</span> <span class="string">devDB,devRedis,devMVC</span></span><br><span class="line">      <span class="attr">&quot;pro&quot;:</span> <span class="string">proDB,proRedis,proMVC</span></span><br></pre></td></tr></table></figure><p><strong>实际开发中 常使用<code>&quot;group&quot;</code></strong></p><p>多环境开发中使用group属性设置配置文件分组,便于线上维护管理</p><h3 id="多环境开发控制"><a href="#多环境开发控制" class="headerlink" title="多环境开发控制"></a><strong>多环境开发控制</strong></h3><p><strong>SpringBoot在工作时是基于maven坐标运行的</strong></p><ul><li>当Maven与SpringBoot同时对多环境进行控制时,以Maven为主,SpringBoot使用<code>@..@</code>占位符读取Maven对应的配置属性值</li><li>基于SpringBoot读取Maven配置属性的前提下,如果在Idea下测试工程时p吗.xml每次更新需要手动compile或是刷新Maven方可生效</li></ul><ol><li>需要在Maven的pom.xml中配置多环境属性值</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置多环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span><span class="comment">&lt;!--设置获得profile--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span><span class="comment">&lt;!--是否默认生效--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_pro<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>pro<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在SpringBoot配置文件中指定获取Maven中活动的profile</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">@profile.active@</span></span><br></pre></td></tr></table></figure><hr><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a><strong>日志</strong></h3><h4 id="日志基础操作"><a href="#日志基础操作" class="headerlink" title="日志基础操作"></a>日志基础操作</h4><ul><li>日志(log)作用<ul><li>编程期调试diamagnetic</li><li>运营期记录信息<ul><li>记录日常运营重要信息(峰值流量 平均响应时长…..)</li><li>记录应用报错信息(错误堆栈)</li><li>记录运维过程数据(扩容 宕机 报警….)</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/log&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Controller3</span> &#123;</span><br><span class="line">    <span class="comment">//创建记录日志的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(Controller3.class);</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doLog</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;debug...&quot;</span>);</span><br><span class="line">        log.error(<span class="string">&quot;error...&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;infor...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;warn...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SpringBoot2 正在运行....&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="日志级别-从上往下依次升高"><a href="#日志级别-从上往下依次升高" class="headerlink" title="日志级别(从上往下依次升高)"></a>日志级别(从上往下依次升高)</h4><blockquote><ul><li><p><strong>TRACE</strong>：运行堆栈信息，使用率低</p></li><li><p><strong>DEBUG</strong>：程序员调试代码使用</p></li><li><p><strong>INFO</strong>：记录运维过程数据</p></li><li><p><strong>WARN</strong>：记录运维过程报警数据</p></li><li><p><strong>ERROR</strong>：记录错误堆栈信息</p></li><li><p><strong>FATAL</strong>：灾难信息，合并计入ERROR</p></li></ul></blockquote><p><strong>设置日志输出级别 可以在springboot配置文件中设置</strong></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启debug模式，输出调试信息，常用于检查系统运行状况</span></span><br><span class="line"><span class="attr">debug:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 设置日志级别，root表示根节点，即整体应用日志级别</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><p><strong>设置日志组,控制指定包对应的日志输出级别,也可以直接空值指定包对应的日志输出级别</strong></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="comment"># 设置日志组</span></span><br><span class="line">  <span class="attr">group:</span></span><br><span class="line"><span class="comment"># 自定义组名，设置当前组中所包含的包</span></span><br><span class="line">    <span class="attr">ebank:</span> <span class="string">com.itheima.controller</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">warn</span></span><br><span class="line"><span class="comment"># 为对应组设置日志级别</span></span><br><span class="line">    <span class="attr">ebank:</span> <span class="string">debug</span></span><br><span class="line"><span class="comment"># 为对包设置日志级别</span></span><br><span class="line">    <span class="attr">com.itheima.controller:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><h4 id="优化日志对象创建代码"><a href="#优化日志对象创建代码" class="headerlink" title="优化日志对象创建代码"></a>优化日志对象创建代码</h4><ul><li>使用lombok提供的注解**@Slf4j**简化开发,减少日志对象的声明操作</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/log&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Controller3</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doLog</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;debug...&quot;</span>);</span><br><span class="line">        log.error(<span class="string">&quot;error...&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;infor...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;warn...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SpringBoot2 正在运行....&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="日志输出格式"><a href="#日志输出格式" class="headerlink" title="日志输出格式"></a>日志输出格式</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2022-01-26 14:07:21.604  INFO 1416 --- [           main] c.a.d.s.b.a.DruidDataSourceAutoConfigure : Init DruidDataSource</span><br><span class="line">2022-01-26 14:07:21.700  INFO 1416 --- [           main] com.alibaba.druid.pool.DruidDataSource   : &#123;dataSource-1&#125; inited</span><br></pre></td></tr></table></figure><p>上述即为日志的默认结构 分为 <strong>时间 日志级别 PID 所属线程 所属类&#x2F;接口名 日志信息</strong></p><ul><li>PID：进程ID，用于表明当前操作所处的进程，当多服务同时记录日志时，该值可用于协助程序员调试程序</li><li>所属类&#x2F;接口名：当前显示信息为SpringBoot重写后的信息，名称过长时，简化包名书写为首字母，甚至直接删除</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SpringBoot&quot;&gt;&lt;a href=&quot;#SpringBoot&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot&quot;&gt;&lt;/a&gt;SpringBoot&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;SpringBoot 相当于是一个Spring 和 SpringMVC的集成 又在其上增加了其他功能 对其他主流框架的支持也是非常好, 所以SpringBoot更新的非常频繁,需要时常关注它更新的内容&lt;/li&gt;
&lt;li&gt;微服务架构&lt;br&gt; 　Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。&lt;br&gt; 　该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。　　&lt;br&gt; 　通过这种方式，Spring Boot 致力于在蓬勃发展的快速应用开发领域（rapidapplication development）成为领导者。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="spring框架" scheme="https://devildyw.github.io/categories/spring%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring" scheme="https://devildyw.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="https://devildyw.github.io/2022/02/28/Spring/"/>
    <id>https://devildyw.github.io/2022/02/28/Spring/</id>
    <published>2022-02-28T12:58:54.000Z</published>
    <updated>2022-04-16T08:56:43.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>spring全家桶：spring ， springmvc ，spring boot , spring cloud </p><p>  spring: 出现是在2002左右，解决企业开发的难度。减轻对项目模块之间的管理，<br>          类和类之间的管理， 帮助开发人员创建对象，管理对象之间的关系。<br>             spring核心技术 ioc ， aop 。能实现模块之间，类之间的解耦合。</p><span id="more"></span><p><strong>耦合</strong>:是指两个或两个以上的体系或两种运动形式间通过相互作用而彼此影响以至联合起来的现象。</p><p><strong>解耦合</strong>:指将程序的结构变得松散不是固定的而是可变化的 例如接口的实现类是可以更换的 而直接写的类是顶死的 <strong>解耦就是用数学方法将两种运动分离开来处理问题。</strong>程序的解耦合大概就是让代码和程序不绑定不互相依赖</p><p>  依赖：classa中使用classb的属性或者方法， 叫做classa依赖classb</p><hr><p>框架怎么学： 框架是一个软件，其它人写好的软件。<br> 1）知道框架能做什么， mybatis–访问数据库， 对表中的数据执行增删改查。<br> 2）框架的语法， 框架要完成一个功能，需要一定的步骤支持的，<br> 3）框架的内部实现， 框架内部怎么做。 原理是什么。<br> 4）通过学习，可以实现一个框架。</p><h3 id="IOC-反转控制"><a href="#IOC-反转控制" class="headerlink" title="IOC(反转控制)"></a>IOC(反转控制)</h3><p>spring的第一个核心功能 ioc</p><p>IoC (Inversion of Control) : 控制反转， 是一个理论，概念，思想。<br> 描述的：把对象的创建，赋值，管理工作都交给代码之外的容器实现， 也就是对象的创建是有其它外部资源完成。</p><p>控制： 创建对象，对象的属性赋值，对象之间的关系管理。<br>反转： 把原来的开发人员管理，创建对象的权限转移给代码之外的容器实现。 由容器代替开发人员管理对象。创建对象，<br>        给属性赋值。</p><p>正转：由开发人员在代码中，使用new 构造方法创建对象， 开发人员主动管理对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">           <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(); <span class="comment">// 在代码中， 创建对象。--正转。</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>容器：是一个服务器软件， 一个框架（spring）</p><p>为什么要使用 ioc ： 目的就是减少对代码的改动， 也能实现不同的功能。 实现解耦合。 </p><p>java中创建对象有哪些方式：</p><ol><li>构造方法 ， new Student（）</li><li>反射</li><li>序列化</li><li>克隆</li><li>ioc ：容器创建对象</li><li>动态代理</li></ol><p>ioc的体现：<br>   servlet  1： 创建类继承HttpServelt<br>             2:  在web.xml 注册servlet ， 使用<servlet-name> myservlet </servlet-name><br>                                                 <servelt-class>com.bjpwernode.controller.MyServlet1</servlet-class></p><pre><code>3. 没有创建 Servlet对象， 没有 MyServlet myservlet = new MyServlet()4. Servlet 是Tomcat服务器它能你创建的。 Tomcat也称为容器 Tomcat作为容器：里面存放的有Servlet对象， Listener ， Filter对象</code></pre><p>IoC的技术实现 ，<br>  DI 是ioc的技术实现，<br>  DI（Dependency Injection） :依赖注入， 只需要在程序中提供要使用的对象名称就可以， 至于对象如何在容器中创建，<br>                              赋值，查找都由容器内部实现。</p><p>spring是使用的di实现了ioc的功能， spring底层创建对象，使用的是<strong>反射机制</strong>。</p><p>spring是一个容器，管理对象，给属性赋值， 底层是反射创建对象。</p><p><strong>几种一般注入</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        声明Student对象</span></span><br><span class="line"><span class="comment">        注入:就是赋值的意思</span></span><br><span class="line"><span class="comment">        简单类型</span></span><br><span class="line"><span class="comment">        di:给属性赋值</span></span><br><span class="line"><span class="comment">        1.set注入(设置注入):spring调用类的set方法;你可以再set方法中完成属性赋值&lt;property&gt;(普通赋值 调用类中写好的set方法)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba01.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span><span class="comment">&lt;!--调用类中的对应的set方法 setName()--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;丁杨维&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    对引用类型进行set设置注入</span></span><br><span class="line"><span class="comment">    引用类型的set注入:spring调用类的set方法</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba01.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;丁杨维&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;school&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mySchool&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mySchool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba02.School&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;成信大&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;四川成都双流区&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        2.构造注入:spring调用类有参构造方法,再创建对象的同时,在构造方法中给属性赋值.</span></span><br><span class="line"><span class="comment">        构造注入使用&lt;constructor-arg&gt;标签</span></span><br><span class="line"><span class="comment">        &lt;constructor-arg&gt;标签:一个&lt;constructor-arg&gt;标签表示构造方法的一个参数</span></span><br><span class="line"><span class="comment">        &lt;constructor-arg&gt;标签属性:</span></span><br><span class="line"><span class="comment">            name:表示构造方法的形参名</span></span><br><span class="line"><span class="comment">            index:表示构造方法的参数的位置.参数从左往右位置是0,1,2</span></span><br><span class="line"><span class="comment">            value:构造方法的形参类型是简单类型,使用value</span></span><br><span class="line"><span class="comment">            ref:构造方法的形参是引用类性,使用ref;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba01.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;丁杨维&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;school&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mySchool&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用index--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba01.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;丁杨维&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mySchool&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mySchool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba02.School&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cuit&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sccd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--省略index 但要按照0,1,2的顺序--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent02&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba01.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>  <span class="attr">value</span>=<span class="string">&quot;阿丁&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>  <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>  <span class="attr">ref</span>=<span class="string">&quot;mySchool&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>引用类型的自动注入</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        引用类型的自动注入:spring框架根据某些规则可以给引用类型赋值.不用我们自己给引用类型赋值了</span></span><br><span class="line"><span class="comment">        使用的规则常用的是byName,byType</span></span><br><span class="line"><span class="comment">        1.byName(按名称注入):java类中的引用类型的属性名和spring容器中(配置文件)&lt;bean&gt;的id一样</span></span><br><span class="line"><span class="comment">        且数据类型是一致的,这样的容器中的bean,spring能够赋值给引用类型.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1.ByName--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba03.Student&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;丁杨维&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;school&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba03.School&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cuit&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sccd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        ByType:按类型注入: java中引用的数据类型和spring容器中(配置文件)&lt;bean&gt;的class=&quot;&quot;中的</span></span><br><span class="line"><span class="comment">                            类是同源关系,这样的bean能够赋值给引用类型</span></span><br><span class="line"><span class="comment">                            同源就是一类的意思:</span></span><br><span class="line"><span class="comment">                            1.java类中引用类型的数据类型和bean的class的值是一样的</span></span><br><span class="line"><span class="comment">                            2.java类中引用类型的数据类型和bean的class的值是父子关系.</span></span><br><span class="line"><span class="comment">                            3.java类中引用类型的数据类型和bean的class的值是接口和实现类的关系.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意bean下是常规的set注入除了引用类型(它是由ByType注入)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--2.ByType--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Student01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba04.Student&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;丁杨维&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mSchool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba04.School&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cuit&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sccd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>spring-conetxt 和 spring-webmvc是spring中的两个模块</p><p>spring-context：是ioc功能的，创建对象的。<br>spring-webmvc做web开发使用的， 是servlet的升级。<br>spring-webmvc中也会用到spring-context中创建对象的功能的。</p><p>junit : 单元测试， 一个工具类库，做测试方法使用的。<br>  单元：指定的是方法， 一个类中有很多方法，一个方法称为单元。</p><p>  使用单元测试<br>   1.需要加入junit依赖。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  2.创建测试作用的类：叫做测试类<br>    src&#x2F;test&#x2F;java目录中创建类</p><p>  3.创建测试方法</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1）public 方法</span><br><span class="line"> 2）没有返回值 void </span><br><span class="line"> 3）方法名称自定义，建议名称是test + 你要测试方法名称</span><br><span class="line"> 4）方法没有参数</span><br><span class="line"> 5）方法的上面加入 @Test ,这样的方法是可以单独执行的。 不用使用main方法。</span><br></pre></td></tr></table></figure><hr><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ol><li>多个配置优势<br> 1.每个文件的大小比一个文件要小很多。效率高<br> 2.避免多人竞争带来的冲突。</li></ol><p>  如果你的项目有多个模块（相关的功能在一起） ，一个模块一个配置文件。<br>  学生考勤模块一个配置文件，  张三<br>  学生成绩一个配置文件，      李四</p><p>  多文件的分配方式：</p><ol><li>按功能模块，一个模块一个配置文件</li><li>按类的功能，数据库相关的配置一个文件配置文件， 做事务的功能一个配置文件， 做service功能的一个配置文件等</li></ol><h3 id="基于注解的DI"><a href="#基于注解的DI" class="headerlink" title="基于注解的DI"></a>基于注解的DI</h3><p>2.基于注解的di： 通过注解完成java对象创建，属性赋值。<br>  使用注解的步骤：<br>   1.加入maven的依赖 spring-context ，在你加入spring-context的同时， 间接加入spring-aop的依赖。<br>      使用注解必须使用spring-aop依赖</p><pre><code>2.在类中加入spring的注解（多个不同功能的注解）3.在spring的配置文件中，加入一个组件扫描器的标签，说明注解在你的项目中的位置</code></pre><p>   学习的注解：<br>     1.@Component </p><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> 用于创建对象 等同于bean的功能</span><br><span class="line">value里的值就等同于&lt;bean&gt;中的id</span><br><span class="line">value的值应当是唯一的 创建的对象在整个spring容器中就一个</span><br><span class="line"></span><br><span class="line">位置:定义类的上面</span><br><span class="line"><span class="meta">@Component(value = &quot;myStudent&quot;)</span></span><br><span class="line">如果就只有value一个参数也可省略value</span><br><span class="line"><span class="meta">@Component(&quot;myStudent&quot;)</span>    </span><br><span class="line">也可不写(中的内容)spring提供默认名称(类的名称但首字母小写)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">一般用第二种</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> 声明组件扫描器(component-scan),组件指的就是java对象</span></span><br><span class="line"><span class="comment"> base-package:指定注解在你项目中的包名</span></span><br><span class="line"><span class="comment"> component-scan工作方式:spring会扫描遍历vase-package指定的包</span></span><br><span class="line"><span class="comment">     把包中和子包中的所有类遍历,找到类中的注解,按照注解的功能,按照注解的功能创建对象,或给属性赋值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--在配置文件中添加一个组件扫描器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw.Ba01&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--组件扫描器指定多个包的三种方式--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--第一种:使用多次组件扫描器,指定不同的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw.Ba01&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw.Ba02&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--第二种:使用分隔符(;或,)分隔多个包名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw.Ba01;com.dyw.Ba02&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--第三种方式:指定父包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></blockquote><p>​    2.@Respotory</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(用在持久层上的):放在dao实现类的上面</span><br><span class="line">表示创建dao对象,dao对象是可以访问数据库的.</span><br><span class="line">用法于@Component一致,但还有额外功能</span><br></pre></td></tr></table></figure><p>​     3.@Service</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(用在业务层上的):放在service的实现类上面,创建service对象,service对象是做业务处理的,可以有事务功能</span><br><span class="line">用法于@Component一致,但还有额外功能</span><br></pre></td></tr></table></figure><p>​     4.@Controller</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(用在控制器上的):放在控制器(处理器)类的上卖弄,创建控制器对象的,</span><br><span class="line">控制器对象,能够接收用户提交的参数,显示请求的处理结果</span><br><span class="line">用法于@Component一致,但还有额外功能</span><br></pre></td></tr></table></figure><hr><blockquote><p>​    <strong>@Respotory(持久层)  @Service(业务层) @Controller(控制层)用于给项目分层</strong></p></blockquote><p>5.@Value</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@value</span>简单类型的属性赋值</span><br><span class="line">      属性: value 是String类型的,表示简单类型的属性值</span><br><span class="line">      位置:<span class="number">1.</span>在属性定义的上面,无需set方法,推荐使用.</span><br><span class="line">          <span class="number">2.</span>在set方法上面</span><br><span class="line">          </span><br><span class="line">    <span class="meta">@Value(value = &quot;20&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="meta">@Value(value = &quot;丁杨维&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;20&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​     6.@Autowired</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>应用类型赋值</span><br><span class="line">   <span class="meta">@Autowired</span>:spring框架提供的注解,实现引用类型的赋值.</span><br><span class="line">   spring中通过注解给引用类型赋值,使用的是自动注入原理,支持byName,byType</span><br><span class="line">   <span class="meta">@Atuowired</span>:默认使用的是byType自动注入</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Autowired</span>默认属性为  require = <span class="literal">true</span> 表示引用类型赋值失败,程序报错,并终止执行</span><br><span class="line">                        require=<span class="literal">false</span>:引用类型如果赋值失败,程序正常执行,引用类型是<span class="literal">null</span>    </span><br><span class="line">       </span><br><span class="line">       位置:<span class="number">1</span>) 在属性定义的上面,无需set方法,推荐使用</span><br><span class="line">            <span class="number">2</span>) 在set方法的上面</span><br><span class="line">           </span><br><span class="line">   如果使用byName方式 需要做的是:</span><br><span class="line">   <span class="number">1.</span>在属性上面加入<span class="meta">@Autowired</span></span><br><span class="line">   <span class="number">2.</span>在属性的上面加入<span class="meta">@Quallifier(value=&quot;bean的id&quot;)</span>:表示使用指定名称的bean完成赋值</span><br><span class="line">   <span class="comment">//byType    </span></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="meta">@Qualifier(value = &quot;school01&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> School school;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">   <span class="comment">//byName    </span></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="meta">@Qualifier(value = &quot;school01&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> School school;</span><br></pre></td></tr></table></figure><p>​     7.@Resource</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">是用之前需要再pom.xml中添加j2ee依赖</span><br><span class="line"><span class="meta">@Resource</span>赋值引用类型: 来自jdk中的注解,spring框架提供了对这个注解的功能的支持,可以使用它给引用类型赋值</span><br><span class="line">     *             使用的也是自动注入原理,支持byName,byType,默认是byName</span><br><span class="line">     * 位置: <span class="number">1</span>)在属性定义的上面,无需set方法,推荐使用</span><br><span class="line">     *       <span class="number">2</span>)在set方法的上面</span><br><span class="line">     *</span><br><span class="line">     * 默认是byName: 先使用byName自动注入,如果byName注入失败,再使用byType</span><br><span class="line">     * 不写(name = <span class="string">&quot;&quot;</span>)是默认属性名 写上就可以指定名称</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">    <span class="meta">@Resource(name = &quot;school03&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> School school;</span><br></pre></td></tr></table></figure><h4 id="其他注解"><a href="#其他注解" class="headerlink" title="其他注解"></a>其他注解</h4><p><strong>注解可以通过与配置文件结合的方式解耦合</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">name=丁杨维</span><br><span class="line">age=20</span><br><span class="line"><span class="comment">&lt;!--anno.properites--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw.Ba07&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--将配置文件路劲导入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:anno.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--然后便可再java文件中使用$&#123;&#125;加注解的方式赋值--&gt;</span></span><br><span class="line">public class Student &#123;</span><br><span class="line">    @Value(&quot;$&#123;age&#125;&quot;)</span><br><span class="line">    private int age;</span><br><span class="line">    @Value(&quot;$&#123;name&#125;&quot;)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">但是@Component好像不能使用这个方式赋值 会报错</span><br></pre></td></tr></table></figure><p>用户处理请求：<br>   用户form ,参数name ，age—–Servlet(接收请求name，age)—Service类（处理name，age操作）—dao类（访问数据库的）—mysql</p><hr><h2 id="aop"><a href="#aop" class="headerlink" title="aop"></a><strong>aop</strong></h2><p>1.动态代理<br>  实现方式：jdk动态代理，使用jdk中的Proxy，Method，InvocaitonHanderl创建代理对象。<br>             jdk动态代理要求目标类必须实现接口</p><p>  cglib动态代理：第三方的工具库，创建代理对象，原理是继承。 通过继承目标类，创建子类。<br>             子类就是代理对象。 要求目标类不能是final的， 方法也不能是final的</p><p>2.动态代理的作用：<br>   1）在目标类源代码不改变的情况下，增加功能。<br>    2）减少代码的重复<br>    3）专注业务逻辑代码<br>    4）解耦合，让你的业务功能和日志，事务非业务功能分离。</p><p>3.Aop:面向切面编程， 基于动态代理的，可以使用jdk，cglib两种代理方式。<br>  Aop就是动态代理的规范化， 把动态代理的实现步骤，方式都定义好了，<br>  让开发人员用一种统一的方式，使用动态代理。</p><ol start="4"><li>AOP（Aspect Orient Programming）面向切面编程<br> Aspect: 切面，给你的目标类增加的功能，就是切面。 像上面用的日志，事务都是切面。<br>   切面的特点： 一般都是非业务方法，独立使用的。<br> Orient：面向， 对着。<br> Programming：编程</li></ol><p>  oop: 面向对象编程</p><p>  怎么理解面向切面编程 ？<br>   1）需要在分析项目功能时，找出切面。<br>    2）合理的安排切面的执行时间（在目标方法前， 还是目标方法后）<br>    3）合理的安全切面执行的位置，在哪个类，哪个方法增加增强功能</p><p>  术语：<br>   1）Aspect:切面，表示增强的功能， 就是一堆代码，完成某个一个功能。非业务功能，<br>              常见的切面功能有日志， 事务， 统计信息， 参数检查， 权限验证。</p><p>   2）JoinPoint:连接点 ，连接业务方法和切面的位置。 就某类中的业务方法,一个类中的每一个方法都是连接点<br>    3）Pointcut : 切入点 ，对连接点的筛选,筛选出需要增强功能的方法<br>    4）目标对象： 给哪个类的方法增加功能， 这个类就是目标对象<br>    5）Advice:通知，通知表示切面功能执行的时间。</p><pre><code>说一个切面有三个关键的要素：1）切面的功能代码，切面干什么2）切面的执行位置，使用Pointcut表示切面执行的位置3）切面的执行时间，使用Advice表示时间，在目标方法之前，还是目标方法之后。</code></pre><p> 5.aop的实现<br>   aop是一个规范，是动态的一个规范化，一个标准<br>    aop的技术实现框架：<br>    1.spring：spring在内部实现了aop规范，能做aop的工作。<br>              spring主要在事务处理时使用aop。<br>                 我们项目开发中很少使用spring的aop实现。 因为spring的aop比较笨重。</p><p>   2.aspectJ: 一个开源的专门做aop的框架。spring框架中集成了aspectj框架，通过spring就能使用aspectj的功能。<br>      aspectJ框架实现aop有两种方式：<br>       1.使用xml的配置文件 ： 配置全局事务<br>        2.使用注解，我们在项目中要做aop功能，一般都使用注解， aspectj有5个注解。</p><p> 6.学习aspectj框架的使用。<br>   1）切面的执行时间， 这个执行时间在规范中叫做Advice(通知，增强)<br>       在aspectj框架中使用注解表示的。也可以使用xml配置文件中的标签</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>:是aspectj框架中的注解</span><br><span class="line">      作用:表示当前类是切面类</span><br><span class="line">      切面类:是用来给业务方法增加功能的类,在这个类中有切面的功能代码</span><br><span class="line">      位置:在类定义的上面</span><br><span class="line">切面类中的方法:</span><br><span class="line">定义方法:实现切面功能的</span><br><span class="line"> 方法的定义要求:</span><br><span class="line">      <span class="number">1.</span>公共方法 <span class="keyword">public</span></span><br><span class="line">      <span class="number">2.</span>方法没有返回值</span><br><span class="line">      <span class="number">3.</span>方法的名称自定义</span><br><span class="line">      <span class="number">4.</span>方法可以有参数,也可以没有参数</span><br><span class="line">           如果有参数,参数不是自定义的,有几个参数类型可以使用</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">     指定通知方法中的参数:JoinPoint</span><br><span class="line">     * JoinPoint:业务方法,要加入切面功能的业务方法</span><br><span class="line">     *      作用是:可以在通知方法中获取方法执行的信息,例如方法的名称,方法的实参.</span><br><span class="line">     *      如果你的切面功能中需要用到方法的信息,就加入JoinPoint.</span><br><span class="line">     *      这个JoinPoint参数的值是由框架赋予的,必须是第一个位置的参数,否装上述功能都没有 程序还会报错</span><br></pre></td></tr></table></figure><p>​        1）@Before</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>:表示前置通知</span><br><span class="line">     *      属性:value,是切入点表达式,表示切面的功能执行的位置.</span><br><span class="line">     *      位置:在方法的上面</span><br><span class="line">     *特点:  <span class="number">1.</span>在目标方法之前先执行</span><br><span class="line">     *       <span class="number">2.</span>不会改变目标方法的执行结果</span><br><span class="line">     *       <span class="number">3.</span>不会影响目标方法的执行.</span><br><span class="line">     *      execution(<span class="keyword">public</span> <span class="keyword">void</span> com.dyw.ba01.SomeServiceImpl.doSome(String,Integer)表示切入的位置</span><br></pre></td></tr></table></figure><p>​        2）@AfterReturning</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 后置通知定义方法,方法是实现切面功能的.</span><br><span class="line">     * 方法定义要求</span><br><span class="line">     * <span class="number">1.</span>公共方法<span class="keyword">public</span></span><br><span class="line">     * <span class="number">2.</span>方法没有返回值</span><br><span class="line">     * <span class="number">3.</span>方法名称自定义</span><br><span class="line">     * <span class="number">4.</span>方法有参数的,推荐Object,参数名自定义</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="meta">@AfterReturning</span>:后置通知</span><br><span class="line">     *      属性:<span class="number">1.</span>value 切入点表达式</span><br><span class="line">     *          <span class="number">2.</span>returning 自定义变量,表示方法的返回值的.</span><br><span class="line">     *          自定义变量名必须和通知方法的形参一样</span><br><span class="line">     *  .    位置:在方法定义的上面</span><br><span class="line">     * 特点:</span><br><span class="line">     * <span class="number">1</span>在目标方法之后生效</span><br><span class="line">     * <span class="number">2.</span>能够获取到目标方法的返回值,可以根据这个返回值做不同的处理功能</span><br><span class="line">     * <span class="number">3.</span>可以修改返回值</span><br><span class="line">     *</span><br><span class="line">     *</span><br><span class="line">     * 后置通知的执行</span><br><span class="line">     *      <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> doOther();</span><br><span class="line">     *      myAfterReturning(res);</span><br><span class="line">     *      System.out.println(res);     </span><br></pre></td></tr></table></figure><p>​        3）@Around</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> * 环绕通知方法的定义格式</span><br><span class="line"> * <span class="number">1.</span><span class="keyword">public</span></span><br><span class="line"> * <span class="number">2.</span>必须要有一个返回值,推荐使用Object</span><br><span class="line"> * <span class="number">3.</span>方法名称自定义</span><br><span class="line"> * <span class="number">4.</span>方法有参数,固定的参数ProceedingJoinPoint</span><br><span class="line"></span><br><span class="line"><span class="meta">@Around</span>: 环绕通知</span><br><span class="line">    属性:value 切入点表达式</span><br><span class="line">    位置:在方法的定义上面</span><br><span class="line">特点:</span><br><span class="line"> <span class="number">1.</span>他是功能最强的通知</span><br><span class="line"> <span class="number">2.</span>在目标方法的前和后都能被调用执行</span><br><span class="line"> <span class="number">3.</span>控制目标方法是否被调用执行</span><br><span class="line"> <span class="number">4.</span>修改原来的目标方法的执行结果.影响最后调用的结果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 环绕通知.等同于jdk动态代理的InvocationHandler接口</span><br><span class="line"></span><br><span class="line"> 参数: ProceedingJoinPoint就等同于jdk动态代理的Method</span><br><span class="line">     作用:执行目标方法的</span><br><span class="line"> 返回值:就是目标方法的执行结果,可以被修改</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      ProceedingJoinPoint是继承了JoinPoint 所以它具有JoinPoint的特性</span><br><span class="line"></span><br><span class="line"> 环绕通知:经常做事务,在目标方法之前开启事务,执行目标方法,在目标方法之后提交事务</span><br><span class="line"><span class="meta">@param</span> proceedingJoinPoint</span><br><span class="line"><span class="meta">@return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        4）@AfterThrowing <strong>异常通知</strong><br>​        5）@After <strong>后置通知</strong></p><p><strong>@Pointcut用于指定切入点的别名</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(value = &quot;myPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myBefore01</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Pointcut</span>:定义和管理切入点,如果你的项目中有多个切入点表达式是重复的,可以复用.</span></span><br><span class="line"><span class="comment">     *              可以使用<span class="doctag">@Pointcut</span></span></span><br><span class="line"><span class="comment">     *           属性:value 切入点表达式</span></span><br><span class="line"><span class="comment">     *           位置:自定义方法的上面</span></span><br><span class="line"><span class="comment">     *      特点:</span></span><br><span class="line"><span class="comment">     *          当使用<span class="doctag">@Pointcut</span>定义在一个方法的上面,此时这方法的名称就是切入点表达式的别名.</span></span><br><span class="line"><span class="comment">     *          当其他的通知中,value属性就可以使用这个方法的名称,代替切入点表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;execution(* *..SomeService.doSome(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myPointcut</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//无需代码 只是用该方法名代替切入点表达式</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>   2）表示切面执行的位置，使用的是切入点表达式。</p><pre><code>    com.service.impl    com.bjpowrnode.service.impl    cn.crm.bjpowernode.service  execution(* *..service.*.*(..))</code></pre><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">readme</span></span><br><span class="line"><span class="code">用aspectj框架实现aop</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"></span><br><span class="line">使用aop的目的是给已经存在的一些了业务方法,增加额外的功能,前提是不会更改原来类中的方法</span><br><span class="line"></span><br><span class="line"><span class="section">### 使用aspectj实现aop的基本步骤</span></span><br><span class="line"><span class="section">#### 1.新建maven项目</span></span><br><span class="line"><span class="section">####2.加入依赖</span></span><br><span class="line"><span class="bullet"> 1.</span> spring依赖</span><br><span class="line"><span class="bullet"> 2.</span> aspectj依赖</span><br><span class="line"><span class="bullet"> 3.</span> junit单元测试</span><br><span class="line"><span class="section">#### 3.创建目标类:接口和他的实现类</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 4.创建切面类:普通类</span></span><br><span class="line"><span class="bullet"> 1.</span> 在类上面加入注解@Aspect</span><br><span class="line"><span class="bullet"> 2.</span> 在类中定义方法,方法就是切面要执行的功能代码</span><br><span class="line"><span class="code">    在方法上面加入aspectj中的通知注解,例如@Before</span></span><br><span class="line"><span class="code">    有需要指定切入点表达式execution()</span></span><br><span class="line"><span class="code"> </span></span><br><span class="line"><span class="code">#### 5.创建spring配置文件:声明对象,把对象交给容器去统一管理声明对象你可以使用注解或xml配置文件&lt;bean&gt;</span></span><br><span class="line"><span class="code">1. 声明目标对象</span></span><br><span class="line"><span class="code">2. 声明切面类对象</span></span><br><span class="line"><span class="code">3. 声明aspectj框架中的自动代理生成器标签.</span></span><br><span class="line"><span class="code">    自动代理生成器:用来完成代理对象的自动创建功能的.</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section">#### 6.创建测试类,从spring容器中获取目标对象(实际就是代理对象).通过代理执行方法,实现aop的功能</span></span><br></pre></td></tr></table></figure><hr><h3 id="mybatis框架和spring集成"><a href="#mybatis框架和spring集成" class="headerlink" title="mybatis框架和spring集成"></a>mybatis框架和spring集成</h3><p>第四章： 把mybatis框架和spring集成在一起，像一个框架一样使用。</p><p>用的技术是：ioc 。<br>为什么ioc：能把mybatis和spring集成在一起，像一个框架， 是因为ioc能创建对象。<br> 可以把mybatis框架中的对象交给spring统一创建， 开发人员从spring中获取对象。<br> 开发人员就不用同时面对两个或多个框架了， 就面对一个spring</p><p>mybatis使用步骤，对象<br>1.定义dao接口 ，StudentDao<br>2.定义mapper文件 StudentDao.xml<br>3.定义mybatis的主配置文件 mybatis.xml<br>4.创建dao的代理对象， StudentDao dao &#x3D; SqlSession.getMapper(StudentDao.class);</p><p>   List<Student> students  &#x3D; dao.selectStudents();</p><p>要使用dao对象，需要使用getMapper()方法，<br>怎么能使用getMapper()方法，需要哪些条件<br>1.获取SqlSession对象， 需要使用SqlSessionFactory的openSession()方法。<br>2.创建SqlSessionFactory对象。 通过读取mybatis的主配置文件，能创建SqlSessionFactory对象</p><p>需要SqlSessionFactory对象， 使用Factory能获取SqlSession ，有了SqlSession就能有dao ， 目的就是获取dao对象<br>Factory创建需要读取主配置文件</p><p>我们会使用独立的连接池类替换mybatis默认自己带的， 把连接池类也交给spring创建。</p><p>主配置文件：<br> 1.数据库信息</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mydev&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--数据库的驱动类名--&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--连接数据库的url字符串--&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/springdb&quot;</span>/&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--访问数据库的用户名--&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--密码--&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>mapper文件的位置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/bjpowernode/dao/StudentDao.xml&quot;</span>/&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--&lt;mapper resource=&quot;com/bjpowernode/dao/SchoolDao.xml&quot; /&gt;--&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><hr><p>通过以上的说明，我们需要让spring创建以下对象<br>1.独立的连接池类的对象， 使用阿里的druid连接池 一般我么只需要配置url,user,password,maxActive(最大连接数);</p><p>2.SqlSessionFactory对象</p><p>3.创建出dao对象</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--DruidDataSource大部分属性都是参考DBCP的，如果你原来就是使用DBCP，迁移是十分方便的。--&gt;</span></span><br><span class="line">init-method 这里xml配置文件指定init是为了druid连接池启动时自动执行 destroy-method也是指销毁数据库连接池会制动执行close</span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc_url&#125;&quot;</span> /&gt;</span><span class="comment">&lt;!--可以使用properties文件指定jdbc的url等内容 然后加载 最后使用注解来解耦合或是隐藏敏感信息--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc_user&#125;&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc_password&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;filters&quot;</span> <span class="attr">value</span>=<span class="string">&quot;stat&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWait&quot;</span> <span class="attr">value</span>=<span class="string">&quot;6000&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;60000&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;300000&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnReturn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;poolPreparedStatements&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxOpenPreparedStatements&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;asyncInit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在上面的配置中，通常你需要配置url、username、password，maxActive这三项。</span></span><br><span class="line"><span class="comment">Druid会自动跟url识别驱动类名，如果连接的数据库非常见数据库，配置属性driverClassName</span></span><br><span class="line"><span class="comment">asyncInit是1.1.4中新增加的配置，如果有initialSize数量较多时，打开会加快应用启动时间--&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">                                            mybatis.xml</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置日志--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--设置别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--实体类所在的包名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.dyw.domain&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--name:是包名,是这个包中所有的mapper.xml一次都能加载--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.dyw.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">applicationContext.xml</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"> 0.使用了properties文件 加载</span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    1.声明数据源 这里用到了上面的druid数据库的spring<span class="tag">&lt;<span class="name">bean</span>&gt;</span>配置</span><br><span class="line">    <span class="comment">&lt;!--声明数据源DataSource ,作用是使用数据库的 这里声明的是DruidDataSource--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.root&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    2.声明SqlSessionFactoryBean(spring-mybatis集成中的类 通过这个工厂类可以创建SqlSessionFactory对象)</span><br><span class="line">    主要是指定数据源 因为mybatis.xml中我们是没有指定的 并且需要将mybatis.xml加载 将配置信息导入里面指定的mapper文件和domian类</span><br><span class="line">    <span class="comment">&lt;!--声明的是mybatis中提供的SqlSessionFactoryBean类,这个类内部创建SqlSessionFactory对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--set注入,把数据库的值付给了dataSource属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis主配置文件的位置</span></span><br><span class="line"><span class="comment">            configLocation属性是Resource类型,读取配置文件</span></span><br><span class="line"><span class="comment">            他的赋值,使用value,指定文件的路径,使用classpath:表示文件的位置</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    3.获取了SqlSessionFactory对象后 需要通过他生成的sqlSession对象 再调用getMapper(Dao.class)方法获取到dao接口的代理对象 让其放入到spring容器中管理</span><br><span class="line">    <span class="comment">&lt;!--创建dao对象,使用sqlSession的getMapper(StudentDao.class)</span></span><br><span class="line"><span class="comment">            MapperScannerConfigurer:在内部调用getMapper()生成每个dao接口的代理对象.</span></span><br><span class="line"><span class="comment">            不用指定id</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指定SqlSessionFactory对象的id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            指定包名,包名是dao接口所在的包名.</span></span><br><span class="line"><span class="comment">            MapperScannerConfigurer会扫描这个包中的所有接口,把每个接口都执行一次getMapper方法,得到每个接口的dao对象.</span></span><br><span class="line"><span class="comment">            创建好了的dao对象放入到spring的容器中的. 创建好的dao对象的名称时接口的首字母小写</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--简单复习 如果赋值时对象内的属性为简单类型 是使用value赋值 如果时引用对象则是ref--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--之所以扫描dao接口的包 是为了获得dao.class调用getMapper(Dao.class)方法创建dao接口的代理对象--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.dyw.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    4.创建业务类(有业务方法)的对象</span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.service.studentServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;studentDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;studentDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要学习就是上面三个对象的创建语法，使用xml的bean标签。</p><p>连接池：多个连接Connection对象的集合， List<Connection>  connlist : connList就是连接池</p><p>通常使用Connection访问数据库<br>Connection conn &#x3D;DriverManger.getConnection(url,username,password);<br>Statemenet stmt &#x3D; conn.createStatement(sql);<br>stmt.executeQuery();<br>conn.close();</p><p>使用连接池<br>在程序启动的时候，先创建一些Connection<br>Connection c1 &#x3D; …<br>Connection c2 &#x3D; …<br>Connection c3 &#x3D; …<br>List<Connection>  connlist &#x3D; new ArrayLits();<br>connList.add(c1);<br>connList.add(c2);<br>connList.add(c3);</p><p>Connection conn &#x3D; connList.get(0);<br>Statemenet stmt &#x3D; conn.createStatement(sql);<br>stmt.executeQuery();<br>把使用过的connection放回到连接池<br>connList.add(conn);</p><p>Connection conn1 &#x3D; connList.get(1);<br>Statemenet stmt &#x3D; conn1.createStatement(sql);<br>stmt.executeQuery();<br>把使用过的connection放回到连接池<br>connList.add(conn1);</p><hr><h2 id="spring的事务处理"><a href="#spring的事务处理" class="headerlink" title="spring的事务处理"></a>spring的事务处理</h2><h3 id="事务的基本要素-4大性质"><a href="#事务的基本要素-4大性质" class="headerlink" title="事务的基本要素 4大性质"></a><strong>事务的基本要素 4大性质</strong></h3><blockquote><ol><li>原子性:事务开始后的所有操作,要么全部成功,要么全部失败回滚,不可能停滞在中间环节.事务执行过程中出错,会回滚到事务开始之前的状态,所有操作就像没有发生一样.也就是说事务是一个不可分割的整体,就像化学中学过的原子,是事务构成的基本单位.</li><li>一致性:事务开始前和结束后,数据库的完整性约束没有被破坏,如A向B转张,不可能出现A扣了钱而B却没有加的情况</li><li>隔离性:同一时间,只允许一个事务请求同一数据,不同事务之间彼此没有任何干扰,如A正在从一张银行卡中取钱,在A取钱的过程结束前,B不能向这张卡转账.</li><li>持久性:事务完成之后,事务对数据库更新将会被保存写在数据库上,不能回滚.</li></ol></blockquote><p>回答问题<br>1.什么是事务<br>  讲mysql的时候，提出了事务。 事务是指一组sql语句的集合， 集合中有多条sql语句<br>  可能是insert ， update ，select ，delete， 我们希望这些多个sql语句都能成功，<br>  或者都失败， 这些sql语句的执行是一致的，作为一个整体执行。</p><p>2.在什么时候想到使用事务<br>  当我的操作，涉及得到多个表，或者是多个sql语句的insert，update，delete。需要保证<br>  这些语句都是成功才能完成我的功能，或者都失败，保证操作是符合要求的。</p><p>  在java代码中写程序，控制事务，此时事务应该放在那里呢？<br>     service类的业务方法上，因为业务方法会调用多个dao方法，执行多个sql语句</p><p>3.通常使用JDBC访问数据库， 还是mybatis访问数据库怎么处理事务<br>   jdbc访问数据库，处理事务  Connection conn ; conn.commit(); conn.rollback();<br>    mybatis访问数据库，处理事务， SqlSession.commit();  SqlSession.rollback();<br>    hibernate访问数据库，处理事务， Session.commit(); Session.rollback();</p><p>4.3问题中事务的处理方式，有什么不足<br>  1)不同的数据库访问技术，处理事务的对象，方法不同，<br>    需要了解不同数据库访问技术使用事务的原理<br>  2)掌握多种数据库中事务的处理逻辑。什么时候提交事务，什么时候回顾事务<br>  3)处理事务的多种方法。</p><p>  总结： 就是多种数据库的访问技术，有不同的事务处理的机制，对象，方法。</p><p>5.怎么解决不足<br>  spring提供一种处理事务的统一模型， 能使用统一步骤，方式完成多种不同数据库访问技术的事务处理。</p><p>  使用spring的事务处理机制，可以完成mybatis访问数据库的事务处理<br>  使用spring的事务处理机制，可以完成hibernate访问数据库的事务处理。</p><h3 id="spring事务的属性"><a href="#spring事务的属性" class="headerlink" title="spring事务的属性"></a><strong>spring事务的属性</strong></h3><p>Spring事务属性对应TransactionDefinition类里面的各个方法。TransactionDefinition类方法如下所示:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionDefinition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回事务传播行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getPropagationBehavior</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getIsolationLevel</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务超时时间，事务必须在多少秒之内完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getTimeout</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isReadOnly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。事务属性包含了5个方面：传播行为、隔离规则、回滚规则、事务超时、是否只读。</strong></p><p>6.处理事务，需要怎么做，做什么<br>  spring处理事务的模型，使用的步骤都是固定的。把事务使用的信息提供给spring就可以了</p><p>  1）事务内部提交，回滚事务，使用的事务管理器对象，代替你完成commit，rollback<br>     事务管理器是一个接口和他的众多实现类。<br>      接口：PlatformTransactionManager ，定义了事务重要方法 commit ，rollback<br>      实现类：spring把每一种数据库访问技术对应的事务处理类都创建好了。<br>               mybatis访问数据库—spring创建好的是DataSourceTransactionManager<br>                  hibernate访问数据库—-spring创建的是HibernateTransactionManager</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">怎么使用：你需要告诉spring 你用是那种数据库的访问技术，怎么告诉spring呢？</span><br><span class="line"> 声明数据库访问技术对于的事务管理器实现类， 在spring的配置文件中使用<span class="tag">&lt;<span class="name">bean</span>&gt;</span>声明就可以了</span><br><span class="line"> 例如，你要使用mybatis访问数据库，你应该在xml配置文件中</span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“xxx</span>&quot; <span class="attr">class</span>=<span class="string">&quot;...DataSourceTransactionManager&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure><h4 id="Spring事务的隔离级别"><a href="#Spring事务的隔离级别" class="headerlink" title="Spring事务的隔离级别"></a>Spring事务的隔离级别</h4><p>你的业务方法需要什么样的事务，说明需要事务的类型。<br>     说明方法需要的事务：<br>        1）事务的隔离级别：有4个值。<br>        ➢<strong>DEFAULT：采用 DB 默认的事务隔离级别。</strong>MySql 的默认为 REPEATABLE_READ； Oracle默认为 READ_COMMITTED。<br>        ➢ <strong>READ_UNCOMMITTED</strong>：<strong>读未提交</strong>(A事务在执行过程中,读到了B事务修改但未提交的数据,可能会发生B事务未修改回滚但被A事务读取到的情况,出现了<strong>脏读</strong>)。未解决任何并发问题。<br>        ➢ <strong>READ_COMMITTED：读已提交</strong>。解决脏读，存在不可重复读与幻读。<br>        ➢ <strong>REPEATABLE_READ：可重复读</strong>。解决脏读、不可重复读，存在幻读<br>        ➢ <strong>SERIALIZABLE：串行化</strong>(事务A执行完毕后才执行B事务)。不存在并发问题。</p><blockquote><p> <strong>ISOLATION_SERIALIZABLE(串行化)</strong> 隔离规则类型在开发中很少用到。举个很简单的例子。咱们使用了ISOLATION_SERIALIZABLE规则。A,B两个事务操作同一个数据表并发过来了。A先执行。A事务这个时候会把表给锁住，B事务执行的时候直接报错。</p><ol><li><p>事务隔离级别为**ISOLATION_READ_UNCOMMITTED(读未提交)**时，写数据只会锁住相应的行。</p></li><li><p>事务隔离级别为可**ISOLATION_REPEATABLE_READ(可重复读)**时，如果检索条件有索引(包括主键索引)的时候，默认加锁方式是next-key锁；如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。</p></li><li><p>事务隔离级别为**ISOLATION_SERIALIZABLE(串行化)**时，读写数据都会锁住整张表。</p></li><li><p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能(隔离级别越高 执行的时间越长)的影响也就越大。</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="number">2</span>) 事务的超时时间： 表示一个方法最长的执行时间，如果方法执行时超过了时间，事务就回滚。</span><br><span class="line">  单位是秒， 整数值， 默认是 -<span class="number">1.</span> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   为了使应用程序很好地运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，也会占用数据库资源。事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>) 事务是否只读:isReadOnly() : <span class="type">boolean</span> <span class="title function_">isReadOnlu</span><span class="params">()</span> <span class="literal">true</span>表示是只读,<span class="literal">false</span>表示非只读</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">如果在一个事务中所有关于数据库的操作都是只读的，也就是说，这些操作只读取数据库中的数据，而并不更新数据,　这个时候我们应该给该事务设置只读属性，这样可以帮助数据库引擎优化事务。提升效率。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>事务的传播行为:</strong> 控制业务方法是不是有事务的， 是什么样的事务的。<br>    7个传播行为，表示你的业务方法调用时，事务在方法之间是如果使用的.</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**当前事务传播行为是REQUIRED时,如果存在一个事务那么直接使用当前事务,如果没有事务,那么就创建一个事务,如:单独MethodB时上下文没有事务,执行时会创建一个新的事务;如果MethodA方法中上下文存在事务,在A中调用B时B会发现上下文中存在事务,MethodB就不会创建一个新的事务,而是直接加入到A的事务中*/</span></span><br><span class="line">PROPAGATION_REQUIRED</span><br><span class="line">        </span><br><span class="line"><span class="comment">/** 需要使用 JtaTransactionManager作为事务管理器。 </span></span><br><span class="line"><span class="comment">上下文没有事务,它会开启一个新的事务。如果一个事务已经存在，则先将这个存在的事务挂起。*/</span></span><br><span class="line">PROPAGATION_REQUIRES_NEW</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/** 如果存在事务,支持当前事务,如果没有事务,则非事务的执行.但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。 */</span></span><br><span class="line">PROPAGATION_SUPPORTS</span><br><span class="line">以上三个需要掌握的</span><br><span class="line"><span class="comment">/** 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。即必须有事务,没有一个事务就抛出异常*/</span></span><br><span class="line">PROPAGATION_MANDATORY</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 如果一个活动的事务存在，则运行在一个嵌套的事务中。 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行。 */</span>   </span><br><span class="line">PROPAGATION_NESTED</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/** 总是非事务地执行，如果存在一个活动事务，则抛出异常。*/</span>  </span><br><span class="line">PROPAGATION_NEVER</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/** 总是非事务地执行，并挂起任何存在的事务。使用PROPAGATION_NOT_SUPPORTED,也需要使用JtaTransactionManager作为事务管理器。 */</span>  </span><br><span class="line">PROPAGATION_NOT_SUPPORTED  </span><br></pre></td></tr></table></figure><p>​    <a href="https://blog.csdn.net/weixin_39625809/article/details/80707695">PROPAGATION_NESTED 与PROPAGATION_REQUIRES_NEW的区别:</a></p><p>​    </p><ol start="4"><li><strong>事务提交事务，回滚事务的时机</strong><br> 1）当你的业务方法，执行成功，没有异常抛出，当方法执行完毕，spring在方法执行后提交事务。事务管理器commit</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="number">2</span>）(默认情况下)当你的业务方法抛出运行时异常或<span class="title function_">ERROR</span>(即未受查异常)， spring执行回滚，调用事务管理器的rollback</span><br><span class="line">     运行时异常的定义： <span class="title class_">RuntimeException</span>  和他的子类都是运行时异常， 例如<span class="title class_">NullPointException</span> , <span class="title class_">NumberFormatException</span></span><br><span class="line">  </span><br><span class="line">  <span class="number">3</span>) 当你的业务方法抛出非运行时异常， 主要是受查异常时，提交事务</span><br><span class="line">    受查异常：在你写代码中，必须处理的异常。例如<span class="title class_">IOException</span>, <span class="title class_">SQLException</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">注意:你可以声明事务遇到特定的受查异常时像遇到运行时异常那样回滚,同样,你还可以声明事务遇到特定的异常不回滚,即使这些异常是运行时异常.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>总结spring的事务<br>  1.管理事务的是 事务管理和他的实现类<br>  2.spring的事务是一个统一模型<br>     1）指定要使用的事务管理器实现类，使用<bean></bean>spring容器创建管理对象<br>      2）指定哪些类，哪些方法需要加入事务的功能<br>      3）指定方法需要的隔离级别，传播行为，超时</p><pre><code>  你需要告诉spring，你的项目中类信息，方法的名称，方法的事务传播行为。</code></pre><p>spring框架中提供的事务处理方案<br>1.适合中小项目使用的， 注解方案。<br>  spring框架自己用<strong>aop</strong>(aspectj框架的 @Around 环绕依赖)实现给业务方法增加事务的功能， 使用**@Transactional注解**增加事务。<br>  @Transactional注解是spring框架自己注解，放在public方法的上面，表示当前方法具有事务。<br>  可以给注解的属性赋值，表示具体的隔离级别，传播行为，异常信息等等</p><p>  使用@Transactional的步骤：<br>  1.需要声明事务管理器对象<br>    <bean id="xx" class="DataSourceTransactionManager"></p><hr><h3 id="Transactional注解"><a href="#Transactional注解" class="headerlink" title="@Transactional注解"></a><strong>@Transactional注解</strong></h3><h4 id="1-Transactional介绍"><a href="#1-Transactional介绍" class="headerlink" title="1. @Transactional介绍"></a>1. @Transactional介绍</h4><ol><li>@Transactional注解 <strong>可以作用于接口、接口方法、类以及类方法上。</strong>当作用于类上时，该类的所有 <strong>public 方法</strong>将都具有该类型的事务属性，同时，<strong>我们也可以在方法级别使用该标注来<em>覆盖</em>类级别的定义。</strong></li><li>虽然@Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， @Transactional注解应该<strong>只被应用到 public 方法上</strong>，这是由<strong>Spring AOP的本质决定的</strong>。如果你在 <strong>protected、private 或者默认可见性</strong>的方法上使用 @Transactional 注解，<strong>这将被忽略，也不会抛出任何异常。</strong></li><li><strong>默认情况下，只有来自外部的方法调用才会被AOP代理捕获</strong>，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰。</li></ol><h4 id="2-Transactional注解属性"><a href="#2-Transactional注解属性" class="headerlink" title="2. @Transactional注解属性"></a>2. @Transactional注解属性</h4><ol><li>@Transactional注解里面的各个属性和咱们在上面讲的事务属性里面是一一对应的。用来设置<strong>事务的传播行为、隔离规则、回滚规则、事务超时、是否只读</strong>。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transactional &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。myBatis是DataSourceTransactionManager 事务管理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;transactionManager&quot;)</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同上。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    String <span class="title function_">transactionManager</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务的传播行为，默认值为 REQUIRED。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Propagation <span class="title function_">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务的隔离规则，默认值采用 DEFAULT mysql中是可重复读。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Isolation <span class="title function_">isolation</span><span class="params">()</span> <span class="keyword">default</span> Isolation.DEFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务超时时间。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">timeout</span><span class="params">()</span> <span class="keyword">default</span> TransactionDefinition.TIMEOUT_DEFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否只读事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">readOnly</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于指定能够触发事务回滚的异常类型 Class对象的数组。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同上，指定类名 这个String类型的数组。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] rollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于指定不会触发事务回滚的异常类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;[] noRollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同上，指定类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] noRollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>value、transactionManager属性</li></ol><p>​    它们两个是一样的意思。当配置了多个事务管理器时，可以使用该属性指定选择哪个事务管理器。大多数项目只需要一个事务管理器。然而，有些项目为了提高效率、或者有多个完全不同又不相干的数据源，从而使用了多个事务管理器。机智的Spring的Transactional管理已经考虑到了这一点，首先定义多个transactional manager，并为qualifier属性指定不同的值；然后在需要使用@Transactional注解的时候指定TransactionManager的qualifier属性值或者直接使用bean名称。配置和代码使用的例子：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;datasource1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">&quot;datasource1Tx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;datasource2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">&quot;datasource2Tx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionalService</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Transactional(&quot;datasource1Tx&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSomethingInDatasource1</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Transactional(&quot;datasource2Tx&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomethingInDatasource2</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p><strong>propagation属性</strong></p><p>propagation用于指定事务的传播行为，默认值为 REQUIRED。propagation有七种类型，就是我们在上文中讲到的事务属性传播行为的七种方式，如下所示:</p></li></ol><table><thead><tr><th>propagation属性</th><th>事务属性-传播行为</th><th>含义</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>REQUIRED</td><td>TransactionDefinition.PROPAGATION_REQUIRED</td><td>如果当前没有事务，就新建一个事务，如果已经存在一个事务，则加入到这个事务中。这是最常见的选择。</td><td></td><td></td><td></td></tr><tr><td>SUPPORTS</td><td>TransactionDefinition.PROPAGATION_SUPPORTS</td><td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td><td></td><td></td><td></td></tr><tr><td>MANDATORY</td><td>TransactionDefinition.PROPAGATION_MANDATORY</td><td>表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常。</td><td></td><td></td><td></td></tr><tr><td>REQUIRES_NEW</td><td>TransactionDefinition.PROPAGATION_REQUIRES_NEW</td><td>表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。</td><td></td><td></td><td></td></tr><tr><td>NOT_SUPPORTED</td><td>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</td><td>表示该方法不应该运行在事务中。如果当前存在事务，就把当前事务挂起。</td><td></td><td></td><td></td></tr><tr><td>NEVER</td><td>TransactionDefinition.PROPAGATION_NEVER</td><td>表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常。</td><td></td><td></td><td></td></tr><tr><td>NESTED</td><td>TransactionDefinition.PROPAGATION_NESTED</td><td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td><td></td><td></td><td></td></tr></tbody></table><ol start="4"><li><p><strong>isolation属性</strong></p><p>​    isolation用于指定事务的隔离规则，默认值为DEFAULT。@Transactional的隔离规则和上文事务属性里面的隔离规则也是一一对应的。总共五种隔离规则，如下所示:</p><table><thead><tr><th>@isolation属性</th><th>事务属性-隔离规则</th><th>含义</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>DEFAULT</td><td>TransactionDefinition.ISOLATION_DEFAULT</td><td>使用后端数据库默认的隔离级别</td><td></td><td></td><td></td></tr><tr><td>READ_UNCOMMITTED</td><td>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</td><td>允许读取尚未提交的数据变更(最低的隔离级别)</td><td>是</td><td>是</td><td>是</td></tr><tr><td>READ_COMMITTED</td><td>TransactionDefinition.ISOLATION_READ_COMMITTED</td><td>允许读取并发事务已经提交的数据</td><td>否</td><td>是</td><td>是</td></tr><tr><td>REPEATABLE_READ</td><td>TransactionDefinition.ISOLATION_REPEATABLE_READ</td><td>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改</td><td>否</td><td>否</td><td>是</td></tr><tr><td>SERIALIZABLE</td><td>TransactionDefinition.ISOLATION_SERIALIZABLE</td><td>最高的隔离级别，完全服从ACID的隔离级别，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的</td><td>否</td><td>否</td><td>否</td></tr></tbody></table></li></ol><hr><ol start="5"><li><p><strong>timeout</strong></p><p>​    timeout用于设置事务的超时属性。</p></li><li><p><strong>readOnly</strong></p><p>​    readOnly用于设置事务是否只读属性。</p></li><li><p><strong>rollbackFor、rollbackForClassName、noRollbackFor、noRollbackForClassName</strong></p><p>​    rollbackFor、rollbackForClassName用于设置那些异常需要回滚；noRollbackFor、noRollbackForClassName用于设置那些异常不需要回滚。他们就是在设置事务的回滚规则。</p></li></ol><h4 id="Transactional注解的使用"><a href="#Transactional注解的使用" class="headerlink" title="@Transactional注解的使用"></a><strong>@Transactional注解的使用</strong></h4><ol><li>@Transactional注解内部实现依赖于Spring AOP编程。而AOP在默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为。</li><li><strong>@Transactional 注解尽量直接加在方法上</strong>:因为每个方法的执行情况不一样,加载类上的话不能更好地区分每个方法的操作 比如查询只需要readOnly</li><li><strong>@Transactional 注解必须添加在public方法上，private、protected方法上是无效的</strong> spring的@Transactional是基于springAOP特性实现</li><li><strong>@Transactional注解在外部调用的函数上才有效果，内部调用的函数添加无效，</strong>要切记。这是由AOP的特性决定的。(即在同一个类中只有只有由@Transactional的方法调用另一个方法有效,两个方法都有@Transactional注解只有外部的生效,内部的不生效  <strong>@Transactional注解只有外部调用才有效。</strong>)</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">         propagation = Propagation.REQUIRED,</span></span><br><span class="line"><span class="meta">         isolation = Isolation.DEFAULT,</span></span><br><span class="line"><span class="meta">         readOnly = false,</span></span><br><span class="line"><span class="meta">         rollbackFor = &#123;</span></span><br><span class="line"><span class="meta">                 NullPointerException.class,  NotEnoughException.class</span></span><br><span class="line"><span class="meta">         &#125;</span></span><br></pre></td></tr></table></figure><hr><p>  2.开启事务注解驱动， 告诉spring框架，我要使用注解的方式管理事务。<br>    spring使用aop机制，创建@Transactional所在的类代理对象，给方法加入事务的功能。<br>    spring给业务方法加入事务：<br>        在你的业务方法执行之前，先开启事务，在业务方法之后提交或回滚事务，使用aop的环绕通知</p><pre><code>     @Around(&quot;你要增加的事务功能的业务方法名称&quot;)     Object myAround()&#123;       开启事务，spring给你开启          try&#123;             buy(1001,10);              spring的事务管理器.commit();          &#125;catch(Exception e)&#123;         spring的事务管理器.rollback();          &#125;              &#125;</code></pre><p>3.在你的方法的上面加入@Trancational 在注解中配置参数</p><p>2.适合大型项目，有很多的类，方法，需要大量的配置事务，使用aspectj框架功能，在spring配置文件中<br>  声明类，方法需要的事务。这种方式业务方法和事务配置完全分离。</p><p>  实现步骤： 都是在xml配置文件中实现。 即不是用@Apest 和 @Trancational 注解 完全使用xml配置文件<br>   1)要使用的是aspectj框架，需要加入依赖<br>    <dependency><br>        <groupId>org.springframework</groupId><br>        <artifactId>spring-aspects</artifactId><br>        <version>5.2.5.RELEASE</version><br>    </dependency></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">2）声明事务管理器对象</span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;xx&quot;</span> <span class="attr">class</span>=<span class="string">&quot;DataSourceTransactionManager&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><pre><code> 3) 声明方法需要的事务类型（配置方法的事务属性【隔离级别，传播行为，超时】） 4)  配置aop：指定哪些哪类要创建代理。</code></pre><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       把数据库的配置信息，写在一个独立的文件，编译修改数据库的配置内容</span></span><br><span class="line"><span class="comment">       spring知道jdbc.properties文件的位置</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明数据源DataSource, 作用是连接数据库的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--set注入给DruidDataSource提供连接数据库信息 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    使用属性配置文件中的数据，语法 $&#123;key&#125; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span><span class="comment">&lt;!--setUrl()--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.passwd&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.max&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明的是mybatis中提供的SqlSessionFactoryBean类，这个类内部创建SqlSessionFactory的</span></span><br><span class="line"><span class="comment">        SqlSessionFactory  sqlSessionFactory = new ..</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--set注入，把数据库连接池付给了dataSource属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;myDataSource&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis主配置文件的位置</span></span><br><span class="line"><span class="comment">           configLocation属性是Resource类型，读取配置文件</span></span><br><span class="line"><span class="comment">           它的赋值，使用value，指定文件的路径，使用classpath:表示文件的位置</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--创建dao对象，使用SqlSession的getMapper（StudentDao.class）</span></span><br><span class="line"><span class="comment">        MapperScannerConfigurer:在内部调用getMapper()生成每个dao接口的代理对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定SqlSessionFactory对象的id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定包名， 包名是dao接口所在的包名。</span></span><br><span class="line"><span class="comment">            MapperScannerConfigurer会扫描这个包中的所有接口，把每个接口都执行</span></span><br><span class="line"><span class="comment">            一次getMapper()方法，得到每个接口的dao对象。</span></span><br><span class="line"><span class="comment">            创建好的dao对象放入到spring的容器中的。 dao对象的默认名称是 接口名首字母小写</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.bjpowernode.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明service--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;buyService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.bjpowernode.service.impl.BuyGoodsServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;goodsDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;goodsDao&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;saleDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;saleDao&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明式事务处理：和源代码完全分离的--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.声明事务管理器对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;myDataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--2.声明业务方法它的事务属性（隔离级别，传播行为，超时时间）</span></span><br><span class="line"><span class="comment">          id:自定义名称，表示 &lt;tx:advice&gt; 和 &lt;/tx:advice&gt;之间的配置内容的</span></span><br><span class="line"><span class="comment">          transaction-manager:事务管理器对象的id 不设置就是默认配置</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--tx:attributes：配置事务属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--tx:method：给具体的方法配置事务属性，method可以有多个，分别给不同的方法设置事务属性</span></span><br><span class="line"><span class="comment">                name:方法名称，1）完整的方法名称，不带有包和类。</span></span><br><span class="line"><span class="comment">                              2）方法可以使用通配符,* 表示任意字符</span></span><br><span class="line"><span class="comment">                propagation：传播行为，枚举值</span></span><br><span class="line"><span class="comment">                isolation：隔离级别</span></span><br><span class="line"><span class="comment">                rollback-for：你指定的异常类名，全限定类名。 发生异常一定回滚</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;buy&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;DEFAULT&quot;</span></span></span><br><span class="line"><span class="tag">                       <span class="attr">rollback-for</span>=<span class="string">&quot;java.lang.NullPointerException,com.bjpowernode.excep.NotEnoughException&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--使用通配符，指定很多的方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRES_NEW&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指定修改方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;modify*&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--删除方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;remove*&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--查询方法，query，search，find--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置aop--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切入点表达式：指定哪些包中类，要使用事务</span></span><br><span class="line"><span class="comment">            id:切入点表达式的名称，唯一值</span></span><br><span class="line"><span class="comment">            expression：切入点表达式，指定哪些类要使用事务，aspectj会创建代理对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            com.bjpowernode.service</span></span><br><span class="line"><span class="comment">            com.crm.service</span></span><br><span class="line"><span class="comment">            com.service</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;servicePt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..service..*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--配置增强器：关联adivce和pointcut</span></span><br><span class="line"><span class="comment">           advice-ref:通知，上面tx:advice哪里的配置</span></span><br><span class="line"><span class="comment">           pointcut-ref：切入点表达式的id</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;servicePt&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="web项目中怎么使用容器对象。"><a href="#web项目中怎么使用容器对象。" class="headerlink" title="web项目中怎么使用容器对象。"></a>web项目中怎么使用容器对象。</h2><ol><li><p>做的是javase项目有main方法的，执行代码是执行main方法的，<br>  在main里面创建的容器对象<br>  ApplicationContext ctx &#x3D; new ClassPathXmlApplicationContext(“applicationContext.xml”);</p></li><li><p>web项目是在tomcat服务器上运行的。 tomcat一起动，项目一直运行的。</p></li></ol><p><strong>需求：</strong><br>web项目中容器对象只需要创建一次，  把容器对象放入到全局作用域ServletContext中。</p><p><strong>怎么实现：</strong><br>   使用监听器 当全局作用域对象被创建时 创建容器 存入ServletContext</p><pre><code>监听器作用：1）创建容器对象，执行 ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);2）把容器对象放入到ServletContext， ServletContext.setAttribute(key,ctx)监听器可以自己创建，也可以使用框架中提供好的ContextLoaderListener private WebApplicationContext context; public interface WebApplicationContext extends ApplicationContext</code></pre><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"> ApplicationContext:javase项目中使用的容器对象</span><br><span class="line">WebApplicationContext：web项目中的使用的容器对象</span><br><span class="line"></span><br><span class="line">把创建的容器对象，放入到全局作用域</span><br><span class="line"> key： WebApplicationContext.ROOT<span class="built_in">_</span>WEB<span class="built_in">_</span>APPLICATION<span class="built_in">_</span>CONTEXT<span class="built_in">_</span>ATTRIBUTE</span><br><span class="line">       WebApplicationContext.ROOT<span class="built_in">_</span>WEB<span class="built_in">_</span>APPLICATION<span class="built_in">_</span>CONTEXT<span class="built_in">_</span>ATTRIBUTE</span><br><span class="line"> value：this.context</span><br><span class="line"></span><br><span class="line"> servletContext.setAttribute(WebApplicationContext.ROOT<span class="built_in">_</span>WEB<span class="built_in">_</span>APPLICATION<span class="built_in">_</span>CONTEXT<span class="built_in">_</span>ATTRIBUTE, this.context);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;spring全家桶：spring ， springmvc ，spring boot , spring cloud &lt;/p&gt;
&lt;p&gt;  spring: 出现是在2002左右，解决企业开发的难度。减轻对项目模块之间的管理，&lt;br&gt;          类和类之间的管理， 帮助开发人员创建对象，管理对象之间的关系。&lt;br&gt;             spring核心技术 ioc ， aop 。能实现模块之间，类之间的解耦合。&lt;/p&gt;</summary>
    
    
    
    <category term="spring框架" scheme="https://devildyw.github.io/categories/spring%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring" scheme="https://devildyw.github.io/tags/Spring/"/>
    
  </entry>
  
</feed>
