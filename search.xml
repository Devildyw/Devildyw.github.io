<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git分布式版本控制工具</title>
    <url>/2022/02/28/Git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="Git分布式版本控制工具"><a href="#Git分布式版本控制工具" class="headerlink" title="Git分布式版本控制工具"></a><a href="D:\BaiduNetdiskDownload\Git讲义.pdf">Git分布式版本控制工具</a></h1><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220127230403996.png" alt="image-20220127230403996"></p>
<p><strong>命令如下：</strong></p>
<ol>
<li><strong>clone（克隆）</strong>: 从远程仓库中克隆代码到本地仓库</li>
<li><strong>checkout （检出）</strong>:从本地仓库中检出一个仓库分支然后进行修订</li>
<li><strong>add（添加）</strong>: 在提交前先将代码提交到暂存区</li>
<li><strong>commit（提交）</strong>: 提交到本地仓库。本地仓库中保存修改的各个历史版本</li>
<li><strong>fetch (抓取)</strong> ： 从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。</li>
<li><strong>pull (拉取)</strong> ： 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于fetch+merge</li>
<li><strong>push（推送）</strong> : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库</li>
</ol>
<span id="more"></span>

<hr>
<p><strong>备注：</strong></p>
<p><strong>Git GUI</strong>：Git提供的图形界面工具</p>
<p><strong>Git Bash</strong>：Git提供的命令行工具</p>
<p>当安装Git后首先要做的事情是<strong>设置用户名称</strong>和<strong>email</strong>地址。这是非常重要的，因为每次Git提交都会使用该用户信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;itcast&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;hello@qq.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>查看配置信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git confifig --global user.name</span><br><span class="line">git confifig --global user.email</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a><strong>本地仓库</strong></h2><p>要使用Git对我们的代码进行版本控制，首先需要获得本地仓库</p>
<ol>
<li><p>在电脑的任意位置创建一个空目录（例如test）作为我们的本地Git仓库</p>
</li>
<li><p>进入这个目录中，点击右键打开Git bash窗口</p>
</li>
<li><p>执行命令<strong>git init</strong> (初始化本文件为本地仓库)</p>
</li>
<li><p>如果创建成功后可在文件夹下看到隐藏的.git目录。</p>
</li>
</ol>
<hr>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a><strong>命令</strong></h2><ul>
<li><strong>git touch</strong> 文件名 可以创建文件</li>
</ul>
<hr>
<p>Git工作目录下对于文件的<strong>修改</strong>(增加、删除、更新)会存在几个状态，这些<strong>修改</strong>的状态会随着我们执行Git的命令而发生变化。</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220127231451204.png" alt="image-20220127231451204"></p>
<ul>
<li><p><strong>git add</strong> (工作区 –&gt; 暂存区) (<strong>git add . 将所有修改加入暂存区</strong>)</p>
</li>
<li><p><strong>git commit</strong> (暂存区 –&gt; 本地仓库) (<strong>git commit -m ‘注释内容’</strong> 将暂存区中的内容提交到本地仓库)</p>
</li>
<li><p><strong>git status</strong>:<strong>查看修改的状态</strong></p>
</li>
</ul>
<hr>
<p><strong>查看提交日志</strong></p>
<ul>
<li><p><strong>git log</strong> [option]</p>
</li>
<li><p>options</p>
<ul>
<li><p><strong>all</strong> 显示所有分支</p>
</li>
<li><p><strong>pretty&#x3D;oneline</strong> 将提交信息显示为一行</p>
</li>
<li><p><strong>abbrev-commit</strong> 使得输出的commitId更简短</p>
</li>
<li><p><strong>graph</strong> 以图的形式显示</p>
</li>
</ul>
</li>
</ul>
<p><strong>对log的格式进行自定义 并且对该操作使用alias起了一个别名</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global alias.lg <span class="string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>版本回退</strong></p>
<ul>
<li>作用: 版本切换</li>
<li>命令: <strong>git reset –hard commitID</strong><ul>
<li><strong>commitID</strong> 可以使用 <strong>git lg</strong> 或 <strong>git log</strong> 指令查看</li>
</ul>
</li>
</ul>
<p><strong>如何查看已经删除的记录？</strong></p>
<ul>
<li><p><strong>git reflflog</strong></p>
</li>
<li><p>这个指令可以看到已经删除的提交记录</p>
</li>
</ul>
<hr>
<p><strong>添加文件至忽略列表</strong></p>
<p>一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以在工作目录中创建一个名为 <strong>.gitignore 的文件（文件名称固定）</strong>，列出要忽略的文件模式。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">HELP.md</span><br><span class="line">target/</span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar</span><br><span class="line">!**/src/main/**/target/</span><br><span class="line">!**/src/test/**/target/</span><br><span class="line"></span><br><span class="line"><span class="params">###</span> STS <span class="params">###</span></span><br><span class="line">.apt<span class="built_in">_</span>generated</span><br><span class="line">.classpath</span><br><span class="line">.factorypath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.springBeans</span><br><span class="line">.sts4-cache</span><br><span class="line"></span><br><span class="line"><span class="params">###</span> IntelliJ IDEA <span class="params">###</span></span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line"></span><br><span class="line"><span class="params">###</span> NetBeans <span class="params">###</span></span><br><span class="line">/nbproject/private/</span><br><span class="line">/nbbuild/</span><br><span class="line">/dist/</span><br><span class="line">/nbdist/</span><br><span class="line">/.nb-gradle/</span><br><span class="line">build/</span><br><span class="line">!**/src/main/**/build/</span><br><span class="line">!**/src/test/**/build/</span><br><span class="line"></span><br><span class="line"><span class="params">###</span> VS Code <span class="params">###</span></span><br><span class="line">.vscode/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a><strong>分支</strong></h2><p><strong>查看本地分支</strong></p>
<ul>
<li><strong>git branch</strong></li>
</ul>
<hr>
<p><strong>创建本地分支</strong></p>
<ul>
<li><strong>git branch 分支名</strong></li>
</ul>
<hr>
<p><strong>切换分支</strong></p>
<ul>
<li><strong>git checkout 分支名</strong></li>
<li><strong>git checkout -b 分支名 (创建并切换)</strong></li>
</ul>
<hr>
<p><strong>合并分支</strong></p>
<ul>
<li><strong>git merge 分支名称</strong></li>
</ul>
<hr>
<p><strong>删除分支</strong></p>
<ul>
<li><strong>git branch -d 分支名 (删除分支时，需要做各种检查)</strong></li>
<li><strong>git branch -D 分支名 (不做任何检查，强制删除)</strong></li>
</ul>
<hr>
<p><strong>解决冲突</strong></p>
<p>当两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解决冲突，解决冲突步骤如下：</p>
<ol>
<li><p>处理文件中冲突的地方</p>
</li>
<li><p>将解决完冲突的文件加入暂存区(add)</p>
</li>
<li><p>提交到仓库(commit)</p>
</li>
</ol>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220127233455735.png" alt="image-20220127233455735"></p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a><strong>远程仓库</strong></h2><ul>
<li><p><strong>注册gitee(码云)</strong></p>
</li>
<li><p><strong>创建仓库</strong></p>
</li>
</ul>
<p><strong>配置SSH公钥</strong></p>
<ul>
<li><p><strong>生成SSH公钥</strong></p>
<ul>
<li><strong>ssh-keygen -t rsa</strong></li>
</ul>
</li>
<li><p><strong>Gitee设置账户共公钥</strong></p>
<ul>
<li><p>上面我们以及生成了SSH公钥 这里我们要获取</p>
</li>
<li><p><strong>cat ~&#x2F;.ssh&#x2F;id_rsa.pub</strong> </p>
</li>
<li><p>复制这个SSH公钥</p>
</li>
<li><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220128220100844.png" alt="image-20220128220100844"></p>
</li>
<li><p>验证是否配置成功 <strong>ssh -T <a href="mailto:&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#101;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#101;&#101;&#x2e;&#99;&#x6f;&#x6d;</a></strong></p>
</li>
</ul>
<h4 id="操作远程仓库"><a href="#操作远程仓库" class="headerlink" title="操作远程仓库"></a>操作远程仓库</h4><ul>
<li><p><strong>添加远程仓库</strong> (此操作是先初始化本地仓库,然后与一创建的远程仓库进行对接)</p>
<ul>
<li><p><strong>命令: git remote add &lt;远端名称(别名)&gt; &lt;仓库路径(url)&gt;</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote add origin git@gitee.com:Devildyw/spring-mvc.git</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>命令: git remote</strong>(查看已添加的远程仓库)</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220128221118298.png" alt="image-20220128221118298"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p><strong>推送到远程仓库</strong></p>
<ul>
<li><p><strong>命令: git push [-f] [–set-upstream] [远端名称[本地分支名 [:远端分支名]]</strong></p>
<ul>
<li><pre><code class="sh">git push origin master
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* **-f** 表示强制覆盖</span><br><span class="line"></span><br><span class="line">* **--set-upstream**: 推送到远端的同时并且建立起和远端分支的关联关系</span><br><span class="line"></span><br><span class="line">* ```sh</span><br><span class="line">  git push --set-upstream origin master</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>如果当前分支已经和远端分支建立关联,则可以省略分支名和远端名 <strong>(git push)</strong></p>
</li>
</ul>
</li>
<li><p><strong>查看本地分支与远程分支的关联关系</strong></p>
<ul>
<li><strong>命令: git brach -vv</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>从远程仓库克隆(一般只有一开始会做一次 后续都会使用pull拉取)</strong><ul>
<li><strong>命令: git clone &lt;仓库路径&gt; [本地目录]</strong><ul>
<li>本地目录可以省略,会自动生成一个目录</li>
</ul>
</li>
</ul>
</li>
<li><strong>从远程仓库中抓取和拉取</strong><ul>
<li>远程分支和本地的分支一样，我们可以进行merge操作，只是需要先把远端仓库里的更新都下载到本地，再进行操作。<ul>
<li><strong>抓取 命令: git fetch [remote name] [branch name]</strong><ul>
<li><strong>抓取指令就是将仓库里的更新都抓取到本地，不会进行合并</strong></li>
<li>如果不指定远端名称和分支名，则抓取所有分支。</li>
</ul>
</li>
<li><strong>拉取 命令: git pull [remote name] [branch name]</strong><ul>
<li>**拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于 ** <strong>fetch+merge</strong></li>
<li>如果不指定远端名称和分支名，则抓取所有并更新当前分支。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p><strong>解决合并冲突</strong></p>
<ul>
<li><p>在一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突。A用户在本地修改代码后优先推送到远程仓库，此时B用户在本地修订代码，提交到本地仓库后，也需要推送到远程仓库，此时B用户晚于A用户，<strong>故需要先拉取远程仓库的提交，经过合并后才能推送到远端分支</strong></p>
</li>
<li><p>在B用户拉取代码时，因为A、B用户同一段时间修改了同一个文件的相同位置代码，故会发生合并冲突。<strong>远程分支也是分支，所以合并时冲突的解决方式也和解决本地分支冲突相同相同</strong></p>
</li>
<li><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220128223521930.png" alt="image-20220128223521930"></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Developer</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal</title>
    <url>/2022/02/28/ThreadLocal/</url>
    <content><![CDATA[<h1 id="ThreadLocal-ThreadLocal-简书-jianshu-com"><a href="#ThreadLocal-ThreadLocal-简书-jianshu-com" class="headerlink" title="[ThreadLocal](ThreadLocal - 简书 (jianshu.com))"></a>[ThreadLocal](<a href="https://www.jianshu.com/p/3c5d7f09dfbd">ThreadLocal - 简书 (jianshu.com)</a>)</h1><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>threadlocal使用方法很简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;T&gt; sThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;T&gt;();</span><br><span class="line">sThreadLocal.set()</span><br><span class="line">sThreadLocal.get()</span><br></pre></td></tr></table></figure>

<p>threadlocal而是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据，官方解释如下。</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220211183419286.png" alt="image-20220211183419286"></p>
<p>大致意思就是ThreadLocal提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。通过get和set方法就可以得到当前线程对应的值。</p>
<p>做个不恰当的比喻，从表面上看ThreadLocal相当于维护了一个map，key就是当前的线程，value就是需要存储的对象。</p>
<p><strong>这里的这个比喻是不恰当的，实际上是ThreadLocal的静态内部类ThreadLocalMap为每个Thread都维护了一个数组table，ThreadLocal确定了一个数组下标，而这个下标就是value存储的对应位置。</strong></p>
<span id="more"></span>

<p>作为一个存储数据的类，关键点就在get和set方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**源码**/</span></span><br><span class="line"><span class="comment">//set 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">      <span class="comment">//获取当前线程</span></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">      <span class="comment">//实际存储的数据结构类型</span></span><br><span class="line">      <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">      <span class="comment">//如果存在map就直接set，没有则创建map并set</span></span><br><span class="line">      <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">          map.set(<span class="built_in">this</span>, value);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          createMap(t, value);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//getMap方法</span></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">      <span class="comment">//thred中维护了一个ThreadLocalMap</span></span><br><span class="line">      <span class="keyword">return</span> t.threadLocals;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//createMap</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">      <span class="comment">//实例化一个新的ThreadLocalMap，并赋值给线程的成员变量threadLocals</span></span><br><span class="line">      t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出<strong>每个线程持有一个ThreadLocalMap对象</strong>。每一个新的线程Thread都会实例化一个ThreadLocalMap并赋值给成员变量threadLocals，使用时若已经存在threadLocals则直接使用已经存在的对象。</p>
<hr>
<h2 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/9e256d87362c4d9295589e3d72e69211.png" alt="在这里插入图片描述"></p>
<p><strong>实线代表强引用,虚线代表弱引用</strong></p>
<ul>
<li><p>每一个Thread维护一个ThreadLocalMap, key为使用弱引用的ThreadLocal实例，value为线程变量的副本。</p>
</li>
<li><p>强引用，使用最普遍的引用，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。</p>
</li>
<li><p>如果想取消强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样可以使JVM在合适的时间就会回收该对象。</p>
</li>
<li><p>弱引用，JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>简单来说就是 ThreadLocal为每个线程提供了一个ThreadLocalMap对象 这样就避免了线程安全问题 实际开发中可以用于存储用户信息代替session</p>
]]></content>
      <categories>
        <category>开发规范</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？</title>
    <url>/2022/02/28/%E5%8E%9F%E5%AD%90%E2%80%BB%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7/</url>
    <content><![CDATA[<h1 id="java原子性是什么-中级Java应该清楚的概念：原子性、可见性、有序性是什么？"><a href="#java原子性是什么-中级Java应该清楚的概念：原子性、可见性、有序性是什么？" class="headerlink" title="java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？"></a>java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？</h1><p>原子性、可见性、有序性是多线程编程中最重要的几个知识点，由于多线程情况复杂，如何让每个线程能看到正确的结果，这是非常重要的，下面和千锋广州小编一起来看看吧！</p>
<p><a href="%5B(4%E6%9D%A1%E6%B6%88%E6%81%AF">原网站</a> java原子性是什么_中级Java应该清楚的概念：原子性、可见性、有序性是什么？…_我才是Guido的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_42460182/article/details/114101352">https://blog.csdn.net/weixin_42460182/article/details/114101352</a>))</p>
<span id="more"></span>

<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性是指一个线程的操作是不能被其他线程打断，同一时间只有一个线程对一个变量进行操作。在多线程情况下，每个线程的执行结果不受其他线程的干扰，比如说多个线程同时对同一个共享成员变量n++100次，如果n初始值为0，n最后的值应该是100，所以说它们是互不干扰的，这就是传说的中的原子性。但n++并不是原子性的操作，要使用AtomicInteger保证原子性。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性是指某个线程修改了某一个共享变量的值，而其他线程是否可以看见该共享变量修改后的值。在单线程中肯定不会有这种问题，单线程读到的肯定都是最新的值，而在多线程编程中就不一定了。</p>
<p>每个线程都有自己的工作内存，线程先把共享变量的值从主内存读到工作内存，形成一个副本，当计算完后再把副本的值刷回主内存，从读取到最后刷回主内存这是一个过程，当还没刷回主内存的时候这时候对其他线程是不可见的，所以其他线程从主内存读到的值是修改之前的旧值。</p>
<p>像CPU的缓存优化、硬件优化、指令重排及对JVM编译器的优化，都会出现可见性的问题。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>我们都知道程序是按代码顺序执行的，对于单线程来说确实是如此，但在多线程情况下就不是如此了。为了优化程序执行和提高CPU的处理性能，JVM和操作系统都会对指令进行重排，也就说前面的代码并不一定都会在后面的代码前面执行，即后面的代码可能会插到前面的代码之前执行，只要不影响当前线程的执行结果。所以，指令重排只会保证当前线程执行结果一致，但指令重排后势必会影响多线程的执行结果。</p>
<p>虽然重排序优化了性能，但也是会遵守一些规则的，并不能随便乱排序，只是重排序会影响多线程执行的结果。</p>
<p>以上就是原子性、可见性、有序性的概念解释，希望对大家有帮助哦！</p>
<p><strong>相关资源：</strong><a href="https://download.csdn.net/download/weixin_38575456/12793647?spm=1001.2101.3001.5697"><em>Java</em>高并发三:<em>Java</em>内存模型和线程安全详解_<em>java</em>高并发模型-其它*.<strong>.</strong>.*</a></p>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库(mysql)</title>
    <url>/2022/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 展示所有数据库</span><br><span class="line">show databases;</span><br><span class="line"># 展示创建数据库的一些详细操作 以及数据库的字符集 等其他信息 可以用来查看已经创建的数据库的一些详细信息</span><br><span class="line">show create database mysql;</span><br><span class="line"># 创建数据库时指定字符集</span><br><span class="line">create database db2 character set gbk;</span><br><span class="line"></span><br><span class="line">show create database db2;</span><br><span class="line"># 删除数据库 如果数据库存在</span><br><span class="line">drop database if exists db2;</span><br><span class="line"># 创建数据库 如果数据库不存在</span><br><span class="line">create database if not exists db2;</span><br><span class="line"># 修改数据库的字符集</span><br><span class="line">alter database db2 character set gb2312;</span><br><span class="line"># 查询正在使用的数据库</span><br><span class="line">select database();</span><br><span class="line"># 查看数据库中的所有表</span><br><span class="line">show tables;</span><br><span class="line"># 使用数据库（选择） </span><br><span class="line">use world;</span><br><span class="line"># 查看表的结构</span><br><span class="line">desc city;</span><br><span class="line"></span><br><span class="line">use my_db;</span><br><span class="line"># 创建表</span><br><span class="line">create table student(</span><br><span class="line">	id int,</span><br><span class="line">    name varchar(32),</span><br><span class="line">    age int,</span><br><span class="line">    score double(4,1),</span><br><span class="line">    birthday date,</span><br><span class="line">    insert_time timestamp default current_timestamp);</span><br><span class="line">    </span><br><span class="line">desc student;</span><br><span class="line"># 删除表</span><br><span class="line">drop table student;</span><br><span class="line"></span><br><span class="line">show tables;</span><br><span class="line"># 删除表如果表存在</span><br><span class="line">drop table if exists student;</span><br><span class="line"># 修改表的名字</span><br><span class="line">alter table student rename to stu;</span><br><span class="line"># 修改表的字符集</span><br><span class="line">alter table stu character set gbk;</span><br><span class="line"></span><br><span class="line">drop table if exists stu;</span><br><span class="line">#查看创建表的操作 与一些详细信息</span><br><span class="line">show create table stu;</span><br><span class="line"># 增加新的一列并指定类型</span><br><span class="line">alter table stu add gender varchar(10);</span><br><span class="line"></span><br><span class="line">desc stu;</span><br><span class="line"></span><br><span class="line">alter table stu change gender sex varchar(20);</span><br><span class="line"># 修改执行列的类型</span><br><span class="line">alter table stu modify sex varchar(10);</span><br><span class="line"># 插入一行 如果没有指定插入那些元素 则你默认全部修改</span><br><span class="line">insert into stu (id,name,age) values(1,&quot;肖明桓&quot;,19);</span><br><span class="line"># 查询表中的全部信息</span><br><span class="line">select* from stu;</span><br><span class="line"># where条件语句 查询指定条件的行</span><br><span class="line">delete from stu where id = 2;</span><br><span class="line"></span><br><span class="line">create table stu(</span><br><span class="line">id int,</span><br><span class="line">name varchar(32),</span><br><span class="line">age int,</span><br><span class="line">score double(4,1),</span><br><span class="line">birthday date,</span><br><span class="line">insert_time timestamp default CURRENT_TIMESTAMP);</span><br><span class="line"></span><br><span class="line">drop table stu;</span><br><span class="line"></span><br><span class="line">insert into stu (id,name,age) values(2,&quot;张敏&quot;,19);</span><br><span class="line"></span><br><span class="line">insert into stu (id,name,age) values(3,&quot;丁杨维&quot;,19);</span><br><span class="line"></span><br><span class="line"># truncate  在创建一个空表</span><br><span class="line">truncate stu;</span><br><span class="line"></span><br><span class="line">#delete from 表名 9[where语句] 删除指定的多少条记录</span><br><span class="line">delete from stu where id = 2;</span><br><span class="line"></span><br><span class="line"># updata from 表名 set 列名 = 值 [where条件] 修改指定元组中的列的值 如不加条件则会将列的所有值都修改</span><br><span class="line">update stu set age = 20 where id = 1;</span><br><span class="line"></span><br><span class="line">update stu set age = 20; </span><br><span class="line"></span><br><span class="line">update stu set score = 70 where id = 2;</span><br><span class="line"></span><br><span class="line">update stu set score = 88 where id = 3;</span><br><span class="line"></span><br><span class="line">update stu set age = 19 where id = 3;</span><br><span class="line">update stu set age = 21 where id = 2;</span><br><span class="line"></span><br><span class="line">update stu set score = 99;</span><br><span class="line"></span><br><span class="line"># 排序 asc 升序 desc 降序 </span><br><span class="line">select* from stu order by score asc; </span><br><span class="line"></span><br><span class="line"># 排序 如果数学成绩一样 则按年龄排序</span><br><span class="line">select* from stu order by score asc, age asc;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>聚合函数</strong> 计算会排除null值</p>
<ol>
<li>count：计算个数</li>
</ol>
<p>  一般以主键作为计数标记 一般不用count(*)(只要一列中有一个不为null那么count就加一);</p>
<ol start="2">
<li><p>max</p>
</li>
<li><p>min</p>
</li>
<li><p>sum</p>
</li>
<li><p>avg</p>
</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(ifnull(english,0)) from student;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：<strong>聚合函数</strong> 计算会排除null值 </p>
<p>解决方案：</p>
<ol>
<li><p>选择不为空的列进行计算</p>
</li>
<li><p>使用ifnull 函数 </p>
<blockquote>
<p>select count(ifnull(english,0)) from student; 将english为null的值按0计数</p>
</blockquote>
</li>
</ol>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>操作数据库database 的关键字： create 创建 drop删除 alter 修改 show展示</p>
<p>table表的关键字 create创建 drop删除 alter修改 desc展示表的结构 </p>
<p>table中的行的插入 insert into 修改 update 删除 delete 查询 select。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM my_db.stu;</span><br><span class="line"># 主键就是 既非空又唯一的特殊约束 primary key </span><br><span class="line"></span><br><span class="line">#添加主键 方式一</span><br><span class="line">alter table stu modify id int primary key;</span><br><span class="line"># 添加主键 方式二 建表的时候定义</span><br><span class="line"></span><br><span class="line"># 删除主键 alter table 表名 drop primary key 一张表只有一个主键;</span><br><span class="line">alter table stu drop primary key;</span><br><span class="line"></span><br><span class="line"># 非空约束 NOT NULL;</span><br><span class="line"># 创建方式一</span><br><span class="line">alter table stu modify name varchar(32) not null;</span><br><span class="line">#创建方式二 创建表时定义</span><br><span class="line"></span><br><span class="line"># 删除非空约束</span><br><span class="line">alter table stu modify name varchar(32);</span><br><span class="line"></span><br><span class="line"># 唯一约束 unique</span><br><span class="line">#创建方式一 创建表时定义</span><br><span class="line">#创建方式二  </span><br><span class="line">alter table stu modify name varchar(32) unique;</span><br><span class="line">#删除 唯一约束</span><br><span class="line"># 错误方式 alter table stu modify name varchar(32);</span><br><span class="line">alter table stu drop index name ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除外键</span><br><span class="line">alter table stu1 drop foreign key c_key;</span><br><span class="line"># 添加外键方式一:</span><br><span class="line">alter table stu1 add constraint c_key foreign key(cid) references course(id);</span><br><span class="line"># 添加外键方式二: 创建时就定义 一般格式 constraint 外键名 foreign key(列名) references 表名 (列名);</span><br><span class="line"></span><br><span class="line"># 复制表的结构方式一用 like 模板 create table 新表 like 旧表 会将约束关系一同复制;</span><br><span class="line">create table stu2 like stu1;</span><br><span class="line"></span><br><span class="line"># 复制表的结构方式二用 create table 新表 select* from 旧表 where 1 = 2 但不会将约束关系一同复制;</span><br><span class="line">create table stu3 select * from stu1 where 1 = 2;</span><br><span class="line"># 复制表的结构与数据 create table 新表 select* from 旧表 但不会将约束关系一同复制;</span><br><span class="line">create table stu4 select* from stu1;</span><br><span class="line"></span><br><span class="line"># 主键约束自动增长 不给主键定值的情况下主键会按照主键的上一个值加一</span><br><span class="line"># 添加方式一: alter table 表名 modify 列名 类型 主键约束 auto_increment;</span><br><span class="line"># 添加方式二: 创建表的时候定义;</span><br><span class="line">alter table stu2 modify id int primary key auto_increment;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库事务</title>
    <url>/2022/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><h3 id="事务的基本要素-4大性质"><a href="#事务的基本要素-4大性质" class="headerlink" title="事务的基本要素 4大性质"></a><strong>事务的基本要素 4大性质</strong></h3><blockquote>
<ol>
<li>原子性:事务开始后的所有操作,要么全部成功,要么全部失败回滚,不可能停滞在中间环节.事务执行过程中出错,会回滚到事务开始之前的状态,所有操作就像没有发生一样.也就是说事务是一个不可分割的整体,就像化学中学过的原子,是事务构成的基本单位.</li>
<li>一致性:事务开始前和结束后,数据库的完整性约束没有被破坏,如A向B转张,不可能出现A扣了钱而B却没有加的情况</li>
<li>隔离性:同一时间,只允许一个事务请求同一数据,不同事务之间彼此没有任何干扰,如A正在从一张银行卡中取钱,在A取钱的过程结束前,B不能向这张卡转账.</li>
<li>持久性:事务完成之后,事务对数据库更新将会被保存写在数据库上,不能回滚.</li>
</ol>
</blockquote>
<span id="more"></span>

<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p> <strong>隔离级别定义了一个事务可能受其他并发事务影响的程度。</strong></p>
<blockquote>
<p><strong>脏读（Dirty reads）</strong>—— 事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。</p>
<p><strong>不可重复读（Nonrepeatable read）</strong>—— 事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</p>
<p><strong>幻读（Phantom read）</strong>—— 系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p>
</blockquote>
<p>不可重复读是指在原本有个数据上进行修改导致一个事务一致都是读到不同的数据, 而幻读则是在原来的数据中的插入,删除等操作导致的.<strong>解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</strong></p>
<hr>
<p><strong>串行化</strong>隔离规则类型在开发中很少用到。举个很简单的例子。咱们使用了ISOLATION_SERIALIZABLE规则。A,B两个事务操作同一个数据表并发过来了。A先执行。A事务这个时候会把表给锁住，B事务执行的时候直接报错。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一记--synchronized关键字</title>
    <url>/2022/02/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0--synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="每日一记–synchronized关键字"><a href="#每日一记–synchronized关键字" class="headerlink" title="每日一记–synchronized关键字"></a>每日一记–synchronized关键字</h1><h2 id="synchronized关键字（隐式的获取和释放锁）"><a href="#synchronized关键字（隐式的获取和释放锁）" class="headerlink" title="synchronized关键字（隐式的获取和释放锁）"></a>synchronized关键字（隐式的获取和释放锁）</h2><p>作用于静态方法：</p>
<p><strong>对象锁</strong>给对象加锁（可以理解为这个对象的内存上锁，<strong>注意：只是这块内存，其他同类对象都会有各自的内存锁</strong>）这时候在其他一个以上线程中执行该对象的这个同步方法（<strong>注意：是该对象</strong>）就会产生互斥）</p>
<p>作用于静态方法：</p>
<p><strong>类锁</strong>：相当于在类上枷锁（*.class位于代码区，静态方法位于静态区域，这个类产生的对象公用这个静态方法，所以这块内存，N个对象来竞争），这时候，只要是这个类产生的对象，在调用这个静态方法时都会产生互斥</p>
<p><strong>对象锁与类锁区别</strong>：主要就在于内存区域不同 <strong>对象锁</strong>只作用与同类的单个对象的内存区域 <strong>类锁</strong>则作用于同类的所有对象的内存区域 </p>
<span id="more"></span>

<p>Java线程内存模型：每个线程都用拥有自己的栈、堆内存共享、如下图所示。锁是线程间内存和信息沟通的载体。<img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/491378-20160720152209982-808156316.png" alt="img"></p>
<p>Java中为了保证每个线程中的原子操作，引入了内置锁或者称监视器锁，其中，每个Java对象都可以作为实现锁的对象。</p>
<p>synchronized关键字修饰的代码块被称为同步代码块 ，线程进入同步代码块自动获取内置锁，退出同步代码块则释放锁，不需要调用者考虑它的创建以及消除而别的线程此时无法获得这把锁，就无法调用这个方法。一个线程想要获得这个锁只能等上一个线程执行结束这个方法将锁释放，下一个线程才能有机会调用这个方法获得该对象的锁（即synchronized关键字可以获得内置锁，同一时间只允许一个线程获得某个锁）。</p>
<blockquote>
<p>java的每个对象都有一个锁，不需要显示地去创建。</p>
<p><strong>java的内置锁</strong>：每个java对象都可以用做一个实现同步的锁，这些锁称为<strong>内置锁</strong>。<strong>线程</strong>进入同步代码块或方法的时候会<strong>自动获得该锁</strong>，在<strong>退出</strong>同步代码块或方法时会<strong>释放</strong>该锁。获得内置锁的<strong>唯一途径就是进入这个锁的保护的同步代码块或方法</strong>。</p>
<p><strong>java内置锁</strong>是一个<strong>互斥锁</strong>，这就意味着同一时间最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，线程A必须<strong>等待或者阻塞</strong>，直到线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。</p>
</blockquote>
<p><strong>1.同步方法（粗粒度锁）</strong>：</p>
<p>即有<strong>synchronized</strong>关键字修饰的方法。</p>
<p><strong>由于java中每个对象都有一个内置锁，当使用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.<strong>同步代码块（细粒度锁）</strong>：</p>
<p>即有<strong>synchronized</strong>关键字修饰的语句块。</p>
<p>被该关键字修饰的语句块会被自动加上内置锁，从而实现同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object)&#123; </span><br><span class="line">	代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：同步是一种高开销的操作，因此应该尽量减少同步的内容。 通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。</strong> 同步会影响一定的多线程性能</p>
<p><strong>synchronized的缺陷</strong>：当某个线程进入同步方法获得对象锁，那么其他线程访问这里对象的同步方法时，必须等待或者阻塞，这对高并发的系统是致命的，这很容易导致系统的崩溃。如果某个线程在同步方法里面发生了死循环，那么它就永远不会释放这个对象锁，那么其他线程就要永远的等待。这是一个致命的问题。</p>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一记--多线程（续）</title>
    <url>/2022/02/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0--%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%BB%AD%EF%BC%89/</url>
    <content><![CDATA[<h1 id="每日一记–多线程（续）"><a href="#每日一记–多线程（续）" class="headerlink" title="每日一记–多线程（续）"></a>每日一记–多线程（续）</h1><hr>
<p>今天看了看书 更了解了多线程。</p>
<h2 id="Java中的线程"><a href="#Java中的线程" class="headerlink" title="Java中的线程"></a>Java中的线程</h2><p><strong>程序</strong>：程序是一段静态的代码，他是应用软件执行的蓝本。</p>
<p><strong>进程</strong>：进程是程序的一次动态执行过程，它对应了从代码加载、执行至完毕的一个完整过程，这个过程也是进程本身从产生、发展至消亡的过程。</p>
<p><strong>线程</strong>：线程是比进程更小的执行单位。线程之间可以共享相同的内存单元（即内存中的堆区 包括代码和数据）并利用这些共享单元来实现数据交换、实时通信与必要的同步操作。</p>
<p><strong>进程与线程的关系</strong>：一个进程在其执行的过程中可以产生多个线程，形成多条执行线索，每条线索，即没有线程都有它自身的产生、存在与消亡的过程，也是一个动态的概念。</p>
<p><strong>多线程原理</strong>：我们知道，操作系统分时管理各个进程，按时间片轮流执行每个进程。Java的多线程就是在操作系统每次分时给Java程序一个时间片的cpu时间内，在若干个独立的可控制的线程之间进行切换。如果机器能有多个cpu处理器，那么JVM就能充分利用这些cpu，使得Java程序在同一时刻能获得多个时间片，Java程序就可以获得真实的线程并发执行效果。</p>
<p><strong>主线程</strong>：每个Java程序都有一个默认的主线程，这个线程就是当执行主类main方法开始执行时，当JVM加载代码发现main方法之后，就会启动一个线程，这个线程就被称为<strong>“主线程”</strong>，该线程负责执行main方法，如果在main方法的执行过程中再创建的线程 就称为<strong>其他线程</strong>。如果main方法中没有创建其他线程，那么当main方法执行完最后一个语句，JVM就会结束Java应用程序。如果main方法中有创建了其他线程，那么JVM就要在主线程和其他线程之间轮流切换，以保证每个线程都能有机会使用cpu资源。</p>
<p><strong>注</strong>：main方法即使执行完最后的语句（主线程结束），JVM也不会结束程序，JVM会等待程序中其他线程都结束才会结束Java应用程序。</p>
<span id="more"></span>

<hr>
<h3 id="线程的状态与生命周期"><a href="#线程的状态与生命周期" class="headerlink" title="线程的状态与生命周期"></a>线程的状态与生命周期</h3><p><strong>新建状态</strong>：当一个Thread类或其子类的对象被声明并创建时，新生的线程处于NEW状态。此时它已经有了相应的内存空间和其他资源，即此时线程已准备但尚未启动（未调用**start()**方法），此时JVM管理的线程中还没有这个线程。</p>
<p><strong>可运行状态</strong>：当处于NEW状态的线程调用了Thread类提供的**start()**方法，此时线程就会进入RUNNABLE状态，称为可运行状态，此时JVM就会知道有一个新的线程在等待切换了。</p>
<p><strong>中断状态</strong>：<strong>BOLOCKED、WAITING、TIMED_WAITING</strong>状态都属于中断状态，当中断的线程重新进入RUNNABLE状态后，一旦JVM将cpu使用权切换给该线程，<strong>run()<strong>方法将</strong>从中断出继续执行</strong>。</p>
<ul>
<li>JVM将从cpu资源从当前RUNNABLE线程切换给其他线程，是本线程让出cpu的使用权进入BLOCKED状态，进入BOLOCKED状态的线程必须等待JVM解除它的BLOCKED状态，再次进入RUNNABLE状态，并从中断处继续执行。</li>
<li>线程使用cpu资源期间，执行了<strong>sleep(int millsecond)</strong>,使得当前线程进入休眠状态。<strong>sleep(int millsecond)<strong>方法是Thread类的类方法，一个线程一旦执行了这个方法，就立刻让出cpu使用权，使当前线程处于</strong>TIMED_WAITING</strong>状态。经过至多参数<strong>millsecond</strong>指定的毫秒数之后，该线程再次进入RUNNABLE状态。</li>
<li>线程使用cpu资源期间，执行了wait()方法，使得当前线程进入<strong>WAITING</strong>状态。该状态的线程不会主动进入RUNNABLE状态，必须由其他线程调用**notify()**方法通知它，使得它进入RUNNABLE状态。</li>
</ul>
<p><strong>死亡状态</strong>：当一个线程执行完<strong>run()<strong>方法，该线程就完成了它的全部工作进入</strong>TERMINATED状态</strong>。</p>
<p><strong>注</strong>：只有处于NEW状态的线程才可以调用<strong>start()<strong>方法，处于其他状态的线程都不可以调用该方法，否则将会触发</strong>IllegalThreadStateException</strong>异常</p>
<hr>
<p>例：用继承Thread的子类创建两个线程，这两个线程在控制台分别输出五句“老虎”和“小猫”；主线程控制台输出6句主人。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DEVIL.多线程;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil(丁杨维)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-14-22:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E_06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;<span class="comment">//主线程</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">//通过Thread类子类创建一个线程 此时出NEW状态</span></span><br><span class="line">        <span class="type">Tiger</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tiger</span>();<span class="comment">//创建另一个线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Tiger线程的状态&quot;</span>+ t1.getState());<span class="comment">//获取线程的状态</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Cat线程的状态&quot;</span>+ t2.getState());</span><br><span class="line">        t1.start();<span class="comment">//启动线程 是现成进入RUNNABLE状态</span></span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;\n%s&quot;</span>,<span class="string">&quot;Tiger线程的状态&quot;</span>+ t1.getState());<span class="comment">//获取线程执行时状态</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;\n%s&quot;</span>,<span class="string">&quot;Cat线程的状态&quot;</span>+t2.getState());</span><br><span class="line">            System.out.printf(<span class="string">&quot;\n%s&quot;</span>,<span class="string">&quot;主人&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;\nTiger线程的状态&quot;</span>+ t1.getState());<span class="comment">//获取线程执行结束时状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Cat线程的状态&quot;</span>+ t2.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;|小猫&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;|老虎&quot;</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//延时1秒 使其进入TIMED_WAITING状态</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tiger线程的状态NEW</span><br><span class="line">Cat线程的状态NEW</span><br><span class="line">Tiger线程的状态RUNNABLE|老虎1|小猫1|小猫2|小猫3|小猫4|小猫5</span><br><span class="line"></span><br><span class="line">Cat线程的状态BLOCKED</span><br><span class="line">主人1</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">主人2</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">主人3</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">主人4</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">主人5</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">主人6</span><br><span class="line">Tiger线程的状态TERMINATED</span><br><span class="line">Cat线程的状态TIMED_WAITING</span><br><span class="line">|老虎2|老虎3|老虎4|老虎5</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：程序在不同的计算机运行或在同一台计算机上反复运行的结果不尽相同，输出结果依赖于当前cpu使用情况。当其他线程的<strong>run()<strong>方法都结束了，线程进入</strong>死亡状态</strong>，只留下一个线程时，<strong>JVM</strong>不再将cpu资源切给主线程，等到最后一个线程也结束了，<strong>JVM</strong>就将java程序退出虚拟机，即java程序的结束。</p>
<hr>
<h3 id="线程的调度与优先级"><a href="#线程的调度与优先级" class="headerlink" title="线程的调度与优先级"></a>线程的调度与优先级</h3><blockquote>
<p>处于就绪状态的线程首先进入就绪队列排队等候cpu资源，同一时刻再就绪队列中的线程可能由多个。Java虚拟机（JVM）中的<strong>线程调度器</strong>负责管理线程，调度器把线程的的优先级分为了10个级别，分别用<strong>Thread类</strong>中的类常量表示。每个Java线程的优先级都为常数1~10，即<strong>Thread.MIN_PRIORITY和Thread.MAX_PRIORITY</strong>之间。<em><strong>如果没有明确第设置线程的优先级别，每个线程的优先级都默认为常数5</strong></em>，即<strong>Thread.NORM_PRIORITY</strong>。</p>
<p>线程的优先级可以通过<strong>setPriority(int grade)<strong>方法调整，该方法需要一个int参数代表设置线程的等级，如果该参数不在1~10的范围内，那么</strong>setPriority</strong>便会产生一个<strong>IllegalArgumentException</strong>异常。如果参数正常该方法会返回所设置的线程的优先级。（ <strong>注</strong>：有些操作系统只能识别3个级别，即1、5和10。）</p>
<p><strong>java线程调度器</strong>的任务就是使高优先级的线程能始终运行，一旦时间片有空闲，则使具有同等优先级的线程以轮流D这四个线程，且A和B的级别高于C和D，那么，Java调度器首先以轮流的方式执行A和B，一直等到A、B都执行完毕进入死亡状态，才会再C、D之间轮流切换。）</p>
<p><strong>注</strong>：在实际编程时，不提倡使用线程的优先级来保证算法的正确执行。如果要编写正确、跨平台的多线程代码，必须假设线程在任何时刻都有可能被剥夺cpu资源的使用权</p>
</blockquote>
<hr>
<h2 id="Java程序内存的简单分析"><a href="#Java程序内存的简单分析" class="headerlink" title="Java程序内存的简单分析"></a>Java程序内存的简单分析</h2><ul>
<li><strong>栈：</strong>一般来说，<strong>基本数据类型</strong>直接在栈中分配空间，<strong>局部变量</strong>（在方法代码段中定义的变量）也在栈中直接分配空间，<strong>当局部变量所在方法执行完成之后该空间便立刻被JVM回收</strong>，还有一种是<strong>引用数据类型</strong>，即我们通常所说的需要用<strong>关键字new创建出来的对象所对应的引用</strong>也是在栈空间中，此时，JVM在栈空间中给对象引用分配了一个地址空间（相当于一个门牌号，通过这个门牌号就可以找到你家），在堆空间中给该引用的对象分配一个空间，栈空间中的地址引用指向了堆空间中的对象区（通过门牌号找住址）；</li>
<li><strong>堆：</strong>一般用来存放用<strong>关键字new出来的数据</strong>。</li>
</ul>
<hr>
<h1 id="end"><a href="#end" class="headerlink" title="-end-"></a>-end-</h1>]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一记</title>
    <url>/2022/02/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h1><hr>
<h2 id="栈简单应用之符号匹配"><a href="#栈简单应用之符号匹配" class="headerlink" title="栈简单应用之符号匹配"></a>栈简单应用之符号匹配</h2><p><strong>关键：</strong>读括号时，如果时括号的左半部分（正常情况下，括号的左半部分总是先读到）,如果遇到括号的右半部分，获取栈顶元素，如果匹配则弹出栈，如果不匹配依旧弹栈且哨兵flag记为FALSE,最后如果flag为TRUE且栈不为空或是flag为FALSE且栈为空则符号不匹配，如果栈为空且flag为TRUE则符号匹配。</p>
<span id="more"></span>

<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DEVIL.泛型与集合框架.堆栈;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil(丁杨维)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-12-18:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">栈应用之符号匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E_04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//先创建一个栈的对象</span></span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//设置哨兵 将他初始化为true</span></span><br><span class="line">        String str;</span><br><span class="line">        <span class="comment">//输入一行字符串其中包含符号(如&#x27;(&#x27; &#x27;)&#x27; &#x27;[&#x27; &#x27;]&#x27; &#x27;&#123;&#x27; &#x27;&#125;&#x27;);</span></span><br><span class="line">        str = sc.nextLine();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;str.length();i++)&#123;<span class="comment">//筛选已输入字符串中符合条件的符号</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&#x27;(&#x27;</span>||ch==<span class="string">&#x27;&#123;&#x27;</span>||ch==<span class="string">&#x27;[&#x27;</span>)&#123;<span class="comment">//如果字符为符合条件且为符号的左半部分则压入栈中</span></span><br><span class="line">                stack.push(ch);<span class="comment">//压栈操作</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果字符为符号的右半部分则获取栈顶元素进行匹配</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;)&#x27;</span>&amp;&amp; !stack.empty())&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.peek() == <span class="string">&#x27;(&#x27;</span>)&#123;<span class="comment">//栈不为空获取栈顶元素进行匹配 匹配成功 弹栈;</span></span><br><span class="line">                    stack.pop();<span class="comment">//弹栈</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;<span class="comment">//除此之外则匹配失败</span></span><br><span class="line">                    stack.pop();<span class="comment">//弹栈</span></span><br><span class="line">                    flag = <span class="literal">false</span>;<span class="comment">//哨兵赋值为false</span></span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//跳出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;&#125;&#x27;</span>&amp;&amp; !stack.empty())&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.peek() == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;]&#x27;</span>&amp;&amp; !stack.empty())&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.peek() == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后如果栈为空且哨兵值为true 则字符串中的符号完全匹配</span></span><br><span class="line">        <span class="keyword">if</span>(flag&amp;&amp;stack.empty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果栈不为空或是哨兵值为false抑或是两者都不满足 则字符串中符号匹配失败</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sc.close();<span class="comment">//最后关闭io流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输入样例1：</p>
<blockquote>
<p>{(1+2)*3+4&#x2F;(3-1)</p>
</blockquote>
<p>控制台输出：</p>
<blockquote>
<p>NO</p>
</blockquote>
<p>输入样例2：</p>
<blockquote>
<p>(1+2)*3+4&#x2F;(3-1)</p>
</blockquote>
<p>控制台输出：</p>
<blockquote>
<p>YES</p>
</blockquote>
<h2 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h2><hr>
<p><em><em>对称矩阵可以将一个n * n存储空间的数组压缩成一个n</em>(n+1)&#x2F;2大小的数组</em>* 一般拿一维数组存储。</p>
<p>接下来代码将展示一般对称矩阵压缩以及还原输出</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习题;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil(丁杨维)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-12-20:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对称矩阵</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E_21</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n;<span class="comment">//矩阵的行列数(对称矩阵的前提是行列数都相等)</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;=======================输入数据==============================&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入一个n*n的矩阵的n:&quot;</span>);</span><br><span class="line">        n = sc.nextInt();<span class="comment">//从键盘输入n</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入n*n矩阵的元素:&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[][] Array = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;Array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;Array[i].length; j++)&#123;</span><br><span class="line">                Array[i][j]=sc.nextInt();<span class="comment">//读入矩阵数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSymmetricMatrix(Array))&#123;<span class="comment">//判断是否是对称矩阵</span></span><br><span class="line">            System.out.println(<span class="string">&quot;输入的矩阵是对称矩阵&quot;</span>);</span><br><span class="line">            <span class="type">int</span>[] SymmetricMatrix = <span class="keyword">new</span> <span class="title class_">int</span>[n*(n+<span class="number">1</span>)/<span class="number">2</span>];<span class="comment">//初始化压缩矩阵</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//压缩矩阵下标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;Array.length; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i+<span class="number">1</span>; j++)&#123;</span><br><span class="line">                    SymmetricMatrix[index++] = Array[i][j];<span class="comment">//装载数据</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;=======================输出压缩后的矩阵==============================&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> symmetricMatrix : SymmetricMatrix) &#123;</span><br><span class="line">                System.out.print(symmetricMatrix+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">&quot;=========================还原对阵矩阵============================&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">                        <span class="comment">//上三角元素下标与压缩矩阵元素下标满足关系k = (j*(j+1)/2+i) k为压缩矩阵元素下标</span></span><br><span class="line">                        System.out.print(SymmetricMatrix[j*(j+<span class="number">1</span>)/<span class="number">2</span>+i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//下三角以及对角线元素下标与压缩矩阵元素下标满足关系k = (j*(j+1)/2+i)</span></span><br><span class="line">                        System.out.print(SymmetricMatrix[i*(i+<span class="number">1</span>)/<span class="number">2</span>+j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是对称矩阵的函数;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSymmetricMatrix</span><span class="params">(<span class="type">int</span>[][] Array)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;Array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt;Array[i].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Array[i][j]!=Array[j][i])&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还原对称矩阵时上三角部分：<em><em>上三角部分的元素下标与压缩矩阵元素下标满足关系k &#x3D; (j</em>(j+1)&#x2F;2+i) k为压缩矩阵元素下标</em>*</p>
<p>还原对称矩阵时上三角部分：<em><em>下三角以及对角线元素下标与压缩矩阵元素下标满足关系k &#x3D; (j</em>(j+1)&#x2F;2+i)</em>*</p>
<p>输入样例；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure>



<p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=======================输入数据==============================</span><br><span class="line">请输入一个n*n的矩阵的n:2</span><br><span class="line">请输入n*n矩阵的元素:</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">输入的矩阵是对称矩阵</span><br><span class="line">=======================输出压缩后的矩阵==============================</span><br><span class="line">1	2	1	</span><br><span class="line">=========================还原对阵矩阵============================</span><br><span class="line">1	2	</span><br><span class="line">2	1	</span><br></pre></td></tr></table></figure>

<hr>
<p>接下来将展示输入一个已经压缩的对称矩阵将其还原输出</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习题;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil(丁杨维)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-12-20:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E_22</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n, row;<span class="comment">//用于储存压缩矩阵的大小 和还原矩阵的大小</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;=======================输入数据==============================&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入压缩的对称矩阵的大小n:&quot;</span>);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请给出矩阵元素:&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[] SymmetricMatrix = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">//录入数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            SymmetricMatrix[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出压缩的对称矩阵</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n======================输出压缩的对称矩阵======================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            System.out.print(SymmetricMatrix[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取还原矩阵的行列数</span></span><br><span class="line">        <span class="keyword">for</span>(row = <span class="number">0</span>; row&lt;n; row++)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((row*(row+<span class="number">1</span>)/<span class="number">2</span>)==n)&#123;<span class="comment">//还原矩阵的行列数与压缩矩阵的长度 关系为n*(n+1)/2</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n======================还原输出对称矩阵======================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;row; j++)&#123;<span class="comment">//还原</span></span><br><span class="line">                <span class="keyword">if</span>(i&lt;j)&#123;<span class="comment">//上三角</span></span><br><span class="line">                    <span class="comment">//上三角元素下标与压缩矩阵元素下标满足关系k = (j*(j+1)/2+i) k为压缩矩阵元素下标</span></span><br><span class="line">                    System.out.print(SymmetricMatrix[j*(j+<span class="number">1</span>)/<span class="number">2</span>+i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;<span class="comment">//下三角以及对角线</span></span><br><span class="line">                    <span class="comment">//下三角以及对角线元素下标与压缩矩阵元素下标满足关系k = (j*(j+1)/2+i)</span></span><br><span class="line">                    System.out.print(SymmetricMatrix[i*(i+<span class="number">1</span>)/<span class="number">2</span>+j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输入样例：</p>
<blockquote>
<p>10</p>
<p>1 2 3 4 5 6 7 8 9 10</p>
</blockquote>
<p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=======================输入数据==============================</span><br><span class="line">请输入压缩的对称矩阵的大小n:10</span><br><span class="line">请给出矩阵元素:</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line"></span><br><span class="line">======================输出压缩的对称矩阵======================</span><br><span class="line">1	2	3	4	5	6	7	8	9	10	</span><br><span class="line">======================还原输出对称矩阵======================</span><br><span class="line">1	2	4	7	</span><br><span class="line">2	3	5	8	</span><br><span class="line">4	5	6	9	</span><br><span class="line">7	8	9	10	</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="end"><a href="#end" class="headerlink" title="-end-"></a>-end-</h1>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>雪花算法</title>
    <url>/2022/04/04/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h1><p><strong>简介:</strong></p>
<ul>
<li>雪花算法是Twitter开源的分布式ID生成算法 <a href="https://github.com/twitter-archive/snowflake.git">Github仓库地址</a></li>
<li>雪花算法主要用于分布式系统中,数据库的ID生成</li>
<li>在自然界中并不存在两片完全一样的雪花,每一片雪花都拥有自己漂亮独特的形状,独一无二.雪花算法也表示生成的分布式id如雪花般独一无二.</li>
</ul>
<span id="more"></span>

<h2 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h2><p>随着业务被使用的人越来越多, 单机的数据库已经很难保证业务能够流畅稳定的运行了, 这是我们需要对数据库进行分库分表存储, 使用分布式集群, 但是这样每个表的数据怎么保证ID唯一呢? 如果使用主键递增肯定发生ID不唯一的冲突情况, 所以急需一种可以生成全局唯一ID的算法来解决这个囧境.</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/v2-6d694779c7d47e3573939f21993318df_720w.jpg" alt="img"></p>
<hr>
<h3 id="分布式ID需要满足的要求"><a href="#分布式ID需要满足的要求" class="headerlink" title="分布式ID需要满足的要求"></a><strong>分布式ID需要满足的要求</strong></h3><h4 id="全局唯一"><a href="#全局唯一" class="headerlink" title="全局唯一:"></a>全局唯一:</h4><ul>
<li>这是最基本的要求</li>
</ul>
<h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能:"></a>高性能:</h4><ul>
<li>不能为了全局唯一就去生成一大长串,肯定需要考虑性能,既要考虑生成的效率,又要考虑查询的效率(即存储的效率).</li>
</ul>
<h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用:"></a>高可用:</h4><ul>
<li>生成分布式ID的服务要保证可用性高,无限接近100%</li>
</ul>
<h4 id="方便易用"><a href="#方便易用" class="headerlink" title="方便易用:"></a>方便易用:</h4><ul>
<li>拿来即用，使用方便，快速接入！</li>
</ul>
<hr>
<h4 id="安全"><a href="#安全" class="headerlink" title="安全:"></a>安全:</h4><ul>
<li>分布式ID中不应含有敏感信息,否则了解算法的不怀好意之人解码可能会获取到这些敏感信息.</li>
</ul>
<h4 id="有序递增"><a href="#有序递增" class="headerlink" title="有序递增:"></a>有序递增:</h4><ul>
<li>如果要把 ID 存放在数据库的话，<strong>ID 的有序性可以提升数据库写入速度</strong>。并且，很多时候 ，我们还很有可能会直接通过 ID 来进行排序。</li>
</ul>
<h4 id="要求具体的业务含义"><a href="#要求具体的业务含义" class="headerlink" title="要求具体的业务含义:"></a>要求具体的业务含义:</h4><ul>
<li>生成的ID如果能有具体的业务含义,可以让定位问题以及开发更透明化(例如根据ID就能确定是哪个业务)</li>
</ul>
<h4 id="独立部署"><a href="#独立部署" class="headerlink" title="独立部署:"></a>独立部署:</h4><ul>
<li>也就是分布式系统单独有一个发号器服务，专门用来生成分布式 ID。这样就生成 ID 的服务可以和业务相关的服务解耦。不过，这样同样带来了网络调用消耗增加的问题。总的来说，如果需要用到分布式 ID 的场景比较多的话，独立部署的发号器服务还是很有必要的。(企业级的大型项目中十分有必要)</li>
</ul>
<hr>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>雪花算法生成的ID是一个<strong>64bit</strong>的<strong>long</strong>型的数字且<strong>按时间趋势递增</strong>.大致有首位符号位(无效位), 时间戳插值, 机器编码, 序列号四部分组成.</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/22531124-e47b04a4e5b26623.png" alt="img"></p>
<p>如图: </p>
<ul>
<li><strong>首位无效符:</strong> 主要用做为符号位,因为一般都是生成正数,所以符号位统一都是0</li>
<li>**时间戳:**占用41bit,精确到毫秒. 41bit位最好可以表示2^41-1毫秒, 转化成单位年为69年.</li>
<li><strong>机器编码:</strong> 占用10bit,其中高位5bit是数据中心ID,低位5bit是工作节点ID,最多可以容纳1024个节点.</li>
<li>**序列号:**占用12bit,每个节点每毫秒0开始不断累加,最多可以累加到2^12-1,一共可以生成4096个ID(包括了0)</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a><strong>Java代码实现</strong></h3><p><code>snowFlake</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dyw.snowFlake;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-04-04 14:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDWorker</span> &#123;</span><br><span class="line">    <span class="comment">//十位的工作机器码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> workerId; <span class="comment">//工作id 五位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> datacenterId; <span class="comment">//数据中心id 五位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//12位序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">sequence</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">twEpoch</span> <span class="operator">=</span> <span class="number">1288834974657L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//长度为5位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">workerIdBits</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">datacenterIdBits</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line">    <span class="comment">//最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">maxWorkerId</span> <span class="operator">=</span> ~(-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">maxDatacenterId</span> <span class="operator">=</span> ~(-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列号id长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">sequenceBits</span> <span class="operator">=</span> <span class="number">12L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">sequenceMask</span> <span class="operator">=</span> ~(-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//工作id需要左移的位数, 12位(序列号的位长)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">workerIdShift</span> <span class="operator">=</span> sequenceBits;</span><br><span class="line">    <span class="comment">//数据中心id需要左移的位数 序列号长+工作id长</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">datacenterIdShift</span> <span class="operator">=</span> sequenceBits + workerIdBits;</span><br><span class="line">    <span class="comment">//时间戳左移位数 = 序列号长+工作id长+工作位长</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">timestampLeftShift</span> <span class="operator">=</span> sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上次时间戳, 初始值位负值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastTimestamp</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workerId 工作节点id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> datacenterId 数据中心id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IDWorker</span><span class="params">(<span class="type">long</span> workerId, <span class="type">long</span> datacenterId)</span> &#123;</span><br><span class="line">        <span class="comment">//检查参数的合法性</span></span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;</span>,</span><br><span class="line">                timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId);</span><br><span class="line">        <span class="built_in">this</span>.workerId = workerId;</span><br><span class="line">        <span class="built_in">this</span>.datacenterId = datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getWorkerId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> workerId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDatacenterId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getSequence</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * //下一个ID生成算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> snowflakeId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//先获取当前系统时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> timeGen();</span><br><span class="line">        <span class="comment">//如果当前系统时间比上次获取id时间戳小就抛出异常 时钟往后移动可能会出现同样id所以这里必须抛异常结束执行</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            System.err.printf(<span class="string">&quot;clock is moving backwards.  Rejecting requests until %d.&quot;</span>,lastTimestamp);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(String.format(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>,</span><br><span class="line">                    lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前时间戳如果等于上次时间戳(同一毫秒内),则在序列号加一,否则序列号赋值为0, 从零开始</span></span><br><span class="line">        <span class="keyword">if</span>(timestamp==lastTimestamp)&#123;</span><br><span class="line">            <span class="comment">//这是使用&amp;sequenceMask是为了防止sequence溢出12位(前面要求了sequence的长度只能是12位)</span></span><br><span class="line">            sequence = (sequence+<span class="number">1</span>)&amp;sequenceMask;</span><br><span class="line">            <span class="comment">//如果防止刚好移除经过&amp;sequenceMask后 会变成0 可能会发生重复的情况</span></span><br><span class="line">            <span class="comment">//所以此时需要再次获取时间戳,并于上次时间戳作比较 直到与上次时间戳不一致返回当前时间戳避免重复</span></span><br><span class="line">            <span class="keyword">if</span>(sequence==<span class="number">0</span>)&#123;</span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//如果不在同一个时间戳中 代表该序列刚开始计数所以初始为0</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sequence = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将上次时间戳值更新</span></span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 返回结果：</span></span><br><span class="line"><span class="comment">         * (timestamp - TwEpoch) &lt;&lt; timestampLeftShift) 表示将时间戳减去初始时间戳，再左移相应位数</span></span><br><span class="line"><span class="comment">         * (datacenterId &lt;&lt; datacenterIdShift) 表示将数据id左移相应位数</span></span><br><span class="line"><span class="comment">         * (workerId &lt;&lt; workerIdShift) 表示将工作id左移相应位数</span></span><br><span class="line"><span class="comment">         * | 是按位或运算符，例如：x | y，只有当x，y都为0的时候结果才为0，其它情况结果都为1。</span></span><br><span class="line"><span class="comment">         * 因为个部分只有相应位上的值有意义，其它位上都是0，所以将各部分的值进行 | 运算就能得到最终拼接好的id</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - twEpoch)&lt;&lt;timestampLeftShift) |</span><br><span class="line">                (datacenterId&lt;&lt;datacenterIdShift) |</span><br><span class="line">                (workerId&lt;&lt;workerIdShift)|</span><br><span class="line">                sequence;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取时间戳,并于上次时间戳作比较</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastTimestamp 上一次获取的时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> timestamp 更新后的系统时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">tilNextMillis</span><span class="params">(<span class="type">long</span> lastTimestamp)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> timeGen();</span><br><span class="line">        <span class="keyword">while</span>(timestamp&lt;=lastTimestamp)&#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取系统时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 系统时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">timeGen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Go语言实现"><a href="#Go语言实现" class="headerlink" title="Go语言实现"></a><strong>Go语言实现</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> al</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutex = sync.Mutex&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">//初始时间戳</span></span><br><span class="line">	twEpoch <span class="type">int64</span> = <span class="number">1288834974657</span></span><br><span class="line">	<span class="comment">//长度为5位</span></span><br><span class="line">	workerIdBits     <span class="type">int64</span> = <span class="number">5</span></span><br><span class="line">	datacenterIdBits <span class="type">int64</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//最大值</span></span><br><span class="line">	maxWorkerId     <span class="type">int64</span> = <span class="number">-1</span> ^ (<span class="number">-1</span> &lt;&lt; workerIdBits)</span><br><span class="line">	maxDatacenterId <span class="type">int64</span> = <span class="number">-1</span> ^ (<span class="number">-1</span> &lt;&lt; datacenterIdBits)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//序列号id长度</span></span><br><span class="line">	sequenceBits <span class="type">int64</span> = <span class="number">12</span></span><br><span class="line">	sequenceMask       = <span class="number">-1</span> ^ (<span class="number">-1</span> &lt;&lt; sequenceBits)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//工作id需要左移的位数, 12位(序列号的位长)</span></span><br><span class="line">	workerIdShift = sequenceBits</span><br><span class="line"></span><br><span class="line">	<span class="comment">//数据中心id需要左移的位数 序列号长+工作id长</span></span><br><span class="line">	datacenterIdShift = sequenceBits + workerIdBits</span><br><span class="line"></span><br><span class="line">	<span class="comment">//时间戳左移位数 = 序列号长+工作id长+工作位长</span></span><br><span class="line">	timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//上次时间戳, 初始值位负值</span></span><br><span class="line"><span class="keyword">var</span> lastTimestamp <span class="type">int64</span> = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IDWorker <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//十位的工作机器码</span></span><br><span class="line">	workerId     <span class="type">int64</span> <span class="comment">//工作id 五位</span></span><br><span class="line">	datacenterId <span class="type">int64</span> <span class="comment">//数据中心id 五位</span></span><br><span class="line">	<span class="comment">//12位序列号</span></span><br><span class="line">	sequence <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitIDWorker</span><span class="params">(workerId, datacenterId <span class="type">int64</span>)</span></span> (*IDWorker, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">//检查参数合法性</span></span><br><span class="line">	<span class="keyword">if</span> workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> err = errors.New(fmt.Sprintf(<span class="string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> err = errors.New(fmt.Sprintf(<span class="string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;</span>,</span><br><span class="line">		timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId)</span><br><span class="line">	<span class="keyword">return</span> &amp;IDWorker&#123;</span><br><span class="line">		datacenterId: datacenterId,</span><br><span class="line">		workerId:     workerId,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	下一个ID生成算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *IDWorker)</span></span> NextId() (id <span class="type">int64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">//上锁</span></span><br><span class="line">	mutex.Lock()</span><br><span class="line">	<span class="comment">//程序结束 释放锁</span></span><br><span class="line">	<span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line">	<span class="comment">//先获取当前系统时间</span></span><br><span class="line">	<span class="keyword">var</span> timestamp = timeGen()</span><br><span class="line">	<span class="comment">//如果当前系统时间比上次获取id时间戳小就抛出异常 时钟往后移动可能会出现同样id所以这里必须抛异常结束执行</span></span><br><span class="line">	<span class="keyword">if</span> timestamp &lt; lastTimestamp &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;clock is moving backwards.  Rejecting requests until %d.&quot;</span>, lastTimestamp)</span><br><span class="line">		err = errors.New(fmt.Sprintf(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>,</span><br><span class="line">			lastTimestamp-timestamp))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取当前时间戳如果等于上次时间戳(同一毫秒内),则在序列号加一,否则序列号赋值为0, 从零开始</span></span><br><span class="line">	<span class="keyword">if</span> timestamp == lastTimestamp &#123;</span><br><span class="line">		<span class="comment">//这是使用&amp;sequenceMask是为了防止sequence溢出12位(前面要求了sequence的长度只能是12位)</span></span><br><span class="line">		i.sequence = (i.sequence + <span class="number">1</span>) &amp; sequenceMask</span><br><span class="line">		<span class="comment">//如果防止刚好移除经过&amp;sequenceMask后 会变成0 可能会发生重复的情况</span></span><br><span class="line">		<span class="comment">//所以此时需要再次获取时间戳,并于上次时间戳作比较 直到与上次时间戳不一致返回当前时间戳避免重复</span></span><br><span class="line">		<span class="keyword">if</span> i.sequence == <span class="number">0</span> &#123;</span><br><span class="line">			timestamp = tilNextMillis(lastTimestamp)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//如果不在同一个时间戳中 代表该序列刚开始计数所以初始为0</span></span><br><span class="line">		i.sequence = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将上次时间戳值更新</span></span><br><span class="line">	lastTimestamp = timestamp</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回雪花算法生成的id</span></span><br><span class="line">	id = ((timestamp - twEpoch) &lt;&lt; timestampLeftShift) |</span><br><span class="line">		(i.datacenterId &lt;&lt; datacenterIdShift) |</span><br><span class="line">		(i.workerId &lt;&lt; workerIdShift) |</span><br><span class="line">		i.sequence</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i IDWorker)</span></span> WorkerId() <span class="type">int64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> i.workerId</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i IDWorker)</span></span> DatacenterId() <span class="type">int64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> i.datacenterId</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i IDWorker)</span></span> Sequence() <span class="type">int64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> i.sequence</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	获取系统时间戳</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeGen</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> time.Now().UnixMilli()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	获取时间戳,并于上次时间戳作比较</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tilNextMillis</span><span class="params">(lastTimestamp <span class="type">int64</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> timestamp = timeGen()</span><br><span class="line">	<span class="keyword">for</span> timestamp &lt;= lastTimestamp &#123;</span><br><span class="line">		timestamp = timeGen()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> timestamp</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo</title>
    <url>/2022/02/28/DUBBO/</url>
    <content><![CDATA[<h1 id="DUBBO"><a href="#DUBBO" class="headerlink" title="DUBBO"></a>DUBBO</h1><h2 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a><a href="https://github.com/guangxush/SpringBoot_GRPC">RPC框架</a></h2><h3 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h3><p>RPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。</p>
<span id="more"></span>

<p>比较正式的描述是：一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p>
<p>那么我们至少从这样的描述中挖掘出几个要点：</p>
<ul>
<li>RPC是协议：既然是协议就只是一套规范，那么就需要有人遵循这套规范来进行实现。目前典型的RPC实现包括：Dubbo、Thrift、GRPC、Hetty等。</li>
<li>网络协议和网络IO模型对其透明：既然RPC的客户端认为自己是在调用本地对象。那么传输层使用的是TCP&#x2F;UDP还是HTTP协议，又或者是一些其他的网络协议它就不需要关心了。</li>
<li>信息格式对其透明：我们知道在本地应用程序中，对于某个对象的调用需要传递一些参数，并且会返回一个调用结果。至于被调用的对象内部是如何使用这些参数，并计算出处理结果的，调用方是不需要关心的。那么对于远程调用来说，这些参数会以某种信息格式传递给网络上的另外一台计算机，这个信息格式是怎样构成的，调用方是不需要关心的。</li>
<li>应该有跨语言能力：为什么这样说呢？因为调用方实际上也不清楚远程服务器的应用程序是使用什么语言运行的。那么对于调用方来说，无论服务器方使用的是什么语言，本次调用都应该成功，并且返回值也应该按照调用方程序语言所能理解的形式进行描述。</li>
</ul>
<p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/640.png" alt="640"></p>
<hr>
<h3 id="为什么要用RPC"><a href="#为什么要用RPC" class="headerlink" title="为什么要用RPC"></a>为什么要用RPC</h3><p>其实这是应用开发到一定的阶段的强烈需求驱动的。如果我们开发简单的单一应用，逻辑简单、用户不多、流量不大，那我们用不着。当我们的系统访问量增大、业务增多时，我们会发现一台单机运行此系统已经无法承受。此时，我们可以将业务拆分成几个互不关联的应用，分别部署在各自机器上，以划清逻辑并减小压力。此时，我们也可以不需要RPC，因为应用之间是互不关联的。</p>
<p>当我们的业务越来越多、应用也越来越多时，自然的，我们会发现有些功能已经不能简单划分开来或者划分不出来。此时，可以将公共业务逻辑抽离出来，将之组成独立的服务Service应用 。而原有的、新增的应用都可以与那些独立的Service应用 交互，以此来完成完整的业务功能。</p>
<p>所以此时，我们急需一种高效的应用程序之间的通讯手段来完成这种需求，所以你看，RPC大显身手的时候来了！</p>
<p>其实描述的场景也是服务化 、微服务和分布式系统架构的基础场景。即RPC框架就是实现以上结构的有力方式。</p>
<h3 id="常用的RPC框架"><a href="#常用的RPC框架" class="headerlink" title="常用的RPC框架"></a>常用的RPC框架</h3><ul>
<li>Thrift：thrift是一个软件框架，用来进行可扩展且跨语言的服务的开发。它结合了功能强大的软件堆栈和代码生成引擎，以构建在 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml 这些编程语言间无缝结合的、高效的服务。</li>
<li>gRPC：一开始由 google 开发，是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。</li>
<li><strong>Dubbo</strong>：Dubbo是一个分布式服务框架，以及SOA治理方案。其功能主要包括：高性能NIO通讯及多协议集成，服务动态寻址与路由，软负载均衡与容错，依赖分析与降级等。Dubbo是阿里巴巴内部的SOA服务化治理方案的核心框架，Dubbo自2011年开源后，已被许多非阿里系公司使用。</li>
<li><strong>Spring Cloud</strong>：Spring Cloud由众多子项目组成，如Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Consul 等，提供了搭建分布式系统及微服务常用的工具，如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性token、全局锁、选主、分布式会话和集群状态等，满足了构建微服务所需的所有解决方案。Spring Cloud基于Spring Boot, 使得开发部署极其简单。</li>
</ul>
<h2 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h2><h3 id="RPC调用流程"><a href="#RPC调用流程" class="headerlink" title="RPC调用流程"></a>RPC调用流程</h3><p>要让网络通信细节对使用者透明，我们需要对通信细节进行封装，我们先看下一个RPC调用的流程涉及到哪些通信细节：</p>
<p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220306235426986.png" alt="image-20220306235426986"></p>
<ol>
<li>服务消费方（client）调用以本地调用方式调用服务；</li>
<li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li>
<li>client stub找到服务地址，并将消息发送到服务端；</li>
<li>server stub收到消息后进行解码；</li>
<li>server stub根据解码结果调用本地的服务；</li>
<li>本地服务执行并将结果返回给server stub；</li>
<li>server stub将返回结果打包成消息并发送至消费方；</li>
<li>client stub接收到消息，并进行解码；</li>
<li>服务消费方得到最终结果。</li>
</ol>
<p>RPC的目标就是要2~8这些步骤都封装起来，让用户对这些细节透明。</p>
<p>下面是网上的另外一幅图，感觉一目了然：</p>
<p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220306235500320.png" alt="image-20220306235500320"></p>
<h3 id="如何做到透明化远程服务调用"><a href="#如何做到透明化远程服务调用" class="headerlink" title="如何做到透明化远程服务调用"></a>如何做到透明化远程服务调用</h3><p>怎么封装通信细节才能让用户像以本地调用方式调用远程服务呢？对java来说就是使用代理！java代理有两种方式：1） jdk 动态代理；2）字节码生成。尽管字节码生成方式实现的代理更为强大和高效，但代码维护不易，大部分公司实现RPC框架时还是选择动态代理方式。</p>
<blockquote>
<p>其实就是通过动态代理模式，在执行该方法的前后对数据进行封装和解码等，让用于感觉就像是直接调用该方法一样，殊不知，我们对方法前后都经过了复杂的处理。(通过代理实现在调用方法前后进行编码和译码)</p>
</blockquote>
<h3 id="如何对消息进行编码和解码"><a href="#如何对消息进行编码和解码" class="headerlink" title="如何对消息进行编码和解码"></a>如何对消息进行编码和解码</h3><h4 id="确定消息数据结构"><a href="#确定消息数据结构" class="headerlink" title="确定消息数据结构"></a>确定消息数据结构</h4><p>客户端的请求消息结构一般需要包括以下内容：</p>
<ul>
<li>接口名称：在我们的例子里接口名是“HelloWorldService”，如果不传，服务端就不知道调用哪个接口了；</li>
<li>方法名：一个接口内可能有很多方法，如果不传方法名服务端也就不知道调用哪个方法；</li>
<li>参数类型&amp;参数值：参数类型有很多，比如有bool、int、long、double、string、map、list，甚至如struct等，以及相应的参数值；</li>
<li>超时时间 + requestID（标识唯一请求id）</li>
</ul>
<p>服务端返回的消息结构一般包括以下内容：</p>
<ul>
<li>状态code + 返回值</li>
<li>requestID(<strong>可以根据requestID去查验调用结果</strong>)</li>
</ul>
<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>一旦确定了消息的数据结构后，下一步就是要考虑序列化与反序列化了。</p>
<p>什么是序列化？序列化就是将数据结构或对象转换成二进制串的过程，也就是编码的过程。</p>
<p>什么是反序列化？将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。</p>
<p>为什么需要序列化？转换为二进制串后才好进行网络传输嘛！</p>
<p>为什么需要反序列化？将二进制转换为对象才好进行后续处理！</p>
<p>现如今序列化的方案越来越多，每种序列化方案都有优点和缺点，它们在设计之初有自己独特的应用场景，那到底选择哪种呢？从RPC的角度上看，主要看三点：</p>
<ul>
<li>通用性：比如是否能支持Map等复杂的数据结构；</li>
<li>性能：包括时间复杂度和空间复杂度，由于RPC框架将会被公司几乎所有服务使用，如果序列化上能节约一点时间，对整个公司的收益都将非常可观，同理如果序列化上能节约一点内存，网络带宽也能省下不少；</li>
<li>可扩展性：对互联网公司而言，业务变化飞快，如果序列化协议具有良好的可扩展性，支持自动增加新的业务字段，而不影响老的服务，这将大大提供系统的灵活度。</li>
</ul>
<p>目前互联网公司广泛使用Protobuf、Thrift、Avro等成熟的序列化解决方案来搭建RPC框架，这些都是久经考验的解决方案。</p>
<h3 id="如何发布自己的服务"><a href="#如何发布自己的服务" class="headerlink" title="如何发布自己的服务"></a>如何发布自己的服务</h3><p>通过注册中心将生产者和消费者联系起来,将生产者(消息的提供者)注册到注册中心,消费者通过与注册中心的长连接获得生产者的ip去获得服务. <strong>java常用的是zookeeper</strong></p>
<p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220306235517192.png" alt="image-20220306235517192"></p>
<hr>
<h2 id="Dubbo-Architecture"><a href="#Dubbo-Architecture" class="headerlink" title="Dubbo Architecture"></a><a href="https://dubbo.apache.org/zh/docs/">Dubbo Architecture</a></h2><p>Dubbo 提供了构建云原生微服务业务的一站式解决方案，可以使用 Dubbo 快速定义并发布微服务组件，同时基于 Dubbo 开箱即用的丰富特性及超强的扩展能力，构建运维整个微服务体系所需的各项服务治理能力，如 Tracing、Transaction 等，Dubbo 提供的基础能力包括：</p>
<ul>
<li>服务发现</li>
<li>流式通信</li>
<li>负载均衡</li>
<li>流量治理</li>
<li>…..</li>
</ul>
<p>Dubbo 计划提供丰富的多语言客户端实现，其中 Java、Golang 版本是当前稳定性、活跃度最好的版本，其他多语言客户端[]正在持续建设中。</p>
<p><strong>Dubbo的优点</strong>:</p>
<blockquote>
<ul>
<li>开箱即用<ul>
<li>易用性高，如 Java 版本的面向接口代理特性能实现本地透明调用</li>
<li>功能丰富，基于原生库或轻量扩展即可实现绝大多数的微服务治理能力</li>
</ul>
</li>
<li>超大规模微服务集群实践<ul>
<li>高性能的跨进程通信协议</li>
<li>地址发现、流量治理层面，轻松支持百万规模集群实例</li>
</ul>
</li>
<li>企业级微服务治理能力<ul>
<li>服务测试</li>
<li>服务Mock</li>
</ul>
</li>
</ul>
</blockquote>
<p>Dubbo3 是在云原生背景下诞生的，使用 Dubbo 构建的微服务遵循云原生思想，能更好的复用底层云原生基础设施、贴合云原生微服务架构。这体现在：</p>
<ul>
<li>服务支持部署在容器、Kubernetes平台，服务生命周期可实现与平台调度周期对齐；</li>
<li>支持经典 Service Mesh 微服务架构，引入了 Proxyless Mesh 架构，进一步简化 Mesh 的落地与迁移成本，提供更灵活的选择；</li>
<li>作为桥接层，支持与 SpringCloud、gRPC 等异构微服务体系的互调互通</li>
</ul>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>服务发现，即消费端自动发现服务地址列表的能力，是微服务框架需要具备的关键能力，借助于自动化的服务发现，微服务之间可以在无需感知对端部署位置与 IP 地址的情况下实现通信。</p>
<p>Dubbo提供的是一种Client-Based的服务发现机制,通常还需要部署第三方的注册中心来实现,例如Nacos,Consul,Zookeeper等,Dubbo自身也提供了对多种注册中心组件的对接,用户可以灵活选择.</p>
<p>Dubbo 基于消费端的自动服务发现能力，其基本工作原理如下图：</p>
<p><img src="https://dubbo.apache.org/imgs/architecture.png" alt="//imgs/architecture.png"></p>
<p><img src="https://dubbo.apache.org/imgs/v3/concepts/threecenters.png" alt="//imgs/v3/concepts/threecenters.png"></p>
<p>服务发现的一个核心组件是注册中心,Provider注册ip地址到注册中心,Consumer从注册中心读取和订阅Provider地址列表,因此要启用服务发现需要为Dubbo增加注册中心的配置</p>
<p><code>dubbo-spring-boot-starter</code>使用方式 增加registry配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"><span class="string">dubbo</span></span><br><span class="line"> <span class="string">registry</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">zookeeper://127.0.0.1:2181</span></span><br></pre></td></tr></table></figure>

<h3 id="Dubbo的协议-RPC-通信协议-Apache-Dubbo"><a href="#Dubbo的协议-RPC-通信协议-Apache-Dubbo" class="headerlink" title="]Dubbo的协议](RPC 通信协议 | Apache Dubbo)"></a>]Dubbo的协议](<a href="https://dubbo.apache.org/zh/docs/concepts/rpc-protocol/">RPC 通信协议 | Apache Dubbo</a>)</h3><ul>
<li><p><strong>Triple</strong></p>
<blockquote>
<p><strong>Triple</strong>是一种兼容 gRPC ，以 HTTP2 作为传输层构建新的协议.</p>
</blockquote>
</li>
</ul>
<h3 id="Dubbo-服务流量管理-服务流量管理-Apache-Dubbo"><a href="#Dubbo-服务流量管理-服务流量管理-Apache-Dubbo" class="headerlink" title="[Dubbo 服务流量管理](服务流量管理 | Apache Dubbo)"></a>[Dubbo 服务流量管理](<a href="https://dubbo.apache.org/zh/docs/concepts/traffic-management/">服务流量管理 | Apache Dubbo</a>)</h3><h4 id="流量管理"><a href="#流量管理" class="headerlink" title="流量管理"></a>流量管理</h4><p>流量管理的本质是将请求根据制定好的路由规则分发到应用服务上，如下图所示：</p>
<p><img src="https://dubbo.apache.org/imgs/v3/concepts/what-is-traffic-control.png" alt="What is traffic control"></p>
<ul>
<li>路由规则可以有多个，不同的路由规则之间存在优先级。如：<strong>Router(1) -&gt; Router(2) -&gt; …… -&gt; Router(n)</strong></li>
<li>一个路由规则可以路由到多个不同的应用服务。如：Router(2)既可以路由到Service(1)也可以路由到Service(2)</li>
<li>多个不同的路由规则可以路由到同一个应用服务。如：Router(1)和Router(2)都可以路由到Service(2)</li>
<li>路由规则也可以不路由到任何应用服务。如：Router(m)没有路由到任何一个Service上，所有命中Router(m)的请求都会因为没有对应的应用服务处理而导致报错</li>
<li>应用服务可以是单个的实例，也可以是一个应用集群。</li>
</ul>
<h3 id="Dubbo的配置"><a href="#Dubbo的配置" class="headerlink" title="Dubbo的配置"></a>Dubbo的配置</h3><h4 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h4><p>即采用xml格式的配置文件 配置Dubbo 详情参数和配置参考官方文档</p>
<p><a href="https://dubbo.apache.org/zh/docs/references/xml/">Schema 配置参考手册 | Apache Dubbo</a></p>
<h4 id="注解配置-注解配置-Apache-Dubbo"><a href="#注解配置-注解配置-Apache-Dubbo" class="headerlink" title="[注解配置](注解配置 | Apache Dubbo)"></a>[注解配置](<a href="https://dubbo.apache.org/zh/docs/references/configuration/annotation/#%E5%A2%9E%E5%8A%A0%E5%BA%94%E7%94%A8%E5%85%B1%E4%BA%AB%E9%85%8D%E7%BD%AE">注解配置 | Apache Dubbo</a>)</h4><h5 id="服务提供方"><a href="#服务提供方" class="headerlink" title="服务提供方"></a>服务提供方</h5><p>**<code>@DubboService</code>**注解暴露服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DubboService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AnnotationService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;annotation: hello, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="增加应用共享配置"><a href="#增加应用共享配置" class="headerlink" title="增加应用共享配置"></a>增加应用共享配置</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dubbo-provider.properties</span></span><br><span class="line"><span class="attr">dubbo.application.name</span>=<span class="string">annotation-provider</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="attr">dubbo.protocol.name</span>=<span class="string">dubbo</span></span><br><span class="line"><span class="attr">dubbo.protocol.port</span>=<span class="string">20880</span></span><br></pre></td></tr></table></figure>

<h5 id="增加spring扫描路径"><a href="#增加spring扫描路径" class="headerlink" title="增加spring扫描路径"></a>增加spring扫描路径</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableDubbo(scanBasePackages = &quot;org.apache.dubbo.samples.simple.annotation.impl&quot;)</span><span class="comment">//也可以在启动类上配置 启动类本身也就是一个配置类</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/spring/dubbo-provider.properties&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderConfiguration</span> &#123;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="服务消费方"><a href="#服务消费方" class="headerlink" title="服务消费方"></a>服务消费方</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;annotationAction&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationAction</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DubboReference</span></span><br><span class="line">    <span class="keyword">private</span> AnnotationService annotationService;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doSayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> annotationService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="增加应用共享配置-1"><a href="#增加应用共享配置-1" class="headerlink" title="增加应用共享配置"></a>增加应用共享配置</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dubbo-consumer.properties</span></span><br><span class="line"><span class="attr">dubbo.application.name</span>=<span class="string">annotation-consumer</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="attr">dubbo.consumer.timeout</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure>

<h5 id="指定Spring扫描路径"><a href="#指定Spring扫描路径" class="headerlink" title="指定Spring扫描路径"></a>指定Spring扫描路径</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableDubbo(scanBasePackages = &quot;org.apache.dubbo.samples.simple.annotation.action&quot;)</span><span class="comment">//同样可以在启动类中配置 也可在配置文件中配置</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/spring/dubbo-consumer.properties&quot;)</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &#123;&quot;org.apache.dubbo.samples.simple.annotation.action&quot;&#125;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用服务"><a href="#调用服务" class="headerlink" title="调用服务"></a>调用服务</h4><p>配置完一切就可以(先启动生产者 在启动消费者)像调用本地方法一样去调用远程服务了(不用去考虑底层的传输协议 编码解码之类的繁琐的东西)</p>
<hr>
<h3 id="Dubbo的使用"><a href="#Dubbo的使用" class="headerlink" title="Dubbo的使用"></a>Dubbo的使用</h3><p>对于Dubbo而言一个完整的简单的Dubbo项目应该有如下三个模块 生产者(服务的提供者) 消费者(服务的消费者) API(暴露的接口名称和公共可用的信息)</p>
<ul>
<li><p>创建一个简单的Demo Maven工程</p>
</li>
<li><p>创建三个子工程分别是**<code>consumer provider dubbo-api</code>**</p>
</li>
<li><p>首先编写dubbo-api编写其中的service接口和需要用的其他信息(consumer和provider都能用到的信息 比如实体类 访问的param对象等)注意: 类应当实现序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MailUserService</span> &#123;</span><br><span class="line">    Result <span class="title function_">save</span><span class="params">(MailUser mailUser)</span>;</span><br><span class="line"></span><br><span class="line">    Result&lt;MailUser&gt; <span class="title function_">selectUserById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    Result&lt;MailUser&gt; <span class="title function_">selectUserByInfo</span><span class="params">(MailUser mailUser)</span>;</span><br><span class="line"></span><br><span class="line">    Result&lt;List&lt;MailUser&gt;&gt; <span class="title function_">selectUserList</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Result&lt;String&gt; <span class="title function_">sendMail</span><span class="params">(MailDTO mailDTO)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220306214920772.png" alt="image-20220306214920772"></p>
<p><strong>然后将其打包上传到本地仓库或是远程仓库供生产者和消费者使用</strong></p>
</li>
<li><p>在provider 和 consumer中都加入 </p>
<blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--这个是dubbo的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这个是注册中心的依赖 这里使用的是zookeeper--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-dependencies-zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这个是公用的api依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dyw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Demo-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.2-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>在provider中实现dubbo-api中的编写的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@DubboService</span> <span class="comment">//使用该注解可以将该服务注册到注册中心 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailUserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MailUserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(MailUser mailUser)</span> &#123;</span><br><span class="line">        userMapper.insert(mailUser);</span><br><span class="line">        <span class="keyword">return</span> R.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;MailUser&gt; <span class="title function_">selectUserById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;MailUser&gt; mailUserLambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        mailUserLambdaQueryWrapper.eq(MailUser::getId, id).last(<span class="string">&quot;last 1&quot;</span>);</span><br><span class="line">        <span class="type">MailUser</span> <span class="variable">mailUser</span> <span class="operator">=</span> userMapper.selectOne(mailUserLambdaQueryWrapper);</span><br><span class="line">        <span class="keyword">return</span> R.success(mailUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;MailUser&gt; <span class="title function_">selectUserByInfo</span><span class="params">(MailUser mailUser)</span> &#123;</span><br><span class="line">        <span class="type">MailUser</span> <span class="variable">mailUser1</span> <span class="operator">=</span> userMapper.selectById(mailUser);</span><br><span class="line">        <span class="keyword">return</span> R.success(mailUser1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;MailUser&gt;&gt; <span class="title function_">selectUserList</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;MailUser&gt; mailUsers = userMapper.selectList(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> R.success(mailUsers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">sendMail</span><span class="params">(MailDTO mailDTO)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; idList = mailDTO.getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sendTime</span> <span class="operator">=</span> mailDTO.getSendTime();</span><br><span class="line">        <span class="type">String</span> <span class="variable">subject</span> <span class="operator">=</span> mailDTO.getSubject();</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> mailDTO.getContent();</span><br><span class="line">        List&lt;MailUser&gt; userList = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(subject) || StringUtils.isBlank(content)) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.fail(<span class="string">&quot;参数有误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idList.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            userList = userMapper.selectList(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            userList = userMapper.selectBatchIds(idList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(sendTime)) &#123;</span><br><span class="line">            sendTime = <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        mailDTO.setUserList(userList);</span><br><span class="line">        mailDTO.setSendTime(sendTime);</span><br><span class="line"></span><br><span class="line">        rocketMQTemplate.asyncSend(<span class="string">&quot;notice:mail&quot;</span>, mailDTO, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;发送信息成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;发送失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> R.success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>编写实现完所有的接口后 记得将服务注册到注册中心 这里需要配置dubbo 和 服务中心的信息</p>
<blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">&gt;dubbo:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Demo-provider</span> <span class="comment">#应用名称</span></span><br><span class="line"><span class="attr">registry:</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">zookeeper://localhost:2181</span> <span class="comment">#注册中心地址</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">6000</span> <span class="comment">#获取配置的超时时间</span></span><br><span class="line"><span class="attr">protocol:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">20880</span> <span class="comment">#服务端口</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dubbo</span> <span class="comment">#协议名称</span></span><br><span class="line"><span class="attr">scan:</span></span><br><span class="line">  <span class="attr">base-packages:</span> <span class="string">com.dyw.demoprovider.service.Impl</span> <span class="comment"># 扫描服务实现的包的位置 使用注解时才使用</span></span><br></pre></td></tr></table></figure>

<p>紧接着就是配置需要注册到注册中心的服务的信息(可以使用注解)如果使用spring-config配置服务的信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">     http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;demo-provider&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20890&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.dubbo.samples.basic.impl.DemoServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;org.apache.dubbo.samples.basic.api.DemoService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;demoService&quot;</span>/&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>


</blockquote>
</li>
<li><p>在consumer中也需要配置注册中心的信息 来获取远端信息</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;dubbo:</span><br><span class="line">registry:</span><br><span class="line">  address: zookeeper:<span class="comment">//localhost:2181</span></span><br><span class="line">application:</span><br><span class="line">  name: Demo-Consumer</span><br></pre></td></tr></table></figure>

<p>完成上述配置后 就可以进行接口的调用了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">@RestController</span></span><br><span class="line">&gt;<span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="meta">@DubboReference</span></span><br><span class="line">  MailUserService mailUserService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span></span><br><span class="line">  <span class="keyword">public</span> Result&lt;List&lt;MailUser&gt;&gt; <span class="title function_">selectUserList</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mailUserService.selectUserList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span></span><br><span class="line">  <span class="keyword">public</span> Result&lt;MailUser&gt; <span class="title function_">addUser</span><span class="params">(<span class="meta">@RequestBody</span> MailUser mailUser)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mailUserService.save(mailUser);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Result&lt;MailUser&gt; <span class="title function_">selectUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mailUserService.selectUserById(id);</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">@RestController</span></span><br><span class="line">&gt;<span class="meta">@RequestMapping(&quot;mail&quot;)</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailController</span> &#123;</span><br><span class="line">  <span class="meta">@DubboReference</span></span><br><span class="line">  MailUserService mailUserService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span></span><br><span class="line">  <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">sendMail</span><span class="params">(<span class="meta">@RequestBody</span> MailDTO mailDTO)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mailUserService.sendMail(mailDTO);</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<p>你会发现一个有意思的事情 比如 我的mybatis log配置在生产者端 但是确实我的消费端看到了日志信息. 这也说明了服务是在消费者端实现的 证明了上述RPC框架的图</p>
</li>
</ul>
<h2 id="Dubbo高级用法"><a href="#Dubbo高级用法" class="headerlink" title="Dubbo高级用法"></a>Dubbo高级用法</h2><p>参考官方文档 用法很多</p>
<p><a href="https://dubbo.apache.org/zh/docs/advanced/">高级用法 | Apache Dubbo</a></p>
<h1 id="—-END—"><a href="#—-END—" class="headerlink" title="—-END—-"></a>—-END—-</h1>]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2022/03/28/Redis/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><a href="https://www.bilibili.com/video/BV1cr4y1671t?p=63&spm_id_from=pageDriver">Redis</a></h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p><strong>Redis是一种NOSQL型数据库,即一种非关系型数据库</strong></p>
<p>我们常见的Mysql是一种SQL型数据库,是一种关系型数据库</p>
<span id="more"></span>

<h3 id="SQL型数据库"><a href="#SQL型数据库" class="headerlink" title="SQL型数据库"></a><strong>SQL型数据库</strong></h3><h4 id="结构化-Structured"><a href="#结构化-Structured" class="headerlink" title="结构化 Structured"></a>结构化 <strong>Structured</strong></h4><ul>
<li>下面这张图,我们创建这张表之初就对表的字段做了指定与规定,比如下面这张表只有三个字段,每个字段我们都加上了不同的约束,并且规定了字段的类型和长度,就使得这张表具有很强的结构体系,后续插入修改的数据都必须遵守表的结构</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307174510020.png" alt="image-20220307174510020"></p>
<h4 id="关联的-Relational"><a href="#关联的-Relational" class="headerlink" title="关联的(Relational)"></a>关联的(Relational)</h4><ul>
<li><p>比如一个表中的某个字段被其他表中的字段所关联(外键) 这样表中的数据就会自动维护,当删除某个字段时,就会提示无法删除的情况,除此之外,关联的优点还有可以节省存储空间,不需要记录数据的全部信息,只需要记录一个数据的主键即可.</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307175758165.png" alt="image-20220307175758165"></p>
<h4 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h4><ul>
<li><p>优点:语法固定</p>
</li>
<li><p>缺点:需要去学习大量的语法 </p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307180551365.png" alt="image-20220307180551365"></p>
</li>
</ul>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><ul>
<li><strong>满足ACID(原子性, 一致性, 隔离性, 持久性) 对关系性要求较高的业务采用SQL</strong></li>
</ul>
<h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><ul>
<li><strong>磁盘</strong></li>
</ul>
<h4 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h4><ul>
<li><strong>垂直</strong>(即一主多从 数据存储的大小没有改变 只是增强了数据的存储效率(读写分离))</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>数据结构稳定</li>
<li>相关业务对数据安全性,一致性较高.(ACID)</li>
</ul>
<hr>
</li>
</ul>
<h3 id="NOSQL"><a href="#NOSQL" class="headerlink" title="NOSQL"></a><strong>NOSQL</strong></h3><h4 id="非结构化"><a href="#非结构化" class="headerlink" title="非结构化"></a>非结构化</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307174959275.png" alt="image-20220307174959275"></p>
<ul>
<li>NoSQL有三种数据存储格式 分别为<strong>key-value型, Document型, 还有Graph型</strong> 没有SQL那种有很强的结构性 比如<strong>key-value型的存储格式中</strong> 不需要指定数据的类型, 只要是NoSQL支持的数据格式 都可以填入. 对于<strong>Document型中 数据的字段数量也可以不同可以任意增添数据字段</strong> 不需要上一条数据有四个字段 这次就可以只有三种</li>
</ul>
<h4 id="无关系的"><a href="#无关系的" class="headerlink" title="无关系的"></a>无关系的</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307175732140.png" alt="image-20220307175732140"></p>
<ul>
<li>一般通过json(Document)的形式存储,缺点就是这种的数据格式不能自己维护,需要程序员自己通过业务逻辑维护 ,并且可能会出现数据的冗余,比如同一个商品多个用户下单,多个用户的信息的存储中都有相同的订单数据,这需要程序员自己根据不同的业务逻辑来维护.</li>
</ul>
<h4 id="非SQL"><a href="#非SQL" class="headerlink" title="非SQL"></a>非SQL</h4><ul>
<li><p>优点: 不需要去学习大量的语法</p>
</li>
<li><p>缺点: 不同的NoSQL语句的格式用法可能不同</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307180601578.png" alt="image-20220307180601578"></p>
<h4 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h4><ul>
<li><strong>BASE(基本一致或者无事务 无法完全满足ACID) 业务对安全性要求较低的可以采用NoSQL</strong></li>
</ul>
<h4 id="存储方式-1"><a href="#存储方式-1" class="headerlink" title="存储方式"></a>存储方式</h4><ul>
<li><strong>内存</strong></li>
</ul>
<h4 id="扩展性-1"><a href="#扩展性-1" class="headerlink" title="扩展性"></a>扩展性</h4><ul>
<li><strong>水平</strong>(即多主多从 数据存储的大小增加 也增强了数据的存储效率(读写分离))</li>
</ul>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>数据结构不稳定</li>
<li>对一致性,安全性要求不高</li>
<li>对性能要求高</li>
</ul>
<hr>
<h2 id="认识Redis"><a href="#认识Redis" class="headerlink" title="认识Redis"></a><strong>认识Redis</strong></h2><p>Redis诞生与2009年全程时<strong>Remote Dictionary Server(远程词典服务器)</strong>,是一个基于内存的键值型NoSQL数据库.</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a><strong>特征</strong></h3></li>
<li><p>键值型(key-value)型, value支持多种不同的数据类型,功能丰富</p>
</li>
<li><p>单线程,每个命令具有原子性</p>
</li>
<li><p>低延迟,速度快(<strong>基于内存</strong>,IO多路复用,良好的编码)</p>
</li>
<li><p>支持数据持久化(持久化到磁盘)</p>
</li>
<li><p>支持主从集群,分片集群(将数据分部分存储到多个master中 增加数据存储的上限)</p>
</li>
<li><p>支持多语言客户端</p>
</li>
</ul>
<hr>
<h2 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a><strong>Redis常见命令</strong></h2><h3 id="Redis数据结构介绍"><a href="#Redis数据结构介绍" class="headerlink" title="Redis数据结构介绍"></a><strong>Redis数据结构介绍</strong></h3><p>Redis是一个key-value的数据库,key一般是String类型,不过value的类型多种多样</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220307191247016.png" alt="image-20220307191247016"></p>
<p>基本类型: String, Hash, List, Set. SortedSet</p>
<p>特殊类型: GEO(主要用于存储地理位置信息), BitMap, HyperLog(用来做基数统计的算法), Stream(主要用于消息队列)</p>
<h3 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a><a href="http://www.redis.cn/commands.html"><strong>Redis通用命令</strong></a></h3><p>通用指令是部分数据类型的,都可以使用的指令,常见的有 用法详情可以官网查看:</p>
<ul>
<li><strong>keys</strong>:查看符合模板的所有key,不建议在生产设备上使用(因为Redis是单线程的 使用keys *命令查看会占用很大资源 导致线程堵塞)</li>
<li>DEL: 删除可以删除一个或多个key (del key1 key2)</li>
<li>EXISTS: 判断key是否存在</li>
<li>EXPIRE: 给一个key设置有效期,有效期到时该key会被自动删除</li>
<li>TTL: 查看一个key剩余有效期</li>
</ul>
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a><strong>String类型</strong></h3><p>String类型,也就是字符串类型,是Redis中最简单的存储类型.</p>
<p>其value是字符串,不过根据字符串的格式不同,又可以分为3类</p>
<ul>
<li>String:普通字符串</li>
<li>int: 整数类型,可以做自增,自减操作</li>
<li>float: 浮点类型,可以做自增,自减操作</li>
</ul>
<p>不管是哪种格式,底层都是字节数组形式存储,只不过是编码方式不同,字符串类型的最大的空间不能超过512m(可以存储图片 只需要将图片转为字节数组的格式存储 但这样会耗很大空间 一般不这样用)</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220308233257985.png" alt="img">&#x2F;image-20220308233257985.png</p>
<h4 id="String类型的常见指令"><a href="#String类型的常见指令" class="headerlink" title="String类型的常见指令"></a>String类型的常见指令</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220308233444257.png" alt="image-20220308233444257"></p>
<p><strong>SETEX</strong>用法比较特殊: <strong><code>set name jack ex 20(存活时间 单位秒)</code></strong></p>
<h3 id="key的结构"><a href="#key的结构" class="headerlink" title="key的结构"></a><strong>key的结构</strong></h3><p>Redis的key允许有多个单词形成<strong>层级结构</strong>,多个单词之间用**<code>&#39;:&#39;</code>**隔开,格式如下:</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220308235659340.png" alt="image-20220308235659340"></p>
<p>这个格式并非固定,也可以根据自己的需求来删除或添加词条</p>
<p>例如 一个项目下有user和product两种不同类型的数据,我们可以这样定义key:</p>
<ul>
<li>user相关的key: project:user:1</li>
<li>product相关的key: project:producet:1</li>
</ul>
<p>这样的格式实际上是以层级结构的形式存储的**(主要是为了区分不同项目中相同的数据 用户的id可以为1 商品的id也可以为1)**</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309000908161.png" alt="image-20220309000908161"></p>
<p>如果value是一个java对象,例如要给User对象,则可以将对象序列化为JSON字符串后存储</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220308235948333.png" alt="image-20220308235948333"></p>
<p>​                    <strong><code>set project:user:1 &#39;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;ding&quot;&#125;&#39;</code></strong></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309000302102.png" alt="image-20220309000302102"></p>
<hr>
<h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a><strong>Hash类型</strong></h3><p>Hash类型,也叫散列,其value是一个无序字典,类似于java中的HashMap结构.</p>
<p>String结构是将对象序列化为JSON字符串后存储,当需要修改对象某个字段时很不方便:</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309191057489.png" alt="image-20220309191057489"></p>
<p>Hash结构可以将对象中的每个字段独立存储,可以针对单个字段做CRUD: 相对于String类型较为灵活</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309191148786.png" alt="image-20220309191148786"></p>
<h4 id="Hash类型的常见命令"><a href="#Hash类型的常见命令" class="headerlink" title="Hash类型的常见命令:"></a>Hash类型的常见命令:</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309191557981.png" alt="image-20220309191557981"></p>
<hr>
<h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a><strong>List类型</strong></h3><p>Redis中的List类型于Java中的LinkedList类似,可以看作是一个双向链表结构.既可以支持正向检索也可以支持反向检索.</p>
<p>特征也与LinkedList类似</p>
<ul>
<li><strong>有序</strong></li>
<li><strong>元素可以重复</strong></li>
<li><strong>插入和删除块</strong></li>
<li><strong>查询速度一般</strong></li>
</ul>
<p>常用来存储一个有序数据,例如:朋友圈点赞列表,批量列表等.</p>
<h4 id="List的常见命令"><a href="#List的常见命令" class="headerlink" title="List的常见命令"></a>List的常见命令</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309194126739.png" alt="image-20220309194126739"></p>
<hr>
<h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a><strong>Set类型</strong></h3><p>Redis的Set结构与Java的中HashSet类似,可以看做是一个value为null的HashMap.因为也是一个Hash表,因此具备与HashSet类似的特征</p>
<ul>
<li><strong>无序</strong></li>
<li><strong>元素不可重复</strong></li>
<li><strong>查找块</strong></li>
<li><strong>支持交集 并集 差集等功能</strong></li>
</ul>
<h4 id="Set类型的常见命令"><a href="#Set类型的常见命令" class="headerlink" title="Set类型的常见命令"></a><strong>Set类型的常见命令</strong></h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309195325392.png" alt="image-20220309195325392"></p>
<hr>
<h3 id="SortedSet类型-有序集合"><a href="#SortedSet类型-有序集合" class="headerlink" title="SortedSet类型(有序集合)"></a><strong>SortedSet类型(有序集合)</strong></h3><p>Redis的SortedSet是一个可排序的set集合,与Java中的TreeSet有些类似,但底层数据结构却差别很大.SortedSet中的每一个元素都带有一个score属性,可以基于score属性对元素排序,底层的实现是一个跳表(SkipList)加hash表.SortedSet具备下列特性:</p>
<ul>
<li><strong>可排序</strong></li>
<li><strong>元素不重复</strong></li>
<li><strong>查询速度快</strong></li>
</ul>
<p>因为SortedSet的可排序特性,经常被用来实现排行榜这样的功能</p>
<h4 id="SortedSet类型的常见命令"><a href="#SortedSet类型的常见命令" class="headerlink" title="SortedSet类型的常见命令"></a>SortedSet类型的常见命令</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309201610780.png" alt="image-20220309201610780"></p>
<h2 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a><strong>Redis的Java客户端</strong></h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309203536114.png" alt="image-20220309203536114"></p>
<h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a><strong>Jedis</strong></h3><ul>
<li><p><strong>创建Maven工程</strong></p>
</li>
<li><p><strong>引入Jedis依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>建立连接</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@BeforeEach</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//建立连接</span></span><br><span class="line">       jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;81.68.186.20&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">       <span class="comment">//设置密码</span></span><br><span class="line">       jedis.auth(<span class="string">&quot;ffdd2021@&quot;</span>);</span><br><span class="line">       <span class="comment">//选择库</span></span><br><span class="line">       jedis.select(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>存取数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//存入数据</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;12&quot;</span>);</span><br><span class="line">       System.out.println(name);</span><br><span class="line">       <span class="comment">//获取数据</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">       System.out.println(name1);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//插入hash数据</span></span><br><span class="line">       <span class="type">long</span> <span class="variable">name</span> <span class="operator">=</span> jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">       System.out.println(name);</span><br><span class="line">       <span class="comment">//取出</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> jedis.hget(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">       System.out.println(name1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>关闭连接</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//关闭连接</span></span><br><span class="line">       <span class="keyword">if</span>(jedis!=<span class="literal">null</span>)&#123;</span><br><span class="line">           jedis.close();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Jedis中数据的存储命令是与命令行一致的</strong></p>
<hr>
</li>
</ul>
</li>
</ul>
<h4 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h4><p>Jedis本身是线程不安全的,并且频繁的创建和销毁连接会有性能损耗,因此我们推荐大家使用Jedis连接池代替Jedis直连的方式.</p>
<p>类似SQL型的数据库连接池 不会直接关闭连接而是归还到连接池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        <span class="comment">//连接总数</span></span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//最大连接数量</span></span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//最小连接数量</span></span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//最大等待时间</span></span><br><span class="line">        jedisPoolConfig.setMaxWait(Duration.ofMillis(<span class="number">10000</span>));</span><br><span class="line">        <span class="comment">//创建连接池对象</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jedisPoolConfig,<span class="string">&quot;81.68.186.20&quot;</span>,<span class="number">6379</span>,<span class="number">1000</span>,<span class="string">&quot;ffdd2021@&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个获取连接的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a><a href="https://spring.io/projects/spring-data-redis"><strong>SpringDataRedis</strong></a></h3><p>SpringData是Spring中数据操作的模板,包含对各种数据库的集成,其中对Redis的集成模板就叫做SpringDataRedis </p>
<ul>
<li><strong>提供了对不同Redis客户端的整合(Lettuce和Jedis)</strong></li>
<li><strong>提供了RedisTemplate统一API来操作Redis</strong></li>
<li><strong>支持Redis的发布订阅模型</strong></li>
<li><strong>支持Redis哨兵和Redis集群</strong></li>
<li><strong>支持基于Lettuce的响应式编程</strong></li>
<li><strong>支持JDK,JSON,字符串,Spring对象的数据序列化及反序列化</strong>(方便地将上述数据格式 转化为字节数组 更方便地去存储在Redis中)</li>
<li><strong>支持基于Redis的JDKCollection实现</strong></li>
</ul>
<p>SpringDataRedis中提供了RedisTemplate工具类,其中封装了各种对Redis的操作.并且将不同数据类型的操作API封装到了不同的类型中:</p>
<h4 id="RedisTemplate工具类"><a href="#RedisTemplate工具类" class="headerlink" title="RedisTemplate工具类"></a>RedisTemplate工具类</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309234553190.png" alt="image-20220309234553190"></p>
<h4 id="RedisTemplate使用"><a href="#RedisTemplate使用" class="headerlink" title="RedisTemplate使用"></a>RedisTemplate使用</h4><ul>
<li><p>导入依赖</p>
<ul>
<li><p>SpringDataRedis依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>连接池依赖(Jedis和Lettuce都是依赖于commons-pool2实现)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">81.68</span><span class="number">.186</span><span class="number">.20</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">ffdd2021@</span></span><br><span class="line">    <span class="comment"># 选择数据库 database: 1</span></span><br><span class="line">    <span class="comment"># pool SpringDataRedis默认使用的客户端是Lettuce 可以导入其他依赖来使用其他连接池</span></span><br><span class="line">    <span class="comment"># 必须要配置了连接池 连接池才能生效</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注入RedisTemplate工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Redis01RedisTemplateApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;丁杨维&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310000959983.png" alt="image-20220310000959983"></p>
</li>
</ul>
<h4 id="SpringDataRedis的序列化方式"><a href="#SpringDataRedis的序列化方式" class="headerlink" title="SpringDataRedis的序列化方式"></a>SpringDataRedis的序列化方式</h4><p>RedisTemplate可以接收任意Object作为值写入Redis,只不过吸入人前会把Object序列化为字节形式,默认是采用的JDK序列化,得到的结果是这样的:(及使用RedisTemplate时没有指定泛型)</p>
<p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220310185259667.png" alt="image-20220310185259667"></p>
<p><strong>缺点:</strong></p>
<ul>
<li><strong>可读性差</strong></li>
<li><strong>内存占用较大</strong></li>
</ul>
<hr>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h4><ul>
<li><p>如果key-value都是String类型 直接指定泛型为String即可 但如果value或者key为Object时就需要自己配置了.</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310190944166.png" alt="image-20220310190944166"></p>
<p>Redis提供了设置key-value序列化方式的接口</p>
</li>
<li><p>首先导入Jackson的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>最新版<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置类 <code>RedisConfig</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">//创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String,Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//创建JSON序列化工具  注意这里使用的时Jackson需要导入Jackson的相关依赖才行</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">genericJackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">//设置key的序列化</span></span><br><span class="line">        template.setKeySerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashKeySerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//设置value的序列化</span></span><br><span class="line">        template.setValueSerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实体类 <code>User</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Redis01RedisTemplateApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,Object&gt; redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;丁杨维&quot;</span>, <span class="number">19</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;user1&quot;</span>,user);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1=&quot;</span>+user1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310191828636.png" alt="image-20220310191828636"></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310191838617.png" alt="image-20220310191838617"></p>
<p>通过配置使用了Jackson序列化对象对JSON字符串格式存储,在取出时也可以将JSON字符串反系列化为对象.</p>
<hr>
<h4 id="JSON序列化的问题"><a href="#JSON序列化的问题" class="headerlink" title="JSON序列化的问题"></a>JSON序列化的问题</h4><p>如上图 我们会发现使用JSON序列化存储value时,会默认带上全类名名称 这样会造成额外的内存开销. (<strong>为了在反序列化时知道对象的类型,JSON序列化器会将类的class类型写入json结果中,存入Redis.</strong> )而如果想使用JSON序列化器序列化对象,这一步又是必不可少的.</p>
<p><strong>解决方案:</strong></p>
<ul>
<li>为了节省内存空间, 我们并不会使用JSON序列化器来处理value, <strong>而是统一使用String序列化器</strong>, 要求只能存储String类型的Key和value. <strong>当需要存储Java对象时, 手动完成对象的序列化和反序列化</strong>.</li>
<li>Spring默认提供了一个StringRedisTemplate类,他的key和value的序列化方式默认就是String方式.省去了我们自定义RedisTemplate的过程.</li>
</ul>
<hr>
<h4 id="StringRedisTemplate类"><a href="#StringRedisTemplate类" class="headerlink" title="StringRedisTemplate类"></a>StringRedisTemplate类</h4><ul>
<li><p>Jackson的ObjectMapper提供了将Java对象序列化为Json字符串和反序列化为Java对象的API</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Redis01RedisTemplateApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTest</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;彭芳姐&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ObjectMapper提供了将对象转化为Json串的API</span></span><br><span class="line">        <span class="comment">//手动序列化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userString</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user2&quot;</span>,userString);</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动反序列化</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> mapper.readValue(userJson, User.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310194423995.png" alt="image-20220310194423995"></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310194441788.png" alt="image-20220310194441788"></p>
<h3 id="RedisTemplate对Hash的操作"><a href="#RedisTemplate对Hash的操作" class="headerlink" title="RedisTemplate对Hash的操作"></a><strong>RedisTemplate对Hash的操作</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void doTest2()&#123;</span><br><span class="line">    stringRedisTemplate.opsForHash().put(&quot;key&quot;,&quot;hashKey&quot;,&quot;value&quot;);</span><br><span class="line">    stringRedisTemplate.opsForHash().put(&quot;key&quot;,&quot;hashKey1&quot;,&quot;value1&quot;);</span><br><span class="line"></span><br><span class="line">    Map&lt;Object, Object&gt; key = stringRedisTemplate.opsForHash().entries(&quot;key&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作习惯上更偏向于java的HashMap之类的.</p>
<p>stringRedisTemplate.opsForHash().entries(String key)会获得hash类型中的某个key的全部key-value信息.</p>
<p>剩余操作或其他类型操作可以参考官方文档.<a href="https://docs.spring.io/spring-data/redis/docs/current/api/">RedisAPI文档</a></p>
<hr>
<h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a><strong>项目实战</strong></h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310200358089.png" alt="image-20220310200358089"></p>
<hr>
<h3 id="Session共享问题"><a href="#Session共享问题" class="headerlink" title="Session共享问题:"></a><strong>Session共享问题:</strong></h3><p>多台TomCat并不共享session存储空间,当请求切换到不同的tomcat服务时,导致数据丢失的问题</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310213458462.png" alt="image-20220310213458462"></p>
<p>session的代替方案应该满足:</p>
<ul>
<li><strong>数据共享</strong></li>
<li><strong>内存存储</strong></li>
<li><strong>key-value结构</strong></li>
</ul>
<p><strong>以上的要求Redis都满足, 可以使用Redis来代替Session存储,但也不是简单的存储.</strong></p>
<h3 id="基于Redis实现共享Session登陆"><a href="#基于Redis实现共享Session登陆" class="headerlink" title="基于Redis实现共享Session登陆"></a><strong>基于Redis实现共享Session登陆</strong></h3><p><strong>Redis要实现共享Session登陆, 需要满足key唯一性.</strong></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220310214224767.png" alt="image-20220310214224767"></p>
<ul>
<li>如果使用用户登陆存储一定的用户信息在Redis中时,一般使用token作为key,而value使用Hash类型.</li>
<li>学习Hash类型的时候我们学过 Hash类型的存储可以将对象的字段分别存储,可以针对单个字段进行crud,不需要每次改的是否传全部信息进行更改.</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220309191148786.png" alt="image-20220309191148786"></p>
<p>使用token存储用户的非敏感信息,传到前端,前端利用浏览器的缓存存储</p>
<p><strong>注意</strong>:</p>
<ul>
<li>使用token存储到Redis时一定要设置过期时间,因为会耗费内存空间(如果存储的token太多 有没有及时清楚 可能会造成堆栈溢出)</li>
<li>使用 RedisTemplate.expire可以指定指定key-value的存活时间</li>
<li>在登陆拦截器中,验证了token后需要刷新token存活时间,及再执行一遍第二步.</li>
<li>常量等可以专门编写一个类来记录 <code>static final constant</code>防止自己写出错.</li>
<li>对于一些不需要登陆拦截的Controller当用户访问时,也是需要刷新token的,设置一个全局刷新的token的拦截器,将其优先级设置为最高,所有请求都由他拦截,后续的登录拦截只需要从,全局拦截器中的存储到ThreadLocal的用户信息取到验证即可.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="全局请求拦截器"><a href="#全局请求拦截器" class="headerlink" title="全局请求拦截器"></a><strong>全局请求拦截器</strong></h3><p>作用:</p>
<ul>
<li>用于拦截所有请求,获取如果有token就获取token中的数据,并且刷新token,并且将数据存入ThreadLocal中,如果没有就直接放行.(后续可能会被登陆拦截器拦截 检查是否有用户信息, 如果没有就返回false)</li>
<li>全局请求拦截器的主要作用就是为了防止用户登陆后,访问一些不需要登陆拦截器的接口token无法刷新的情况.</li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><strong>缓存</strong></h2><p><strong>缓存</strong>就是数据交换的缓存区(称作Cache), 是存储数据的临时地方,一般读写性能较高</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311151533133.png" alt="image-20220311151533133"></p>
<h3 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h3><ul>
<li>降低后端负载</li>
<li>提高读写效率,降低响应时间.</li>
</ul>
<h3 id="缓存的成本"><a href="#缓存的成本" class="headerlink" title="缓存的成本"></a>缓存的成本</h3><ul>
<li>数据一致性成本</li>
<li>代码维护成本</li>
<li>运维成本</li>
</ul>
<h3 id="添加Redis缓存"><a href="#添加Redis缓存" class="headerlink" title="添加Redis缓存"></a>添加Redis缓存</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311152211102.png" alt="image-20220311152211102"></p>
<h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311153346059.png" alt="image-20220311153346059"></p>
<p>对于经常修改的数据,可以采用主动更新策略,在修改数据库的同时,更新缓存,这样的数据一致性较好,相应的维护成本较高. 对于不经常修改的数据,采用默认策略即可.</p>
<h4 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h4><h5 id="Cache-Aside-Pattern-常用"><a href="#Cache-Aside-Pattern-常用" class="headerlink" title="Cache Aside Pattern*(常用)"></a>Cache Aside Pattern*(常用)</h5><ul>
<li>由缓存的调用者,在更新数据库同时更新缓存.</li>
</ul>
<h5 id="Read-x2F-Write-Through-Pattern"><a href="#Read-x2F-Write-Through-Pattern" class="headerlink" title="Read&#x2F;Write Through Pattern"></a>Read&#x2F;Write Through Pattern</h5><ul>
<li>缓存与数据库整合为一个服务, 有服务来维护一致性. 调用者调用该服务, 无需关心缓存的一致性.</li>
</ul>
<h5 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h5><ul>
<li>调用者只是操作缓存,有其他线程异步地将缓存数据持久化到数据库,保证最终一致性</li>
</ul>
<h3 id="操作缓存和数据库时的三个问题考虑-For-Cache-Aside-Pattern"><a href="#操作缓存和数据库时的三个问题考虑-For-Cache-Aside-Pattern" class="headerlink" title="操作缓存和数据库时的三个问题考虑(For Cache Aside Pattern)"></a>操作缓存和数据库时的三个问题考虑(For Cache Aside Pattern)</h3><ol>
<li><p>删除缓存还是更新缓存 ?</p>
<ul>
<li>更新缓存: 每次更新数据库都更新缓存, 无效写操作较多(<strong>×</strong>)</li>
<li>删除缓存: 更新数据库时让缓存失效, 查询时在更新缓存(<strong>√</strong>)</li>
</ul>
</li>
<li><p>如何保证数据与数据库的同时成功或失败 ?</p>
<ul>
<li>单体系统, 将缓存与数据库操作防止一个事务</li>
<li>分布式系统,利用TTC等分布式事务方案</li>
</ul>
</li>
<li><p>先操作缓存还是先操作数据库 ?</p>
<ul>
<li>对于先操作缓存,可能会出现在删除缓存后将要操作数据库时, 另一个线程在查询缓存, 此时缓存中已无数据, 缓存未命中查询数据库写入缓存的情况,然后才去更新我们的数据库 造成读到脏数据的线程安全问题.</li>
<li>对于先操作数据库,也可能出现(刚好一个缓存过期)一个线程想要来查询缓存,缓存未命中,查询数据库的情况,此时数据库还没有更新,在要进行吸入缓存之前数据库才更新,这就造成读取到脏数据的情况.</li>
<li>但是对于先操作数据库的情况,实际上写入缓存的时间是非常快的,是远远快于操作数据库的情况,所以基本上不会出现在写入缓存之前,还能操作数据库的情况,所以一般采用先操作数据库的情况. 相比于第一种安全性更高.</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311160417480.png" alt="image-20220311160417480"></p>
</li>
</ol>
<h3 id="缓存更新的最佳实践方案"><a href="#缓存更新的最佳实践方案" class="headerlink" title="缓存更新的最佳实践方案:"></a><strong>缓存更新的最佳实践方案:</strong></h3><ol>
<li>低一致性需求: 使用Redis自带的淘汰机制</li>
<li>高一致性需求: 主动更新,并以超时作为兜底<ul>
<li>读操作:<ul>
<li>缓存命中则直接返回</li>
<li>缓存 未命中则查询数据库,并写入缓存,设定超时时间</li>
</ul>
</li>
<li>写操作:<ul>
<li>先写入数据库,再删除缓存</li>
<li>要确保数据的于缓存操作的原子性</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="缓存未命中"><a href="#缓存未命中" class="headerlink" title="缓存未命中"></a><strong>缓存未命中</strong></h2><p>当CPU在缓存中找到有用的数据时，称为命中。当缓存中没有CPU需要的数据时（这称为未命中）</p>
<hr>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><strong>缓存穿透</strong></h2><p><strong>缓存穿透</strong>是指客户端请求的数据在缓存中和数据库中都不存在,这样的缓存永远都不会生效,这些请求都会打到数据库.</p>
<p>一些不坏好意的人可能会利用这里点来多线程发送多次请求导致数据库崩坏. 不存在的数据在数据库中查询对于数据库来说是会遍历全部数据然后返回NULL这对数据库的压力很大.</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311161920235.png" alt="image-20220311161920235"></p>
<p><strong>常见的解决方案</strong>:</p>
<ul>
<li><p><strong>缓存空对象</strong>*</p>
<ul>
<li>优点: 实现简单,维护方便</li>
<li>缺点:<ul>
<li>额外的内存消耗(一般设置过期时间,且过期时间较短)</li>
<li>可能造成短期的不一致(此时新增一条该key对应的数据,但是在TTL结束前,查询到的都是NULL 造成短期不一致)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>布隆过滤</strong></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311162648729.png" alt="image-20220311162648729"></p>
<ul>
<li>优点: 内存占用较少, 没有多余key</li>
<li>缺点:<ul>
<li>实现复杂</li>
<li>存在误判</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>除此之外缓存穿透的解决方案还有:</strong></p>
<ul>
<li>增强id的复杂度,避免被猜测id规律</li>
<li>做好数据的基础格式校验</li>
<li>加强用户权限校验</li>
<li>做好热点参数的限流(也可以减小数据库压力)</li>
</ul>
<hr>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h2><p><strong>缓存雪崩</strong>是指在同一时间段大量的缓存key同时失效或者Redis服务宕机,导致大量请求到达数据库,带来巨大压力.</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311163954070.png" alt="image-20220311163954070"></p>
<p><strong>解决方案</strong>:</p>
<ul>
<li>给不同的key的TTL添加随机值(防止大量的缓存Key同时失效)</li>
<li>利用Redis集群提高服务的可用性(防止单机宕机的情况)</li>
<li>给缓存业务添加降级限流策略(待学)</li>
<li>给业务添加多级缓存</li>
</ul>
<hr>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><strong>缓存击穿</strong></h2><p><strong>缓存击穿问题</strong>也叫热点Key问题,就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务比较复杂</strong>的key突然失效了,无数的请求访问会在瞬间给数据库带来巨大的冲击.</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311165255394.png" alt="image-20220311165255394"></p>
<p><strong>常见解决方案</strong>:</p>
<ul>
<li><p><strong>互斥锁</strong></p>
<ul>
<li><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311165723072.png" alt="image-20220311165723072"></li>
<li>加锁,性能低.</li>
</ul>
</li>
<li><p><strong>逻辑过期</strong></p>
<ul>
<li>设置逻辑过期时间 而非TTL</li>
<li>获取互斥锁 开启新线程,去查询数据库重建缓存数据.</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311170401649.png" alt="image-20220311170401649"></p>
</li>
</ul>
<p><strong>两种方案的比较</strong>:</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311170545184.png" alt="image-20220311170545184"></p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁实现原理是通过Redis中的String类型的SETNX(插入一个不存在的数据)方法.这样别人就无法修改了.</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311172926169.png" alt="image-20220311172926169"></p>
<p>RedisTemplate中的api是 opsForValue.setIfAbsent()</p>
<h3 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h3><p>使用逻辑过期 需要给数据设置一个逻辑过期时间, 一般会创建一个RedisData类 将逻辑过期时间和业务数据封装在一起,避免了在原有的业务基础上修改代码(指在实体类上新增逻辑过期字段).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="comment">//业务数据</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LocalDateTime.After(LocalDateTime time),如果时间过期那么返回</p>
<h2 id="封装Redis工具"><a href="#封装Redis工具" class="headerlink" title="封装Redis工具"></a><strong>封装Redis工具</strong></h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311180308032.png" alt="image-20220311180308032"></p>
<h2 id="全局ID生成器"><a href="#全局ID生成器" class="headerlink" title="全局ID生成器"></a><strong>全局ID生成器</strong></h2><p>当用户抢购时,就会生成订单数据保存到订单表中,而订单表如果使用数据库自增ID就存在一些问题:</p>
<ul>
<li><strong>id的规律性太明显</strong></li>
<li><strong>受单表数据量的限制</strong></li>
</ul>
<p>全局ID生成器,是一种在分布式系统下用来生成全局唯一ID的工具,一般满足下列特性:</p>
<ul>
<li><strong>唯一性</strong></li>
<li><strong>高可用</strong></li>
<li><strong>递增性</strong></li>
<li><strong>安全性</strong></li>
<li><strong>高性能</strong></li>
</ul>
<p>为了增加ID的安全性,我们可以不直接使用Redis自增的数值,而是拼接一些其他的信息.</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220311210845236.png" alt="image-20220311210845236">ID的组成部分:</p>
<blockquote>
<ul>
<li>符号位: 1bit, 永远为0</li>
<li>时间戳: 31bit,以秒为单位</li>
<li>序列号: 32bit,秒内的计数器, 支持每秒产生2^32个不同的ID</li>
</ul>
</blockquote>
<p>全局唯一ID生成策略:</p>
<blockquote>
<ul>
<li>UUID</li>
<li><strong>Redis自增</strong>*</li>
<li><strong>snowflake算法(雪花算法)</strong>*</li>
<li>数据库自增</li>
</ul>
</blockquote>
<p><strong>Redis自增策略</strong>:</p>
<ul>
<li>每天一个key, 方便统计订单量</li>
<li>ID构造是 时间戳 + 计数器</li>
</ul>
<h2 id="优惠券秒杀下单功能"><a href="#优惠券秒杀下单功能" class="headerlink" title="优惠券秒杀下单功能"></a>优惠券秒杀下单功能</h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312123558073.png" alt="image-20220312123558073"></p>
<h3 id="超卖问题-线程安全问题"><a href="#超卖问题-线程安全问题" class="headerlink" title="超卖问题(线程安全问题)"></a>超卖问题(线程安全问题)</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312131903889.png" alt="image-20220312131903889"></p>
<p><strong>解决方案: 加锁</strong></p>
<ul>
<li><strong>悲观锁</strong></li>
<li><strong>乐观锁</strong></li>
</ul>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>认为线程安全问题一定会发生,因此在操作数据之前先获取锁,确保线程串行执行.</p>
<blockquote>
<ul>
<li>例如Synchronized, Lock都属于悲观锁</li>
<li>优点: 简单粗暴</li>
<li>缺点: 性能一般</li>
</ul>
</blockquote>
<hr>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>认为线程安全问题不一定会发生,因此不加锁,只是在更新数据时去判断有没有其他线程对数据进行了修改</p>
<blockquote>
<ul>
<li>如果没有修改则认为是安全的, 自己才更新数据</li>
<li>如果已经被其他线程修改说明发生了线程安全问题,此时可以重试或异常.</li>
<li>优点: 性能好</li>
<li>缺点存在成功率低的问题</li>
</ul>
</blockquote>
<p>乐观锁的关键是判断之前查询到的数据是否被修改过,常见的方式有两种:</p>
<ul>
<li><p>版本号法</p>
<p>设置一个用于悲观锁修改是判断的字段(版本号),每次修改后都会被修改</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312132808463.png" alt="image-20220312132808463"></p>
</li>
<li><p>CAS法</p>
<p>利用本身的数据作为判断依据(不新增任何字段 用自身数据代替版本)</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312133142933.png" alt="image-20220312133142933"></p>
</li>
</ul>
<h3 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h3><p>同一张优惠券一个用户只能下一单</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312135825445.png" alt="image-20220312135825445"></p>
<h4 id="集群下的一人一单问题"><a href="#集群下的一人一单问题" class="headerlink" title="集群下的一人一单问题"></a>集群下的一人一单问题</h4><p>JVM中有一个锁监视器 单机情况下可以实现锁的监视,但是在集群模式下 多个的JVM有不同的锁监视器, 即集群模式下的悲观锁失效了(它只能保证单个JVM下的线程安全问题)</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312142218951.png" alt="image-20220312142218951"></p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><strong>分布式锁</strong></h3><p>**分布式锁:**满足分布式系统或集群模式下多进程可见并且互斥的锁.</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312142754987.png" alt="image-20220312142754987"></p>
<blockquote>
<ul>
<li><strong>多线程可见</strong>*</li>
<li><strong>互斥</strong>*</li>
<li><strong>高可用</strong>*</li>
<li><strong>高性能(指获得锁的性能)</strong>*</li>
<li><strong>安全性</strong>*</li>
<li>…</li>
</ul>
</blockquote>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312143720266.png" alt="image-20220312143720266"></p>
<h3 id="实现分布式锁-此处的是实现都是基于一人一单的情况下"><a href="#实现分布式锁-此处的是实现都是基于一人一单的情况下" class="headerlink" title="实现分布式锁(此处的是实现都是基于一人一单的情况下)"></a><strong>实现分布式锁</strong>(此处的是实现都是基于一人一单的情况下)</h3><p>实现分布式锁需要实现两个基本方法</p>
<ul>
<li>获取锁</li>
<li>释放锁</li>
</ul>
<h3 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a><strong>基于Redis的分布式锁</strong></h3><p>利用SETNX的互斥机制 和DEL的删除机制</p>
<p>为了防止Redis异常宕机的情况下锁的安全性问题(需要设置锁的过期时间)</p>
<ul>
<li><p>获取锁:</p>
<ul>
<li><p>互斥: 确保只能有一个线程获取锁</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">添加锁, NX是互斥 EX是设置超时时间</span></span><br><span class="line">set lock thread1 NX EX 10</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>释放锁:</p>
<ul>
<li><p>手动释放</p>
</li>
<li><p>超时释放: 获取锁时添加一个超时时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">释放锁, 删除即可</span></span><br><span class="line">DEL key</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312145523204.png" alt="image-20220312145523204"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">//获取线程表示</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">//获取锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的分布式锁的线程安全问题</p>
<p>业务堵塞导致锁的时间到期释放, 第二个线程此时获取到锁,在执行业务中,一号线程业务堵塞完毕此时释放锁 就导致线程二的锁被释放了.</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312152342991.png" alt="image-20220312152342991"></p>
<p>改进后</p>
<p>通过新增UUID+ThreadID作为锁标识 在释放锁之前判断锁标识是否一致(同一个线程的锁标识一致,这样就不会出现业务堵塞导致释放了其他线程的锁的情况)</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312152522311.png" alt="image-20220312152522311"></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312152710464.png" alt="image-20220312152710464"></p>
<h4 id="改进Redis的分布式锁"><a href="#改进Redis的分布式锁" class="headerlink" title="改进Redis的分布式锁"></a>改进Redis的分布式锁</h4><p>修改之前的分布式锁实现,满足</p>
<ol>
<li><p>在获取锁时存入线程表示(可用UUID表示)</p>
</li>
<li><p>在释放锁时先获取锁中的线程标识,判断是否与当前线程标识一致</p>
<blockquote>
<ul>
<li><p>如果不一致则不释放锁</p>
</li>
<li><p>如果一致则释放锁</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取线程标识</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX+Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">//获取锁中的标识</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="comment">//判断是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(threadId.equals(id))&#123;</span><br><span class="line">        <span class="comment">//一致就释放锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX+name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则就不释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>改良后的Redis分布式锁 依旧存在如下问题就是在 删除锁的时候发生了堵塞 导致超时释放锁 此时二号线程进入获得锁执行业务,但是刚好一号线程堵塞完毕就将二号线程的锁释放了.</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312173903547.png" alt="image-20220312173903547"></p>
<h3 id="Redis的Lua脚本"><a href="#Redis的Lua脚本" class="headerlink" title="Redis的Lua脚本"></a>Redis的Lua脚本</h3><p>释放锁业务的Lua脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- 比较线程标示与锁中的标示是否一致</span><br><span class="line">if(redis.call(&#x27;get&#x27;, KEYS[1]) ==  ARGV[1]) then</span><br><span class="line">    -- 释放锁 del key</span><br><span class="line">    return redis.call(&#x27;del&#x27;, KEYS[1])</span><br><span class="line">end</span><br><span class="line">return 0</span><br></pre></td></tr></table></figure>

<h3 id="Java中调用Lua脚本"><a href="#Java中调用Lua脚本" class="headerlink" title="Java中调用Lua脚本"></a>Java中调用Lua脚本</h3><p>RedisTemplate可以直接调用Lua脚本</p>
<p>使用静态代码块初始化lua脚本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">    UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将原来java中的两行代码,变为了一行代码, 就不会出现上述的情况</p>
<p>改良后的unlock方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX+name),</span><br><span class="line">            ID_PREFIX+Thread.currentThread().getId());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于Redis的分布式锁优化"><a href="#基于Redis的分布式锁优化" class="headerlink" title="基于Redis的分布式锁优化"></a>基于Redis的分布式锁优化</h3><p>基于SETNX实现的分布式锁存在下面的问题:</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312184555611.png" alt="image-20220312184555611"></p>
<p><a href="https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95"><strong>Redission官方文档</strong></a></p>
<p>Redission是一个在Redis的基础上实现的java驻内存数据网络(In-Memory Data Grid). 它不仅提供了一系列的分布式java常用对象,还提供了许多分布式服务,其中就包含了各种分布式锁的实现</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220312200824948.png" alt="image-20220312200824948"></p>
]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ</title>
    <url>/2022/02/28/RocketMQ/</url>
    <content><![CDATA[<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/concept.md">RocketMQ</a></h1><p><strong>MQ(Message Queue)</strong>:消息队列</p>
<span id="more"></span>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="消息模型（Message-Model）"><a href="#消息模型（Message-Model）" class="headerlink" title="消息模型（Message Model）:"></a>消息模型（Message Model）:</h3><p>RocketMQ主要由 <strong>Producer、Broker、Consumer 三部分组成</strong>，其中Producer 负责生产消息，Consumer 负责消费消息，<strong>Broker 负责存储消息</strong>。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。</p>
<h3 id="消息生产者（Producer）"><a href="#消息生产者（Producer）" class="headerlink" title="消息生产者（Producer）:"></a>消息生产者（Producer）:</h3><p>负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，<strong>同步发送、异步发送、顺序发送、单向发送</strong>。<strong>同步和异步方式均需要Broker返回确认信息，单向发送不需要。</strong></p>
<h3 id="消息消费者（Consumer）"><a href="#消息消费者（Consumer）" class="headerlink" title="消息消费者（Consumer）:"></a>消息消费者（Consumer）:</h3><p>负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。</p>
<h3 id="主题（Topic）"><a href="#主题（Topic）" class="headerlink" title="主题（Topic）:"></a>主题（Topic）:</h3><p>表示一类消息的集合，<strong>每个主题包含若干条消息，每条消息只能属于一个主题</strong>，(topic)<strong>是RocketMQ进行消息订阅的基本单位。</strong></p>
<h3 id="代理服务器（Broker-Server）"><a href="#代理服务器（Broker-Server）" class="headerlink" title="代理服务器（Broker Server）:"></a>代理服务器（Broker Server）:</h3><p><strong>消息中转角色，负责存储消息、转发消息。</strong>代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p>
<h3 id="名字服务（Name-Server）"><a href="#名字服务（Name-Server）" class="headerlink" title="名字服务（Name Server）:"></a>名字服务（Name Server）:</h3><p>名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/2ms3i8hm3a.jpg" alt="2ms3i8hm3a"></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220222203606812.png" alt="image-20220222203606812"></p>
<p>由上图可知 Broker集群,producer集群,consumer集群都要与NameServer集群进行通信.</p>
<h3 id="拉取式消费（Pull-Consumer）"><a href="#拉取式消费（Pull-Consumer）" class="headerlink" title="拉取式消费（Pull Consumer）:"></a>拉取式消费（Pull Consumer）:</h3><p>Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、<strong>主动权由应用控制</strong>。一旦获取了批量消息，应用就会启动消费过程。</p>
<h3 id="推动式消费（Push-Consumer）"><a href="#推动式消费（Push-Consumer）" class="headerlink" title="推动式消费（Push Consumer）:"></a>推动式消费（Push Consumer）:</h3><p>Consumer消费的一种类型，<strong>该模式下Broker收到数据后会主动推送给消费端</strong>，该消费模式一般实时性较高。</p>
<h3 id="生产者组（Producer-Group）"><a href="#生产者组（Producer-Group）" class="headerlink" title="生产者组（Producer Group）:"></a>生产者组（Producer Group）:</h3><p><strong>同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。</strong>如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p>
<h3 id="消费者组（Consumer-Group）"><a href="#消费者组（Consumer-Group）" class="headerlink" title="消费者组（Consumer Group）:"></a>消费者组（Consumer Group）:</h3><p><strong>同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。</strong>消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，<strong>消费者组的消费者实例必须订阅完全相同的Topic。</strong>RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p>
<h3 id="集群消费（Clustering）"><a href="#集群消费（Clustering）" class="headerlink" title="集群消费（Clustering）:"></a>集群消费（Clustering）:</h3><p>集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</p>
<h3 id="广播消费（Broadcasting）"><a href="#广播消费（Broadcasting）" class="headerlink" title="广播消费（Broadcasting）:"></a>广播消费（Broadcasting）:</h3><p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。</p>
<h3 id="普通顺序消息（Normal-Ordered-Message）"><a href="#普通顺序消息（Normal-Ordered-Message）" class="headerlink" title="普通顺序消息（Normal Ordered Message）:"></a>普通顺序消息（Normal Ordered Message）:</h3><p>普通顺序消费模式下，消费者通过同一个消息队列（ Topic 分区，称作 Message Queue） 收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。</p>
<h3 id="严格顺序消息（Strictly-Ordered-Message）"><a href="#严格顺序消息（Strictly-Ordered-Message）" class="headerlink" title="严格顺序消息（Strictly Ordered Message）:"></a>严格顺序消息（Strictly Ordered Message）:</h3><p>严格顺序消息模式下，消费者收到的所有消息均是有顺序的。</p>
<h3 id="消息（Message）"><a href="#消息（Message）" class="headerlink" title="消息（Message）:"></a>消息（Message）:</h3><p><strong>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。</strong>RocketMQ中<strong>每个消息拥有唯一的Message ID</strong>，且<strong>可以携带具有业务标识的Key</strong>。系统提供了<strong>通过Message ID和Key查询消息</strong>的功能。</p>
<h3 id="标签（Tag）"><a href="#标签（Tag）" class="headerlink" title="标签（Tag）:"></a>标签（Tag）:</h3><p><strong>为消息设置的标志，用于同一主题下区分不同类型的消息。</strong>来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。<strong>标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统</strong>。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p>
<h3 id="MQ-Messages-Queue-三大优点"><a href="#MQ-Messages-Queue-三大优点" class="headerlink" title="MQ(Messages Queue)三大优点:"></a>MQ(Messages Queue)三大优点:</h3><ul>
<li>应用解耦: <strong>提高系统的容错性和可维护性</strong></li>
<li>削峰填谷: <strong>提升用户体验和系统的吞吐量</strong></li>
<li>异步提速:<strong>提高系统的稳定性</strong></li>
</ul>
<h3 id="通常的MQ-三大缺点"><a href="#通常的MQ-三大缺点" class="headerlink" title="通常的MQ 三大缺点:"></a>通常的MQ 三大缺点:</h3><ul>
<li><p>应用可用性降低</p>
<blockquote>
<p>系统引入的外部依赖越多, 系统的稳定性越差,一旦MQ宕机,就会对业造成影响.</p>
</blockquote>
</li>
<li><p>系统的复杂度提高</p>
<blockquote>
<p>MQ的加入大大增加了系统的复杂度,以前系统间是同步的远程调用,现在是通过MQ进行异步调用.</p>
</blockquote>
</li>
<li><p>一致性的问题(A B系统正常 但是C系统处理失败 会发生事务问题)</p>
<blockquote>
<p>A系统处理完业务,通过MQ给BCD三个系统发送消息数据,如果B系统,C系统处理成功,D系统处理失败.</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="单对单模式-初始RocketMQ"><a href="#单对单模式-初始RocketMQ" class="headerlink" title="单对单模式(初始RocketMQ)"></a>单对单模式(初始RocketMQ)</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><blockquote>
<ul>
<li>谁来发</li>
<li>发给谁</li>
<li>启动连接</li>
<li>发什么</li>
<li>怎么发</li>
<li>发的结果是?</li>
<li>关闭连接</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQBrokerException, RemotingException, InterruptedException, MQClientException &#123;</span><br><span class="line">        <span class="comment">//1. 谁来发?</span></span><br><span class="line">        <span class="comment">//创建一个生产者</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="comment">/*可以在这里设置名称*/</span><span class="string">&quot;group1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.发给谁</span></span><br><span class="line">        <span class="comment">//发送给命名服务器 通过Name Server分配Brokerip 再由生产者发送给broker</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动连接</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.怎么发</span></span><br><span class="line">        <span class="comment">//发送Message apache包下的 网络传输都是字节流传输</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic1&quot;</span>,<span class="string">&quot;Tag1&quot;</span>,(<span class="string">&quot;Hello World&quot;</span>).getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.发什么</span></span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.发的结果是什么</span></span><br><span class="line">        <span class="comment">//SendResult 就是发送后的结果</span></span><br><span class="line">        System.out.println(sendResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.打扫战场</span></span><br><span class="line">        <span class="comment">//生产者是与name Server建立了一个长连接进行发送消息 所以发送完毕后 关闭连接</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><blockquote>
<ul>
<li>谁来收</li>
<li>从哪里收</li>
<li>监听那个消息队列</li>
<li>处理业务流程</li>
<li>启动连接</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.谁来收</span></span><br><span class="line">        <span class="comment">//消费者有两种模式 一种是拉去(需要消费者自己去拉去) 一种是推送(消息主动推送给消费者)</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">pushConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.从哪里收</span></span><br><span class="line">        <span class="comment">//与生产者一样 消费者 也许要去name Server中获得对应broker的地址去获得消息</span></span><br><span class="line">        pushConsumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.监听那个消息队列</span></span><br><span class="line">        <span class="comment">//设置监听队列 subscribe:订阅 指定主题 和订阅表达式 &quot;*&quot;表示订阅主题中的所有</span></span><br><span class="line">        pushConsumer.subscribe(<span class="string">&quot;Topic1&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.处理业务流程</span></span><br><span class="line">        <span class="comment">//注册一个监听器 去监听是否有消息被生产 一有就立刻接收</span></span><br><span class="line">        pushConsumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                <span class="comment">//接收到的消息就是 List&lt;MessageExt&gt; msgs 这时我们就能写我们的业务逻辑</span></span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//启动连接</span></span><br><span class="line">        pushConsumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消费者启动起来了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意不要关闭消费者(如果还有对应主题的生产者的情况下 关闭就无法监听消息 就无法收到消息了)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一对多-单生产者-多消费者模式"><a href="#一对多-单生产者-多消费者模式" class="headerlink" title="一对多(单生产者 多消费者模式)"></a>一对多(单生产者 多消费者模式)</h2><h3 id="多消费者都在同一组中时"><a href="#多消费者都在同一组中时" class="headerlink" title="多消费者都在同一组中时"></a>多消费者都在同一组中时</h3><p><strong>消息会被分配到该组的不同消费者手中(当一个组中的消费者为偶数时平分)</strong></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220223173114990.png" alt="image-20220223173114990"></p>
<h3 id="多消费者在不同组时"><a href="#多消费者在不同组时" class="headerlink" title="多消费者在不同组时"></a>多消费者在不同组时</h3><p><strong>每个组都会有完整的消息数目和消息信息(广播式 消息先被复制到不同的消费者组)</strong></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220223173349238.png" alt="image-20220223173349238"></p>
<p>**特别的:**如果想在同一组中实现广播模式 可以在接收消息前设置消息的模式</p>
<blockquote>
<p><code>Consumer.setMessageModel(消息模式);</code></p>
<p>默认是CLUSTERING 负载均衡模式</p>
<p>可以设置为BROADCASTING 就是广播模式</p>
</blockquote>
<h2 id="多对多-多生产者-多消费者模式"><a href="#多对多-多生产者-多消费者模式" class="headerlink" title="多对多(多生产者 多消费者模式)"></a>多对多(多生产者 多消费者模式)</h2><p>对于生产者生产的消息而言</p>
<hr>
<h2 id="消息类别"><a href="#消息类别" class="headerlink" title="消息类别"></a>消息类别</h2><h3 id="同步消息"><a href="#同步消息" class="headerlink" title="同步消息"></a>同步消息</h3><p><strong>特征:</strong> 即时性较强,重要的消息,且必须有回执的消息,例如短息,通知(转账成功)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;Devilsproducer&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicTest&quot;</span>,<span class="string">&quot;TagA&quot;</span>,(<span class="string">&quot;Hello RocketMq &quot;</span>+ i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s%n&quot;</span>,sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异步消息"><a href="#异步消息" class="headerlink" title="异步消息"></a>异步消息</h3><p><strong>特征:</strong> 即时性较弱,但需要有回执的消息,例如订单中的某些信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group3&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic3&quot;</span>, <span class="string">&quot;tag1&quot;</span>, msg.getBytes());</span><br><span class="line">            <span class="comment">//异步消息 Callback也是一个多线的接口</span></span><br><span class="line">            producer.send(message, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">                <span class="comment">//发送成功的回调方法a</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">                    System.out.println(sendResult);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//发送失败的回调方法</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                    System.out.println(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;异步发送完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单向消息"><a href="#单向消息" class="headerlink" title="单向消息"></a>单向消息</h3><p><strong>特征:</strong> 不需要有回执的信息,例如日志类消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneWayProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group3&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//单项消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>+i;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic1&quot;</span>, <span class="string">&quot;tag1&quot;</span>, msg.getBytes());</span><br><span class="line">            <span class="comment">//发送单项消息 没有回执消息</span></span><br><span class="line">            producer.sendOneway(message);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送完成了&quot;</span>);</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h3><p><strong>特征:</strong> 消息发送时并不直接发送到消息服务器,而是根据设定等待的时间到达,起到延时到达的缓冲作用</p>
<p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220223203009432.png" alt="image-20220223203009432"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//延时消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>+i;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic1&quot;</span>, <span class="string">&quot;tag1&quot;</span>, msg.getBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置延时 能分别设置每一条消息的延时等级 数字对应等级 而不是真正的时间</span></span><br><span class="line">            message.setDelayTimeLevel(<span class="number">4</span>);</span><br><span class="line">            <span class="comment">//发送延时消息</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line">            System.out.println(sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送成功了&quot;</span>);</span><br><span class="line">        <span class="comment">//断开连接</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h3><p><strong>特征:</strong> 一次发送多条消息,节约网络开销</p>
<p>原理就是通过producer可以通过send方法发送Collection(集合)的缘故 这样我们就可以将Message对象封装到一个集合中 通过send方法完成批量消息的发送</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过producer的send方法可以传输Collection的机制 我们只需要将消息封装到一个集合中 我们就能发送批量消息了</span></span><br><span class="line">        ArrayList&lt;Message&gt; messages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>+i;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic1&quot;</span>, <span class="string">&quot;tag1&quot;</span>, msg.getBytes());</span><br><span class="line">            messages.add(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//批量发送</span></span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">send</span> <span class="operator">=</span> producer.send(messages);</span><br><span class="line">        System.out.println(send);</span><br><span class="line">        System.out.println(<span class="string">&quot;批量消息发送成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<blockquote>
<ul>
<li><p>这些批量消息应该有相同的topic</p>
</li>
<li><p>相同的waitStoreMsgOK</p>
</li>
<li><p>不能是延时消息</p>
</li>
<li><p>消息内容的总长度不能超过4M</p>
</li>
<li><p>消息内容总长度包含如下:</p>
<blockquote>
<ol>
<li>topic(字符串字节数)</li>
<li>body(字节数组长度)</li>
<li>消息追加的属性(key与value对应的字符串字节数)</li>
<li>日志(固定20字节)</li>
</ol>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h2><p>语法过滤(属性过滤&#x2F;语法过滤&#x2F;SQL过滤):按照消息的某些属性过滤;</p>
<p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220223210153476.png" alt="image-20220223210153476"></p>
<p>针对消费者而言在设置订阅消息的模式时, 可以设置主题(Topic) 还可以设置订阅表达式 该订阅表示就是用来过滤你要接收的消息的</p>
<hr>
<h3 id="Tag过滤"><a href="#Tag过滤" class="headerlink" title="Tag过滤"></a>Tag过滤</h3><p><strong><code>pushConsumer.subscribe(&quot;Topic1&quot;,MessageSelector.byTag(&quot;Tag1 || vip&quot;));</code></strong></p>
<p>表示只接收标签为Tag1 或者 vip的消息(默认不指定也是以Tag执行)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.谁来收</span></span><br><span class="line">        <span class="comment">//消费者有两种模式 一种是拉去(需要消费者自己去拉去) 一种是推送(消息主动推送给消费者)</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">pushConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.从哪里收</span></span><br><span class="line">        <span class="comment">//与生产者一样 消费者 也许要去name Server中获得对应broker的地址去获得消息</span></span><br><span class="line">        pushConsumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.监听那个消息队列</span></span><br><span class="line">        <span class="comment">//设置监听队列 subscribe:订阅 指定主题 和订阅表达式 &quot;*&quot;表示订阅主题中的所有</span></span><br><span class="line">        pushConsumer.subscribe(<span class="string">&quot;Topic1&quot;</span>,<span class="string">&quot;Tag1 || vip&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.处理业务流程</span></span><br><span class="line">        <span class="comment">//注册一个监听器 去监听是否有消息被生产 一有就立刻接收</span></span><br><span class="line">        pushConsumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                <span class="comment">//接收到的消息就是 List&lt;MessageExt&gt; msgs 这时我们就能写我们的业务逻辑</span></span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//启动连接</span></span><br><span class="line">        pushConsumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消费者启动起来了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意不要关闭消费者(如果还有对应主题的生产者的情况下 关闭就无法监听消息 就无法收到消息了)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SQL过滤"><a href="#SQL过滤" class="headerlink" title="SQL过滤"></a>SQL过滤</h3><p>要是使用sql过滤首先生产者方在发送消息时需要给消息添加参数 <strong><code>message.putUserProperty(&quot;key&quot;,&quot;value&quot;);</code></strong>(因为这不是Tag过滤 并且tag也无法搭载过多的信息)</p>
<p>使用SQL过滤之前需要在broker.conf添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开启对 propertyfilter的支持</span><br><span class="line">enablePropertyFilter = true</span><br><span class="line">filterSupportRetry = true</span><br></pre></td></tr></table></figure>

<p>然后再调用**<code>pushConsumer.subscribe(&quot;Topic1&quot;,MessageSelector.bySql(&quot;age&gt;18&quot;));</code>**</p>
<p><code>producer</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic1&quot;</span>,<span class="string">&quot;vip&quot;</span>,(<span class="string">&quot;Hello World&quot;</span>).getBytes());</span><br><span class="line"></span><br><span class="line">message.putUserProperty(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">message.putUserProperty(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.发什么</span></span><br><span class="line"><span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br></pre></td></tr></table></figure>

<p><code>consumer</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.谁来收</span></span><br><span class="line">        <span class="comment">//消费者有两种模式 一种是拉去(需要消费者自己去拉去) 一种是推送(消息主动推送给消费者)</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">pushConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.从哪里收</span></span><br><span class="line">        <span class="comment">//与生产者一样 消费者 也许要去name Server中获得对应broker的地址去获得消息</span></span><br><span class="line">        pushConsumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.监听那个消息队列</span></span><br><span class="line">        <span class="comment">//设置监听队列 subscribe:订阅 指定主题 和订阅表达式 &quot;*&quot;表示订阅主题中的所有</span></span><br><span class="line">        pushConsumer.subscribe(<span class="string">&quot;Topic1&quot;</span>, MessageSelector.bySql(<span class="string">&quot;age &gt; 16&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.处理业务流程</span></span><br><span class="line">        <span class="comment">//注册一个监听器 去监听是否有消息被生产 一有就立刻接收</span></span><br><span class="line">        pushConsumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                <span class="comment">//接收到的消息就是 List&lt;MessageExt&gt; msgs 这时我们就能写我们的业务逻辑</span></span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                    Map&lt;String, String&gt; properties = msg.getProperties();</span><br><span class="line">                    Iterator&lt;Map.Entry&lt;String,String&gt;&gt; iter = properties.entrySet().iterator();</span><br><span class="line">                    <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">                        Map.Entry&lt;String, String&gt; next = iter.next();</span><br><span class="line">                        System.out.println(next.getKey()+<span class="string">&quot; = &quot;</span>+next.getValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//启动连接</span></span><br><span class="line">        pushConsumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消费者启动起来了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意不要关闭消费者(如果还有对应主题的生产者的情况下 关闭就无法监听消息 就无法收到消息了)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Springboot整合RocketMQ"><a href="#Springboot整合RocketMQ" class="headerlink" title="Springboot整合RocketMQ"></a>Springboot整合RocketMQ</h2><ul>
<li>导入Springboot与RocketMQ整合starter</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以在application中配置rocketmq name-server的ip地址 和生产者的信息 或是消费者的信息</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="attr">name-server:</span> <span class="string">localhost:9876</span></span><br><span class="line">  <span class="attr">consumer:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">group1</span></span><br><span class="line">  <span class="attr">producer:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">group1</span></span><br></pre></td></tr></table></figure>

<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><ul>
<li><p>在使用时 我们需要将springboot容器中的RocketMQTemplate(使用@Autowired)注册到我们的类中</p>
</li>
<li><p><strong>RocketMQTemplate:RocketMQ模板类 : 建立连接 断开连接</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;<span class="comment">//RocketMQ模板类: 建连接 短链接</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Springboot中传输的消息是Springboot框架提供的 <strong><code>org.springframework.messaging.Message&lt;T&gt;</code></strong></p>
</li>
<li><p>可以使用 <strong><code>org.springframework.messaging.support.MessageBuilder</code><strong>的</strong>静态方法withPayload(T payload)新建一个消息构建器 再调用build()方法</strong> 就可以将<strong>payload转换为一个Message对象</strong></p>
</li>
<li><p>上述都是使用send方法发送信息的需要做的 我们可以使用rocketMQTemplate的其他方法 例如 **<code>converAndSend()</code><strong>该方法由名字就知道它可以转化并且发送 它可以将java对象转化为</strong><code>org.springframework.messaging.Message&lt;T&gt;</code>**发送</p>
</li>
<li><p>除了上述两种方法 还有**<code>syncSend(), asyncSend(), sendOneWay() </code><strong>分别对应着同步,异步,单向消息 还可以在方法的参数上添加</strong><code>timeout delayLevel</code>**等参数以达到延时效果</p>
</li>
</ul>
<p><strong>注意:</strong> 这里不再是单纯的填入Topic了而是<strong>destination</strong> 并且格式是 <strong><code>topicName:tags</code></strong> </p>
<p>RocketMQ获取destination的源码</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220224202331947.png" alt="image-20220224202331947"></p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><ul>
<li><p>Consumer方面我们使用了监听器的方式来接收消息 实现RocketMQ自带的**<code>RocketMQListener&lt;T&gt;</code>** T指的**<code>withpayload</code>**中的消息类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span> <span class="comment">//注册到容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConsumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收成功的回调方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(User message)</span> &#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>设置了接收的监听器 我们还要设置监听的消息的主题 消息过滤 还有消费者组的名称 才能满足RocketMQ的规范</p>
<ul>
<li>这里我们使用**<code>rocketmq-spring-boot-starter</code><strong>的注解</strong><code>@RocketMQMessageListener</code>**设置参数 因为name-server在application.yml中我们已经设置了 springboot会自动识别并且设置.</li>
</ul>
</li>
<li><p>@RocketMQMessageListener</p>
<blockquote>
<ul>
<li>topic:主题</li>
<li>selectorExpression:过滤表达式</li>
<li>selectorType:设置过滤类型(Tag or Sql)</li>
<li>consumerGroup: 消费者组的名称</li>
<li>messageModel:消息的模式(广播或是集群)</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong><code>Producer</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;<span class="comment">//RocketMQ模板类: 建连接 短链接</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/send&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Devil&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        rocketMQTemplate.convertAndSend(<span class="string">&quot;Topic2&quot;</span>,user);<span class="comment">//convert: 消息转换为字节数组 甚至可以自动将对象转化为字节数组 但必须实现序列化</span></span><br><span class="line"></span><br><span class="line">        rocketMQTemplate.syncSend(<span class="string">&quot;Topic2&quot;</span>,user);<span class="comment">//发送同步消息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送异步消息</span></span><br><span class="line">        rocketMQTemplate.asyncSend(<span class="string">&quot;Topic2&quot;</span>, user, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">            <span class="comment">//发送成功的回调方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//发送失败的回调方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送单项消息</span></span><br><span class="line">        rocketMQTemplate.sendOneWay(<span class="string">&quot;Topic2&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送延时消息</span></span><br><span class="line">        rocketMQTemplate.syncSend(<span class="string">&quot;Topic2:tag1&quot;</span>, MessageBuilder.withPayload(user).build(),<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><code>Consumer</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(topic = &quot;Topic2&quot;,selectorExpression = &quot;tag1 || tag2&quot;,consumerGroup = &quot;$&#123;rocketmq.producer.group&#125;&quot;,</span></span><br><span class="line"><span class="meta">        selectorType = SelectorType.TAG,messageModel = MessageModel.BROADCASTING)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConsumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收成功的回调方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(User message)</span> &#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="消息顺序"><a href="#消息顺序" class="headerlink" title="消息顺序"></a>消息顺序</h2><p> <strong>消息错乱的原因:</strong></p>
<blockquote>
<p>默认消息的发送是每条消息按照 依次按照queue的顺序进入queue 即:<strong>队列内无序,队列外有序</strong></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220224214903923.png" alt="image-20220224214903923"></p>
<p><strong><code>Producer</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这样发送会导致消息错乱</span></span><br><span class="line"><span class="keyword">for</span> (OrderStep orderStep : orderSteps) &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;topic3&quot;</span>, <span class="string">&quot;tag1&quot;</span>, orderStep.toString().getBytes());</span><br><span class="line">    <span class="type">SendResult</span> <span class="variable">send</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line"></span><br><span class="line">    System.out.println(send);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>Consumer</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这样接收会导致消息错乱</span></span><br><span class="line">pushConsumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">        <span class="comment">//接收到的消息就是 List&lt;MessageExt&gt; msgs 这时我们就能写我们的业务逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


</blockquote>
<p><strong>纠正消息错乱:</strong></p>
<blockquote>
<p>修改消息的顺序,即指定消息进入的队列, 完整的顺序(订单的完整流程 创建 支付 完成)应当进入同一个消息队列. 即:<strong>队列内有序,队列外无序</strong></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220224214826242.png" alt="image-20220224214826242"></p>
<p>为了使得生产的消息有序可以在producer中发送消息时指定消息进入的消息队列</p>
<p><strong><code>producer.send(message, new MessageQueueSelector() &#123;...&#125;,null);</code></strong> 其中的**<code>MessageQueueSelector()</code>**接口的select方法就可以指定消息填充的队列的队列id 更具这个id就可以获得这个队列 再通过send方法 发送到这个队列中</p>
<p><strong><code>Producer</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正确的发送</span></span><br><span class="line"><span class="keyword">for</span> (OrderStep orderStep : orderSteps) &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;topic3&quot;</span>, <span class="string">&quot;tag1&quot;</span>, orderStep.toString().getBytes());</span><br><span class="line">    <span class="type">SendResult</span> <span class="variable">send</span> <span class="operator">=</span> producer.send(message, <span class="keyword">new</span> <span class="title class_">MessageQueueSelector</span>() &#123;</span><br><span class="line">        <span class="comment">//这个方法就是队列悬着的方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> MessageQueue <span class="title function_">select</span><span class="params">(List&lt;MessageQueue&gt; mqs<span class="comment">/*消息队里额*/</span>, Message msg, Object arg)</span> &#123;</span><br><span class="line">            <span class="comment">//队列数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> mqs.size();</span><br><span class="line">            <span class="comment">//确定的orderId对应确定的队列 取模运算</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">orderId</span> <span class="operator">=</span> (<span class="type">int</span>) (orderStep.getOrderId());</span><br><span class="line">            <span class="type">int</span> <span class="variable">queueId</span> <span class="operator">=</span> orderId % size;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//根据 计算出的queueId 从List&lt;MessageQueue&gt; mqs中获取消息队列</span></span><br><span class="line">            <span class="keyword">return</span> mqs.get(queueId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(send);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于Consumer需要注册<strong>顺序的监听器</strong> 作用就是一个线程只监听一个MessageQueue 这样就可以接收一个queue中的消息了</p>
<p>而一个queue中都是producer生产的顺序的消息.</p>
<blockquote>
<p> <strong><code>new MessageListenerOrderly()&#123;...&#125;</code></strong></p>
</blockquote>
<p><strong><code>Consumer</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消费者注册一个顺序的监听器 作用就是一个线程只监听一个MessageQueue</span></span><br><span class="line">pushConsumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerOrderly</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeOrderlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(context.getMessageQueue().getQueueId());</span><br><span class="line">        <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


</blockquote>
<hr>
<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><h3 id="RocketMQ事务流程概要"><a href="#RocketMQ事务流程概要" class="headerlink" title="RocketMQ事务流程概要"></a>RocketMQ事务流程概要</h3><p>RocketMQ实现事务主要分为两个阶段: 正常事务的发送及提交、事务信息的补偿流程(都是针对生产者 因为事务只出现在DataBase中 有些情况需要将消息存储在数据库中 如果发生事务问题….)</p>
<p><strong>整体流程为:</strong></p>
<blockquote>
<ul>
<li>正常事务发送与提交阶段<ol>
<li>生产者发送一个半消息给broker(半消息是指的暂时不能消费的消息)</li>
<li>服务端响应消息写入结果,半消息发送成功</li>
<li>开始执行本地事务</li>
<li>根据本地事务的执行情况执行Commit或者Rollback</li>
</ol>
</li>
<li>事务信息的补偿流程<ol>
<li>如果broker长时间没有收到本地事务的执行状态,会向生产者发起一个确认会查的操作请求</li>
<li>生产者收到确认会查请求后,检查本地事务的执行状态</li>
<li>根据检查后的结果执行Commit或者Rollback操作 补偿阶段主要是用于解决生产者在发送Commit或者Rollbacke操作时发生超时或失败的情况</li>
</ol>
</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-325e5949a667b144f2684caac49dd41a_720w.png" alt="img"></p>
</blockquote>
<h3 id="RocketMQ事务流程关键"><a href="#RocketMQ事务流程关键" class="headerlink" title="RocketMQ事务流程关键"></a>RocketMQ事务流程关键</h3><ul>
<li><p><strong>事务消息在一阶段对用户不可见</strong> </p>
<p>事务消息相对普通消息最大的特点就是一阶段发送的消息对用户是不可见的,也就是说消费者不能直接消费.这里RocketMQ实现方法是原消息的主题与消息消费队列,然后把主题改成**<code>RMQ_SYS_TRANS_HALF_TOPIC</code>**.这样由于消费者没有订阅这个主题,所以不会消费.</p>
</li>
<li><p><strong>如何处理第二阶段的发送消息?</strong></p>
<p>在本地事务执行完成后回向Broker发送Commit或者Rollback操作,此时如果在发送消息的时候生产者出故障了,要保证这条消息最终被消费,broker就会向服务端发送回查请求,确认本地事务的执行状态.当然RocketMQ并不会无休止的发送事务状态回查请求,<strong>默认是15次</strong>,如果15次回查还是无法得知事务的状态,RocketMQ默认回滚消息(broker就会将这条半消息删除)</p>
</li>
<li><p>事务的三种状态:</p>
<blockquote>
<ul>
<li><strong>TransactionStatus.CommitTransaction</strong>：提交事务消息，消费者可以消费此消息</li>
<li><strong>TransactionStatus.RollbackTransaction</strong>：回滚事务，它代表该消息将被删除，不允许被消费。</li>
<li><strong>TransactionStatus.Unknown</strong> ：中间状态，它代表需要检查消息队列来确定状态。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>创建生产者时我们不在简单地创建**<code>DefaultMQProducer</code>** 而是RocketMQ事务专属的 <strong><code>TransactionMQProducer</code></strong> 并且不再简单地发送消息了 而是设置一个事务监听器 <strong><code>setTransactionListener(new TransactionListener()&#123;...&#125;);</code></strong> 实现接口方法 并且由于监听器需要等待本地事务的执行情况我们不能再生产者发送完消息后关闭</p>
<p><strong><code>Producer</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TransactionMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionMQProducer</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置事务监听</span></span><br><span class="line">        producer.setTransactionListener(<span class="keyword">new</span> <span class="title class_">TransactionListener</span>() &#123;</span><br><span class="line">            <span class="comment">//执行本地事务 这就是正常事务过程</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> &#123;</span><br><span class="line">                <span class="comment">//消息保存到数据库中</span></span><br><span class="line">                <span class="comment">//sql代码</span></span><br><span class="line">                <span class="comment">//根据数据库事务状态 返回事务状态</span></span><br><span class="line">                System.out.println(<span class="string">&quot;正常执行的过程&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//LocalTransactionState.ROLLBACK_MESSAGE 表示事务回滚 这时broker就会删除掉half消息 消费者接收不到</span></span><br><span class="line">                <span class="comment">//如果是LocalTransactionState.COMMIT_MESSAGE 表示提交消息 这时broker就会提交half消息 消费能接收</span></span><br><span class="line">                <span class="comment">//LocalTransactionState.UNKNOW 事务结果未知 执行事务补偿过程 即broker主动询问生产者事务结果</span></span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//检查本地事务 这就是事务补偿过程</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> LocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行事务补偿过程&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello Transaction&quot;</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;topic4&quot;</span>, <span class="string">&quot;tag1&quot;</span>, msg.getBytes());</span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">send</span> <span class="operator">=</span> producer.sendMessageInTransaction(message,<span class="literal">null</span>);</span><br><span class="line">        System.out.println(send);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消息生产完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能关闭 涉及事务的提交和回滚 以及事务与broker的交互过程 不能一发出消息就关闭</span></span><br><span class="line">        <span class="comment">//producer.shutdown();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>Consumer</code></strong> 整个事务消息环节与Consumer相关不大,所以不用对原来的Consumer进行修改 正常接收消息即可.</p>
<h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><h3 id="集群分类"><a href="#集群分类" class="headerlink" title="集群分类"></a>集群分类</h3><ul>
<li><strong>单机</strong><ul>
<li>一个broker提供服务(宕机后服务瘫痪)</li>
</ul>
</li>
<li><strong>集群</strong><ul>
<li>多个broker提供服务(单机宕机后消息无法及时被消费)</li>
<li>多个master和多个slave<ul>
<li>master到slave消息同步方式为同步(较异步方式性能略低,消息无延迟)</li>
<li>master到slave消息同步方式为异步(较同步方式性能略高,数据略有延迟)</li>
</ul>
</li>
</ul>
</li>
<li><strong>根据配置文件中的信息来设置主从集群</strong></li>
</ul>
<h3 id="RocketMQ集群工作流程"><a href="#RocketMQ集群工作流程" class="headerlink" title="RocketMQ集群工作流程"></a>RocketMQ集群工作流程</h3><ul>
<li>NameServer启动,开启监听,等待broker,producer与consumer连接</li>
<li>broker启动,根据配置信息,连接所有的NameServer,并保持长连接 <ul>
<li>如果broker中现存数据,NameServer将保存topic与broker关系</li>
</ul>
</li>
<li>producer发送信息,连接某个NameServer,并建立长连接</li>
<li>producer发送消息<ul>
<li>如果topic存在,由NameServer直接分配</li>
<li>如果topic不存在,由NameServer创建topic与broker关系,并分配</li>
</ul>
</li>
<li>producer与broker的topic选择一个消息队列(从列表中选择)</li>
<li>producer与broker建立长连接,用于发送消息</li>
<li>producer发送消息</li>
</ul>
<p><strong><code>Consumer</code><strong>工作流程同</strong><code>Producer</code></strong></p>
<hr>
<h2 id="RocketMQ高级特性"><a href="#RocketMQ高级特性" class="headerlink" title="RocketMQ高级特性"></a>RocketMQ高级特性</h2><p><strong>RocketMQ消息发送底层</strong></p>
<ol>
<li><p>消息的生产者发送消息到MQ</p>
</li>
<li><p>MQ返回ACK给生产者</p>
</li>
<li><p>MQ push消息给对于的消费者</p>
</li>
<li><p>消息消费者返回ACK给MQ</p>
</li>
</ol>
<p>说明: ACK(Acknowledge character)</p>
<p>注意: <strong>如果broker出现问题不能发送和接收ACK  生产者就会接收不到broker发送的ACK 就会导致生产者一直发送同一条消息 也会导致消费者一直消费同一条消息</strong></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225203843889.png" alt="image-20220225203843889"></p>
<h3 id="消息的存储"><a href="#消息的存储" class="headerlink" title="消息的存储"></a>消息的存储</h3><ol>
<li><p>消息生产者发送消息到MQ</p>
</li>
<li><p>MQ接收到消息,将消息持久化,存储该消息</p>
</li>
<li><p>MQ返回ACK给生产者</p>
</li>
<li><p>MQpush消息给对应的消费者</p>
</li>
<li><p>消息消费者返回ACK给MQ</p>
</li>
<li><p>MQ删除消息</p>
</li>
</ol>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225204155340.png" alt="image-20220225204155340"></p>
<p><strong>注意:</strong></p>
<blockquote>
<ul>
<li>第5步 MQ在指定时间接收到消息消费者返回ACK, MQ认定消息消费成功,执行6</li>
<li>第5步 MQ在指定时间未接收到消息消费者返回ACK,MQ认定消费失败,重新执行456</li>
</ul>
</blockquote>
<h3 id="消息的存储介质"><a href="#消息的存储介质" class="headerlink" title="消息的存储介质"></a>消息的存储介质</h3><p>为了防止数据库出现故障和数据库I&#x2F;O降低性能(数据库最后也是将数据存储再磁盘上(文件系统))</p>
<p><strong>所以我们直接绕过数据库 直接将消息存在本地的文件系统上</strong></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225204909019.png" alt="image-20220225204909019"></p>
<p><strong>数据库:</strong></p>
<ul>
<li>ActiveMQ使用</li>
<li>缺点: 数据库瓶颈将成为MQ瓶颈</li>
</ul>
<p><strong>文件系统:</strong></p>
<ul>
<li>RocketMQ&#x2F;Kafka&#x2F;RabbitMQ</li>
<li>解决方案: 采用消息刷盘的机制进行数据的存储</li>
<li>缺点:硬盘损坏的问题无法避免</li>
</ul>
<h3 id="高效的消息存储与读写方式"><a href="#高效的消息存储与读写方式" class="headerlink" title="高效的消息存储与读写方式"></a>高效的消息存储与读写方式</h3><ul>
<li><strong>SSD(Solid State Disk): 固态硬盘</strong><ul>
<li>随机写 100kb&#x2F;s</li>
<li>顺序写 600-3000m&#x2F;s</li>
</ul>
</li>
<li>由上可知 顺序写的速度是远远快于随机写的</li>
</ul>
<hr>
<ul>
<li><p><strong>RocketMQ中向文件系统预先申请了一定大小的磁盘空间 用于顺序读写</strong>(这就是RocketMQ高速读写的第一个原因)</p>
</li>
<li><p>Linux系统发送数据的方式</p>
<blockquote>
<p>“零拷贝”技术</p>
<ul>
<li>数据传输由传统的4次复制简化成3次复制,减少1次复制过程</li>
<li>java语言中使用MappedByteBuffer类实现了该技术</li>
<li>要求:预留存储空间,用于保存数据(1G存储空间起步)</li>
</ul>
</blockquote>
<p>传统模式</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225211130484.png" alt="image-20220225211130484"></p>
</li>
</ul>
<p>“零拷贝模式”</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225211155810.png" alt="image-20220225211155810"></p>
<p><strong>总结(RocketMQ高速读写的原因):</strong></p>
<blockquote>
<ul>
<li>磁盘读写方式</li>
<li>“零拷贝”技术</li>
</ul>
</blockquote>
<h3 id="消息存储的结构"><a href="#消息存储的结构" class="headerlink" title="消息存储的结构"></a>消息存储的结构</h3><p>MQ数据存储区域包括如下内容</p>
<ul>
<li><p>消息数据存储区域</p>
<ul>
<li>topic</li>
<li>queueId</li>
<li>message</li>
</ul>
</li>
<li><p>消费逻辑队列(会记录每一个队列被每一个消费者消费到了什么(多少偏移量))</p>
<ul>
<li>minOffset</li>
<li>maxOffset</li>
<li>consumerOffset</li>
</ul>
</li>
<li><p>索引</p>
<ul>
<li>key索引</li>
<li>创建时间索引</li>
<li>……</li>
</ul>
</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225212158831.png" alt="image-20220225212158831"></p>
<h3 id="刷盘机制"><a href="#刷盘机制" class="headerlink" title="刷盘机制"></a>刷盘机制</h3><h4 id="同步刷盘"><a href="#同步刷盘" class="headerlink" title="同步刷盘:"></a>同步刷盘:</h4><ol>
<li>生产者发送消息到MQ,MQ接到消息数据</li>
<li>MQ挂起生产者发送消息的线程</li>
<li>MQ将消息数据写入内存</li>
<li>内存数据写入硬盘</li>
<li>磁盘存储后返回SUCCESS</li>
<li>MQ回复挂起的生产者线程</li>
<li>发送ACK到生产者</li>
</ol>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225212521664.png" alt="image-20220225212521664"></p>
<h4 id="异步刷盘"><a href="#异步刷盘" class="headerlink" title="异步刷盘"></a>异步刷盘</h4><ol>
<li><p>生产者发送消息到MQ,MQ接收到消息数据</p>
</li>
<li><p>MQ将消息写入内存</p>
</li>
<li><p>发送ACK到生产者</p>
</li>
<li><p>待到内存中的消息数据积累到一定量 就将消息数据写入硬盘</p>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><blockquote>
<ul>
<li>同步刷盘: 安全性高,效率低,速度慢(适用于对数据安全性要求较高的业务)</li>
<li>异步刷盘:安全性低,效率高,速度块(使用与对数据处理速度要求较高的业务)</li>
</ul>
</blockquote>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225213018812.png" alt="image-20220225213018812"></p>
<hr>
<h3 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h3><ul>
<li>NameServer<ul>
<li>无状态(相互之间无联系)+全服务器注册</li>
</ul>
</li>
<li>消息服务器<ul>
<li>主从框架(2M-2S)</li>
</ul>
</li>
<li>消息生产<ul>
<li>生产者将相同的topic绑定到多个group组,保障master挂掉后,其他master仍可以正常进行消息接收</li>
</ul>
</li>
<li>消息消费<ul>
<li>RocketMQ自身会根据master的压力确认是否由master承担消息读取的功能,当master繁忙的时候,自动切换slave成单数据读取的工作(主从分离 当压力过大时 master只写入 因为slave中的数据与master实时更新 所以这时slave可以承担读的功能)</li>
</ul>
</li>
</ul>
<p><strong>主从数据复制</strong></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225213710132.png" alt="image-20220225213710132"></p>
<hr>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul>
<li>**<code>Producer</code>**负载均衡</li>
</ul>
<blockquote>
<ul>
<li>内部实现了不同broker集群中对同一个topic对应消息队列的负载均衡</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225214232482.png" alt="image-20220225214232482"></p>
</blockquote>
<ul>
<li>**<code>Consumer</code>**负载均衡(针对相同的消费者组间)</li>
</ul>
<blockquote>
<ul>
<li>平均分配</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225214249237.png" alt="image-20220225214249237"></p>
<ul>
<li>循环平均分配(解决宕机问题)</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225214305341.png" alt="image-20220225214305341"></p>
</blockquote>
<hr>
<h3 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h3><p>当消息消费后未正常返回消费成功的消息将启动消息重试机制</p>
<p><strong>消息重试机制</strong></p>
<blockquote>
<ul>
<li><p><strong>顺序消息重试</strong></p>
<blockquote>
<p>当消费者消费失败后,RocketMQ会自动进行消息重试(每次间隔为1s)</p>
<p><strong>注意:</strong> 应用会出现消息消费被堵塞的情况,因此要对顺序消息的消费情况进行监控,避免阻塞的现象发生</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225214842367.png" alt="image-20220225214842367"></p>
</blockquote>
</li>
<li><p><strong>无序消息重试</strong></p>
<blockquote>
<ul>
<li>无序消息包括普通消息、定时消息、延时消息、事务消息</li>
<li>无序消息重试仅适用于负载均衡（集群）模型下的消息消费，不适用于广播模式下的消息</li>
<li>消费为保障无序消息的消费，MQ设定了合理的消息重试间隔时长</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225215028265.png" alt="image-20220225215028265"></p>
</blockquote>
</li>
</ul>
</blockquote>
<hr>
<h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p><strong>死信队列就是那些重试无果的消息存在的队列</strong></p>
<ul>
<li><p><strong>死信队列特征</strong></p>
<blockquote>
<ul>
<li>归属某一个组（Gourp Id)，而不归属Topic，也不归属消费者。</li>
<li>一个死信队列中可以包含同一个组下的多个Topic中的死信消息</li>
<li>死信队列不会进行默认初始化，当第一个死信出现后，此队列首次初始化</li>
</ul>
</blockquote>
</li>
<li><p><strong>死信队列中消息特征</strong></p>
<blockquote>
<ul>
<li><p>不会被再次重复消费</p>
</li>
<li><p>死信队列中的消息有效期为3天，达到时限后将被清除</p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>死信处理</strong></p>
<blockquote>
<p>在监控平台中,通过查找死信,获取死信的messageId,然后通过id对死信进行精准消费</p>
</blockquote>
</li>
</ul>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h4><ul>
<li><p>死信</p>
<blockquote>
<ul>
<li><p>死信队列与死信</p>
</li>
<li><p>死信处理方式</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<h3 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h3><h4 id="消息重复发送的原因"><a href="#消息重复发送的原因" class="headerlink" title="消息重复发送的原因"></a>消息重复发送的原因</h4><ul>
<li>生产者发送了重复的消息<ul>
<li>网络闪断(例如: 消息服务器没有发送ACK给生产者)</li>
<li>生产者宕机</li>
</ul>
</li>
<li>消息服务器投递了重复的消息<ul>
<li>网络闪断(例如: 消费者没有发送ACK给消息服务器)</li>
</ul>
</li>
<li>动态的负载均衡过程<ul>
<li>网络闪断&#x2F;抖动</li>
<li>broker重启</li>
<li>订阅方应用重启(消费者)</li>
<li>客户端扩容</li>
<li>客户端缩容</li>
</ul>
</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225220215976.png" alt="image-20220225220215976"></p>
<h4 id="消息幂等"><a href="#消息幂等" class="headerlink" title="消息幂等"></a>消息幂等</h4><ul>
<li><p>对于同一条消息,无论消费了多少次,结果保持一致,称为<strong>消息幂等性</strong></p>
</li>
<li><p>解决方案</p>
<ul>
<li>使用业务id作为消息的key</li>
<li>在消费消息时,客户端对key做判定,未使用过放行,使用过抛弃</li>
</ul>
</li>
<li><p>注意: <strong>messageId由RocketMQ产生,MessageId并不具有唯一性,不能作用幂等判定条件</strong></p>
</li>
<li><p><strong>常见的幂等方法示例</strong></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220225220811978.png" alt="image-20220225220811978"></p>
</li>
</ul>
<h1 id="——End——"><a href="#——End——" class="headerlink" title="——End——"></a>——End——</h1>]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2022/02/28/Springboot/</url>
    <content><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><ol>
<li>SpringBoot 相当于是一个Spring 和 SpringMVC的集成 又在其上增加了其他功能 对其他主流框架的支持也是非常好, 所以SpringBoot更新的非常频繁,需要时常关注它更新的内容</li>
<li>微服务架构<br> 　Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。<br> 　该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。　　<br> 　通过这种方式，Spring Boot 致力于在蓬勃发展的快速应用开发领域（rapidapplication development）成为领导者。</li>
</ol>
<span id="more"></span>

<h4 id="SpringBoot优点"><a href="#SpringBoot优点" class="headerlink" title="SpringBoot优点"></a>SpringBoot优点</h4><ul>
<li>Create stand-alone Spring applications</li>
</ul>
<ul>
<li><ul>
<li>创建独立Spring应用</li>
</ul>
</li>
<li><p>Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)</p>
</li>
<li><ul>
<li>内嵌web服务器</li>
</ul>
</li>
<li><p>Provide opinionated ‘starter’ dependencies to simplify your build configuration</p>
</li>
<li><ul>
<li>自动starter依赖，简化构建配置</li>
</ul>
</li>
<li><p>Automatically configure Spring and 3rd party libraries whenever possible</p>
</li>
<li><ul>
<li>自动配置Spring以及第三方功能</li>
</ul>
</li>
<li><p>Provide production-ready features such as metrics, health checks, and externalized configuration</p>
</li>
<li><ul>
<li>提供生产级别的监控、健康检查及外部化配置</li>
</ul>
</li>
<li><p>Absolutely no code generation and no requirement for XML configuration</p>
</li>
<li><ul>
<li><strong>无代码生成、无需编写XML</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>SpringBoot是整合Spring技术栈的一站式框架</p>
<p>SpringBoot是简化Spring技术栈的快速开发脚手架</p>
</blockquote>
<p>SpringBoot最大的特点就是 无需编写大量的配置文件 需要什么功能模块 只需要导入相应的starter即可 &lt; parent&gt;中也几乎包含所有需要用到的功能依赖的版本号</p>
<h4 id="SpringBoot缺点"><a href="#SpringBoot缺点" class="headerlink" title="SpringBoot缺点"></a>SpringBoot缺点</h4><ul>
<li>人称版本帝，迭代快，需要时刻关注变化</li>
<li>封装太深，内部原理复杂，不容易精通</li>
</ul>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a><strong>微服务</strong></h2><ul>
<li><p>微服务是一种架构风格</p>
</li>
<li><p>一个应用拆分为一组小型服务</p>
</li>
<li><p>每个服务运行在自己的进程内，也就是可独立部署和升级</p>
</li>
<li><p>服务之间使用轻量级HTTP交互</p>
</li>
<li><p>服务围绕业务功能拆分</p>
</li>
<li><p>可以由全自动部署机制独立部署</p>
</li>
<li><p>去中心化，服务自治。服务可以使用不同的语言、不同的存储技术</p>
</li>
</ul>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a><strong>分布式</strong></h2><p>就是把一个一个的服务细分为不同功能的微服务 再将这些服务部署到不同的服务器上 以达到性能能效最大化 同时也避免了一台服务器出现问题 整个系统业务完全瘫痪</p>
<p><strong>分布式的困难</strong></p>
<ul>
<li><p>远程调用</p>
</li>
<li><p>服务发现</p>
</li>
<li><p>负载均衡</p>
</li>
<li><p>服务容错</p>
</li>
<li><p>配置管理</p>
</li>
<li><p>服务监控</p>
</li>
<li><p>链路追踪</p>
</li>
<li><p>日志管理</p>
</li>
<li><p>任务调度</p>
</li>
<li><p>……</p>
</li>
</ul>
<p>分布式的解决: SpringBoot+SpringCloud</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/1599799119457-841ef47a-6585-4ca4-8e3d-8298e796012c.png" alt="img"></p>
<h2 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a><strong>云原生</strong></h2><p>原生应用如何上云。 Cloud Native</p>
<h4 id="上云的困难"><a href="#上云的困难" class="headerlink" title="上云的困难"></a><strong>上云的困难</strong></h4><ul>
<li><p>服务自愈</p>
</li>
<li><p>弹性伸缩</p>
</li>
<li><p>服务隔离</p>
</li>
<li><p>自动化部署</p>
</li>
<li><p>灰度发布</p>
</li>
<li><p>流量治理</p>
</li>
<li><p>……</p>
</li>
</ul>
<h4 id="上云的解决"><a href="#上云的解决" class="headerlink" title="上云的解决"></a>上云的解决</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/1599563498261-8b0b4d86-bd9b-49a3-aefc-89696a375dcb.png" alt="img"></h4><h2 id="学习SpringBoot"><a href="#学习SpringBoot" class="headerlink" title="学习SpringBoot"></a><strong>学习SpringBoot</strong></h2><ol>
<li><p>查看官方文档:<strong><a href="https://spring.io/">Spring官方 所有Spring的框架 包括分布式的解决方案</a></strong></p>
</li>
<li><p>查看SpringBoot官方文档 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/"><strong>Spring Boot官方文档</strong></a></p>
</li>
<li><p>查看版本新特性: <a href="https://github.com/spring-projects/spring-boot/wiki#release-notes"><strong>SpringBoot迭代更新文档</strong></a></p>
</li>
</ol>
<h2 id="SpringBoot2入门"><a href="#SpringBoot2入门" class="headerlink" title="SpringBoot2入门"></a><strong>SpringBoot2入门</strong></h2><h4 id="一-基础要求"><a href="#一-基础要求" class="headerlink" title="一: 基础要求"></a>一: 基础要求</h4><p><strong>系统要求</strong></p>
<ul>
<li><p><a href="https://www.java.com/">Java 8</a> &amp; 兼容java14 .</p>
</li>
<li><p>Maven 3.3+</p>
</li>
<li><p>idea 2019.1.2</p>
</li>
</ul>
<h4 id="二-开始步骤"><a href="#二-开始步骤" class="headerlink" title="二: 开始步骤"></a>二: 开始步骤</h4><h5 id="方式一-直接使用Maven创建SpringBoot项目"><a href="#方式一-直接使用Maven创建SpringBoot项目" class="headerlink" title="方式一:直接使用Maven创建SpringBoot项目"></a>方式一:直接使用Maven创建SpringBoot项目</h5><ol>
<li>需要导入&lt; parent&gt;&lt;&#x2F; parent&gt; 依赖 里面包含了几乎开发要用到的所用依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>开始一个web项目,就加入spring-boot-starter-web依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>加入插件 该插件可以简化部署</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>该插件可以将 Spring Boot应用打包为可执行的jar或war文件，然后以通常的方式运行Spring Boot应用。</p>
<ol start="4">
<li>如果想更改SpringBoot内置服务器的端口号 就创建一个application.properties</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8888</span></span><br></pre></td></tr></table></figure>

<p>这样SpringBoot就能识别出了并修改了</p>
<ol start="5">
<li>创建主程序类 (也是SpringBoot的核心)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主程序类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@SpringBootApplication</span>: 这是一个SpringBoot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>编写一个控制器 和 处理器方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-01-11-20:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handler01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello,Spring Boot2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>运行主程序类 并测试</li>
</ol>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120140741819.png" alt="image-20220120140741819"></p>
<h5 id="方式二-使用idea自带的模板创建-spring-initializr"><a href="#方式二-使用idea自带的模板创建-spring-initializr" class="headerlink" title="方式二: 使用idea自带的模板创建(spring initializr)"></a>方式二: 使用idea自带的模板创建(spring initializr)</h5><p>选择spring initalizr 填入相应的信息 然后点击next</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120141041583.png" alt="image-20220120141041583"></p>
<p>因为我们是做web应用 所以这里选择springweb 如果是其他项目 选择相应的模块即可</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120141138907.png" alt="image-20220120141138907"></p>
<p>然后等待创建 最后创建相应的Controller等 运行即可(剩下于方式一相同)</p>
<h5 id="方式三-spring官网创建-同样使用的是spring-initializr"><a href="#方式三-spring官网创建-同样使用的是spring-initializr" class="headerlink" title="方式三:spring官网创建(同样使用的是spring initializr)"></a>方式三:spring官网创建(同样使用的是spring initializr)</h5><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120141750951.png" alt="image-20220120141750951"></p>
<p><strong>官网找到 project 点击SpringBoot 拉到最后</strong></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120141836152.png" alt="image-20220120141836152"></p>
<p><strong>点击Spring initializr</strong></p>
<p>界面如图</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120141947001.png" alt="image-20220120141947001"></p>
<p>方式于idea创建相同 只是创建后的形式不同 创建后是以压缩包的形式下载 下载后要导入idea 这种方式是用来应付idea无法联网的情况 </p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><ol>
<li>SpringBoot的配置文件一定要写到 resources目录下 且尽量以application为文件名 这样才能识别</li>
<li>所有的Controller类 等业务类都要写道SpringBootApplication(主程序类)的同级或是子级目录下 否则会报<strong>404</strong></li>
<li><strong>常用的方式是 一 和 二</strong></li>
</ol>
<h2 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a><strong>自动配置原理</strong></h2><h4 id="一-yin-yang-依赖管理"><a href="#一-yin-yang-依赖管理" class="headerlink" title="一:yin_yang:依赖管理"></a>一:yin_yang:依赖管理</h4><ul>
<li>SpringBoot使用了父项目做为项目管理</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">依赖管理    </span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">他的父项目</span><br><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">几乎声明了所有开发中常用的依赖的版本号,自动版本仲裁机制</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>开发只需要导入starter场景启动器(<strong>Starter就是一个包含了若干个坐标定义的pom管理文件, 即包含了若干个依赖的信息</strong>)</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1、见到很多 spring-boot-starter-* ： *就某种场景</span><br><span class="line">2、只要引入starter，这个场景的所有常规需要的依赖我们都自动引入</span><br><span class="line">3、SpringBoot所有支持的场景</span><br><span class="line">https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter</span><br><span class="line">4、见到的  *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。</span><br><span class="line">5、所有场景启动器最底层的依赖</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>无需关注版本号，自动版本仲裁</li>
</ul>
<blockquote>
<p>1、引入依赖默认都可以不写版本<br>2、引入非版本仲裁的jar，要写版本号。</p>
</blockquote>
<p>修改默认版本号 是使用依赖覆盖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1、查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。</span><br><span class="line">2、在当前项目里面重写配置</span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.43<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">也可以直接在pom.xml中重写依赖来覆盖</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之所以在配置了&lt; parent&gt;之后不需要填写版本号 是因为 &lt; parent&gt;中使用了&lt; dependencyManagement&gt;管理</p>
<h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意:"></a>注意:</h5><ol>
<li>当导入一个Starter时又想导入一些其他技术 又不想直接导入其他的Starter 可以直接导入该技术的依赖 而且只需要写GAV中的GA而不需要写V 但是如果&lt; Parent&gt;中没有该依赖时 就需要完整写上GAV</li>
</ol>
<h4 id="二-first-quarter-moon-自动配置"><a href="#二-first-quarter-moon-自动配置" class="headerlink" title="二:first_quarter_moon:自动配置:"></a>二:first_quarter_moon:自动配置:</h4><ul>
<li><p>自动配好Tomcat</p>
</li>
<li><ul>
<li>引入Tomcat依赖。</li>
<li>配置Tomcat</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>自动配好SpringMVC</p>
</li>
<li><ul>
<li>引入SpringMVC全套组件</li>
<li>自动配好SpringMVC常用组件（功能）</li>
</ul>
</li>
<li><p>自动配好Web常见功能，如：字符编码问题</p>
</li>
<li><ul>
<li>SpringBoot帮我们配置好了所有web开发的常见场景</li>
</ul>
</li>
<li><p>默认的包结构</p>
</li>
<li><ul>
<li><strong>主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来</strong>(所以一般将组件都写在主程序的同级或是子级目录)</li>
<li>无需以前的包扫描配置</li>
</ul>
</li>
<li><ul>
<li>想要改变扫描路径，</li>
<li>@SpringBootApplication(scanBasePackages&#x3D;<strong>“com.atguigu”</strong>)</li>
</ul>
</li>
<li><ul>
<li>或者@ComponentScan 指定扫描路径(更改方式)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">等同于</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.boot&quot;)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>各种配置拥有默认值</p>
</li>
<li><ul>
<li>默认配置最终都是映射到某个类上，如：MultipartProperties</li>
<li>配置文件的值最终会绑定每个类上，这个类会在容器中创建对象</li>
</ul>
</li>
<li><p>按需加载所有自动配置项</p>
</li>
<li><ul>
<li>非常多的starter</li>
<li>引入了哪些场景这个场景的自动配置才会开启</li>
</ul>
</li>
<li><ul>
<li>SpringBoot所有的自动配置功能都在 spring-boot-autoconfigure 包里面</li>
</ul>
</li>
<li><p>….</p>
</li>
</ul>
<hr>
<h4 id="容器中的注解的功能"><a href="#容器中的注解的功能" class="headerlink" title="容器中的注解的功能"></a>容器中的注解的功能</h4><h5 id="一-question-Configuration-配置类"><a href="#一-question-Configuration-配置类" class="headerlink" title="一:question:@Configuration(配置类):"></a>一:question:@Configuration(配置类):</h5><p><strong>使用:</strong></p>
<ol>
<li>用在类的上方 表示该类为配置类 可以与@Bean标签一起使用 作用类似于Spring.xml文件中&lt; bean&gt;创建对象</li>
</ol>
<p><strong>告诉springboot这个是一个配置类 &#x3D;&#x3D; 配置文件</strong></p>
<ul>
<li><p>配置类里面使用@Bean标注在方法的上面给容器注册组件,默认也是单实例的</p>
</li>
<li><p>配置类本身也是组件</p>
</li>
<li><p>proxyBeanMethods()方法:代理bean的方法</p>
</li>
<li><p>当@Configuration中的参数proxyBeanMethods 的值为true时为代理模式 Cglib代理 会在原来的方法上增加功能 判断容器中是否已有对象 单例模式</p>
</li>
<li><p>当@Configuration中的参数proxyBeanMethods 的值为false时为非代理模式 就是非单例模式</p>
</li>
<li><p>Full模式(proxyBeanMethods &#x3D; true)(保证每个@Bean方法被调用多少次返回的组件都是单实例的)</p>
</li>
<li><p>Lite模式(proxyBeanMethods &#x3D; false)(每个@Bean方法被调用多少次返回的组件都是新创建的)</p>
<blockquote>
<ul>
<li>配置 类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断</li>
<li>配置类组件之间有依赖关系，方法会被调用得到之前单实例组件，用Full模式</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 外部无论对配置类中的这个组件注解方法调用多少次,获取的都是之前注册容器中的单实例对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * //给容器中添加组件.以方法名作为组件的id,返回类型的,就是组件在容器中的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Cat</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span> 方法名就是实例的名称</span><br><span class="line">    <span class="keyword">public</span> Cat <span class="title function_">cat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;彭芳姐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试发现 Full模式(proxyBea+nMethods &#x3D; true) 使用的是Cglib代理模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.dyw.application.config.MyConfig$$EnhancerBySpringCGLIB$$c5874a7@120d3fd</span><br></pre></td></tr></table></figure>

<p>Lite(proxyBeanMethods &#x3D; true)则是没有被代理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.dyw.application.config.MyConfig@29fa6b65</span><br></pre></td></tr></table></figure>

<h6 id="1-1-Import"><a href="#1-1-Import" class="headerlink" title="1. 1 @Import"></a>1. 1 @Import</h6><p><code> @Import(&#123;Cat.class&#125;)</code> 给容器中自动创建出这个类型的组件  默认组件的名字为全类名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;User.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">bean</span> <span class="operator">=</span> context.containsBean(<span class="string">&quot;com.dyw.springboot.entity.User&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h6 id="1-2-Conditional"><a href="#1-2-Conditional" class="headerlink" title="1.2 @Conditional"></a>1.2 @Conditional</h6><ul>
<li>条件装配: 满足Conditional指定的条件,则进行组件注入</li>
<li>@ConditionalOnBean</li>
<li>@ConditionalOnMissingBean</li>
<li>@ConditionalOnMissingClass</li>
<li>@ConditionalOnResource</li>
<li>@ConditionalOnJava</li>
<li>@ConditionalOnWebApplication</li>
<li>@ConditionalOnNotWebApplication</li>
<li>@ConditionalOnClass</li>
</ul>
<p>使用在@Configuration注解类中的@Bean标签下 根据注解条件判断是否注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(Cat.class)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setCat(cat());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="二-SpringBootApplication-主程序类或引导类"><a href="#二-SpringBootApplication-主程序类或引导类" class="headerlink" title="二: @SpringBootApplication(主程序类或引导类)"></a>二: @SpringBootApplication(主程序类或引导类)</h5><ol>
<li>类上加上@SpringBootApplication 表示该类为主程序类 </li>
<li>在类中写上主方法(main) 调用 SpringApplication.run(主程序类.class, args);即可开始SpringBoot程序</li>
<li>注意 组件都要写到主程序类的同级或是子级目录</li>
<li>SpringApplication.run()方法会返回SpringBoot的容器 可以根据容器的getBean(“组件名”,类名.class)获取组件</li>
<li><strong>SpringApplication.run(主程序类.class, args)方法会返回一个Context上下文对象(容器), 里面包含了DispatcherServlet等对象, 这也是问什么运行此方法就可以达到实现web应用的功能. 通过内嵌的TomCat服务器核心就可以读取这个容器的组件</strong>.</li>
<li>SpringBoot内嵌的服务器核心同样也是通过组件的方式存在SpringBoot的Context上下文对象中.(因为TomCat是java写的 运行原理就是执行java对象 所以把Tomcat的对象的创建和管理交给了SpringBoot);</li>
</ol>
<hr>
<h5 id="三-Bean"><a href="#三-Bean" class="headerlink" title="三: @Bean"></a>三: @Bean</h5><ol>
<li><p>用于配置类的方法上 用来注册组件 使得组件管理的主权在容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cat <span class="title function_">cat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;彭芳姐&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>方法名就是组件的名称 也可以在@Bean中设置组件的名称 @Bean(“组件名”)</p>
</li>
<li><p>创建组件的方法有两种 </p>
<ol>
<li><p>一种是利用有参构造创建组件 可以利用有参构造注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cat <span class="title function_">cat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;彭芳姐&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一种是利用无参构造 需要后续使用set方法注入 或是利用spring中的注解注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cat <span class="title function_">cat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<hr>
<h5 id="四-RestController"><a href="#四-RestController" class="headerlink" title="四: @RestController"></a>四: @RestController</h5><ul>
<li><strong>@RestController &#x3D; @Controller + @ResponseBody</strong></li>
</ul>
<p>即**@RestController<strong>在</strong>@Controller<strong>的基础上 集成了</strong>@ResponseBody**的特性 即将java对象转换为json数据或是其他数据</p>
<ul>
<li><strong>@ResponseBody</strong> 注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是<a href="https://so.csdn.net/so/search?q=XML&spm=1001.2101.3001.7020">XML </a>数据。</li>
</ul>
<blockquote>
<p>注意：在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。</p>
</blockquote>
<ul>
<li>@ResponseBody是作用在方法上(可使用在类上表示整个类中的方法都受@ResponseBody的影响)的，@ResponseBody 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】。</li>
<li>注意：<strong>在使用 @RequestMapping后</strong>，<strong>返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。</strong> 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据。@RequestBody 将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。</li>
</ul>
<hr>
<h5 id="五-eagle-RequstMapping"><a href="#五-eagle-RequstMapping" class="headerlink" title="五:eagle:@RequstMapping"></a>五:eagle:@RequstMapping</h5><p>在SpringMVC的学习中我们知道 被它标注的方法称为<strong>处理器方法</strong> , 它可以标注一个处理器方法的请求路径, 被他修饰的处理器方法, 默认返回值通常解析为跳转路径</p>
<p>在SpringBoot中 它的功能被细分了</p>
<p>原本的**@RequestMapping**在不指定请求方法时,会接收任意请求方法的请求</p>
<p>但是SpringBoot中推荐不直接在方法而是使用功能更细的**@请求方法名Mapping** 例如**@GetMapping<strong>或是</strong>@PostMapping**</p>
<p>而把@RequstMapping用在类上 用来当访问路径的前缀</p>
<p><a href="http://localhost:8088/dyw/cat">http://localhost:8088/dyw/cat</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/dyw&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/cat&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doCat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="六：-PathVariable（常用于REST风格）"><a href="#六：-PathVariable（常用于REST风格）" class="headerlink" title="六：@PathVariable（常用于REST风格）"></a>六：@PathVariable（常用于REST风格）</h5><ul>
<li>绑定路径参数于处理器方法形参间的关系，要求路径参数名于形参名一一对应</li>
<li>使用： 用在SpringMVC控制器方法形参定义前面</li>
<li>@PathVariable常用于RESTful中且 请求路径参数只有较少数量时 如一个</li>
</ul>
<p><strong>注意</strong>：<strong>参数是在路径上的</strong>使用{参数名称}描述路径参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String delete(@PathVariable Integer id)&#123;</span><br><span class="line">        System.out.println(&quot;user delete...&quot;+id);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:user delete&#125;&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120201849092.png" alt="image-20220120201849092"></p>
<h5 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h5><ul>
<li>用来接收Josn请求</li>
</ul>
<p>json请求传参方式</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">12</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>使用键值对的方式传参 **键名+”:”+值 ** 键值放在{}中</p>
<h5 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h5><ul>
<li>用于接收url地址传来的参数 或是表单提交的参数 但路径传参的格式相对于RESTful的**@PathVariable**麻烦一点</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">@RequestParam</span><br><span class="line">http://localhost:0000/users?id=1 </span><br><span class="line">=====================================================</span><br><span class="line">@PathVariable</span><br><span class="line">http://localhost:0000/users/1</span><br></pre></td></tr></table></figure>

<h5 id="RequestBody、-RequestParam和-PathVariable总结"><a href="#RequestBody、-RequestParam和-PathVariable总结" class="headerlink" title="@RequestBody、@RequestParam和@PathVariable总结"></a>@RequestBody、@RequestParam和@PathVariable总结</h5><ul>
<li>应用<ul>
<li>后期开发中，发送请求参数超过一个时 ，以json格式为主，@RequestBody应用较广</li>
<li>如果发送非json格式数据，选用@RequestParam接收参数</li>
<li>采用RESTful进行开发，当参数数量较少时，例如一个可以采用@PathVariable接收请求路径变量，通常用于传递id值</li>
</ul>
</li>
</ul>
<hr>
<h5 id="七-ImportResource"><a href="#七-ImportResource" class="headerlink" title="七:@ImportResource"></a>七:@ImportResource</h5><ul>
<li><p>该注解可以导入原生的配置文件 例如Spring中的Bean.xml配置文件 让其生效</p>
</li>
<li><p>使用在任意配置类上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;Cat.class&#125;)</span></span><br><span class="line"><span class="meta">@ImportResource(&quot;classpath:Bean.xml&quot;)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    Bean.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.springboot.entity.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;cat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.springboot.entity.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
</li>
</ul>
<h5 id="八-ConfigurationProperties"><a href="#八-ConfigurationProperties" class="headerlink" title="八: @ConfigurationProperties"></a>八: @ConfigurationProperties</h5><ul>
<li><p>配置绑定 使用该注解 可以使用java读取到的配置文件(xml properties yml)中的内容,并且把它封装到JavaBean中,以供随时使用</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">mycar.name</span>=<span class="string">BYD</span></span><br><span class="line"><span class="attr">mycar.price</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>方式一: 在JavaBean上加上@Component(将其注册到springboot容器)和@ConfigurationPropertes注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>方式二:在JavaBean上只用加上@ConfigurationPropertes注解 并且在配置类(@Configuration)上加上@EnableConfigurationPropertes(Class&lt;?&gt;[])</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(Car.class)</span></span><br><span class="line"><span class="comment">//1. 开启Car配置绑定功能</span></span><br><span class="line"><span class="comment">//2. 把这个Car这个组件自动注册到容器中</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="REST风格"><a href="#REST风格" class="headerlink" title="REST风格"></a><strong>REST风格</strong></h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介:"></a>简介:</h4><ul>
<li><p>按照REST风格访问资源时使用<strong>行为动作</strong>区分对资源进行了何种操作</p>
<ul>
<li><a href="http://localhost:0/users">http://localhost:0000/users</a>                           查询全部用户信息  GET(查询)</li>
<li><a href="http://localhost:0/users/1">http://localhost:0000/users/1</a>                           查询指定用户信息  GET(查询)</li>
<li><a href="http://localhost:0/users">http://localhost:0000/users</a>                           添加用户信息  POST(新增&#x2F;保存)</li>
<li><a href="http://localhost:0/users">http://localhost:0000/users</a>                           修改用户信息  PUT(修改&#x2F;更新)</li>
<li><a href="http://localhost:0/users/1">http://localhost:0000/users/1</a>                           删除用户信息  DELETE(删除)</li>
</ul>
</li>
<li><p>根据REST风格对资源进行访问称为<strong>RESTful</strong></p>
</li>
<li><p>RESTful通常要使用四种访问的请求方法 如GET、POST、PUT、DELETE。</p>
</li>
</ul>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>隐藏资源的访问行为，无法通过地址得知资源是何种操作</li>
<li>书写简化</li>
</ul>
<h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意:"></a>注意:</h4><ul>
<li>上述行为是约定方式，约定方式不是规范，可以打破，所以称为REST风格，而不是REST规范 但是由于使用REST风格的公司越来越多，也就慢慢都认为它是一种规范（都去遵守它了）。</li>
<li>描述模块名称通常使用复数，也就是加s的格式描述，表示此类资源，而非单个资源，例如users、books….。</li>
</ul>
<h4 id="实例步骤："><a href="#实例步骤：" class="headerlink" title="实例步骤："></a>实例步骤：</h4><ol>
<li>设定http请求动作（动词）</li>
<li>设定请求参数（路径变量）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="comment">//保存用户</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user save...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:user save&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除用户</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user delete...&quot;</span>+id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:user delete&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改用户</span></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user update...&quot;</span>+user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:user update&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取指定用户</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getById</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user getById...&quot;</span>+id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:user getById&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取全部用户</span></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAll</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user getAll...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:user getAll&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a><strong>配置文件</strong></h2><p>配置文件（application.properties）前面提到可以修改Springboot内置的端口号 </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br></pre></td></tr></table></figure>

<p>还可以修改banner、log等配置信息</p>
<p>更多的、详细的配置信息都在<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties%E4%B8%AD">https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties中</a> </p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120211025873.png" alt="image-20220120211025873"></p>
<p><strong>注意：</strong></p>
<ul>
<li>配置文件中的内容要与你导入的依赖相关，如果你没有导入相关的依赖那么配置的内容是不会生效的，例如没有导入tomcat的依赖，那么配置文件中修改server.port是不会有高亮提示的也不生效。</li>
</ul>
<h4 id="配置文件的格式"><a href="#配置文件的格式" class="headerlink" title="配置文件的格式"></a>配置文件的格式</h4><ul>
<li><strong>.properties(传统格式&#x2F;默认格式)</strong></li>
<li>.yaml</li>
<li>.<strong>yml(主流)</strong></li>
</ul>
<p>上述三种配置文件同时存在的执行的优先级（会加载覆盖） </p>
<p>是properties &gt;&gt; yml &gt;&gt; yaml</p>
<p>但上述情况一般不会出现</p>
<hr>
<h5 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h5><ul>
<li><p>YAML（YAML Ain’t Markup Language）,一种数据序列化格式</p>
</li>
<li><p><strong>优点：</strong></p>
<ul>
<li>容易阅读</li>
<li>容易与脚本语言交互</li>
<li>以数据为核心，重数据格式</li>
</ul>
</li>
<li><p><strong>YAML文件扩展名</strong></p>
<ul>
<li>.yaml</li>
<li><strong>.yml（主流）</strong></li>
</ul>
</li>
<li><p><strong>语法规则</strong></p>
<ul>
<li>大小写敏感</li>
<li>属性层级关系使用多行描述，每行结尾使用冒号结束</li>
<li>使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）</li>
<li>属性值前面添加空格（属性名与属性之间使用冒号+空格作为分隔）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">country:</span> <span class="string">china</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>#表示注释</p>
</li>
<li><p>更多语法<a href="https://www.runoob.com/w3cnote/yaml-intro.html">YAML 入门教程 | 菜鸟教程 (runoob.com)</a></p>
<hr>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4></li>
</ul>
<h4 id="Java程序读取"><a href="#Java程序读取" class="headerlink" title="Java程序读取"></a><strong>Java程序读取</strong></h4><ul>
<li><p>使用Spring的IOC机制使用@Value注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;country&#125;&quot;)</span><span class="comment">//读取键值对中的值</span></span><br><span class="line"><span class="keyword">private</span> String Country;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用java类读取 （YAML类）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line">		<span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> YamlReader.class.getClassLoader().getResourceAsStream(<span class="string">&quot;application.yml&quot;</span>);) &#123;</span><br><span class="line">			properties = yaml.loadAs(in, HashMap.class);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			log.error(<span class="string">&quot;Init yaml failed !&quot;</span>, e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用环境变量对象来存储yaml配置文件中的键值对（使用@Autowire注入赋值）<strong>用来应对当yaml配置文件中对象过多的情况</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line">    </span><br><span class="line">System.out.println(env.getProperty(<span class="string">&quot;server.port&quot;</span>));</span><br><span class="line">System.out.println(env.getProperty(<span class="string">&quot;Country&quot;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>使用自定义类封装yaml配置文件中的数据</strong></p>
<p>​    application.yaml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">User:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">丁杨维</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>自定义User类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span><span class="comment">//将对象的生命周期交给容器管理 也为了容器将配置文件中的信息赋值给该对象</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Controller.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getById</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120224222972.png" alt="image-20220120224222972"></p>
</li>
<li><p>yaml文件中值的相互引用 直接使用${键名}即可</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">BaseDir:</span> <span class="string">c\windows</span></span><br><span class="line"><span class="attr">TempDir:</span> <span class="string">$&#123;BaseDir&#125;\temp</span></span><br><span class="line"><span class="comment">#如果有转义字符想要显示出来 就加上双引号 如这里\t就是一个转义字符</span></span><br><span class="line"><span class="attr">TempDir:</span> <span class="string">&quot;$&#123;BaseDir&#125;\temp&quot;</span></span><br></pre></td></tr></table></figure>



<hr>
<p><strong>注意：</strong></p>
<ul>
<li><p>虽然配置文件格式多 单文件名可不是乱取的 名字一定是<strong>application.xxx</strong>才行</p>
</li>
<li><p>如果idea没有识别你的yaml文件或是yml文件为springboot配置文件（前提是文件名是applicaiton.xxx） 可以在Project Struct中设置</p>
</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120213544643.png" alt="image-20220120213544643"></p>
<p>选择Facts 选择Configuration Files 在点击那个绿叶标志</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120213633139.png" alt="image-20220120213633139"></p>
<p>点击+号找到你的文件</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120213807493.png" alt="image-20220120213807493"></p>
<h2 id="SpringBoot整合第三方技术"><a href="#SpringBoot整合第三方技术" class="headerlink" title="SpringBoot整合第三方技术"></a>SpringBoot整合第三方技术</h2><p><strong>注意：</strong>如果使用的第三方技术无法在Spring Initializr中勾选到 则需要手动添加（maven中央仓库中查找）</p>
<h4 id="SpringBoot整合Junit"><a href="#SpringBoot整合Junit" class="headerlink" title="SpringBoot整合Junit"></a>SpringBoot整合Junit</h4><p>使用Spring Initializr创建一个普通的SpringBoot程序（啥都不选） 会自动导入test依赖</p>
<p><strong>这是因为maven创建的项目，生命周期中离不开test的原因，所以不用我们导入它会自动引入。</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">&lt;/dependenc</span><br></pre></td></tr></table></figure>

<p>BookDao.java接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BookImpl.java实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book save&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Springboot05ApplicationTests.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Springboot05ApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookImpl book;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        book.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试类获得结果</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120230704919.png" alt="image-20220120230704919"></p>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>使用测试类时要将测试类放在与classes目录下引导类的路径呈同级或子级关系 否则测试类会找不到**@SpringBootConfiguration**而出现异常，而引导类的注解中包含@SpringBootConfiguration 所以引导类也是一个SpringBootConfiguration。</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ol>
<li><strong>将测试类放在classes目录下与引导类的路径呈同级或是子级关系的包下。</strong></li>
<li>使用@ContextConfiguration(classes&#x3D;…)注解指定引导类</li>
<li><strong>使用@SpringBootTest(classes&#x3D;…)注解指定引导类</strong></li>
</ol>
<h4 id="SpringBoot整合Mybatis"><a href="#SpringBoot整合Mybatis" class="headerlink" title="SpringBoot整合Mybatis"></a>SpringBoot整合Mybatis</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><ol>
<li>使用Spring Initializr创建，<strong>需要勾选SQL中的MySQL Driver和MyBatis Framework，根据需要勾选WEB。</strong></li>
</ol>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120232906258.png" alt="image-20220120232906258"></p>
<p>Mybatis与SpringBoot整合的依赖以及JDBC的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置数据库连接信息</li>
</ol>
<p>application.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/my_db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">devil</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>写实体类</li>
</ol>
<p>Student.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dyw.springboot06mybatis.Domain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Devil</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-01-20-23:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>写StudentDao接口 写入相关操作</li>
</ol>
<p>StudentDao.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentDao</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select id,name,age from student order by id&quot;)</span></span><br><span class="line">    List&lt;Student&gt; <span class="title function_">selectStudents</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不适用配置文件那么则加入**@Mapper**注解 就类似于配置文件 自动代理 在里面使用@Select注解（查找）配置操作 @Update（修改&#x2F;更新）….</p>
<p>执行测试类</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220120234846000.png" alt="image-20220120234846000"></p>
<h5 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h5><p>如果出现了serverTimezone异常 需要在配置文件URL后加入?serverTimezone&#x3D;UTC（时区任意）</p>
<h4 id="SpringBoot整合Mybatis-Plus"><a href="#SpringBoot整合Mybatis-Plus" class="headerlink" title="SpringBoot整合Mybatis-Plus"></a>SpringBoot整合Mybatis-Plus</h4><p>直接导入相应的依赖mybatis-plus-boot-starter即可</p>
<p>并且在配置文件中写上数据库相关配置即可</p>
<hr>
<h4 id="SpringBoot整合Mybatis-Druid"><a href="#SpringBoot整合Mybatis-Druid" class="headerlink" title="SpringBoot整合Mybatis+Druid"></a>SpringBoot整合Mybatis+Druid</h4><p>需要导入druid的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>application.yml配置数据源类型</p>
<p>方式一: 在spring.datasource中配置type为DruidDataSource</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/my_db?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">devil</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br></pre></td></tr></table></figure>

<p>方式二: 直接在spring.datasource.druid中配置数据源信息</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/my_db?serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">devil</span></span><br></pre></td></tr></table></figure>

<p>推荐第二种</p>
<h2 id="SSMP-SpringBoot-Mybatis-Plus-综合案例"><a href="#SSMP-SpringBoot-Mybatis-Plus-综合案例" class="headerlink" title="SSMP(SpringBoot+Mybatis-Plus)综合案例"></a>SSMP(SpringBoot+Mybatis-Plus)综合案例</h2><blockquote>
<ol>
<li><strong>pom.xml</strong>  配置起步依赖</li>
<li><strong>application.yml</strong> 设置数据源 端口 框架技术相关配置等</li>
<li><strong>dao</strong> 继承BaseMapper, 设置@Mapper</li>
<li><strong>dao 测试类</strong></li>
<li><strong>service</strong> 调用数据层接口或Mybatis-Plus提供的接口(ServiceImpl&lt;BookMapper,Book&gt;)快速开发</li>
<li><strong>service测试类</strong></li>
<li><strong>controller</strong> 基于Restful开发, 使用Postman测试跑通功能</li>
<li><strong>页面</strong> 放置在resources目录下的static目录中</li>
</ol>
</blockquote>
<p>使用<strong>Spring Initializr</strong>创建项目 勾选<strong>Spring web</strong> 和 <strong>Mysql Driver</strong> 额外加入依赖<strong>Druid Mybatis-Plus</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建数据库表 创建实体类</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220123202528206.png" alt="image-20220123202528206"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="comment">//@TableName(&quot;tbl_book&quot;)(这里可以选择在application.yml文件中配置mybaits-plus中的table_prefix=tbl_)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(value = &quot;id&quot;,type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/my_db?serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">devil</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">tbl_</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># mybatis-plus 日志配置    </span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure>





<h3 id="表现层消息一致性处理"><a href="#表现层消息一致性处理" class="headerlink" title="表现层消息一致性处理"></a><strong>表现层消息一致性处理</strong></h3><ul>
<li>设计表现层返回结果的模型类,用于后端与前端进行数据格式的同意, 也称为<strong>前后端数据协议</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean flag;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Boolean flag)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Boolean flag, Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Boolean flag,String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>设计同一个返回值结果类型便于前端开发读取数据</li>
<li>返回值结果类型可以根据需求自行设定,没有固定格式</li>
<li>返回值结果模型类用于后端与前端进行数据格式同意, 也称为前后端数据协议</li>
</ol>
<h3 id="异常消息处理"><a href="#异常消息处理" class="headerlink" title="异常消息处理"></a><strong>异常消息处理</strong></h3><p>根据前文我们定义的<strong>前后端数据协议</strong> 如果遇到程序出现<strong>异常</strong> 会给前端返回一个异常数据 这并不在前后端数据协议定义范围 如果要进行消息处理 就必须进行<strong>异常消息处理</strong></p>
<ol>
<li><p>这里就要使用注解**@RestControllerAdvice**(控制器增强)定义SpringMVC异常处理器来处理异常的</p>
</li>
<li><p><strong>@ExceptionHandler</strong>(异常处理器)必须被扫描加载,否则无法生效</p>
</li>
<li><p>表现层返回结果中模型类中添加消息属性用来传递消息到页面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作为springmvc异常处理</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//拦截所有的异常信息</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">doException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        <span class="comment">//记录日志</span></span><br><span class="line">        <span class="comment">//通知运维</span></span><br><span class="line">        <span class="comment">//通知开发</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="string">&quot;服务器故障,请稍后再试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="运维部分"><a href="#运维部分" class="headerlink" title="运维部分"></a><a href="D:\BaiduNetdiskDownload\运维实用篇-资料\PPT\SpringBoot运维实用篇（发布版）.pdf"><strong>运维部分</strong></a></h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220124205028879.png" alt="image-20220124205028879"></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220124205017270.png" alt="image-20220124205017270"></p>
<h3 id="临时属性"><a href="#临时属性" class="headerlink" title="临时属性"></a>临时属性</h3><ol>
<li>使用命令行dos命令运行springboot工程是可以使用临时属性替换配置文件中的属性</li>
<li>临时属性添加方式: java -jar 工程名.jar –属性名&#x3D;值</li>
<li>多个临时属性之间使用空格分隔</li>
<li>临时属性必须是当前boot工程支持的属性,否则设置无效</li>
</ol>
<h3 id="配置文件的四级分类"><a href="#配置文件的四级分类" class="headerlink" title="配置文件的四级分类"></a>配置文件的四级分类</h3><ul>
<li>SpringBoot中4级配置文件(级别越高 优先级越高)</li>
</ul>
<blockquote>
<p>1级： file ：config&#x2F;application.yml  <strong>【最高】</strong> </p>
<p>2级： file ：application.yml</p>
<p>3级：classpath：config&#x2F;application.yml</p>
<p>4级：classpath：application.yml  <strong>【最低】</strong></p>
</blockquote>
<ul>
<li>作用：</li>
</ul>
<blockquote>
<p>1级与2级留做系统打包后设置通用属性，1级常用于运维经理进行线上整体项目部署方案调控</p>
<p>3级与4级用于系统开发阶段设置通用属性，3级常用于项目经理进行整体项目属性调控</p>
</blockquote>
<h3 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h3><ul>
<li>通过启动参数加载配置文件（无需书写配置文件扩展名)</li>
<li><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220125222425964.png" alt="image-20220125222425964"></li>
<li>通过启动参数加载指定文件路径下的配置文件</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220125222635339.png" alt="image-20220125222635339"></p>
<ul>
<li>通过启动参数加载指定文件路径下的配置文件时可以加载多个配置</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220125222709306.png" alt="image-20220125222709306"></p>
<h4 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h4><blockquote>
<ul>
<li><p>单服务器项目：使用自定义配置文件需求较低</p>
</li>
<li><p>多服务器项目：使用自定义配置文件需求较高，将所有配置放置在一个目录中，统一管理</p>
</li>
<li><p>基于SpringCloud技术，所有的服务器将不再设置配置文件，而是通过配置中心进行设定，动态加载配置信息</p>
</li>
</ul>
</blockquote>
<h3 id="多环境开发-YAML版"><a href="#多环境开发-YAML版" class="headerlink" title="多环境开发(YAML版)"></a>多环境开发(YAML版)</h3><h4 id="单配置文件版本"><a href="#单配置文件版本" class="headerlink" title="单配置文件版本"></a>单配置文件版本</h4><ul>
<li><p>多环境开发需要设置若干种常用环境,例如开发 生产 测试环境</p>
</li>
<li><p>yaml格式中设置多环境使用<code>&quot;---&quot;</code>区分环境设置边界</p>
</li>
<li><p>每种环境的区别在于加载的配置属性不同</p>
</li>
<li><p>启用某种环境时需要指定启动时使用该环境</p>
</li>
<li><pre><code class="yml">#生成环境
spring:
  config:
    activate:
      on-profile: pro
</code></pre>
</li>
<li><p>&#96;&#96;&#96;yml<br>#指定环境<br>spring:<br>  profiles:<br>active: test</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  实例</span><br><span class="line"></span><br><span class="line">```yml</span><br><span class="line">#应用环境</span><br><span class="line">#公共配置</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: test</span><br><span class="line">---</span><br><span class="line">#设置环境</span><br><span class="line">#生成环境</span><br><span class="line">spring:</span><br><span class="line">  config:</span><br><span class="line">    activate:</span><br><span class="line">      on-profile: pro</span><br><span class="line">server:</span><br><span class="line">  port: 81</span><br><span class="line">---</span><br><span class="line">#开发环境</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">server:</span><br><span class="line">  port: 82</span><br><span class="line">---</span><br><span class="line">#测试环境</span><br><span class="line">spring:</span><br><span class="line">  config:</span><br><span class="line">    activate:</span><br><span class="line">      on-profile: test</span><br><span class="line">server:</span><br><span class="line">  port: 83</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="多配置文件版本"><a href="#多配置文件版本" class="headerlink" title="多配置文件版本"></a>多配置文件版本</h4><ol>
<li>主启动配置文件 application.yml</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>环境分类配置文件application-pro.yml</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">82</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>环境分类配置文件application-dev.yml</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">81</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>环境分类配置文件application-dev.yml</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">83</span></span><br></pre></td></tr></table></figure>

<p>环境的分类多配置文件其实就是在application后加上<code>-环境名称</code>即可</p>
<ul>
<li>可以独立配置文件定义环境属性</li>
<li>独立配置文件便于线上系统维护更新并保障系统安全性</li>
</ul>
<h3 id="多环境开发-Properties"><a href="#多环境开发-Properties" class="headerlink" title="多环境开发(Properties)"></a><strong>多环境开发(Properties)</strong></h3><p>步骤与yml版一致 只是由于与yml文件的格式不同导致两者的格式不同 </p>
<ul>
<li>但properties版本支支持多文件模式 不支持单一配置文件多环境模式</li>
</ul>
<h3 id="多环境分组管理"><a href="#多环境分组管理" class="headerlink" title="多环境分组管理"></a><strong>多环境分组管理</strong></h3><ul>
<li><p>根据功能对配置文件中的信息进行拆分,并制作成独立的配置文件,命名规则如下(实际开发中)</p>
<ul>
<li>applicaiton-devDB.yml</li>
<li>applicaiton-devRedis.yml</li>
<li>applicaiton-devMVC.yml</li>
</ul>
</li>
<li><p>使用include属性在激活指定环境的情况下,同时对多个环境进行加载使其生效,多个环境间使用逗号分隔(引入一个环境配置文件组)</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">    <span class="attr">include:</span> <span class="string">devDB,devRedis,devMVC</span></span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> 当主环境有相同属性时,当主环境生效;其他环境中有相同属性时,最后加载的环境属性生效</p>
</li>
</ul>
<hr>
<ul>
<li>从SpringBoot2.4版本开始使用group替代了include属性,降低了配置书写量</li>
<li>使用group属性定义多种主环境与子环境的包含关系</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">    <span class="attr">group:</span> </span><br><span class="line">      <span class="attr">&quot;dev&quot;:</span> <span class="string">devDB,devRedis,devMVC</span></span><br><span class="line">      <span class="attr">&quot;pro&quot;:</span> <span class="string">proDB,proRedis,proMVC</span></span><br></pre></td></tr></table></figure>

<p><strong>实际开发中 常使用<code>&quot;group&quot;</code></strong></p>
<p>多环境开发中使用group属性设置配置文件分组,便于线上维护管理</p>
<h3 id="多环境开发控制"><a href="#多环境开发控制" class="headerlink" title="多环境开发控制"></a><strong>多环境开发控制</strong></h3><p><strong>SpringBoot在工作时是基于maven坐标运行的</strong></p>
<ul>
<li>当Maven与SpringBoot同时对多环境进行控制时,以Maven为主,SpringBoot使用<code>@..@</code>占位符读取Maven对应的配置属性值</li>
<li>基于SpringBoot读取Maven配置属性的前提下,如果在Idea下测试工程时p吗.xml每次更新需要手动compile或是刷新Maven方可生效</li>
</ul>
<ol>
<li>需要在Maven的pom.xml中配置多环境属性值</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置多环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span><span class="comment">&lt;!--设置获得profile--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span><span class="comment">&lt;!--是否默认生效--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_pro<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>pro<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在SpringBoot配置文件中指定获取Maven中活动的profile</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">@profile.active@</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a><strong>日志</strong></h3><h4 id="日志基础操作"><a href="#日志基础操作" class="headerlink" title="日志基础操作"></a>日志基础操作</h4><ul>
<li>日志(log)作用<ul>
<li>编程期调试diamagnetic</li>
<li>运营期记录信息<ul>
<li>记录日常运营重要信息(峰值流量 平均响应时长…..)</li>
<li>记录应用报错信息(错误堆栈)</li>
<li>记录运维过程数据(扩容 宕机 报警….)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/log&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Controller3</span> &#123;</span><br><span class="line">    <span class="comment">//创建记录日志的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(Controller3.class);</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doLog</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;debug...&quot;</span>);</span><br><span class="line">        log.error(<span class="string">&quot;error...&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;infor...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;warn...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SpringBoot2 正在运行....&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="日志级别-从上往下依次升高"><a href="#日志级别-从上往下依次升高" class="headerlink" title="日志级别(从上往下依次升高)"></a>日志级别(从上往下依次升高)</h4><blockquote>
<ul>
<li><p><strong>TRACE</strong>：运行堆栈信息，使用率低</p>
</li>
<li><p><strong>DEBUG</strong>：程序员调试代码使用</p>
</li>
<li><p><strong>INFO</strong>：记录运维过程数据</p>
</li>
<li><p><strong>WARN</strong>：记录运维过程报警数据</p>
</li>
<li><p><strong>ERROR</strong>：记录错误堆栈信息</p>
</li>
<li><p><strong>FATAL</strong>：灾难信息，合并计入ERROR</p>
</li>
</ul>
</blockquote>
<p><strong>设置日志输出级别 可以在springboot配置文件中设置</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启debug模式，输出调试信息，常用于检查系统运行状况</span></span><br><span class="line"><span class="attr">debug:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 设置日志级别，root表示根节点，即整体应用日志级别</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

<p><strong>设置日志组,控制指定包对应的日志输出级别,也可以直接空值指定包对应的日志输出级别</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="comment"># 设置日志组</span></span><br><span class="line">  <span class="attr">group:</span></span><br><span class="line"><span class="comment"># 自定义组名，设置当前组中所包含的包</span></span><br><span class="line">    <span class="attr">ebank:</span> <span class="string">com.itheima.controller</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">warn</span></span><br><span class="line"><span class="comment"># 为对应组设置日志级别</span></span><br><span class="line">    <span class="attr">ebank:</span> <span class="string">debug</span></span><br><span class="line"><span class="comment"># 为对包设置日志级别</span></span><br><span class="line">    <span class="attr">com.itheima.controller:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

<h4 id="优化日志对象创建代码"><a href="#优化日志对象创建代码" class="headerlink" title="优化日志对象创建代码"></a>优化日志对象创建代码</h4><ul>
<li>使用lombok提供的注解**@Slf4j**简化开发,减少日志对象的声明操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/log&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Controller3</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doLog</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;debug...&quot;</span>);</span><br><span class="line">        log.error(<span class="string">&quot;error...&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;infor...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;warn...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SpringBoot2 正在运行....&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="日志输出格式"><a href="#日志输出格式" class="headerlink" title="日志输出格式"></a>日志输出格式</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2022-01-26 14:07:21.604  INFO 1416 --- [           main] c.a.d.s.b.a.DruidDataSourceAutoConfigure : Init DruidDataSource</span><br><span class="line">2022-01-26 14:07:21.700  INFO 1416 --- [           main] com.alibaba.druid.pool.DruidDataSource   : &#123;dataSource-1&#125; inited</span><br></pre></td></tr></table></figure>

<p>上述即为日志的默认结构 分为 <strong>时间 日志级别 PID 所属线程 所属类&#x2F;接口名 日志信息</strong></p>
<ul>
<li>PID：进程ID，用于表明当前操作所处的进程，当多服务同时记录日志时，该值可用于协助程序员调试程序</li>
<li>所属类&#x2F;接口名：当前显示信息为SpringBoot重写后的信息，名称过长时，简化包名书写为首字母，甚至直接删除</li>
</ul>
]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2022/02/28/Spring/</url>
    <content><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>spring全家桶：spring ， springmvc ，spring boot , spring cloud </p>
<p>  spring: 出现是在2002左右，解决企业开发的难度。减轻对项目模块之间的管理，<br>          类和类之间的管理， 帮助开发人员创建对象，管理对象之间的关系。<br>             spring核心技术 ioc ， aop 。能实现模块之间，类之间的解耦合。</p>
<span id="more"></span>

<p><strong>耦合</strong>:是指两个或两个以上的体系或两种运动形式间通过相互作用而彼此影响以至联合起来的现象。</p>
<p><strong>解耦合</strong>:指将程序的结构变得松散不是固定的而是可变化的 例如接口的实现类是可以更换的 而直接写的类是顶死的 <strong>解耦就是用数学方法将两种运动分离开来处理问题。</strong>程序的解耦合大概就是让代码和程序不绑定不互相依赖</p>
<p>  依赖：classa中使用classb的属性或者方法， 叫做classa依赖classb</p>
<hr>
<p>框架怎么学： 框架是一个软件，其它人写好的软件。<br> 1）知道框架能做什么， mybatis–访问数据库， 对表中的数据执行增删改查。<br> 2）框架的语法， 框架要完成一个功能，需要一定的步骤支持的，<br> 3）框架的内部实现， 框架内部怎么做。 原理是什么。<br> 4）通过学习，可以实现一个框架。</p>
<h3 id="IOC-反转控制"><a href="#IOC-反转控制" class="headerlink" title="IOC(反转控制)"></a>IOC(反转控制)</h3><p>spring的第一个核心功能 ioc</p>
<p>IoC (Inversion of Control) : 控制反转， 是一个理论，概念，思想。<br> 描述的：把对象的创建，赋值，管理工作都交给代码之外的容器实现， 也就是对象的创建是有其它外部资源完成。</p>
<p>控制： 创建对象，对象的属性赋值，对象之间的关系管理。<br>反转： 把原来的开发人员管理，创建对象的权限转移给代码之外的容器实现。 由容器代替开发人员管理对象。创建对象，<br>        给属性赋值。</p>
<p>正转：由开发人员在代码中，使用new 构造方法创建对象， 开发人员主动管理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">           <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(); <span class="comment">// 在代码中， 创建对象。--正转。</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>容器：是一个服务器软件， 一个框架（spring）</p>
<p>为什么要使用 ioc ： 目的就是减少对代码的改动， 也能实现不同的功能。 实现解耦合。 </p>
<p>java中创建对象有哪些方式：</p>
<ol>
<li>构造方法 ， new Student（）</li>
<li>反射</li>
<li>序列化</li>
<li>克隆</li>
<li>ioc ：容器创建对象</li>
<li>动态代理</li>
</ol>
<p>ioc的体现：<br>   servlet  1： 创建类继承HttpServelt<br>             2:  在web.xml 注册servlet ， 使用<servlet-name> myservlet </servlet-name><br>                                                 <servelt-class>com.bjpwernode.controller.MyServlet1</servlet-class></p>
<pre><code>3. 没有创建 Servlet对象， 没有 MyServlet myservlet = new MyServlet()

4. Servlet 是Tomcat服务器它能你创建的。 Tomcat也称为容器 Tomcat作为容器：里面存放的有Servlet对象， Listener ， Filter对象
</code></pre>
<p>IoC的技术实现 ，<br>  DI 是ioc的技术实现，<br>  DI（Dependency Injection） :依赖注入， 只需要在程序中提供要使用的对象名称就可以， 至于对象如何在容器中创建，<br>                              赋值，查找都由容器内部实现。</p>
<p>spring是使用的di实现了ioc的功能， spring底层创建对象，使用的是<strong>反射机制</strong>。</p>
<p>spring是一个容器，管理对象，给属性赋值， 底层是反射创建对象。</p>
<p><strong>几种一般注入</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        声明Student对象</span></span><br><span class="line"><span class="comment">        注入:就是赋值的意思</span></span><br><span class="line"><span class="comment">        简单类型</span></span><br><span class="line"><span class="comment">        di:给属性赋值</span></span><br><span class="line"><span class="comment">        1.set注入(设置注入):spring调用类的set方法;你可以再set方法中完成属性赋值&lt;property&gt;(普通赋值 调用类中写好的set方法)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba01.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span><span class="comment">&lt;!--调用类中的对应的set方法 setName()--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;丁杨维&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    对引用类型进行set设置注入</span></span><br><span class="line"><span class="comment">    引用类型的set注入:spring调用类的set方法</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba01.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;丁杨维&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;school&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mySchool&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mySchool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba02.School&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;成信大&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;四川成都双流区&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        2.构造注入:spring调用类有参构造方法,再创建对象的同时,在构造方法中给属性赋值.</span></span><br><span class="line"><span class="comment">        构造注入使用&lt;constructor-arg&gt;标签</span></span><br><span class="line"><span class="comment">        &lt;constructor-arg&gt;标签:一个&lt;constructor-arg&gt;标签表示构造方法的一个参数</span></span><br><span class="line"><span class="comment">        &lt;constructor-arg&gt;标签属性:</span></span><br><span class="line"><span class="comment">            name:表示构造方法的形参名</span></span><br><span class="line"><span class="comment">            index:表示构造方法的参数的位置.参数从左往右位置是0,1,2</span></span><br><span class="line"><span class="comment">            value:构造方法的形参类型是简单类型,使用value</span></span><br><span class="line"><span class="comment">            ref:构造方法的形参是引用类性,使用ref;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba01.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;丁杨维&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;school&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mySchool&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用index--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba01.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;丁杨维&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mySchool&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mySchool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba02.School&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cuit&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sccd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--省略index 但要按照0,1,2的顺序--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent02&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba01.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>  <span class="attr">value</span>=<span class="string">&quot;阿丁&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>  <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>  <span class="attr">ref</span>=<span class="string">&quot;mySchool&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>引用类型的自动注入</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        引用类型的自动注入:spring框架根据某些规则可以给引用类型赋值.不用我们自己给引用类型赋值了</span></span><br><span class="line"><span class="comment">        使用的规则常用的是byName,byType</span></span><br><span class="line"><span class="comment">        1.byName(按名称注入):java类中的引用类型的属性名和spring容器中(配置文件)&lt;bean&gt;的id一样</span></span><br><span class="line"><span class="comment">        且数据类型是一致的,这样的容器中的bean,spring能够赋值给引用类型.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--1.ByName--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba03.Student&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;丁杨维&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;school&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba03.School&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cuit&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sccd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        ByType:按类型注入: java中引用的数据类型和spring容器中(配置文件)&lt;bean&gt;的class=&quot;&quot;中的</span></span><br><span class="line"><span class="comment">                            类是同源关系,这样的bean能够赋值给引用类型</span></span><br><span class="line"><span class="comment">                            同源就是一类的意思:</span></span><br><span class="line"><span class="comment">                            1.java类中引用类型的数据类型和bean的class的值是一样的</span></span><br><span class="line"><span class="comment">                            2.java类中引用类型的数据类型和bean的class的值是父子关系.</span></span><br><span class="line"><span class="comment">                            3.java类中引用类型的数据类型和bean的class的值是接口和实现类的关系.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意bean下是常规的set注入除了引用类型(它是由ByType注入)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--2.ByType--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Student01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba04.Student&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;丁杨维&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mSchool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Ba04.School&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cuit&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sccd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>spring-conetxt 和 spring-webmvc是spring中的两个模块</p>
<p>spring-context：是ioc功能的，创建对象的。<br>spring-webmvc做web开发使用的， 是servlet的升级。<br>spring-webmvc中也会用到spring-context中创建对象的功能的。</p>
<p>junit : 单元测试， 一个工具类库，做测试方法使用的。<br>  单元：指定的是方法， 一个类中有很多方法，一个方法称为单元。</p>
<p>  使用单元测试<br>   1.需要加入junit依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>  2.创建测试作用的类：叫做测试类<br>    src&#x2F;test&#x2F;java目录中创建类</p>
<p>  3.创建测试方法</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1）public 方法</span><br><span class="line"> 2）没有返回值 void </span><br><span class="line"> 3）方法名称自定义，建议名称是test + 你要测试方法名称</span><br><span class="line"> 4）方法没有参数</span><br><span class="line"> 5）方法的上面加入 @Test ,这样的方法是可以单独执行的。 不用使用main方法。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ol>
<li>多个配置优势<br> 1.每个文件的大小比一个文件要小很多。效率高<br> 2.避免多人竞争带来的冲突。</li>
</ol>
<p>  如果你的项目有多个模块（相关的功能在一起） ，一个模块一个配置文件。<br>  学生考勤模块一个配置文件，  张三<br>  学生成绩一个配置文件，      李四</p>
<p>  多文件的分配方式：</p>
<ol>
<li>按功能模块，一个模块一个配置文件</li>
<li>按类的功能，数据库相关的配置一个文件配置文件， 做事务的功能一个配置文件， 做service功能的一个配置文件等</li>
</ol>
<h3 id="基于注解的DI"><a href="#基于注解的DI" class="headerlink" title="基于注解的DI"></a>基于注解的DI</h3><p>2.基于注解的di： 通过注解完成java对象创建，属性赋值。<br>  使用注解的步骤：<br>   1.加入maven的依赖 spring-context ，在你加入spring-context的同时， 间接加入spring-aop的依赖。<br>      使用注解必须使用spring-aop依赖</p>
<pre><code>2.在类中加入spring的注解（多个不同功能的注解）

3.在spring的配置文件中，加入一个组件扫描器的标签，说明注解在你的项目中的位置
</code></pre>
<p>   学习的注解：<br>     1.@Component </p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> 用于创建对象 等同于bean的功能</span><br><span class="line">value里的值就等同于&lt;bean&gt;中的id</span><br><span class="line">value的值应当是唯一的 创建的对象在整个spring容器中就一个</span><br><span class="line"></span><br><span class="line">位置:定义类的上面</span><br><span class="line"><span class="meta">@Component(value = &quot;myStudent&quot;)</span></span><br><span class="line">如果就只有value一个参数也可省略value</span><br><span class="line"><span class="meta">@Component(&quot;myStudent&quot;)</span>    </span><br><span class="line">也可不写(中的内容)spring提供默认名称(类的名称但首字母小写)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">一般用第二种</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> 声明组件扫描器(component-scan),组件指的就是java对象</span></span><br><span class="line"><span class="comment"> base-package:指定注解在你项目中的包名</span></span><br><span class="line"><span class="comment"> component-scan工作方式:spring会扫描遍历vase-package指定的包</span></span><br><span class="line"><span class="comment">     把包中和子包中的所有类遍历,找到类中的注解,按照注解的功能,按照注解的功能创建对象,或给属性赋值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--在配置文件中添加一个组件扫描器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw.Ba01&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--组件扫描器指定多个包的三种方式--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--第一种:使用多次组件扫描器,指定不同的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw.Ba01&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw.Ba02&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--第二种:使用分隔符(;或,)分隔多个包名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw.Ba01;com.dyw.Ba02&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--第三种方式:指定父包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>​    2.@Respotory</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(用在持久层上的):放在dao实现类的上面</span><br><span class="line">表示创建dao对象,dao对象是可以访问数据库的.</span><br><span class="line">用法于@Component一致,但还有额外功能</span><br></pre></td></tr></table></figure>

<p>​     3.@Service</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(用在业务层上的):放在service的实现类上面,创建service对象,service对象是做业务处理的,可以有事务功能</span><br><span class="line">用法于@Component一致,但还有额外功能</span><br></pre></td></tr></table></figure>

<p>​     4.@Controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(用在控制器上的):放在控制器(处理器)类的上卖弄,创建控制器对象的,</span><br><span class="line">控制器对象,能够接收用户提交的参数,显示请求的处理结果</span><br><span class="line">用法于@Component一致,但还有额外功能</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>​    <strong>@Respotory(持久层)  @Service(业务层) @Controller(控制层)用于给项目分层</strong></p>
</blockquote>
<p>5.@Value</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@value</span>简单类型的属性赋值</span><br><span class="line">      属性: value 是String类型的,表示简单类型的属性值</span><br><span class="line">      位置:<span class="number">1.</span>在属性定义的上面,无需set方法,推荐使用.</span><br><span class="line">          <span class="number">2.</span>在set方法上面</span><br><span class="line">          </span><br><span class="line">    <span class="meta">@Value(value = &quot;20&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="meta">@Value(value = &quot;丁杨维&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;20&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​     6.@Autowired</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>应用类型赋值</span><br><span class="line">   <span class="meta">@Autowired</span>:spring框架提供的注解,实现引用类型的赋值.</span><br><span class="line">   spring中通过注解给引用类型赋值,使用的是自动注入原理,支持byName,byType</span><br><span class="line">   <span class="meta">@Atuowired</span>:默认使用的是byType自动注入</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Autowired</span>默认属性为  require = <span class="literal">true</span> 表示引用类型赋值失败,程序报错,并终止执行</span><br><span class="line">                        require=<span class="literal">false</span>:引用类型如果赋值失败,程序正常执行,引用类型是<span class="literal">null</span>    </span><br><span class="line">       </span><br><span class="line">       位置:<span class="number">1</span>) 在属性定义的上面,无需set方法,推荐使用</span><br><span class="line">            <span class="number">2</span>) 在set方法的上面</span><br><span class="line">           </span><br><span class="line">   如果使用byName方式 需要做的是:</span><br><span class="line">   <span class="number">1.</span>在属性上面加入<span class="meta">@Autowired</span></span><br><span class="line">   <span class="number">2.</span>在属性的上面加入<span class="meta">@Quallifier(value=&quot;bean的id&quot;)</span>:表示使用指定名称的bean完成赋值</span><br><span class="line">   <span class="comment">//byType    </span></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="meta">@Qualifier(value = &quot;school01&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> School school;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">   <span class="comment">//byName    </span></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="meta">@Qualifier(value = &quot;school01&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> School school;</span><br></pre></td></tr></table></figure>

<p>​     7.@Resource</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">是用之前需要再pom.xml中添加j2ee依赖</span><br><span class="line"><span class="meta">@Resource</span>赋值引用类型: 来自jdk中的注解,spring框架提供了对这个注解的功能的支持,可以使用它给引用类型赋值</span><br><span class="line">     *             使用的也是自动注入原理,支持byName,byType,默认是byName</span><br><span class="line">     * 位置: <span class="number">1</span>)在属性定义的上面,无需set方法,推荐使用</span><br><span class="line">     *       <span class="number">2</span>)在set方法的上面</span><br><span class="line">     *</span><br><span class="line">     * 默认是byName: 先使用byName自动注入,如果byName注入失败,再使用byType</span><br><span class="line">     * 不写(name = <span class="string">&quot;&quot;</span>)是默认属性名 写上就可以指定名称</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">    <span class="meta">@Resource(name = &quot;school03&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> School school;</span><br></pre></td></tr></table></figure>

<h4 id="其他注解"><a href="#其他注解" class="headerlink" title="其他注解"></a>其他注解</h4><p><strong>注解可以通过与配置文件结合的方式解耦合</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">name=丁杨维</span><br><span class="line">age=20</span><br><span class="line"><span class="comment">&lt;!--anno.properites--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw.Ba07&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--将配置文件路劲导入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:anno.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--然后便可再java文件中使用$&#123;&#125;加注解的方式赋值--&gt;</span></span><br><span class="line">public class Student &#123;</span><br><span class="line">    @Value(&quot;$&#123;age&#125;&quot;)</span><br><span class="line">    private int age;</span><br><span class="line">    @Value(&quot;$&#123;name&#125;&quot;)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">但是@Component好像不能使用这个方式赋值 会报错</span><br></pre></td></tr></table></figure>



<p>用户处理请求：<br>   用户form ,参数name ，age—–Servlet(接收请求name，age)—Service类（处理name，age操作）—dao类（访问数据库的）—mysql</p>
<hr>
<h2 id="aop"><a href="#aop" class="headerlink" title="aop"></a><strong>aop</strong></h2><p>1.动态代理<br>  实现方式：jdk动态代理，使用jdk中的Proxy，Method，InvocaitonHanderl创建代理对象。<br>             jdk动态代理要求目标类必须实现接口</p>
<p>  cglib动态代理：第三方的工具库，创建代理对象，原理是继承。 通过继承目标类，创建子类。<br>             子类就是代理对象。 要求目标类不能是final的， 方法也不能是final的</p>
<p>2.动态代理的作用：<br>   1）在目标类源代码不改变的情况下，增加功能。<br>    2）减少代码的重复<br>    3）专注业务逻辑代码<br>    4）解耦合，让你的业务功能和日志，事务非业务功能分离。</p>
<p>3.Aop:面向切面编程， 基于动态代理的，可以使用jdk，cglib两种代理方式。<br>  Aop就是动态代理的规范化， 把动态代理的实现步骤，方式都定义好了，<br>  让开发人员用一种统一的方式，使用动态代理。</p>
<ol start="4">
<li>AOP（Aspect Orient Programming）面向切面编程<br> Aspect: 切面，给你的目标类增加的功能，就是切面。 像上面用的日志，事务都是切面。<br>   切面的特点： 一般都是非业务方法，独立使用的。<br> Orient：面向， 对着。<br> Programming：编程</li>
</ol>
<p>  oop: 面向对象编程</p>
<p>  怎么理解面向切面编程 ？<br>   1）需要在分析项目功能时，找出切面。<br>    2）合理的安排切面的执行时间（在目标方法前， 还是目标方法后）<br>    3）合理的安全切面执行的位置，在哪个类，哪个方法增加增强功能</p>
<p>  术语：<br>   1）Aspect:切面，表示增强的功能， 就是一堆代码，完成某个一个功能。非业务功能，<br>              常见的切面功能有日志， 事务， 统计信息， 参数检查， 权限验证。</p>
<p>   2）JoinPoint:连接点 ，连接业务方法和切面的位置。 就某类中的业务方法,一个类中的每一个方法都是连接点<br>    3）Pointcut : 切入点 ，对连接点的筛选,筛选出需要增强功能的方法<br>    4）目标对象： 给哪个类的方法增加功能， 这个类就是目标对象<br>    5）Advice:通知，通知表示切面功能执行的时间。</p>
<pre><code>说一个切面有三个关键的要素：
1）切面的功能代码，切面干什么
2）切面的执行位置，使用Pointcut表示切面执行的位置
3）切面的执行时间，使用Advice表示时间，在目标方法之前，还是目标方法之后。
</code></pre>
<p> 5.aop的实现<br>   aop是一个规范，是动态的一个规范化，一个标准<br>    aop的技术实现框架：<br>    1.spring：spring在内部实现了aop规范，能做aop的工作。<br>              spring主要在事务处理时使用aop。<br>                 我们项目开发中很少使用spring的aop实现。 因为spring的aop比较笨重。</p>
<p>   2.aspectJ: 一个开源的专门做aop的框架。spring框架中集成了aspectj框架，通过spring就能使用aspectj的功能。<br>      aspectJ框架实现aop有两种方式：<br>       1.使用xml的配置文件 ： 配置全局事务<br>        2.使用注解，我们在项目中要做aop功能，一般都使用注解， aspectj有5个注解。</p>
<p> 6.学习aspectj框架的使用。<br>   1）切面的执行时间， 这个执行时间在规范中叫做Advice(通知，增强)<br>       在aspectj框架中使用注解表示的。也可以使用xml配置文件中的标签</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>:是aspectj框架中的注解</span><br><span class="line">      作用:表示当前类是切面类</span><br><span class="line">      切面类:是用来给业务方法增加功能的类,在这个类中有切面的功能代码</span><br><span class="line">      位置:在类定义的上面</span><br><span class="line">切面类中的方法:</span><br><span class="line">定义方法:实现切面功能的</span><br><span class="line">	 方法的定义要求:</span><br><span class="line">      <span class="number">1.</span>公共方法 <span class="keyword">public</span></span><br><span class="line">      <span class="number">2.</span>方法没有返回值</span><br><span class="line">      <span class="number">3.</span>方法的名称自定义</span><br><span class="line">      <span class="number">4.</span>方法可以有参数,也可以没有参数</span><br><span class="line">           如果有参数,参数不是自定义的,有几个参数类型可以使用</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">     指定通知方法中的参数:JoinPoint</span><br><span class="line">     * JoinPoint:业务方法,要加入切面功能的业务方法</span><br><span class="line">     *      作用是:可以在通知方法中获取方法执行的信息,例如方法的名称,方法的实参.</span><br><span class="line">     *      如果你的切面功能中需要用到方法的信息,就加入JoinPoint.</span><br><span class="line">     *      这个JoinPoint参数的值是由框架赋予的,必须是第一个位置的参数,否装上述功能都没有 程序还会报错</span><br></pre></td></tr></table></figure>

<p>​        1）@Before</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>:表示前置通知</span><br><span class="line">     *      属性:value,是切入点表达式,表示切面的功能执行的位置.</span><br><span class="line">     *      位置:在方法的上面</span><br><span class="line">     *特点:  <span class="number">1.</span>在目标方法之前先执行</span><br><span class="line">     *       <span class="number">2.</span>不会改变目标方法的执行结果</span><br><span class="line">     *       <span class="number">3.</span>不会影响目标方法的执行.</span><br><span class="line">     *      execution(<span class="keyword">public</span> <span class="keyword">void</span> com.dyw.ba01.SomeServiceImpl.doSome(String,Integer)表示切入的位置</span><br></pre></td></tr></table></figure>

<p>​        2）@AfterReturning</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 后置通知定义方法,方法是实现切面功能的.</span><br><span class="line">     * 方法定义要求</span><br><span class="line">     * <span class="number">1.</span>公共方法<span class="keyword">public</span></span><br><span class="line">     * <span class="number">2.</span>方法没有返回值</span><br><span class="line">     * <span class="number">3.</span>方法名称自定义</span><br><span class="line">     * <span class="number">4.</span>方法有参数的,推荐Object,参数名自定义</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="meta">@AfterReturning</span>:后置通知</span><br><span class="line">     *      属性:<span class="number">1.</span>value 切入点表达式</span><br><span class="line">     *          <span class="number">2.</span>returning 自定义变量,表示方法的返回值的.</span><br><span class="line">     *          自定义变量名必须和通知方法的形参一样</span><br><span class="line">     *  .    位置:在方法定义的上面</span><br><span class="line">     * 特点:</span><br><span class="line">     * <span class="number">1</span>在目标方法之后生效</span><br><span class="line">     * <span class="number">2.</span>能够获取到目标方法的返回值,可以根据这个返回值做不同的处理功能</span><br><span class="line">     * <span class="number">3.</span>可以修改返回值</span><br><span class="line">     *</span><br><span class="line">     *</span><br><span class="line">     * 后置通知的执行</span><br><span class="line">     *      <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> doOther();</span><br><span class="line">     *      myAfterReturning(res);</span><br><span class="line">     *      System.out.println(res);     </span><br></pre></td></tr></table></figure>

<p>​        3）@Around</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> * 环绕通知方法的定义格式</span><br><span class="line"> * <span class="number">1.</span><span class="keyword">public</span></span><br><span class="line"> * <span class="number">2.</span>必须要有一个返回值,推荐使用Object</span><br><span class="line"> * <span class="number">3.</span>方法名称自定义</span><br><span class="line"> * <span class="number">4.</span>方法有参数,固定的参数ProceedingJoinPoint</span><br><span class="line"></span><br><span class="line"><span class="meta">@Around</span>: 环绕通知</span><br><span class="line">    属性:value 切入点表达式</span><br><span class="line">    位置:在方法的定义上面</span><br><span class="line">特点:</span><br><span class="line"> <span class="number">1.</span>他是功能最强的通知</span><br><span class="line"> <span class="number">2.</span>在目标方法的前和后都能被调用执行</span><br><span class="line"> <span class="number">3.</span>控制目标方法是否被调用执行</span><br><span class="line"> <span class="number">4.</span>修改原来的目标方法的执行结果.影响最后调用的结果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 环绕通知.等同于jdk动态代理的InvocationHandler接口</span><br><span class="line"></span><br><span class="line"> 参数: ProceedingJoinPoint就等同于jdk动态代理的Method</span><br><span class="line">     作用:执行目标方法的</span><br><span class="line"> 返回值:就是目标方法的执行结果,可以被修改</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      ProceedingJoinPoint是继承了JoinPoint 所以它具有JoinPoint的特性</span><br><span class="line"></span><br><span class="line"> 环绕通知:经常做事务,在目标方法之前开启事务,执行目标方法,在目标方法之后提交事务</span><br><span class="line"><span class="meta">@param</span> proceedingJoinPoint</span><br><span class="line"><span class="meta">@return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        4）@AfterThrowing <strong>异常通知</strong><br>​        5）@After <strong>后置通知</strong></p>
<p><strong>@Pointcut用于指定切入点的别名</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(value = &quot;myPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myBefore01</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Pointcut</span>:定义和管理切入点,如果你的项目中有多个切入点表达式是重复的,可以复用.</span></span><br><span class="line"><span class="comment">     *              可以使用<span class="doctag">@Pointcut</span></span></span><br><span class="line"><span class="comment">     *           属性:value 切入点表达式</span></span><br><span class="line"><span class="comment">     *           位置:自定义方法的上面</span></span><br><span class="line"><span class="comment">     *      特点:</span></span><br><span class="line"><span class="comment">     *          当使用<span class="doctag">@Pointcut</span>定义在一个方法的上面,此时这方法的名称就是切入点表达式的别名.</span></span><br><span class="line"><span class="comment">     *          当其他的通知中,value属性就可以使用这个方法的名称,代替切入点表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;execution(* *..SomeService.doSome(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myPointcut</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//无需代码 只是用该方法名代替切入点表达式</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>   2）表示切面执行的位置，使用的是切入点表达式。</p>
<pre><code>    com.service.impl
    com.bjpowrnode.service.impl
    cn.crm.bjpowernode.service


  execution(* *..service.*.*(..))
</code></pre>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">											readme</span></span><br><span class="line"><span class="code">									用aspectj框架实现aop</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"></span><br><span class="line">使用aop的目的是给已经存在的一些了业务方法,增加额外的功能,前提是不会更改原来类中的方法</span><br><span class="line"></span><br><span class="line"><span class="section">### 使用aspectj实现aop的基本步骤</span></span><br><span class="line"><span class="section">#### 1.新建maven项目</span></span><br><span class="line"><span class="section">####2.加入依赖</span></span><br><span class="line"><span class="bullet"> 1.</span> spring依赖</span><br><span class="line"><span class="bullet"> 2.</span> aspectj依赖</span><br><span class="line"><span class="bullet"> 3.</span> junit单元测试</span><br><span class="line"><span class="section">#### 3.创建目标类:接口和他的实现类</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 4.创建切面类:普通类</span></span><br><span class="line"><span class="bullet"> 1.</span> 在类上面加入注解@Aspect</span><br><span class="line"><span class="bullet"> 2.</span> 在类中定义方法,方法就是切面要执行的功能代码</span><br><span class="line"><span class="code">    在方法上面加入aspectj中的通知注解,例如@Before</span></span><br><span class="line"><span class="code">    有需要指定切入点表达式execution()</span></span><br><span class="line"><span class="code"> </span></span><br><span class="line"><span class="code">#### 5.创建spring配置文件:声明对象,把对象交给容器去统一管理声明对象你可以使用注解或xml配置文件&lt;bean&gt;</span></span><br><span class="line"><span class="code">1. 声明目标对象</span></span><br><span class="line"><span class="code">2. 声明切面类对象</span></span><br><span class="line"><span class="code">3. 声明aspectj框架中的自动代理生成器标签.</span></span><br><span class="line"><span class="code">    自动代理生成器:用来完成代理对象的自动创建功能的.</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section">#### 6.创建测试类,从spring容器中获取目标对象(实际就是代理对象).通过代理执行方法,实现aop的功能</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="mybatis框架和spring集成"><a href="#mybatis框架和spring集成" class="headerlink" title="mybatis框架和spring集成"></a>mybatis框架和spring集成</h3><p>第四章： 把mybatis框架和spring集成在一起，像一个框架一样使用。</p>
<p>用的技术是：ioc 。<br>为什么ioc：能把mybatis和spring集成在一起，像一个框架， 是因为ioc能创建对象。<br> 可以把mybatis框架中的对象交给spring统一创建， 开发人员从spring中获取对象。<br> 开发人员就不用同时面对两个或多个框架了， 就面对一个spring</p>
<p>mybatis使用步骤，对象<br>1.定义dao接口 ，StudentDao<br>2.定义mapper文件 StudentDao.xml<br>3.定义mybatis的主配置文件 mybatis.xml<br>4.创建dao的代理对象， StudentDao dao &#x3D; SqlSession.getMapper(StudentDao.class);</p>
<p>   List<Student> students  &#x3D; dao.selectStudents();</p>
<p>要使用dao对象，需要使用getMapper()方法，<br>怎么能使用getMapper()方法，需要哪些条件<br>1.获取SqlSession对象， 需要使用SqlSessionFactory的openSession()方法。<br>2.创建SqlSessionFactory对象。 通过读取mybatis的主配置文件，能创建SqlSessionFactory对象</p>
<p>需要SqlSessionFactory对象， 使用Factory能获取SqlSession ，有了SqlSession就能有dao ， 目的就是获取dao对象<br>Factory创建需要读取主配置文件</p>
<p>我们会使用独立的连接池类替换mybatis默认自己带的， 把连接池类也交给spring创建。</p>
<p>主配置文件：<br> 1.数据库信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mydev&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--数据库的驱动类名--&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--连接数据库的url字符串--&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/springdb&quot;</span>/&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--访问数据库的用户名--&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--密码--&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p>mapper文件的位置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/bjpowernode/dao/StudentDao.xml&quot;</span>/&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--&lt;mapper resource=&quot;com/bjpowernode/dao/SchoolDao.xml&quot; /&gt;--&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p>通过以上的说明，我们需要让spring创建以下对象<br>1.独立的连接池类的对象， 使用阿里的druid连接池 一般我么只需要配置url,user,password,maxActive(最大连接数);</p>
<p>2.SqlSessionFactory对象</p>
<p>3.创建出dao对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--DruidDataSource大部分属性都是参考DBCP的，如果你原来就是使用DBCP，迁移是十分方便的。--&gt;</span></span><br><span class="line">init-method 这里xml配置文件指定init是为了druid连接池启动时自动执行 destroy-method也是指销毁数据库连接池会制动执行close</span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc_url&#125;&quot;</span> /&gt;</span><span class="comment">&lt;!--可以使用properties文件指定jdbc的url等内容 然后加载 最后使用注解来解耦合或是隐藏敏感信息--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc_user&#125;&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc_password&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;filters&quot;</span> <span class="attr">value</span>=<span class="string">&quot;stat&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWait&quot;</span> <span class="attr">value</span>=<span class="string">&quot;6000&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;60000&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;300000&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnReturn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;poolPreparedStatements&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxOpenPreparedStatements&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;asyncInit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在上面的配置中，通常你需要配置url、username、password，maxActive这三项。</span></span><br><span class="line"><span class="comment">Druid会自动跟url识别驱动类名，如果连接的数据库非常见数据库，配置属性driverClassName</span></span><br><span class="line"><span class="comment">asyncInit是1.1.4中新增加的配置，如果有initialSize数量较多时，打开会加快应用启动时间--&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">                                            mybatis.xml</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置日志--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--设置别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--实体类所在的包名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.dyw.domain&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--name:是包名,是这个包中所有的mapper.xml一次都能加载--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.dyw.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">								applicationContext.xml</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">	 0.使用了properties文件 加载</span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    1.声明数据源 这里用到了上面的druid数据库的spring<span class="tag">&lt;<span class="name">bean</span>&gt;</span>配置</span><br><span class="line">    <span class="comment">&lt;!--声明数据源DataSource ,作用是使用数据库的 这里声明的是DruidDataSource--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.root&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    2.声明SqlSessionFactoryBean(spring-mybatis集成中的类 通过这个工厂类可以创建SqlSessionFactory对象)</span><br><span class="line">    主要是指定数据源 因为mybatis.xml中我们是没有指定的 并且需要将mybatis.xml加载 将配置信息导入里面指定的mapper文件和domian类</span><br><span class="line">    <span class="comment">&lt;!--声明的是mybatis中提供的SqlSessionFactoryBean类,这个类内部创建SqlSessionFactory对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--set注入,把数据库的值付给了dataSource属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis主配置文件的位置</span></span><br><span class="line"><span class="comment">            configLocation属性是Resource类型,读取配置文件</span></span><br><span class="line"><span class="comment">            他的赋值,使用value,指定文件的路径,使用classpath:表示文件的位置</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    3.获取了SqlSessionFactory对象后 需要通过他生成的sqlSession对象 再调用getMapper(Dao.class)方法获取到dao接口的代理对象 让其放入到spring容器中管理</span><br><span class="line">    <span class="comment">&lt;!--创建dao对象,使用sqlSession的getMapper(StudentDao.class)</span></span><br><span class="line"><span class="comment">            MapperScannerConfigurer:在内部调用getMapper()生成每个dao接口的代理对象.</span></span><br><span class="line"><span class="comment">            不用指定id</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指定SqlSessionFactory对象的id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            指定包名,包名是dao接口所在的包名.</span></span><br><span class="line"><span class="comment">            MapperScannerConfigurer会扫描这个包中的所有接口,把每个接口都执行一次getMapper方法,得到每个接口的dao对象.			</span></span><br><span class="line"><span class="comment">            创建好了的dao对象放入到spring的容器中的. 创建好的dao对象的名称时接口的首字母小写</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--简单复习 如果赋值时对象内的属性为简单类型 是使用value赋值 如果时引用对象则是ref--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--之所以扫描dao接口的包 是为了获得dao.class调用getMapper(Dao.class)方法创建dao接口的代理对象--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.dyw.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    4.创建业务类(有业务方法)的对象</span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.service.studentServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;studentDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;studentDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要学习就是上面三个对象的创建语法，使用xml的bean标签。</p>
<p>连接池：多个连接Connection对象的集合， List<Connection>  connlist : connList就是连接池</p>
<p>通常使用Connection访问数据库<br>Connection conn &#x3D;DriverManger.getConnection(url,username,password);<br>Statemenet stmt &#x3D; conn.createStatement(sql);<br>stmt.executeQuery();<br>conn.close();</p>
<p>使用连接池<br>在程序启动的时候，先创建一些Connection<br>Connection c1 &#x3D; …<br>Connection c2 &#x3D; …<br>Connection c3 &#x3D; …<br>List<Connection>  connlist &#x3D; new ArrayLits();<br>connList.add(c1);<br>connList.add(c2);<br>connList.add(c3);</p>
<p>Connection conn &#x3D; connList.get(0);<br>Statemenet stmt &#x3D; conn.createStatement(sql);<br>stmt.executeQuery();<br>把使用过的connection放回到连接池<br>connList.add(conn);</p>
<p>Connection conn1 &#x3D; connList.get(1);<br>Statemenet stmt &#x3D; conn1.createStatement(sql);<br>stmt.executeQuery();<br>把使用过的connection放回到连接池<br>connList.add(conn1);</p>
<hr>
<h2 id="spring的事务处理"><a href="#spring的事务处理" class="headerlink" title="spring的事务处理"></a>spring的事务处理</h2><h3 id="事务的基本要素-4大性质"><a href="#事务的基本要素-4大性质" class="headerlink" title="事务的基本要素 4大性质"></a><strong>事务的基本要素 4大性质</strong></h3><blockquote>
<ol>
<li>原子性:事务开始后的所有操作,要么全部成功,要么全部失败回滚,不可能停滞在中间环节.事务执行过程中出错,会回滚到事务开始之前的状态,所有操作就像没有发生一样.也就是说事务是一个不可分割的整体,就像化学中学过的原子,是事务构成的基本单位.</li>
<li>一致性:事务开始前和结束后,数据库的完整性约束没有被破坏,如A向B转张,不可能出现A扣了钱而B却没有加的情况</li>
<li>隔离性:同一时间,只允许一个事务请求同一数据,不同事务之间彼此没有任何干扰,如A正在从一张银行卡中取钱,在A取钱的过程结束前,B不能向这张卡转账.</li>
<li>持久性:事务完成之后,事务对数据库更新将会被保存写在数据库上,不能回滚.</li>
</ol>
</blockquote>
<p>回答问题<br>1.什么是事务<br>  讲mysql的时候，提出了事务。 事务是指一组sql语句的集合， 集合中有多条sql语句<br>  可能是insert ， update ，select ，delete， 我们希望这些多个sql语句都能成功，<br>  或者都失败， 这些sql语句的执行是一致的，作为一个整体执行。</p>
<p>2.在什么时候想到使用事务<br>  当我的操作，涉及得到多个表，或者是多个sql语句的insert，update，delete。需要保证<br>  这些语句都是成功才能完成我的功能，或者都失败，保证操作是符合要求的。</p>
<p>  在java代码中写程序，控制事务，此时事务应该放在那里呢？<br>     service类的业务方法上，因为业务方法会调用多个dao方法，执行多个sql语句</p>
<p>3.通常使用JDBC访问数据库， 还是mybatis访问数据库怎么处理事务<br>   jdbc访问数据库，处理事务  Connection conn ; conn.commit(); conn.rollback();<br>    mybatis访问数据库，处理事务， SqlSession.commit();  SqlSession.rollback();<br>    hibernate访问数据库，处理事务， Session.commit(); Session.rollback();</p>
<p>4.3问题中事务的处理方式，有什么不足<br>  1)不同的数据库访问技术，处理事务的对象，方法不同，<br>    需要了解不同数据库访问技术使用事务的原理<br>  2)掌握多种数据库中事务的处理逻辑。什么时候提交事务，什么时候回顾事务<br>  3)处理事务的多种方法。</p>
<p>  总结： 就是多种数据库的访问技术，有不同的事务处理的机制，对象，方法。</p>
<p>5.怎么解决不足<br>  spring提供一种处理事务的统一模型， 能使用统一步骤，方式完成多种不同数据库访问技术的事务处理。</p>
<p>  使用spring的事务处理机制，可以完成mybatis访问数据库的事务处理<br>  使用spring的事务处理机制，可以完成hibernate访问数据库的事务处理。</p>
<h3 id="spring事务的属性"><a href="#spring事务的属性" class="headerlink" title="spring事务的属性"></a><strong>spring事务的属性</strong></h3><p>Spring事务属性对应TransactionDefinition类里面的各个方法。TransactionDefinition类方法如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionDefinition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回事务传播行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getPropagationBehavior</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getIsolationLevel</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务超时时间，事务必须在多少秒之内完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getTimeout</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isReadOnly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。事务属性包含了5个方面：传播行为、隔离规则、回滚规则、事务超时、是否只读。</strong></p>
<p>6.处理事务，需要怎么做，做什么<br>  spring处理事务的模型，使用的步骤都是固定的。把事务使用的信息提供给spring就可以了</p>
<p>  1）事务内部提交，回滚事务，使用的事务管理器对象，代替你完成commit，rollback<br>     事务管理器是一个接口和他的众多实现类。<br>      接口：PlatformTransactionManager ，定义了事务重要方法 commit ，rollback<br>      实现类：spring把每一种数据库访问技术对应的事务处理类都创建好了。<br>               mybatis访问数据库—spring创建好的是DataSourceTransactionManager<br>                  hibernate访问数据库—-spring创建的是HibernateTransactionManager</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">怎么使用：你需要告诉spring 你用是那种数据库的访问技术，怎么告诉spring呢？</span><br><span class="line"> 声明数据库访问技术对于的事务管理器实现类， 在spring的配置文件中使用<span class="tag">&lt;<span class="name">bean</span>&gt;</span>声明就可以了</span><br><span class="line"> 例如，你要使用mybatis访问数据库，你应该在xml配置文件中</span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“xxx</span>&quot; <span class="attr">class</span>=<span class="string">&quot;...DataSourceTransactionManager&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<h4 id="Spring事务的隔离级别"><a href="#Spring事务的隔离级别" class="headerlink" title="Spring事务的隔离级别"></a>Spring事务的隔离级别</h4><p>你的业务方法需要什么样的事务，说明需要事务的类型。<br>     说明方法需要的事务：<br>        1）事务的隔离级别：有4个值。<br>        ➢<strong>DEFAULT：采用 DB 默认的事务隔离级别。</strong>MySql 的默认为 REPEATABLE_READ； Oracle默认为 READ_COMMITTED。<br>        ➢ <strong>READ_UNCOMMITTED</strong>：<strong>读未提交</strong>(A事务在执行过程中,读到了B事务修改但未提交的数据,可能会发生B事务未修改回滚但被A事务读取到的情况,出现了<strong>脏读</strong>)。未解决任何并发问题。<br>        ➢ <strong>READ_COMMITTED：读已提交</strong>。解决脏读，存在不可重复读与幻读。<br>        ➢ <strong>REPEATABLE_READ：可重复读</strong>。解决脏读、不可重复读，存在幻读<br>        ➢ <strong>SERIALIZABLE：串行化</strong>(事务A执行完毕后才执行B事务)。不存在并发问题。</p>
<blockquote>
<p> <strong>ISOLATION_SERIALIZABLE(串行化)</strong> 隔离规则类型在开发中很少用到。举个很简单的例子。咱们使用了ISOLATION_SERIALIZABLE规则。A,B两个事务操作同一个数据表并发过来了。A先执行。A事务这个时候会把表给锁住，B事务执行的时候直接报错。</p>
<ol>
<li><p>事务隔离级别为**ISOLATION_READ_UNCOMMITTED(读未提交)**时，写数据只会锁住相应的行。</p>
</li>
<li><p>事务隔离级别为可**ISOLATION_REPEATABLE_READ(可重复读)**时，如果检索条件有索引(包括主键索引)的时候，默认加锁方式是next-key锁；如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。</p>
</li>
<li><p>事务隔离级别为**ISOLATION_SERIALIZABLE(串行化)**时，读写数据都会锁住整张表。</p>
</li>
<li><p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能(隔离级别越高 执行的时间越长)的影响也就越大。</p>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="number">2</span>) 事务的超时时间： 表示一个方法最长的执行时间，如果方法执行时超过了时间，事务就回滚。</span><br><span class="line">	  单位是秒， 整数值， 默认是 -<span class="number">1.</span> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   为了使应用程序很好地运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，也会占用数据库资源。事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>) 事务是否只读:isReadOnly() : <span class="type">boolean</span> <span class="title function_">isReadOnlu</span><span class="params">()</span> <span class="literal">true</span>表示是只读,<span class="literal">false</span>表示非只读</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	如果在一个事务中所有关于数据库的操作都是只读的，也就是说，这些操作只读取数据库中的数据，而并不更新数据,　这个时候我们应该给该事务设置只读属性，这样可以帮助数据库引擎优化事务。提升效率。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>事务的传播行为:</strong> 控制业务方法是不是有事务的， 是什么样的事务的。<br>    7个传播行为，表示你的业务方法调用时，事务在方法之间是如果使用的.</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**当前事务传播行为是REQUIRED时,如果存在一个事务那么直接使用当前事务,如果没有事务,那么就创建一个事务,如:单独MethodB时上下文没有事务,执行时会创建一个新的事务;如果MethodA方法中上下文存在事务,在A中调用B时B会发现上下文中存在事务,MethodB就不会创建一个新的事务,而是直接加入到A的事务中*/</span></span><br><span class="line">	PROPAGATION_REQUIRED</span><br><span class="line">        </span><br><span class="line">	<span class="comment">/** 需要使用 JtaTransactionManager作为事务管理器。 </span></span><br><span class="line"><span class="comment">上下文没有事务,它会开启一个新的事务。如果一个事务已经存在，则先将这个存在的事务挂起。*/</span></span><br><span class="line">	PROPAGATION_REQUIRES_NEW</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/** 如果存在事务,支持当前事务,如果没有事务,则非事务的执行.但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。 */</span></span><br><span class="line">	PROPAGATION_SUPPORTS</span><br><span class="line">	以上三个需要掌握的</span><br><span class="line">	<span class="comment">/** 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。即必须有事务,没有一个事务就抛出异常*/</span></span><br><span class="line">	PROPAGATION_MANDATORY</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 如果一个活动的事务存在，则运行在一个嵌套的事务中。 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行。 */</span>   </span><br><span class="line">	PROPAGATION_NESTED</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/** 总是非事务地执行，如果存在一个活动事务，则抛出异常。*/</span>  </span><br><span class="line">	PROPAGATION_NEVER</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/** 总是非事务地执行，并挂起任何存在的事务。使用PROPAGATION_NOT_SUPPORTED,也需要使用JtaTransactionManager作为事务管理器。 */</span>  </span><br><span class="line">	PROPAGATION_NOT_SUPPORTED  </span><br></pre></td></tr></table></figure>

<p>​    <a href="https://blog.csdn.net/weixin_39625809/article/details/80707695">PROPAGATION_NESTED 与PROPAGATION_REQUIRES_NEW的区别:</a></p>
<p>​    </p>
<ol start="4">
<li><strong>事务提交事务，回滚事务的时机</strong><br> 1）当你的业务方法，执行成功，没有异常抛出，当方法执行完毕，spring在方法执行后提交事务。事务管理器commit</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="number">2</span>）(默认情况下)当你的业务方法抛出运行时异常或<span class="title function_">ERROR</span>(即未受查异常)， spring执行回滚，调用事务管理器的rollback</span><br><span class="line">     运行时异常的定义： <span class="title class_">RuntimeException</span>  和他的子类都是运行时异常， 例如<span class="title class_">NullPointException</span> , <span class="title class_">NumberFormatException</span></span><br><span class="line">  </span><br><span class="line">  <span class="number">3</span>) 当你的业务方法抛出非运行时异常， 主要是受查异常时，提交事务</span><br><span class="line">    受查异常：在你写代码中，必须处理的异常。例如<span class="title class_">IOException</span>, <span class="title class_">SQLException</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	注意:你可以声明事务遇到特定的受查异常时像遇到运行时异常那样回滚,同样,你还可以声明事务遇到特定的异常不回滚,即使这些异常是运行时异常.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>总结spring的事务<br>  1.管理事务的是 事务管理和他的实现类<br>  2.spring的事务是一个统一模型<br>     1）指定要使用的事务管理器实现类，使用<bean></bean>spring容器创建管理对象<br>      2）指定哪些类，哪些方法需要加入事务的功能<br>      3）指定方法需要的隔离级别，传播行为，超时</p>
<pre><code>  你需要告诉spring，你的项目中类信息，方法的名称，方法的事务传播行为。
</code></pre>
<p>spring框架中提供的事务处理方案<br>1.适合中小项目使用的， 注解方案。<br>  spring框架自己用<strong>aop</strong>(aspectj框架的 @Around 环绕依赖)实现给业务方法增加事务的功能， 使用**@Transactional注解**增加事务。<br>  @Transactional注解是spring框架自己注解，放在public方法的上面，表示当前方法具有事务。<br>  可以给注解的属性赋值，表示具体的隔离级别，传播行为，异常信息等等</p>
<p>  使用@Transactional的步骤：<br>  1.需要声明事务管理器对象<br>    <bean id="xx" class="DataSourceTransactionManager"></p>
<hr>
<h3 id="Transactional注解"><a href="#Transactional注解" class="headerlink" title="@Transactional注解"></a><strong>@Transactional注解</strong></h3><h4 id="1-Transactional介绍"><a href="#1-Transactional介绍" class="headerlink" title="1. @Transactional介绍"></a>1. @Transactional介绍</h4><ol>
<li>@Transactional注解 <strong>可以作用于接口、接口方法、类以及类方法上。</strong>当作用于类上时，该类的所有 <strong>public 方法</strong>将都具有该类型的事务属性，同时，<strong>我们也可以在方法级别使用该标注来<em>覆盖</em>类级别的定义。</strong></li>
<li>虽然@Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， @Transactional注解应该<strong>只被应用到 public 方法上</strong>，这是由<strong>Spring AOP的本质决定的</strong>。如果你在 <strong>protected、private 或者默认可见性</strong>的方法上使用 @Transactional 注解，<strong>这将被忽略，也不会抛出任何异常。</strong></li>
<li><strong>默认情况下，只有来自外部的方法调用才会被AOP代理捕获</strong>，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰。</li>
</ol>
<h4 id="2-Transactional注解属性"><a href="#2-Transactional注解属性" class="headerlink" title="2. @Transactional注解属性"></a>2. @Transactional注解属性</h4><ol>
<li>@Transactional注解里面的各个属性和咱们在上面讲的事务属性里面是一一对应的。用来设置<strong>事务的传播行为、隔离规则、回滚规则、事务超时、是否只读</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transactional &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。myBatis是DataSourceTransactionManager 事务管理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;transactionManager&quot;)</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同上。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    String <span class="title function_">transactionManager</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务的传播行为，默认值为 REQUIRED。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Propagation <span class="title function_">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务的隔离规则，默认值采用 DEFAULT mysql中是可重复读。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Isolation <span class="title function_">isolation</span><span class="params">()</span> <span class="keyword">default</span> Isolation.DEFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务超时时间。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">timeout</span><span class="params">()</span> <span class="keyword">default</span> TransactionDefinition.TIMEOUT_DEFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否只读事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">readOnly</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于指定能够触发事务回滚的异常类型 Class对象的数组。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同上，指定类名 这个String类型的数组。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] rollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于指定不会触发事务回滚的异常类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;[] noRollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同上，指定类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] noRollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>value、transactionManager属性</li>
</ol>
<p>​    它们两个是一样的意思。当配置了多个事务管理器时，可以使用该属性指定选择哪个事务管理器。大多数项目只需要一个事务管理器。然而，有些项目为了提高效率、或者有多个完全不同又不相干的数据源，从而使用了多个事务管理器。机智的Spring的Transactional管理已经考虑到了这一点，首先定义多个transactional manager，并为qualifier属性指定不同的值；然后在需要使用@Transactional注解的时候指定TransactionManager的qualifier属性值或者直接使用bean名称。配置和代码使用的例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;datasource1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">&quot;datasource1Tx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;datasource2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">&quot;datasource2Tx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionalService</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Transactional(&quot;datasource1Tx&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSomethingInDatasource1</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Transactional(&quot;datasource2Tx&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomethingInDatasource2</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>propagation属性</strong></p>
<p>propagation用于指定事务的传播行为，默认值为 REQUIRED。propagation有七种类型，就是我们在上文中讲到的事务属性传播行为的七种方式，如下所示:</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>propagation属性</th>
<th>事务属性-传播行为</th>
<th>含义</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>REQUIRED</td>
<td>TransactionDefinition.PROPAGATION_REQUIRED</td>
<td>如果当前没有事务，就新建一个事务，如果已经存在一个事务，则加入到这个事务中。这是最常见的选择。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>SUPPORTS</td>
<td>TransactionDefinition.PROPAGATION_SUPPORTS</td>
<td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>MANDATORY</td>
<td>TransactionDefinition.PROPAGATION_MANDATORY</td>
<td>表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>REQUIRES_NEW</td>
<td>TransactionDefinition.PROPAGATION_REQUIRES_NEW</td>
<td>表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>NOT_SUPPORTED</td>
<td>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</td>
<td>表示该方法不应该运行在事务中。如果当前存在事务，就把当前事务挂起。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>NEVER</td>
<td>TransactionDefinition.PROPAGATION_NEVER</td>
<td>表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>NESTED</td>
<td>TransactionDefinition.PROPAGATION_NESTED</td>
<td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol start="4">
<li><p><strong>isolation属性</strong></p>
<p>​    isolation用于指定事务的隔离规则，默认值为DEFAULT。@Transactional的隔离规则和上文事务属性里面的隔离规则也是一一对应的。总共五种隔离规则，如下所示:</p>
<table>
<thead>
<tr>
<th>@isolation属性</th>
<th>事务属性-隔离规则</th>
<th>含义</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>DEFAULT</td>
<td>TransactionDefinition.ISOLATION_DEFAULT</td>
<td>使用后端数据库默认的隔离级别</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>READ_UNCOMMITTED</td>
<td>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</td>
<td>允许读取尚未提交的数据变更(最低的隔离级别)</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>READ_COMMITTED</td>
<td>TransactionDefinition.ISOLATION_READ_COMMITTED</td>
<td>允许读取并发事务已经提交的数据</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>REPEATABLE_READ</td>
<td>TransactionDefinition.ISOLATION_REPEATABLE_READ</td>
<td>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>TransactionDefinition.ISOLATION_SERIALIZABLE</td>
<td>最高的隔离级别，完全服从ACID的隔离级别，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
</li>
</ol>
<hr>
<ol start="5">
<li><p><strong>timeout</strong></p>
<p>​    timeout用于设置事务的超时属性。</p>
</li>
<li><p><strong>readOnly</strong></p>
<p>​    readOnly用于设置事务是否只读属性。</p>
</li>
<li><p><strong>rollbackFor、rollbackForClassName、noRollbackFor、noRollbackForClassName</strong></p>
<p>​    rollbackFor、rollbackForClassName用于设置那些异常需要回滚；noRollbackFor、noRollbackForClassName用于设置那些异常不需要回滚。他们就是在设置事务的回滚规则。</p>
</li>
</ol>
<h4 id="Transactional注解的使用"><a href="#Transactional注解的使用" class="headerlink" title="@Transactional注解的使用"></a><strong>@Transactional注解的使用</strong></h4><ol>
<li>@Transactional注解内部实现依赖于Spring AOP编程。而AOP在默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为。</li>
<li><strong>@Transactional 注解尽量直接加在方法上</strong>:因为每个方法的执行情况不一样,加载类上的话不能更好地区分每个方法的操作 比如查询只需要readOnly</li>
<li><strong>@Transactional 注解必须添加在public方法上，private、protected方法上是无效的</strong> spring的@Transactional是基于springAOP特性实现</li>
<li><strong>@Transactional注解在外部调用的函数上才有效果，内部调用的函数添加无效，</strong>要切记。这是由AOP的特性决定的。(即在同一个类中只有只有由@Transactional的方法调用另一个方法有效,两个方法都有@Transactional注解只有外部的生效,内部的不生效  <strong>@Transactional注解只有外部调用才有效。</strong>)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">         propagation = Propagation.REQUIRED,</span></span><br><span class="line"><span class="meta">         isolation = Isolation.DEFAULT,</span></span><br><span class="line"><span class="meta">         readOnly = false,</span></span><br><span class="line"><span class="meta">         rollbackFor = &#123;</span></span><br><span class="line"><span class="meta">                 NullPointerException.class,  NotEnoughException.class</span></span><br><span class="line"><span class="meta">         &#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<p>  2.开启事务注解驱动， 告诉spring框架，我要使用注解的方式管理事务。<br>    spring使用aop机制，创建@Transactional所在的类代理对象，给方法加入事务的功能。<br>    spring给业务方法加入事务：<br>        在你的业务方法执行之前，先开启事务，在业务方法之后提交或回滚事务，使用aop的环绕通知</p>
<pre><code>     @Around(&quot;你要增加的事务功能的业务方法名称&quot;)
     Object myAround()&#123;
       开启事务，spring给你开启
          try&#123;
             buy(1001,10);
              spring的事务管理器.commit();
          &#125;catch(Exception e)&#123;
         spring的事务管理器.rollback();
          &#125;
         
     &#125;
</code></pre>
<p>3.在你的方法的上面加入@Trancational 在注解中配置参数</p>
<p>2.适合大型项目，有很多的类，方法，需要大量的配置事务，使用aspectj框架功能，在spring配置文件中<br>  声明类，方法需要的事务。这种方式业务方法和事务配置完全分离。</p>
<p>  实现步骤： 都是在xml配置文件中实现。 即不是用@Apest 和 @Trancational 注解 完全使用xml配置文件<br>   1)要使用的是aspectj框架，需要加入依赖<br>    <dependency><br>        <groupId>org.springframework</groupId><br>        <artifactId>spring-aspects</artifactId><br>        <version>5.2.5.RELEASE</version><br>    </dependency></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">2）声明事务管理器对象</span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;xx&quot;</span> <span class="attr">class</span>=<span class="string">&quot;DataSourceTransactionManager&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<pre><code> 3) 声明方法需要的事务类型（配置方法的事务属性【隔离级别，传播行为，超时】）
 4)  配置aop：指定哪些哪类要创建代理。
</code></pre>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       把数据库的配置信息，写在一个独立的文件，编译修改数据库的配置内容</span></span><br><span class="line"><span class="comment">       spring知道jdbc.properties文件的位置</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明数据源DataSource, 作用是连接数据库的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--set注入给DruidDataSource提供连接数据库信息 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    使用属性配置文件中的数据，语法 $&#123;key&#125; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span><span class="comment">&lt;!--setUrl()--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.passwd&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.max&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明的是mybatis中提供的SqlSessionFactoryBean类，这个类内部创建SqlSessionFactory的</span></span><br><span class="line"><span class="comment">        SqlSessionFactory  sqlSessionFactory = new ..</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--set注入，把数据库连接池付给了dataSource属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;myDataSource&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis主配置文件的位置</span></span><br><span class="line"><span class="comment">           configLocation属性是Resource类型，读取配置文件</span></span><br><span class="line"><span class="comment">           它的赋值，使用value，指定文件的路径，使用classpath:表示文件的位置</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--创建dao对象，使用SqlSession的getMapper（StudentDao.class）</span></span><br><span class="line"><span class="comment">        MapperScannerConfigurer:在内部调用getMapper()生成每个dao接口的代理对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定SqlSessionFactory对象的id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定包名， 包名是dao接口所在的包名。</span></span><br><span class="line"><span class="comment">            MapperScannerConfigurer会扫描这个包中的所有接口，把每个接口都执行</span></span><br><span class="line"><span class="comment">            一次getMapper()方法，得到每个接口的dao对象。</span></span><br><span class="line"><span class="comment">            创建好的dao对象放入到spring的容器中的。 dao对象的默认名称是 接口名首字母小写</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.bjpowernode.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明service--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;buyService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.bjpowernode.service.impl.BuyGoodsServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;goodsDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;goodsDao&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;saleDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;saleDao&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明式事务处理：和源代码完全分离的--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.声明事务管理器对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;myDataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--2.声明业务方法它的事务属性（隔离级别，传播行为，超时时间）</span></span><br><span class="line"><span class="comment">          id:自定义名称，表示 &lt;tx:advice&gt; 和 &lt;/tx:advice&gt;之间的配置内容的</span></span><br><span class="line"><span class="comment">          transaction-manager:事务管理器对象的id 不设置就是默认配置</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--tx:attributes：配置事务属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--tx:method：给具体的方法配置事务属性，method可以有多个，分别给不同的方法设置事务属性</span></span><br><span class="line"><span class="comment">                name:方法名称，1）完整的方法名称，不带有包和类。</span></span><br><span class="line"><span class="comment">                              2）方法可以使用通配符,* 表示任意字符</span></span><br><span class="line"><span class="comment">                propagation：传播行为，枚举值</span></span><br><span class="line"><span class="comment">                isolation：隔离级别</span></span><br><span class="line"><span class="comment">                rollback-for：你指定的异常类名，全限定类名。 发生异常一定回滚</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;buy&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;DEFAULT&quot;</span></span></span><br><span class="line"><span class="tag">                       <span class="attr">rollback-for</span>=<span class="string">&quot;java.lang.NullPointerException,com.bjpowernode.excep.NotEnoughException&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--使用通配符，指定很多的方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRES_NEW&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指定修改方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;modify*&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--删除方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;remove*&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--查询方法，query，search，find--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置aop--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切入点表达式：指定哪些包中类，要使用事务</span></span><br><span class="line"><span class="comment">            id:切入点表达式的名称，唯一值</span></span><br><span class="line"><span class="comment">            expression：切入点表达式，指定哪些类要使用事务，aspectj会创建代理对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            com.bjpowernode.service</span></span><br><span class="line"><span class="comment">            com.crm.service</span></span><br><span class="line"><span class="comment">            com.service</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;servicePt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..service..*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--配置增强器：关联adivce和pointcut</span></span><br><span class="line"><span class="comment">           advice-ref:通知，上面tx:advice哪里的配置</span></span><br><span class="line"><span class="comment">           pointcut-ref：切入点表达式的id</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;servicePt&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="web项目中怎么使用容器对象。"><a href="#web项目中怎么使用容器对象。" class="headerlink" title="web项目中怎么使用容器对象。"></a>web项目中怎么使用容器对象。</h2><ol>
<li><p>做的是javase项目有main方法的，执行代码是执行main方法的，<br>  在main里面创建的容器对象<br>  ApplicationContext ctx &#x3D; new ClassPathXmlApplicationContext(“applicationContext.xml”);</p>
</li>
<li><p>web项目是在tomcat服务器上运行的。 tomcat一起动，项目一直运行的。</p>
</li>
</ol>
<p><strong>需求：</strong><br>web项目中容器对象只需要创建一次，  把容器对象放入到全局作用域ServletContext中。</p>
<p><strong>怎么实现：</strong><br>   使用监听器 当全局作用域对象被创建时 创建容器 存入ServletContext</p>
<pre><code>监听器作用：
1）创建容器对象，执行 ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
2）把容器对象放入到ServletContext， ServletContext.setAttribute(key,ctx)

监听器可以自己创建，也可以使用框架中提供好的ContextLoaderListener


 private WebApplicationContext context;
 public interface WebApplicationContext extends ApplicationContext
</code></pre>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"> ApplicationContext:javase项目中使用的容器对象</span><br><span class="line">WebApplicationContext：web项目中的使用的容器对象</span><br><span class="line"></span><br><span class="line">把创建的容器对象，放入到全局作用域</span><br><span class="line"> key： WebApplicationContext.ROOT<span class="built_in">_</span>WEB<span class="built_in">_</span>APPLICATION<span class="built_in">_</span>CONTEXT<span class="built_in">_</span>ATTRIBUTE</span><br><span class="line">       WebApplicationContext.ROOT<span class="built_in">_</span>WEB<span class="built_in">_</span>APPLICATION<span class="built_in">_</span>CONTEXT<span class="built_in">_</span>ATTRIBUTE</span><br><span class="line"> value：this.context</span><br><span class="line"></span><br><span class="line"> servletContext.setAttribute(WebApplicationContext.ROOT<span class="built_in">_</span>WEB<span class="built_in">_</span>APPLICATION<span class="built_in">_</span>CONTEXT<span class="built_in">_</span>ATTRIBUTE, this.context);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2022/02/28/SpringMVC/</url>
    <content><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a><strong>SpringMVC</strong></h1><p>SpringMVC：是基于spring的一个框架， 实际上就是spring的一个模块， 专门是做web开发的。<br>           理解是servlet的一个升级</p>
<pre><code>   web开发底层是servlet ， 框架是在servlet基础上面加入一些功能，让你做web开发方便。
</code></pre>
<p>SpringMVC就是一个Spring。 Spring是容器，ioc能够管理对象，使用<bean>, @Component, @Repository, @Service, @Controller<br>  SpringMVC能够创建对象， 放入到容器中（SpringMVC容器）， springmvc容器中放的是控制器对象，</p>
<p>  我们要做的是 使用@Contorller创建控制器对象， 把对象放入到springmvc容器中， 把创建的对象作为控制器使用<br>  这个控制器对象能接收用户的请求， 显示处理结果，就当做是一个servlet使用。</p>
<p>  使用@Controller注解创建的是一个普通类的对象， 不是Servlet。 springmvc赋予了控制器对象一些额外的功能。</p>
<p>  web开发底层是servlet， springmvc中有一个对象是Servlet ：DispatcherServlet(中央调度器)<br>  DispatcherServlet: 负责接收用户的所有请求， 用户把请求给了DispatherServlet， 之后DispatcherServlet把请求转发给<br>                    我们的Controller对象， 最后是Controller对象处理请求。</p>
<p>​    <span id="more"></span></p>
<blockquote>
<p>  index.jsp—–DispatcherServlet(Servlet)—-转发，分配给—Controller对象（@Controller注解创建的对象）<br>  main.jsp                                                   MainController<br>  addUser.jsp                                                UserController</p>
</blockquote>
<h3 id="SpringMVC核心-DispatcherServlet"><a href="#SpringMVC核心-DispatcherServlet" class="headerlink" title="SpringMVC核心 DispatcherServlet"></a><strong>SpringMVC核心 DispatcherServlet</strong></h3><h4 id="DispatcherServlet处理流程"><a href="#DispatcherServlet处理流程" class="headerlink" title="DispatcherServlet处理流程"></a>DispatcherServlet处理流程</h4><p><strong>和其他Servlet一样他也是通过Tomcat服务器创建的</strong>需要在web.xml文件中配置这个Servlet类的<servlet>和<servlet-mapping>只有这样Tomcat服务器才知道什么时候去创建这个指定的Servlet </p>
<p><strong>DispatcherServlet</strong>主要负责在tomcat启动的一开始 创建一个Springmvc容器放入ServletContext中, DispatcherServlet初始化时会读取<servlet-name>.xml文件,创建容器和里面的类的实例 比如组件扫描器配置后 @Controller注解所指的类的对象</p>
<p>在整个 Spring MVC 框架中，DispatcherServlet 处于核心位置，它负责协调和组织不同组件完成请求处理并返回响应工作。DispatcherServlet 是 SpringMVC统一的入口，所有的请求都通过它。DispatcherServlet 是前端控制器，配置在web.xml文件中，Servlet依自已定义的具体规则拦截匹配的请求，分发到目标Controller来处理。 初始化 DispatcherServlet时，该框架在web应用程序WEB-INF目录中寻找一个名为[servlet-名称]-servlet.xml的文件，并在那里定义相关的Beans，重写在全局中定义的任何Beans。在看DispatcherServlet 类之前，我们先来看一下请求处理的大致流程：</p>
<blockquote>
<ol>
<li><p>Tomcat 启动，(前提是在&lt;servlet中配置了<load-on-startup>标签 他会告诉tomcat在它启动时实例化该Servlet)对 DispatcherServlet 进行实例化，然后调用它的 init() 进行初始化，在这个初始化过程中完成了：对 web.xml 中初始化参数的加载；建立 WebApplicationContext(SpringMVC的IOC容器)；进行组件的初始化；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DispatcherServlet的初始化会执行init()方法.DispatcherServlet在inti()中&#123;</span><br><span class="line">            <span class="comment">//创建SpringMVC的IOC容器,读取配置文件</span></span><br><span class="line">            <span class="type">WebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;springmvc.xml&quot;</span>);</span><br><span class="line">            <span class="comment">//把容器对象放到ServletContext中(全局作用域)</span></span><br><span class="line">            getServletContext().getAttribute(key,ctx);</span><br><span class="line">                                                                  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>客户端发出请求，由 Tomcat 接收到这个请求，如果匹配 DispatcherServlet 在 web.xml中配置的映射路径，Tomcat 就将请求转交给 DispatcherServlet 处理；</p>
</li>
<li><p>DispatcherServlet 从容器中取出所有 HandlerMapping 实例（每个实例对应一个 HandlerMapping接口的实现类）并遍历，每个 HandlerMapping 会根据请求信息，通过自己实现类中的方式去找到处理该请求的 Handler(执行程序，如 Controller 中的方法)，并且将这个 Handler 与一堆 HandlerInterceptor (拦截器)封装成一个 HandlerExecutionChain 对象，一旦有一个 HandlerMapping 可以找到 Handler则退出循环；</p>
</li>
<li><p>DispatcherServlet 取出 HandlerAdapter 组件，根据已经找到的 Handler，再从所有HandlerAdapter 中找到可以处理该 Handler 的 HandlerAdapter 对象；</p>
</li>
<li><p>执行 HandlerExecutionChain 中所有拦截器的 preHandler()，然后再利用 HandlerAdapter 执行 Handler ，执行完成得到 ModelAndView，再依次调用拦截器的 postHandler()；</p>
</li>
<li><p>利用 ViewResolver 将 ModelAndView 或是 Exception (可解析成 ModelAndView)解析成View，然后 View 会调用 render() 再根据 ModelAndView 中的数据渲染出页面；</p>
</li>
<li><p>最后再依次调用拦截器的 afterCompletion()，这一次请求就结束了。</p>
</li>
</ol>
</blockquote>
<hr>
<h2 id="SpringMVC配置文件"><a href="#SpringMVC配置文件" class="headerlink" title="SpringMVC配置文件"></a><strong>SpringMVC配置文件</strong></h2><p>web,xml配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明,注册springmvc的核心对象DispatcherServlet</span></span><br><span class="line"><span class="comment">        需要在tomcat服务器启动后,创建DispatcherServlet对象的实例</span></span><br><span class="line"><span class="comment">        为什么要创建DispatcherServlet对象的实例呢?</span></span><br><span class="line"><span class="comment">        因为DispatcherServlet在他创建的过程中会同时创建springmvc容器对象</span></span><br><span class="line"><span class="comment">        读取springmvc的配置文件,把这个配置文件中的对象创建好,当用户发起请求时就可以直接直接使用对象了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        servlet的初始化会执行init()方法.DispatcherServlet在inti()中&#123;</span></span><br><span class="line"><span class="comment">            //创建容器,读取配置文件</span></span><br><span class="line"><span class="comment">            WebApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;springmvc.xml&quot;);</span></span><br><span class="line"><span class="comment">            //把容器对象放到ServletContext中</span></span><br><span class="line"><span class="comment">            getServletContext().getAttribute(key,ctx);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--自定义springmvc读取的配置文件的位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--springmvc读取的配置文件的位置的属性--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指定配置文件的位置--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--默认tomcat启动后不创建Servlet对象 只有接收到请求才会创建对象</span></span><br><span class="line"><span class="comment">            为了能够在tomcat启动后,创建Servlet对象 load-on-startup:表示tomcat启动后创建对象的顺序</span></span><br><span class="line"><span class="comment">            ,他的值时整数,数值越小,tomcat创建对象的时间越早,大于等于零的整数</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            使用框架的时候,url-pattern可以使用两种值</span></span><br><span class="line"><span class="comment">            1.使用扩展名,语法*.xxx,xxx是自定义扩展名.常用方式 *.do,*.action,*.mvc等</span></span><br><span class="line"><span class="comment">            表示以xxx结尾的请求都由&lt;servlet-name&gt;对应的servlet处理</span></span><br><span class="line"><span class="comment">            http://localhost:8088/myweb/web.do</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            2.使用&quot;/&quot; 与一般servlet使用无差 即拦截所有请求</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置组件扫描器 配合扫描组件的@Controller和其中的@RequestMapping--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw.controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置视图解析器 原理就是字符串的拼接--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/page/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这是SpringMVC-config.xml;</p>
<hr>
<h2 id="SpringMVC请求处理过程"><a href="#SpringMVC请求处理过程" class="headerlink" title="SpringMVC请求处理过程"></a><strong>SpringMVC请求处理过程</strong></h2><p>springmvc请求的处理流程</p>
<p> 1）发起some.do<br> 2）tomcat(web.xml–url-pattern知道 *.do的请求给DispatcherServlet)<br> 3）DispatcherServlet（根据springmvc.xml配置知道 some.do—doSome()）<br> 4）DispatcherServlet把some.do转发个MyController.doSome()方法<br> 5）框架执行doSome（）把得到ModelAndView进行处理， 转发到show.jsp</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/18868114-b856800a4b003e56.png" alt="img"></p>
<p>上面的过程简化的方式</p>
<p><strong>some.do—DispatcherServlet—MyController</strong></p>
<p>springmvc执行过程源代码分析</p>
<ol>
<li>tomcat启动，创建容器的过程<br>通过load-on-start标签指定的1，创建DisaptcherServlet对象，<br>DisaptcherServlet它的父类是继承HttpServlet的， 它是一个serlvet， 在被创建时，会执行init（）方法。<br>在init（）方法中<br>&#x2F;&#x2F;创建容器，读取配置文件<br> WebApplicationContext ctx &#x3D; new ClassPathXmlApplicationContext(“springmvc.xml”);<br> &#x2F;&#x2F;把容器对象放入到ServletContext中<br> getServletContext().setAttribute(key, ctx);</li>
</ol>
<p>  上面创建容器作用： 创建@controller注解所在的类的对象， 创建MyController对象，<br>   这个对象放入到 springmvc的容器中， 容器是map ， 类似 map.put(“myController”,MyController对象)</p>
<p>2.请求的处理过程<br>  1）执行servlet的service()<br>       protected void service(HttpServletRequest request, HttpServletResponse response)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void doService(HttpServletRequest request, HttpServletResponse response)</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DispatcherServlet.doDispatch(request, response)&#123;</span><br><span class="line"></span><br><span class="line">    调用MyController的.doSome()方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   doDispatch：springmvc中DispatcherServlet的核心方法， 所有的请求都在这个方法中完成的。</p>
<hr>
<h2 id="SpringMVC中的注解"><a href="#SpringMVC中的注解" class="headerlink" title="SpringMVC中的注解"></a><strong>SpringMVC中的注解</strong></h2><h4 id="Controller-控制器"><a href="#Controller-控制器" class="headerlink" title="@Controller(控制器)"></a>@Controller(控制器)</h4><blockquote>
<p>@Controller:创建处理器对象,对象放在springmvc容器中.<br>位置:类的上面<br>和spring中讲的@service和@Component一样</p>
<p>能处理请求的都是控制器(处理器):MyController能处理请,叫做后端控制器(back controller)</p>
</blockquote>
<h4 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h4><blockquote>
<p><strong>表示当前方法为处理器方法。该方法要对 value 属性所指定的 URI进行处理与响应。被注解的方法的方法名可以随意。</strong></p>
<p>@RequestMapping:请求映射:作用是把一个请求地址和一个方法绑定在一起.<br>         一个请求指定一个方法处理<br>    属性: 1.value是一个String,表示请求的uri地址的(some.do). 可以使用数组表示多个请求路径都有这个方法处理<br>         2.value的值必须是唯一的,不能重复. 再使用时推荐地址以”&#x2F;“开头</p>
<p>​            </p>
<pre><code>位置:1.在方法上面,常用的
        2.在类上面
</code></pre>
<p>说明:使用RequestMapping修饰的方法叫做处理器方法或者控制器方法<br>使用@RequestMapping修饰的方法可以处理请求的,类似与Servlet中的doGet() or doPost()</p>
<p>可以在@RequestMapping指定请求的方法 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">@RequestMapping(value = &quot;/some.do&quot;,method = RequestMethod.GET)</span></span><br></pre></td></tr></table></figure>

<p>RequestMethod.GET、RequestMethod.POST</p>
</blockquote>
<p>​    如果不设置就是任意请求方法都能处理不会报405错</p>
<h2 id="请求传参"><a href="#请求传参" class="headerlink" title="请求传参"></a><strong>请求传参</strong></h2><h4 id="处理器方法的参数"><a href="#处理器方法的参数" class="headerlink" title="处理器方法的参数"></a>处理器方法的参数</h4><blockquote>
<p>处理器方法可以包含以下四类参数，这些参数会在系统调用时由系统自动赋值，即程序员可在方法内直接使用。<br>➢ HttpServletRequest<br>➢ HttpServletResponse<br>➢ HttpSession<br>➢ 请求中所携带的请求参数</p>
</blockquote>
<h4 id="方式一-直接在方法中写入与前端页面同样名称的参数（同名匹配规则）"><a href="#方式一-直接在方法中写入与前端页面同样名称的参数（同名匹配规则）" class="headerlink" title="方式一 直接在方法中写入与前端页面同样名称的参数（同名匹配规则）"></a>方式一 直接在方法中写入与前端页面同样名称的参数（同名匹配规则）</h4><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;/springmvc_03/doSome.do&quot;</span>&gt;</span><br><span class="line">        姓名:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span> /&gt;</span><br><span class="line">        年龄:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;age&quot;</span>/&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/doSome.do&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">doSome</span><span class="params">(String name,Integer age)</span>&#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        mv.addObject(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">        mv.addObject(<span class="string">&quot;age&quot;</span>,age);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名:&quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄:&quot;</span>+Integer.valueOf(age));</span><br><span class="line">        mv.setViewName(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方式二-使用-RequestParam-“前台参数名”-注入"><a href="#方式二-使用-RequestParam-“前台参数名”-注入" class="headerlink" title="方式二 使用@RequestParam(“前台参数名”) 注入"></a>方式二 使用@RequestParam(“前台参数名”) 注入</h4><p>防止前台名称与后台名称不一致导致出错 同时也防止同名匹配规则与前台的耦合 利于更好的分离开发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/doSome.do&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">doSome</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String sname, <span class="meta">@RequestParam(&quot;age&quot;)</span> Integer sage)</span>&#123;</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    mv.addObject(<span class="string">&quot;name&quot;</span>,sname);</span><br><span class="line">    mv.addObject(<span class="string">&quot;age&quot;</span>,sage);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;姓名:&quot;</span>+sname);</span><br><span class="line">    System.out.println(<span class="string">&quot;年龄:&quot;</span>+Integer.valueOf(sage));</span><br><span class="line">    mv.setViewName(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>@RequestParam</code> 注解细节：</strong></p>
<blockquote>
<p>该注解有三个变量：**<code>value</code>、<code>required</code>、<code>defaultvalue</code>**</p>
<p><strong>value</strong> ：指定 <code>name</code> 属性的名称是什么，<code>value</code> 属性都可以默认不写</p>
<p><strong>required</strong> ：是否必须要有该参数，可以设置为【true】或者【false】防止出现空指针异常</p>
<p><strong>defaultvalue</strong> ：设置默认值</p>
</blockquote>
<h4 id="方式三-使用模型传参（使用对象）"><a href="#方式三-使用模型传参（使用对象）" class="headerlink" title="方式三 使用模型传参（使用对象）"></a>方式三 使用模型传参（使用对象）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/doSome.do&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">doSome</span><span class="params">(People people)</span>&#123;</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    mv.addObject(<span class="string">&quot;name&quot;</span>,people.getName());</span><br><span class="line">    mv.addObject(<span class="string">&quot;age&quot;</span>,people.getAge());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;姓名:&quot;</span>+people.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;年龄:&quot;</span>+people.getAge());</span><br><span class="line">    mv.setViewName(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用模型传参 要求参数的形参名要和对象的属性名一样,  框架会调用模型类的构造方法 创建一个模型 在调用模型的set方法完成注入 </p>
<p><strong>优点</strong>：可以避免方法参数过多而引起的参数过长，乱而不方便查看，而且可以隐藏信息</p>
<h4 id="注意-："><a href="#注意-：" class="headerlink" title="注意 ："></a>注意 ：</h4><p><strong>中文乱码问题</strong> </p>
<p>这种问题主要出现在POST请求中 对于这种问题如果我们没写一个方法都去写一个setCharacterEncoding的话会 程序会出现很多冗余。</p>
<p>解决方案：使用过滤器 <strong>通过配置 Spring MVC 字符编码过滤器</strong>来解决POST请求传参乱码问题 </p>
<p>**注意:**最好将该过滤器注册在其它过滤器之前。因为过滤器的执行是按照其注册顺序进行的。</p>
<p>在web.xml中配置这样一段</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置过滤器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--设置编码格式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--强制请求的编码为utf-8--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceRequestEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--强制响应的编码为utf-8--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--对所有请求路径都修改编码--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="控制器回显数据"><a href="#控制器回显数据" class="headerlink" title="控制器回显数据"></a><strong>控制器回显数据</strong></h2><p>Controller处理器中的方法返回值为String就代表 视图名  一般用在同步请求</p>
<h4 id="方式一：使用-Spring-MVC-所提供的-ModelAndView-对象"><a href="#方式一：使用-Spring-MVC-所提供的-ModelAndView-对象" class="headerlink" title="方式一：使用 Spring MVC 所提供的 ModelAndView 对象"></a>方式一：使用 Spring MVC 所提供的 ModelAndView 对象</h4><p>​        在使用他之前需要创建一个show.jsp 用来充当视图 前面的演示中也是使用的这样的方式</p>
<p><strong>index.jsp</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;/springmvc_03/doSome.do&quot;</span>&gt;</span><br><span class="line">        姓名:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span> /&gt;</span><br><span class="line">        年龄:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;age&quot;</span>/&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>MyController</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/doSome.do&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">doSome</span><span class="params">(People people)</span>&#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        mv.addObject(<span class="string">&quot;name&quot;</span>,people.getName());</span><br><span class="line">        mv.addObject(<span class="string">&quot;age&quot;</span>,people.getAge());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名:&quot;</span>+people.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄:&quot;</span>+people.getAge());</span><br><span class="line">        mv.setViewName(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>show.jsp</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h3&gt;$&#123;name&#125;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt;$&#123;age&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>结果如图：</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220109182433561.png" alt="image-20220109182433561"></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220109182513274.png" alt="image-20220109182513274"></p>
<h4 id="方式二-使用-Model-对象"><a href="#方式二-使用-Model-对象" class="headerlink" title="方式二 使用 Model 对象"></a>方式二 使用 Model 对象</h4><p>在 Spring MVC 中，我们通常都是使用这样的方式来绑定数据</p>
<p>index.jsp</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a href=<span class="string">&quot;/springmvc_04/some.do&quot;</span>&gt;test1-Model方式回显数据&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>MyController.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/some.do&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doSome</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;这是使用Model方式回显数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;show&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值就是一个就是一个jsp资源可以使用完整路径 也可以使用视图解析器简化</p>
<p>show.jsp</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h3&gt;$&#123;msg&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220109194719801.png" alt="image-20220109194719801"></p>
<h4 id="方式三-使用-ModelAttribute-注解："><a href="#方式三-使用-ModelAttribute-注解：" class="headerlink" title="方式三 使用 @ModelAttribute 注解："></a>方式三 <strong>使用 <code>@ModelAttribute</code> 注解：</strong></h4><p>单独创建一个方法model用于在一开始向Model中添加数据</p>
<p>MyController.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">model</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;这是方式三使用@ModelAttribute&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/some.do&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;show&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这样写就会在访问控制器方法 handleRequest() 时，会首先调用 model() 方法将 <code>message</code> 添加进页面参数中去，在视图中可以直接调用，但是这样写会导致该控制器所有的方法都会首先调用 model() 方法，但同样的也很方便，因为可以加入各种各样的数据。</p>
<h4 id="方式四-使用void-了解"><a href="#方式四-使用void-了解" class="headerlink" title="方式四:使用void(了解)"></a>方式四:使用void(了解)</h4><p>对于处理器方法返回 void 的应用场景，AJAX 响应.</p>
<p>若处理器对请求处理后，无需跳转到其它任何资源，此时可以让处理器方法返回 void。</p>
<p>例如，对于 AJAX 的异步请求的响应。</p>
<h4 id="方式五-使用Object"><a href="#方式五-使用Object" class="headerlink" title="方式五:使用Object"></a>方式五:使用Object</h4><p><strong>主要用于响应Ajax请求</strong></p>
<blockquote>
<p>处理器方法也可以返回 Object 对象。这个 Object 可以是 Integer，String，自定义对象，Map，List 等。但返回的对象不是作为逻辑视图出现的，而是作为直接在页面显示的数据出现的。</p>
<p>返回对象，需要使用@ResponseBody 注解，将转换后的 JSON 数据放入到响应体中。</p>
</blockquote>
<p><strong>环境搭建:</strong></p>
<p>由于返回 Object 数据，一般都是将数据转化为了 JSON 对象后传递给浏览器页面的。而这个由 Object 转换为 JSON，是由 Jackson 工具完成的。所以需要导入 Jackson 的相关 Jar 包。所以需要在maven的pom.xml中添加jackson相关依赖 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>声明注解驱动:</strong></p>
<p>将 Object 数据转化为 JSON 数据，需要由消息转换器 HttpMessageConverter 完成。而转换器的开启，需要由<a href="mvc:annotation-driven/">mvc:annotation-driven/</a>来完成。(注意:一定时路径带有mvc的)</p>
<p>SpringMVC 使用消息转换器实现请求数据和对象，处理器方法返回对象和响应输出之间的自动转换</p>
<p>当 Spring 容器进行初始化过程中，在<a href="mvc:annotation-driven/">mvc:annotation-driven/</a>处创建注解驱动时，默认创建了七个 HttpMessageConverter 对象。也就是说，我们注册<a href="mvc:annotation-driven/">mvc:annotation-driven/</a>，就是为了让容器为我们创建 <strong>HttpMessageConverter</strong> 对象。(对应七个转换不同类型的对象)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">没有加入注解驱动标签时的状态</span><br><span class="line">org.springframework.http.converter.ByteArrayHttpMessageConverter </span><br><span class="line">org.springframework.http.converter.StringHttpMessageConverter</span><br><span class="line">org.springframework.http.converter.xml.SourceHttpMessageConverter</span><br><span class="line">org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter</span><br><span class="line"></span><br><span class="line">加入注解驱动标签时的状态</span><br><span class="line">org.springframework.http.converter.ByteArrayHttpMessageConverter</span><br><span class="line">org.springframework.http.converter.StringHttpMessageConverter</span><br><span class="line">org.springframework.http.converter.ResourceHttpMessageConverter</span><br><span class="line">org.springframework.http.converter.ResourceRegionHttpMessageConverter</span><br><span class="line">org.springframework.http.converter.xml.SourceHttpMessageConverter </span><br><span class="line">org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter </span><br><span class="line">org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverter</span><br><span class="line">org.springframework.http.converter.json.MappingJackson2HttpMessageConverter</span><br></pre></td></tr></table></figure>



<p><strong>HttpMessageConverter 接口 :</strong> HttpMessageConverter<T>是 Spring3.0 新添加的一个接口，负责将请求信息转换为一个对象（类型为 T），将对象（类型为 T）输出为响应信息</p>
<p><em><strong>HttpMessageConverter<T>接口定义的方法：</strong></em></p>
<ol>
<li><p><strong>boolean canRead(Class&lt;?&gt; clazz,MediaType mediaType)</strong>: 指定转换器可以读取的对象类型，即转 换 器 是 否 可 将 请 求 信 息 转 换 为 clazz 类 型 的 对 象 ， 同 时 指 定 支 持 MIME 类 型(text&#x2F;html,applaiction&#x2F;json 等)</p>
</li>
<li><p>**boolean canWrite(Class&lt;?&gt; clazz,MediaType mediaType):**指定转换器是否可将 clazz 类型的对象写到响应流中，响应流支持的媒体类型在 MediaType 中定义。<br> <strong>LIst<MediaType> getSupportMediaTypes()：</strong>该转换器支持的媒体类型</p>
</li>
<li><p><strong>T read(Class&lt;? extends T&gt; clazz,HttpInputMessage inputMessage)：</strong>将请求信息流转换为 T 类型的对象。</p>
</li>
<li><p>**void write(T t,MediaType contnetType,HttpOutputMessgae outputMessage):**将 T 类型的对象写到响应流中，同时指定相应的媒体类型为 contentType</p>
</li>
</ol>
<p>加入注解驱动<a href="mvc:annotation-driven/">mvc:annotation-driven/</a>后适配器类的 messageConverters 属性值</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/18868114-5a5b24aab0a648c9.webp" alt="18868114-5a5b24aab0a648c9"></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/18868114-0248cc96bbce4592.webp" alt="18868114-0248cc96bbce4592"></p>
<p><strong>返回自定义类型对象</strong></p>
<p>返回自定义类型对象时，不能以对象的形式直接返回给客户端浏览器，而是将对象转换为 JSON 格式的数据发送给浏览器的。</p>
<p><strong>在处理器方法上使用@ResponseBody即可使得返回值可以以数据的形式响应</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;myajax.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Student <span class="title function_">doStudentJson</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//创建Student对象</span></span><br><span class="line">    <span class="comment">//返回Student对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>返回其他对象也同样可以按照这个方法</strong></p>
<hr>
<h2 id="客户端跳转-重定向"><a href="#客户端跳转-重定向" class="headerlink" title="客户端跳转(重定向)"></a><strong>客户端跳转(重定向)</strong></h2><h4 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h4><p>​    框架的底层会在我们使用@Controller方法时, 在指定<strong>视图名称和Model</strong>后,帮助我们将<strong>Modl封装到request请求域</strong>中,然后自动调用**request.getRequestDispatcher(“地址”).forward(request, response);**也就是请求转发. 也就是说 这些都是服务端的跳转</p>
<p>​    在学习servlet中我们可知 请求转发是一次请求 用法为<strong>request.getRequestDispatcher(“xx.jsp”).forward()</strong></p>
<p>重定向是两次转发:<strong>response.sendRedirect(“xxx.jsp”)</strong></p>
<p>​    在SpringMVC框架中把原来 Servlet 中的请求转发和重定向操作进行了封装。现在可以使用简单的方式实现转发和重定向。</p>
<h4 id="服务端跳转"><a href="#服务端跳转" class="headerlink" title="服务端跳转"></a>服务端跳转</h4><p>​    前面对框架的介绍时我说过SpringMVC框架在你指定视图名称之后是自动帮你转发到视图资源上的(来让其获得Model中的资源).</p>
<p>​    也可以手动指定只需要在前方加入”forward”即可</p>
<p>**方式一:**以ModelAndView对象的方式返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(...)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">	ModelAndView mv= <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">	</span><br><span class="line">    mv.set(<span class="string">&quot;forward:/...jsp&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**方式二:**以String方式返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(...)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/...jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> **方式三:**以ModelAndView初始化的方式 且 以ModelAndView对象的方式返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(...)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">	ModelAndView mv= <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;forward:/...jsp&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>如何进行客户端跳转?</strong></p>
<p>注意: <strong>ModeAndView的构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当没有模型数据要公开时，方便的构造函数。也可以与 &#123;<span class="doctag">@code</span> addObject&#125; 结合使用。 <span class="doctag">@param</span> viewName 要渲染的视图名		称，由 DispatcherServlet 的 ViewResolver 解析 <span class="doctag">@see</span> addObject</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 	即可以在创建ModelAndView对象时 没有设置返回的ViewName时 可以指定视图路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ModelAndView</span><span class="params">(String viewName)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.view = viewName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**方式一:**MyController.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/jump&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">jump</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;redirect:/jump.jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以在创建 ModelAndView对象时指定重定向的资源(html、jsp、controller、servlet等)路径  </p>
<p>格式为 <strong>ModelAndView mav &#x3D; new ModelAndView(“redirect:&#x2F;资源路径”);</strong> 相当于服务器又发了一次请求但这个不能使用视图解析器 因为这是浏览器发来的另一次请求</p>
<p><strong>方式二:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/jump&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">jump</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        mav.setViewName(<span class="string">&quot;redirect:/jump.jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>方式三:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/jump&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">jump</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/jump.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><blockquote>
<p>​    1. 对于请求转发的页面，可以是WEB-INF中页面；而重定向的页面，是不能为WEB-INF中页的。因为重定向相当于用户再次发出一次请求，而用户是不能直接访问 WEB-INF 中资源的。</p>
</blockquote>
<hr>
<h2 id="解读-lt-url-pattern-gt"><a href="#解读-lt-url-pattern-gt" class="headerlink" title="解读&lt; url-pattern &gt;"></a><strong>解读&lt; url-pattern &gt;</strong></h2><h4 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h4><p><strong>（1） “*.xxx”</strong></p>
<p>​    以指定后缀结尾的请求都交由DispatcherServlet处理</p>
<p><strong>（2） “&#x2F;“</strong></p>
<p>​    “&#x2F;“将会 <strong>覆盖容器的default servlet</strong>, 凡是在web.xml文件中找不到匹配的URL，它们的访问请求都将交给该Servlet处理(静态资源也将会拦截). 所以web.xml没有配置其他特殊路径的servlet, 基本上 <strong>所有的请求</strong>都交由DispatcherServlet处理.但DispacherServlet是不能处理图片这样的静态资源的 但也有解决方法 但还是尽量让交给Tomcat去做</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220110145823608.png" alt="image-20220110145823608"></p>
<p><strong>（3）”&#x2F;*”</strong></p>
<p>​    <code>&#39;/*&#39;</code> <strong>错误的配置</strong>,会拦截 <code>*.jsp, *.jspx</code>的请求, 使用这种配置最终要转发到一个JSP页面,仍然会由DispatcherServlet, 解析jsp地址, 不能根据jsp页面找到handler, 会报错</p>
<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>发起的请求是由哪些服务器程序处理的。</p>
<p><a href="http://localhost:8080/ch05_url_pattern/index.jsp">http://localhost:8080/ch05_url_pattern/index.jsp</a> ：tomcat（jsp底层本质是Servlet）<br><a href="http://localhost:8080/ch05_url_pattern/js/jquery-3.4.1.js">http://localhost:8080/ch05_url_pattern/js/jquery-3.4.1.js</a> ： tomcat<br><a href="http://localhost:8080/ch05_url_pattern/images/p1.jpg">http://localhost:8080/ch05_url_pattern/images/p1.jpg</a> ： tomcat<br><a href="http://localhost:8080/ch05_url_pattern/html/test.html%EF%BC%9A">http://localhost:8080/ch05_url_pattern/html/test.html：</a> tomcat<br><a href="http://localhost:8080/ch05_url_pattern/some.do">http://localhost:8080/ch05_url_pattern/some.do</a> ：  DispatcherServlet（springmvc框架处理的）</p>
<p>tomcat本身能处理静态资源的访问， 像html， 图片， js文件都是静态资源</p>
<h4 id="Tomcat的default"><a href="#Tomcat的default" class="headerlink" title="Tomcat的default"></a>Tomcat的default</h4><p>tomcat的web.xml文件有一个servlet 名称是 default ， 在服务器启动时创建的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>listings<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  表示静态资源和未映射的请求都这个default处理</span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>default这个servlet作用：</strong> </p>
<blockquote>
<p>The default servlet for all web applications, that serves static<br>resources.  It processes all requests that are not mapped to other<br>servlets with servlet mappings (defined either here or in your own<br>web.xml file).</p>
<hr>
<p>所有 Web 应用程序的默认 servlet，提供静态服务<br>资源。它处理所有未映射到其他请求的请求<br>带有 servlet 映射的 servlet（在此处定义或在您自己的<br>web.xml 文件）。</p>
</blockquote>
<ol>
<li>处理静态资源(也就是说Tomcat服务器中的DefaultServlet会处理静态资源)</li>
<li>处理未映射到其它servlet的请求。</li>
</ol>
<h4 id="解决DisPatcherServlet-配置为”-x2F-“-无法处理图片等静态资源的问题"><a href="#解决DisPatcherServlet-配置为”-x2F-“-无法处理图片等静态资源的问题" class="headerlink" title="解决DisPatcherServlet 配置为”&#x2F;“ 无法处理图片等静态资源的问题"></a>解决DisPatcherServlet 配置为”&#x2F;“ 无法处理图片等静态资源的问题</h4><p><url-pattern/>的值并不是说写为&#x2F;后，静态资源就无法访问了。经过一些配置后，该问题也是可以解决的。(.jsp还是可以访问的)</p>
<p><strong>（1） 使用&lt; mvc:default-servlet-handler &#x2F;&gt;</strong></p>
<p>​    声 明 了 <strong>&lt;mvc:default-servlet-handler &#x2F;&gt;</strong> 后 ， springmvc 框 架 会 在 容 器 中 创 建DefaultServletHttpRequestHandler 处理器对象。它会像一个检查员，对进入 DispatcherServlet的 URL 进行筛查，如果发现是静态资源的请求，就将该请求转由 Web 应用服务器默认的Servlet 处理。一般的服务器都有默认的 Servlet。</p>
<p>​    在 Tomcat 中，有一个专门用于处理静态资源访问的 Servlet 名叫 DefaultServlet。其<servlet-name/>为 default。可以处理各种静态资源访问请求。该 Servlet 注册在 Tomcat 服务器的 web.xml 中。在 Tomcat 安装目录&#x2F;conf&#x2F;web.xml。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18868114-31aa480553735354.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/897/format/webp" alt="img"></p>
<p>​    项目：url-pattern-2。在项目 url-pattern 基础上修改。</p>
<p>​    只需要在 springmvc.xml 中添加&lt; mvc:default-servlet-handler&#x2F;&gt;标签即可。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18868114-6cea9309a84d3376.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/589/format/webp" alt="img"></p>
<p>​    &lt; mvc:default-servlet-handler&#x2F;&gt;表示使用 DefaultServletHttpRequestHandler 处理器对象。而该处理器调用了 Tomcat 的 DefaultServlet 来处理静态资源的访问请求。</p>
<p>当然了，要想使用&lt;mvc: …&#x2F;&gt;标签，需要引入 mvc 约束</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18868114-f8b1be1ab1fc19ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/883/format/webp" alt="img"></p>
<p>​    该约束可从 Spring 帮助文档中搜索关键字 spring-mvc.xsd 即可获取：<br> docs&#x2F;spring-framework-reference&#x2F;htmlsingle&#x2F;index.html</p>
<p><strong>（2） 使用&lt; mvc:resources&#x2F;&gt;（掌握）</strong></p>
<p>项目：url-pattern-3。在项目 url-pattern 基础上修改。</p>
<p>​    在 Spring3.0 版本后，Spring 定义了专门用于处理静态资源访问请求的处理器ResourceHttpRequestHandler。并且添加了**&lt; mvc:resources&#x2F;&gt;**标签，专门用于解决静态资源无法访问问题。需要在 springmvc 配置文件中添加如下形式的配置：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18868114-9c8075b366097d7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/729/format/webp" alt="img"></p>
<p>​    location 表示静态资源(webapp-statics)所在目录。当然，目录不要使用&#x2F;WEB-INF&#x2F;及其子目录。</p>
<p>​    mapping 表 示 对 该 资 源 的 请 求 （ 以 &#x2F;images&#x2F; 开 始 的 请 求 ， 如 &#x2F;image&#x2F;beauty.jpg , &#x2F;images&#x2F;car.png 等）。注意，后面是两个星号**。</p>
<p><strong>（3） 声明注解驱动</strong></p>
<p>​    解决动态资源和静态资源冲突的问题，在 springmvc 配置文件加入：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18868114-9226df82b7068704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/463/format/webp" alt="img"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--为了解决静态资源和动态资源冲突的问题,可以加入 &lt;mvc:annotation-driven/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方案一 调用Tomcat的默认Servlet去实现静态资源的请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方案二 通过Springmvc框架去处理静态资源的请求 使用&lt; mvc:resources/&gt;且将静态资源放入webapp下的statics文件夹统一处理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;statics/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/statics/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><ol>
<li><p>使用”&#x2F;“符合当今流行的REST风格</p>
</li>
<li><p>处理静态资源文件时应该将尽可能交给Tomcat服务器去做  可以通过配置&lt; mvc:resources&#x2F;&gt;实现 </p>
</li>
<li><p>我们在配置DisPatcherServlet时 应该尽可能将他的<url-pattern>配置为”*.xxxx”的形式 减少DisPatcherServlet的处理压力 增强其功能</p>
</li>
</ol>
<hr>
<h2 id="相对与绝对路径的问题"><a href="#相对与绝对路径的问题" class="headerlink" title="相对与绝对路径的问题"></a><strong>相对与绝对路径的问题</strong></h2><p>在jsp ， html中使用的地址， 都是在前端页面中的地址，都是相对地址</p>
<p><strong>地址分类：</strong></p>
<ol>
<li><p>绝对地址 ， 带有协议名称的是绝对地址，  <a href="http://www.baidu.com/">http://www.baidu.com</a> , <a href="ftp://202.122.23.1/">ftp://202.122.23.1</a></p>
</li>
<li><p>相对地址， 没有协议开头的， 例如 user&#x2F;some.do  , &#x2F;user&#x2F;some.do<br>          相对地址不能独立使用，必须有一个参考地址。 通过参考地址+相对地址本身才能指定资源。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">张三同学， 1班有张三， 2班也有张三</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>参考地址<ol>
<li>在你的页面中的，访问地址不加 “&#x2F;“</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">访问的是： http://localhost:8080/ch06_path/index.jsp</span><br><span class="line">  路径： http://localhost:8080/ch06_path/</span><br><span class="line">	资源： index.jsp</span><br><span class="line"></span><br><span class="line">在index.jsp发起 user/some.do请求，访问地址变为 http://localhost:8080/ch06_path/user/some.do</span><br><span class="line">   当你的地址 没有斜杠开头,例如 user/some.do , 当你点击链接时， 访问地址是当前页面的地址</span><br><span class="line">	加上链接的地址。</span><br><span class="line">  http://localhost:8080/ch06_path/ + user/some.do</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> index.jsp  访问 user/some.do  ， 返回后现在的地址： http://localhost:8080/ch06_path/user/some.do</span><br><span class="line"></span><br><span class="line"> http://localhost:8080/ch06_path/user/some.do</span><br><span class="line"> 路径：	  http://localhost:8080/ch06_path/user/</span><br><span class="line"> 资源：   some.do</span><br><span class="line"></span><br><span class="line"> 在index.jsp 再访问 user/some.do ，就变为 http://localhost:8080/ch06_path/user/user/some.do</span><br><span class="line"></span><br><span class="line"> 解决方案：</span><br><span class="line">  1.加入$&#123;pageContext.request.contextPath&#125;</span><br><span class="line">2.加入一个base标签， 是html语言中的标签。 表示当前页面中访问地址的基地址。</span><br><span class="line">  你的页面中所有 没有“/”开头的地址，都是以base标签中的地址为参考地址</span><br><span class="line">   使用base中的地址 + user/some.do 组成访问地址</span><br></pre></td></tr></table></figure>

<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>index.jsp</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a href=<span class="string">&quot;user/some.do&quot;</span>&gt;带有不带斜杠的发起请求&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MyController.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user/some.do&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        mv.setViewName(<span class="string">&quot;/index.jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后出现如下问题</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>在你的页面中的，访问地址加 “&#x2F;“<br>    访问的是： <a href="http://localhost:8080/ch06_path/index.jsp">http://localhost:8080/ch06_path/index.jsp</a><br>   路径： <a href="http://localhost:8080/ch06_path/">http://localhost:8080/ch06_path/</a><br>       资源： index.jsp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击 /user/some.do, 访问地址变为 http://localhost:8080/user/some.do</span><br><span class="line">参考地址是 你的服务器地址， 也就是 http://localhost:8080</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果你的资源不能访问： 加入$&#123;pageContext.request.contextPath&#125;</span><br><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/some.do&quot;&gt;发起user/some.do的get请求&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h4><ol>
<li><p>前端页面中href&#x3D;””中最前方加入”&#x2F;“表示为绝对地址 即除去域名端口后的地址包括(&#x2F;项目名&#x2F;资源路径)</p>
</li>
<li><p>前端页面中href&#x3D;””中最前方不加入”&#x2F;“表示为相对地址 即在(1)的基础上还去除了项目名(资源路径)</p>
</li>
<li><p>为了避免使用相对路径出现<img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220110155717000.jpg" alt="image-20220110155717000">的错误可以使用绝对路径 </p>
<blockquote>
<ol>
<li>使用在前面加入完整路径的方式(<a href="http://localhost:8088/%E9%A1%B9%E7%9B%AE%E5%90%8D/%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84)%E7%9A%84%E6%96%B9%E5%BC%8F">http://localhost:8088/项目名/资源路径)的方式</a></li>
<li>在jsp页面中使用${pageContext.request.contextPath}&#x2F;</li>
<li>在jsp页面中使用<base href="http://localhost:8088/项目名/">的方式 他会在所有的请求路径之前加上base中的内容</li>
<li>但前三种始终是静态的 所以第四种为动态地获取 在jsp页面上方加入如下语句</li>
</ol>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    <span class="type">String</span> <span class="variable">basePath</span> <span class="operator">=</span> request.getScheme()+<span class="string">&quot;://&quot;</span></span><br><span class="line">            +request.getServerName()+<span class="string">&quot;:&quot;</span>+</span><br><span class="line">            request.getServerPort()+</span><br><span class="line">            request.getContextPath()+<span class="string">&quot;/&quot;</span>;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>再再base标签中配置&lt;%&#x3D;basePath%&gt;即可 与第三种的区别在于 第四种可以动态获取前方的地址</p>
<p>这些情况都是解决前端请求路径中不加入”&#x2F;“问题的处理方法</p>
<p>如果使用”&#x2F;“就上项目名即可</p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a><strong>SSM整合</strong></h2><h4 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h4><p>SSM 编程，即 SpringMVC + Spring + MyBatis 整合，是当前最为流行的 JavaEE 开发技术架构。其实 SSM 整合的实质，仅仅就是将 MyBatis整合入 Spring。因为 SpringMVC原本就是 Spring的一部分，不用专门整合。</p>
<p>**第一个容器:**SpringMVC容器,管理Controller控制器对象的.</p>
<p>**第二个容器:**Spring容器,管理Service,Dao,工具类对象的.</p>
<p><strong>整合思路就是:</strong></p>
<ol>
<li><p>我们要将使用的对象交给合适的容器去创建、管理,把Controller还有web开发相关的对象交给SpringMVC容器，这些web用的对象写在SpringMVC配置文件中</p>
</li>
<li><p>service，dao对象定义在Spring的配置文件中，让spring创建和创建这些对象</p>
</li>
</ol>
<p><strong>关键：</strong>由于SpringMVC容器时Spring容器的子容器，类似于java中的继承 子是可以访问父的内容的。也就是说springmvc容器中的对象可以访问spring容器中的对象。</p>
<p><strong>SSM 整合的实现方式可分为两种：</strong>基于 XML 配置方式，基于注解方式。</p>
<h4 id="搭建-SSM-开发环境"><a href="#搭建-SSM-开发环境" class="headerlink" title="搭建 SSM 开发环境"></a>搭建 SSM 开发环境</h4><p><strong>一：</strong>搭建SSM开发环境需要 再maven中添加如下依赖</p>
<blockquote>
<ol>
<li><p>Servlet依赖 (J2EE WEB核心)</p>
</li>
<li><p>JSP依赖</p>
</li>
<li><p>SpringMVC依赖</p>
</li>
<li><p>Spring依赖</p>
</li>
<li><p>Mybatis依赖</p>
</li>
<li><p>jackson依赖</p>
</li>
<li><p>mysql依赖</p>
</li>
<li><p>druid依赖</p>
</li>
</ol>
</blockquote>
<p>需要添加的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--servlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--jsp--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--springmvc--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--spring事务的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--事务相关的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--jackson工具包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- spring-mybatis整合用到的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql驱动依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--druid连接池依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>build中需要添加的Resources</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>二：</strong>编写web.xml</p>
<blockquote>
<ol>
<li>创建DispatcherServlet,<ol>
<li>目的创建springmvc容器,才能船舰controller类对象</li>
<li>创建的时Servlet才能接收请求</li>
</ol>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册DispatcherServlet中央调度器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:conf/springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​     配置中央调度器时需要注意，SpringMVC的配置文件名与其它 Spring配置文件名不相同。这样做的目的是 Spring 容器创建管理 Spring 配置文件中的 bean， SpringMVC 容器中负责视图层 bean 的初始。</p>
<hr>
<ol start="2">
<li>创建spring的监听器:ContextLoaderListener<ol>
<li>目的创建spring的容器对象,才能那个创建service,doo等对象.</li>
</ol>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册ContextLoadListener 监听器 用于初始化Spring容器的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:conf/spring.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    注册 ServletContext 监听器的实现类 ContextLoaderListener，用于创建 Spring 容器及将创建好的 Spring 容器对象放入到 ServletContext 的作用域中。</p>
<hr>
<ol start="3">
<li>注册字符集过滤器,解决post请求乱码问题</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册请求字符集过滤器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceRequestEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    注册字符集过滤器，用于解决请求参数中携带中文时产生乱码问题。</p>
</blockquote>
<p>**三:**创建包,Controller包,service,dao,实体类包</p>
<p>**四:**Spring、SpringMVC、Mybatis配置文件</p>
<blockquote>
<ol>
<li>Spring配置文件</li>
<li>SpringMVC配置文件</li>
<li>Mybatis主配置文件</li>
<li>数据库的属性配置文件(.properties)</li>
</ol>
</blockquote>
<p>**五:**编写代码</p>
<ol>
<li><strong>写代码、dao接口、mapper配置文件</strong></li>
<li><strong>Service和实现类、controller、实体类</strong></li>
</ol>
<p><strong>六：</strong>写页面</p>
<h4 id="项目执行流程"><a href="#项目执行流程" class="headerlink" title="项目执行流程"></a>项目执行流程</h4><p>index.jsp–addStudent.jsp—student&#x2F;addStudent.do( service的方法，调用dao的方法)–result.jsp</p>
<hr>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h2><p><strong>异常处理：</strong><br>springmvc框架采用的是统一，全局的异常处理。<br>把controller中的所有异常处理都集中到一个地方。 采用的是aop的思想。把业务逻辑和异常处理代码分开。解耦合。</p>
<p>SpringMVC 框架处理异常的常用方式：使用**@ExceptionHandler** 注解处理异常和**@ControllerAdvice**</p>
<h4 id="ExceptionHandler-注解"><a href="#ExceptionHandler-注解" class="headerlink" title="@ExceptionHandler 注解"></a>@ExceptionHandler 注解</h4><blockquote>
<p>​    使用注解@ExceptionHandler 可以将一个方法指定为异常处理方法。该注解只有一个可选属性 value，为一个 Class&lt;?&gt;数组，用于指定该注解的方法所要处理的异常类，即所要匹配的异常。</p>
<p>​    对于异常处理注解的用法，也可以直接将异常处理方法注解于 Controller 之中。</p>
<p><strong>注意</strong>:如果指定参数那么只处理参数中指定的异常,如果参数为空，则默认为方法参数列表中列出的任何异常</p>
</blockquote>
<h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法:"></a>使用方法:</h5><blockquote>
<p>​    定义在Controller类的方法上(一般不用在由@RequestMapping的方法上),在方法上面加入**@ExceptionHandler 注解**并且根据需求指定参数即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doException</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>​    不过,一般不这样使用,而是将异常处理方法专门定义在一个类中,作为全局的异常处理类.    这时需要使用注解**@ControllerAdvice**</p>
</blockquote>
<h4 id="ControllerAdvice注解"><a href="#ControllerAdvice注解" class="headerlink" title="@ControllerAdvice注解"></a>@ControllerAdvice注解</h4><blockquote>
<p>​    字面理解就是“控制器增强”，是给控制器对象增强功能的。使用@ControllerAdvice 修饰的类中可以使用**@ExceptionHandler**。</p>
<p>​    当使用**@RequestMapping** 注解修饰的方法抛出异常时，会执行**@ControllerAdvice** 修饰的类中的异常处理方法。</p>
<p>​    <strong>@ControllerAdvice</strong> 是使用**@Component** 注解修饰的，可以&lt; context:component-scan&gt;扫描到@ControllerAdvice 所在的类路径(包名)，创建对象。</p>
</blockquote>
<h5 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法:"></a>使用方法:</h5><blockquote>
<p>定义在一个类的上面 然后里面的方法使用**@ExceptionHandler注解**, 表示异常处理方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionController</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doException</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringMVC.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">使用@ControllerAdvice注解需要注册注解驱动</span><br><span class="line"><span class="comment">&lt;!--声明组件扫描器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw.Controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.dyw.Execp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注册注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>


</blockquote>
<hr>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a><strong>拦截器</strong></h2><h4 id="拦截器-1"><a href="#拦截器-1" class="headerlink" title="拦截器"></a>拦截器</h4><p>​    SpringMVC 中的 Interceptor 拦截器是非常重要和相当有用的，它的主要作用是拦截指定的用户请求，并进行相应的预处理与后处理。其拦截的时间点在“处理器映射器根据用户提交的请求映射出了所要执行的处理器类，并且也找到了要执行该处理器类的处理器适配器，在处理器适配器执行处理器之前”。当然，在处理器映射器映射出所要执行的处理器类时，已经将拦截器与处理器组合为了一个处理器执行链，并返回给了中央调度器。</p>
<h4 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h4><p>​    自定义拦截器，需要实现 HandlerInterceptor 接口。而该接口中含有三个方法：</p>
<blockquote>
<p>➢ <strong>preHandle(request,response, Object handler)：</strong><br> 该方法在处理器方法执行之前执行。其返回值为 boolean，若为 true，则紧接着会执行处理器方法，且会将 afterCompletion()方法放入到一个专门的方法栈中等待执行。</p>
<p>➢ <strong>postHandle(request,response, Object handler,modelAndView)：</strong><br> 该方法在处理器方法执行之后执行。处理器方法若最终未被执行，则该方法不会执行。由于该方法是在处理器方法执行完后执行，且该方法参数中包含 ModelAndView，所以该方法可以修改处理器方法的处理结果数据，且可以修改跳转方向。</p>
<p>➢ <strong>afterCompletion(request,response, Object handler, Exception ex)：</strong><br> 当 preHandle()方法返回 true 时，会将该方法放到专门的方法栈中，等到对请求进行响应的所有工作完成之后才执行该方法。即该方法是在中央调度器渲染（数据填充）了响应页面之后执行的，此时对 ModelAndView 再操作也对响应无济于事。</p>
<p><strong>afterCompletion 最后执行的方法，清除资源，例如在 Controller 方法中加入数据</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行MyInterceptor-------preHandle()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行MyInterceptor-------postHandle()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行MyInterceptor-------afterCompletion()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>拦截器中的方法与处理器方法的执行顺序如下：（会在请求到达处理器方法之前进行拦截的预处理，也会在处理器方法返回后响应前进行后处理）</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/18868114-b27c6ef989f87246.webp" alt="18868114-b27c6ef989f87246"></p>
<h4 id="注册拦截器"><a href="#注册拦截器" class="headerlink" title="注册拦截器"></a>注册拦截器</h4><p>需要在SpringMVC.xml配置文件中 注册拦截器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册拦截器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Interceptor.MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中 &lt; mvc:mapping&#x2F;&gt;用于指定当前所注册的拦截器可以拦截的请求路径，而&#x2F;**表示拦截所有请求。</p>
<p>MyController.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/some.do&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">doSome</span><span class="params">(String name, Integer age, HttpSession session)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行MyController处理器方法&quot;</span>);</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;myname&quot;</span>,name);</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;myage&quot;</span>,age);</span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;atter&quot;</span>,<span class="string">&quot;session中的数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220110213638275.png" alt="image-20220110213638275"></p>
<h4 id="多个拦截器的执行"><a href="#多个拦截器的执行" class="headerlink" title="多个拦截器的执行"></a>多个拦截器的执行</h4><p>再创建一个拦截器 Myinterceptor2.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor2</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;124&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;125&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个拦截器可以注册再一个&lt; mvc:interceptors&gt;&lt; &#x2F;mvc:interceptors&gt;中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册多个拦截器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Interceptor.MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.dyw.Interceptor.MyInterceptor2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>执行情况：</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220110214156717.png" alt="image-20220110214156717"></p>
<p><strong>可以推断出 一个请求的拦截会依次经过注册的拦截器 且拦截器的处理顺序与注册顺序有关</strong></p>
<blockquote>
<p>当有多个拦截器时，形成拦截器链。拦截器链的执行顺序，与其注册顺序一致。需要再次强调一点的是，当某一个拦截器的 preHandle()方法返回 true 并被执行到时，会向一个专门的方法栈中放入该拦截器的 afterCompletion()方法。</p>
</blockquote>
<p>多个拦截器中方法与处理器方法的执行顺序如下：</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/18868114-97a75714642e9b19.png" alt="img"></p>
<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>我们将第一个拦截器的preHandle（）方法返回值设为false</p>
<p>执行结果</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220110214845745.png" alt="image-20220110214845745"></p>
<p>可以发现 后面的的Interceptor没有执行结合上图（多个拦截器执行情况图）可知 只要有一个 preHandle()方法返回 false，则上部的执行链将被断开，其后续的处理器方法与 postHandle()方法将无法执行。但，无论执行链执行情况怎样，只要方法栈中有方法，即执行链中只要有 preHandle()方法返回 true，就会执行方法栈中的afterCompletion()方法。最终都会给出响应。</p>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>可以用作检查用户权限 当用户访问一个资源时可以通过注册拦截器的方式 去检测用户的权限、用户登录处理和记录日志</p>
<p>例如：只有经过登录的用户方可访问处理器，否则，将返回“无权访问”提示。</p>
<h4 id="解惑："><a href="#解惑：" class="headerlink" title="解惑："></a>解惑：</h4><p><strong>拦截器与过滤器的区别：</strong></p>
<ol>
<li><p>过滤器是servlet中的对象，  拦截器是框架中的对象</p>
</li>
<li><p>过滤器实现Filter接口的对象， 拦截器是实现HandlerInterceptor</p>
</li>
<li><p>过滤器是用来设置request，response的参数，属性的，侧重对数据过滤的。<br>拦截器是用来验证请求的，能截断请求。</p>
</li>
<li><p>过滤器是在拦截器之前先执行的。</p>
</li>
<li><p>过滤器是tomcat服务器创建的对象<br>拦截器是springmvc容器中创建的对象</p>
</li>
<li><p>过滤器是一个执行时间点。<br>  拦截器有三个执行时间点</p>
</li>
<li><p>过滤器可以处理jsp，js，html等等<br>拦截器是侧重拦截对Controller的对象。 如果你的请求不能被DispatcherServlet接收， 这个请求不会执行拦截器内容</p>
</li>
<li><p>拦截器拦截普通类方法执行，过滤器过滤servlet请求响应</p>
</li>
</ol>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p><strong>拦截器：</strong></p>
<ol>
<li>拦截器是springmvc中的一种，需要实现HandlerInterceptor接口。</li>
<li>拦截器和过滤器类似，功能方向侧重点不同。 过滤器是用来过滤器请求参数，设置编码字符集等工作。<br>拦截器是拦截用户的请求，做请求做判断处理的。</li>
<li>拦截器是全局的，可以对多个Controller做拦截。 一个项目中可以有0个或多个拦截器， 他们在一起拦截用户的请求。<br>拦截器常用在：用户登陆验证，权限验证，日志记录</li>
</ol>
<p><strong>拦截器的使用步骤：</strong><br> 1.定义类实现HandlerInterceptor接口<br> 2.在springmvc配置文件中，声明拦截器， 让框架知道拦截器的存在。</p>
<p><strong>拦截器的执行时间：</strong><br>  1）在请求处理之前， 也就是controller类中的方法执行之前先被拦截。<br>  2）在控制器方法执行之后也会执行拦截器。<br>  3）在请求处理完成后也会执行拦截器。</p>
<p><strong>拦截器：看做是多个Controller中公用的功能，集中到拦截器统一处理。使用的aop的思想</strong></p>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity</title>
    <url>/2022/02/28/SpringSecurity/</url>
    <content><![CDATA[<h1 id="SpringSecurity从入门到精通"><a href="#SpringSecurity从入门到精通" class="headerlink" title="SpringSecurity从入门到精通"></a>SpringSecurity从入门到精通</h1><h2 id="0-简介"><a href="#0-简介" class="headerlink" title="0. 简介"></a>0. 简介</h2><p>​    <strong>Spring Security</strong> 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架<strong>Shiro</strong>，它提供了更丰富的功能，社区资源也比Shiro丰富。</p>
<p>​    一般来说中大型的项目都是使用<strong>SpringSecurity</strong> 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。</p>
<p>​     一般Web应用的需要进行<strong>认证</strong>和<strong>授权</strong>。</p>
<p>​        <strong>认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户</strong></p>
<p>​        <strong>授权：经过认证后判断当前用户是否有权限进行某个操作</strong></p>
<p>​    而认证和授权也是SpringSecurity作为安全框架的核心功能。</p>
<span id="more"></span>

<h2 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1. 快速入门"></a>1. 快速入门</h2><h3 id="1-1-准备工作"><a href="#1-1-准备工作" class="headerlink" title="1.1 准备工作"></a>1.1 准备工作</h3><p>​    我们先要搭建一个简单的SpringBoot工程</p>
<p>① 设置父工程 添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>② 创建启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SecurityApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>③ 创建Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="1-2-引入SpringSecurity"><a href="#1-2-引入SpringSecurity" class="headerlink" title="1.2 引入SpringSecurity"></a>1.2 引入SpringSecurity</h3><p>​    在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。</p>
<p>​    必须登陆之后才能对接口进行访问。</p>
<h2 id="2-认证"><a href="#2-认证" class="headerlink" title="2. 认证"></a>2. 认证</h2><h3 id="2-1-登陆校验流程"><a href="#2-1-登陆校验流程" class="headerlink" title="2.1 登陆校验流程"></a>2.1 登陆校验流程</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20211215094003288.png" alt="img"></p>
<h3 id="2-2-原理初探"><a href="#2-2-原理初探" class="headerlink" title="2.2 原理初探"></a>2.2 原理初探</h3><p>​    想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。</p>
<h4 id="2-2-1-SpringSecurity完整流程"><a href="#2-2-1-SpringSecurity完整流程" class="headerlink" title="2.2.1 SpringSecurity完整流程"></a>2.2.1 SpringSecurity完整流程</h4><p>​    SpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20211214144425527.png" alt="img"></p>
<p>​    图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。</p>
<p><strong>UsernamePasswordAuthenticationFilter</strong>:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。</p>
<p><strong>ExceptionTranslationFilter：</strong>处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。</p>
<p><strong>FilterSecurityInterceptor：</strong>负责权限校验的过滤器。</p>
<p>​    </p>
<p>​    我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220313204443234.png" alt="img"></p>
<h4 id="2-2-2-认证流程详解"><a href="#2-2-2-认证流程详解" class="headerlink" title="2.2.2 认证流程详解"></a>2.2.2 认证流程详解</h4><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20211214151515385.png" alt="img"></p>
<p>概念速查:</p>
<p>Authentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。</p>
<p>AuthenticationManager接口：定义了认证Authentication的方法 </p>
<p>UserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。</p>
<p>UserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。</p>
<h3 id="2-3-解决问题"><a href="#2-3-解决问题" class="headerlink" title="2.3 解决问题"></a>2.3 解决问题</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20211215095331510.png" alt="img"></p>
<h4 id="2-3-1-思路分析"><a href="#2-3-1-思路分析" class="headerlink" title="2.3.1 思路分析"></a>2.3.1 思路分析</h4><p>登录</p>
<p>​    ①自定义登录接口  </p>
<p>​                调用ProviderManager的方法进行认证 如果认证通过生成jwt</p>
<p>​                把用户信息存入redis中</p>
<p>​    ②自定义UserDetailsService </p>
<p>​                在这个实现类中去查询数据库</p>
<p>校验：</p>
<p>​    ①定义Jwt认证过滤器</p>
<p>​                获取token</p>
<p>​                解析token获取其中的userid</p>
<p>​                从redis中获取用户信息</p>
<p>​                存入SecurityContextHolder</p>
<h4 id="2-3-2-准备工作"><a href="#2-3-2-准备工作" class="headerlink" title="2.3.2 准备工作"></a>2.3.2 准备工作</h4><p>①添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--fastjson依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--jwt依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>② 添加Redis相关配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JavaType;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.type.TypeFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.SerializationException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis使用FastJson序列化</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastJsonRedisSerializer</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">RedisSerializer</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Charset</span> <span class="variable">DEFAULT_CHARSET</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; clazz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastJsonRedisSerializer</span><span class="params">(Class&lt;T&gt; clazz)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.clazz = clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] serialize(T t) <span class="keyword">throws</span> SerializationException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> SerializationException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span> || bytes.length &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, DEFAULT_CHARSET);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(str, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> JavaType <span class="title function_">getJavaType</span><span class="params">(Class&lt;?&gt; clazz)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TypeFactory.defaultInstance().constructType(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span></span><br><span class="line">    &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="type">FastJsonRedisSerializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FastJsonRedisSerializer</span>(Object.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setValueSerializer(serializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hash的key也采用StringRedisSerializer的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setHashValueSerializer(serializer);</span><br><span class="line"></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③ 响应类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonInclude;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseResult</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提示信息，如果有错误时，前端可以获取该字段进行提示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询到的结果数据，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResponseResult</span><span class="params">(Integer code, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResponseResult</span><span class="params">(Integer code, T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(Integer code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResponseResult</span><span class="params">(Integer code, String msg, T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>④工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.JwtBuilder;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JWT工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有效期为</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">JWT_TTL</span> <span class="operator">=</span> <span class="number">60</span> * <span class="number">60</span> *<span class="number">1000L</span>;<span class="comment">// 60 * 60 *1000  一个小时</span></span><br><span class="line">    <span class="comment">//设置秘钥明文</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JWT_KEY</span> <span class="operator">=</span> <span class="string">&quot;sangeng&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getUUID</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成jtw</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject token中要存放的数据（json格式）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String subject)</span> &#123;</span><br><span class="line">        <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getJwtBuilder(subject, <span class="literal">null</span>, getUUID());<span class="comment">// 设置过期时间</span></span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成jtw</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject token中要存放的数据（json格式）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ttlMillis token超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String subject, Long ttlMillis)</span> &#123;</span><br><span class="line">        <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getJwtBuilder(subject, ttlMillis, getUUID());<span class="comment">// 设置过期时间</span></span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JwtBuilder <span class="title function_">getJwtBuilder</span><span class="params">(String subject, Long ttlMillis, String uuid)</span> &#123;</span><br><span class="line">        <span class="type">SignatureAlgorithm</span> <span class="variable">signatureAlgorithm</span> <span class="operator">=</span> SignatureAlgorithm.HS256;</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> generalKey();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(nowMillis);</span><br><span class="line">        <span class="keyword">if</span>(ttlMillis==<span class="literal">null</span>)&#123;</span><br><span class="line">            ttlMillis=JwtUtil.JWT_TTL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">expMillis</span> <span class="operator">=</span> nowMillis + ttlMillis;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">expDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(expMillis);</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setId(uuid)              <span class="comment">//唯一的ID</span></span><br><span class="line">                .setSubject(subject)   <span class="comment">// 主题  可以是JSON数据</span></span><br><span class="line">                .setIssuer(<span class="string">&quot;sg&quot;</span>)     <span class="comment">// 签发者</span></span><br><span class="line">                .setIssuedAt(now)      <span class="comment">// 签发时间</span></span><br><span class="line">                .signWith(signatureAlgorithm, secretKey) <span class="comment">//使用HS256对称加密算法签名, 第二个参数为秘钥</span></span><br><span class="line">                .setExpiration(expDate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ttlMillis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String id, String subject, Long ttlMillis)</span> &#123;</span><br><span class="line">        <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getJwtBuilder(subject, ttlMillis, id);<span class="comment">// 设置过期时间</span></span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> <span class="string">&quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg&quot;</span>;</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> parseJWT(token);</span><br><span class="line">        System.out.println(claims);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成加密后的秘钥 secretKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SecretKey <span class="title function_">generalKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(encodedKey, <span class="number">0</span>, encodedKey.length, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseJWT</span><span class="params">(String jwt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> generalKey();</span><br><span class="line">        <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">                .setSigningKey(secretKey)</span><br><span class="line">                .parseClaimsJws(jwt)</span><br><span class="line">                .getBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCache</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存基本的对象，Integer、String、实体类等</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 缓存的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">setCacheObject</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> T value)</span></span><br><span class="line">    &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存基本的对象，Integer、String、实体类等</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 缓存的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeUnit 时间颗粒度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">setCacheObject</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> T value, <span class="keyword">final</span> Integer timeout, <span class="keyword">final</span> TimeUnit timeUnit)</span></span><br><span class="line">    &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置有效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true=设置成功；false=设置失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">expire</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="type">long</span> timeout)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置有效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true=设置成功；false=设置失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">expire</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="type">long</span> timeout, <span class="keyword">final</span> TimeUnit unit)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.expire(key, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的基本对象。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存键值对应的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getCacheObject</span><span class="params">(<span class="keyword">final</span> String key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue();</span><br><span class="line">        <span class="keyword">return</span> operation.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除单个对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteObject</span><span class="params">(<span class="keyword">final</span> String key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除集合对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> collection 多个对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">deleteObject</span><span class="params">(<span class="keyword">final</span> Collection collection)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.delete(collection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存List数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataList 待缓存的List数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">long</span> <span class="title function_">setCacheList</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> List&lt;T&gt; dataList)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForList().rightPushAll(key, dataList);</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= <span class="literal">null</span> ? <span class="number">0</span> : count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的list对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存键值对应的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">getCacheList</span><span class="params">(<span class="keyword">final</span> String key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().range(key, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存Set</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSet 缓存的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存数据的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; BoundSetOperations&lt;String, T&gt; <span class="title function_">setCacheSet</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> Set&lt;T&gt; dataSet)</span></span><br><span class="line">    &#123;</span><br><span class="line">        BoundSetOperations&lt;String, T&gt; setOperation = redisTemplate.boundSetOps(key);</span><br><span class="line">        Iterator&lt;T&gt; it = dataSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            setOperation.add(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setOperation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的set</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Set&lt;T&gt; <span class="title function_">getCacheSet</span><span class="params">(<span class="keyword">final</span> String key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存Map</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">setCacheMap</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> Map&lt;String, T&gt; dataMap)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dataMap != <span class="literal">null</span>) &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, dataMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的Map</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Map&lt;String, T&gt; <span class="title function_">getCacheMap</span><span class="params">(<span class="keyword">final</span> String key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往Hash中存入数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hKey Hash键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">setCacheMapValue</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String hKey, <span class="keyword">final</span> T value)</span></span><br><span class="line">    &#123;</span><br><span class="line">        redisTemplate.opsForHash().put(key, hKey, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Hash中的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hKey Hash键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Hash中的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getCacheMapValue</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String hKey)</span></span><br><span class="line">    &#123;</span><br><span class="line">        HashOperations&lt;String, String, T&gt; opsForHash = redisTemplate.opsForHash();</span><br><span class="line">        <span class="keyword">return</span> opsForHash.get(key, hKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除Hash中的数据</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hkey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delCacheMapValue</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String hkey)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">HashOperations</span> <span class="variable">hashOperations</span> <span class="operator">=</span> redisTemplate.opsForHash();</span><br><span class="line">        hashOperations.delete(key, hkey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取多个Hash中的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hKeys Hash键集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Hash对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">getMultiCacheMapValue</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> Collection&lt;Object&gt; hKeys)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().multiGet(key, hKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的基本对象列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern 字符串前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对象列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;String&gt; <span class="title function_">keys</span><span class="params">(<span class="keyword">final</span> String pattern)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.keys(pattern);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebUtils</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字符串渲染到客户端</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response 渲染对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string 待渲染的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">renderString</span><span class="params">(HttpServletResponse response, String string)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            response.setStatus(<span class="number">200</span>);</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">            response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            response.getWriter().print(string);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑤实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户表(User)实体类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 三更</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">40356785423868312L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 主键</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用户名</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 昵称</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 密码</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 账号状态（0正常 1停用）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 邮箱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 手机号</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String phonenumber;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用户性别（0男，1女，2未知）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 头像</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String avatar;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用户类型（0管理员，1普通用户）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String userType;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建人的用户id</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Long createBy;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建时间</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 更新人</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Long updateBy;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 更新时间</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 删除标志（0代表未删除，1代表已删除）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Integer delFlag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-3-3-实现"><a href="#2-3-3-实现" class="headerlink" title="2.3.3 实现"></a>2.3.3 实现</h4><h5 id="2-3-3-1-数据库校验用户"><a href="#2-3-3-1-数据库校验用户" class="headerlink" title="2.3.3.1 数据库校验用户"></a>2.3.3.1 数据库校验用户</h5><p>​    从之前的分析我们可以知道，我们可以自定义一个UserDetailsService,让SpringSecurity使用我们的UserDetailsService。我们自己的UserDetailsService可以从数据库中查询用户名和密码。</p>
<h6 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h6><p>​    我们先创建一个用户表， 建表语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `sys_user` (</span><br><span class="line">  `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">  `user_name` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;用户名&#x27;,</span><br><span class="line">  `nick_name` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;昵称&#x27;,</span><br><span class="line">  `password` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;密码&#x27;,</span><br><span class="line">  `status` CHAR(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;账号状态（0正常 1停用）&#x27;,</span><br><span class="line">  `email` VARCHAR(64) DEFAULT NULL COMMENT &#x27;邮箱&#x27;,</span><br><span class="line">  `phonenumber` VARCHAR(32) DEFAULT NULL COMMENT &#x27;手机号&#x27;,</span><br><span class="line">  `sex` CHAR(1) DEFAULT NULL COMMENT &#x27;用户性别（0男，1女，2未知）&#x27;,</span><br><span class="line">  `avatar` VARCHAR(128) DEFAULT NULL COMMENT &#x27;头像&#x27;,</span><br><span class="line">  `user_type` CHAR(1) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;用户类型（0管理员，1普通用户）&#x27;,</span><br><span class="line">  `create_by` BIGINT(20) DEFAULT NULL COMMENT &#x27;创建人的用户id&#x27;,</span><br><span class="line">  `create_time` DATETIME DEFAULT NULL COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `update_by` BIGINT(20) DEFAULT NULL COMMENT &#x27;更新人&#x27;,</span><br><span class="line">  `update_time` DATETIME DEFAULT NULL COMMENT &#x27;更新时间&#x27;,</span><br><span class="line">  `del_flag` INT(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志（0代表未删除，1代表已删除）&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27;</span><br></pre></td></tr></table></figure>

<p>​        引入MybatisPuls和mysql驱动的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        配置数据库信息</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p>​        定义Mapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        修改User实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名上加<span class="meta">@TableName(value = &quot;sys_user&quot;)</span> ,id字段上加 <span class="meta">@TableId</span></span><br></pre></td></tr></table></figure>

<p>​        配置Mapper扫描</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.sangeng.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleSecurityApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(SimpleSecurityApplication.class);</span><br><span class="line">        System.out.println(run);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        添加junit依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>​       测试MP是否能正常使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUserMapper</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="核心代码实现"><a href="#核心代码实现" class="headerlink" title="核心代码实现"></a>核心代码实现</h6><p>创建一个类实现UserDetailsService接口，重写其中的方法。更加用户名从数据库中查询用户信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="comment">//根据用户名查询用户信息</span></span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        wrapper.eq(User::getUserName,username);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectOne(wrapper);</span><br><span class="line">        <span class="comment">//如果查询不到数据就通过抛出异常来给出提示</span></span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(user))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//TODO 根据用户查询权限信息 添加到LoginUser中</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//封装成UserDetails对象返回 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginUser</span>(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为UserDetailsService方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginUser</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getUserName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。</p>
<p>这样登陆的时候就可以用sg作为用户名，1234作为密码来登陆了。</p>
<h5 id="2-3-3-2-密码加密存储"><a href="#2-3-3-2-密码加密存储" class="headerlink" title="2.3.3.2 密码加密存储"></a>2.3.3.2 密码加密存储</h5><p>​    实际项目中我们不会把密码明文存储在数据库中。</p>
<p>​    默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。</p>
<p>​    我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。</p>
<p>​    我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。</p>
<p>​    我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-3-3-登陆接口"><a href="#2-3-3-3-登陆接口" class="headerlink" title="2.3.3.3 登陆接口"></a>2.3.3.3 登陆接口</h5><p>​    接下我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。</p>
<p>​    在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器。</p>
<p>​    认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginServcie loginServcie;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseResult <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loginServcie.login(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                <span class="comment">//关闭csrf</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">//不通过Session获取SecurityContext</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 对于登录接口 允许匿名访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()</span><br><span class="line">                <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">LoginServcie</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ResponseResult <span class="title function_">login</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(user.getUserName(),user.getPassword());</span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authenticate</span> <span class="operator">=</span> authenticationManager.authenticate(authenticationToken);</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(authenticate))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用userid生成token</span></span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authenticate.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> loginUser.getUser().getId().toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> JwtUtil.createJWT(userId);</span><br><span class="line">        <span class="comment">//authenticate存入redis</span></span><br><span class="line">        redisCache.setCacheObject(<span class="string">&quot;login:&quot;</span>+userId,loginUser);</span><br><span class="line">        <span class="comment">//把token响应给前端</span></span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;token&quot;</span>,jwt);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseResult</span>(<span class="number">200</span>,<span class="string">&quot;登陆成功&quot;</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="2-3-3-4-认证过滤器"><a href="#2-3-3-4-认证过滤器" class="headerlink" title="2.3.3.4 认证过滤器"></a>2.3.3.4 认证过滤器</h5><p>​    我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。</p>
<p>​    使用userid去redis中获取对应的LoginUser对象。</p>
<p>​    然后封装Authentication对象存入SecurityContextHolder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(token)) &#123;</span><br><span class="line">            <span class="comment">//放行</span></span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析token</span></span><br><span class="line">        String userid;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseJWT(token);</span><br><span class="line">            userid = claims.getSubject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;token非法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从redis中获取用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> <span class="string">&quot;login:&quot;</span> + userid;</span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> redisCache.getCacheObject(redisKey);</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(loginUser))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存入SecurityContextHolder</span></span><br><span class="line">        <span class="comment">//TODO 获取权限信息封装到Authentication中</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(loginUser,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                <span class="comment">//关闭csrf</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">//不通过Session获取SecurityContext</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 对于登录接口 允许匿名访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()</span><br><span class="line">                <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把token校验过滤器添加到过滤器链中</span></span><br><span class="line">        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="2-3-3-5-退出登陆"><a href="#2-3-3-5-退出登陆" class="headerlink" title="2.3.3.5 退出登陆"></a>2.3.3.5 退出登陆</h5><p>​    我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">LoginServcie</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ResponseResult <span class="title function_">login</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(user.getUserName(),user.getPassword());</span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authenticate</span> <span class="operator">=</span> authenticationManager.authenticate(authenticationToken);</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(authenticate))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用userid生成token</span></span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authenticate.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> loginUser.getUser().getId().toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> JwtUtil.createJWT(userId);</span><br><span class="line">        <span class="comment">//authenticate存入redis</span></span><br><span class="line">        redisCache.setCacheObject(<span class="string">&quot;login:&quot;</span>+userId,loginUser);</span><br><span class="line">        <span class="comment">//把token响应给前端</span></span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;token&quot;</span>,jwt);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseResult</span>(<span class="number">200</span>,<span class="string">&quot;登陆成功&quot;</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ResponseResult <span class="title function_">logout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authentication.getPrincipal();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userid</span> <span class="operator">=</span> loginUser.getUser().getId();</span><br><span class="line">        redisCache.deleteObject(<span class="string">&quot;login:&quot;</span>+userid);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseResult</span>(<span class="number">200</span>,<span class="string">&quot;退出成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="3-授权"><a href="#3-授权" class="headerlink" title="3. 授权"></a>3. 授权</h2><h3 id="3-0-权限系统的作用"><a href="#3-0-权限系统的作用" class="headerlink" title="3.0 权限系统的作用"></a>3.0 权限系统的作用</h3><p>​    例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。</p>
<p>​    总结起来就是<strong>不同的用户可以使用不同的功能</strong>。这就是权限系统要去实现的效果。</p>
<p>​    我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。</p>
<p>​    所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。</p>
<p>​    </p>
<h3 id="3-1-授权基本流程"><a href="#3-1-授权基本流程" class="headerlink" title="3.1 授权基本流程"></a>3.1 授权基本流程</h3><p>​    在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。</p>
<p>​    所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。</p>
<p>​    然后设置我们的资源所需要的权限即可。</p>
<h3 id="3-2-授权实现"><a href="#3-2-授权实现" class="headerlink" title="3.2 授权实现"></a>3.2 授权实现</h3><h4 id="3-2-1-限制访问资源所需权限"><a href="#3-2-1-限制访问资源所需权限" class="headerlink" title="3.2.1 限制访问资源所需权限"></a>3.2.1 限制访问资源所需权限</h4><p>​    SpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。</p>
<p>​    但是要使用它我们需要先开启相关配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br></pre></td></tr></table></figure>

<p>​    然后就可以使用对应的注解。@PreAuthorize</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;test&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-封装权限信息"><a href="#3-2-2-封装权限信息" class="headerlink" title="3.2.2 封装权限信息"></a>3.2.2 封装权限信息</h4><p>​    我们前面在写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。</p>
<p>​    我们先直接把权限信息写死封装到UserDetails中进行测试。</p>
<p>​    我们之前定义了UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sangeng.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.annotation.JSONField;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginUser</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//存储权限信息</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; permissions;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginUser</span><span class="params">(User user,List&lt;String&gt; permissions)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">        <span class="built_in">this</span>.permissions = permissions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储SpringSecurity所需要的权限信息的集合</span></span><br><span class="line">    <span class="meta">@JSONField(serialize = false)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;GrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span>  Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">if</span>(authorities!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> authorities;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities中</span></span><br><span class="line">        authorities = permissions.stream().</span><br><span class="line">                map(SimpleGrantedAuthority::<span class="keyword">new</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getUserName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        LoginUser修改完后我们就可以在UserDetailsServiceImpl中去把权限信息封装到LoginUser中了。我们写死权限进行测试，后面我们再从数据库中查询权限信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sangeng.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.conditions.query.LambdaQueryChainWrapper;</span><br><span class="line"><span class="keyword">import</span> com.sangeng.domain.LoginUser;</span><br><span class="line"><span class="keyword">import</span> com.sangeng.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.sangeng.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        wrapper.eq(User::getUserName,username);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectOne(wrapper);</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(user))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//TODO 根据用户查询权限信息 添加到LoginUser中</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginUser</span>(user,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="3-2-3-从数据库查询权限信息"><a href="#3-2-3-从数据库查询权限信息" class="headerlink" title="3.2.3 从数据库查询权限信息"></a>3.2.3 从数据库查询权限信息</h4><h5 id="3-2-3-1-RBAC权限模型"><a href="#3-2-3-1-RBAC权限模型" class="headerlink" title="3.2.3.1 RBAC权限模型"></a>3.2.3.1 RBAC权限模型</h5><p>​    RBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。</p>
<p>​    <img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20211222110249727.png" alt="image-20211222110249727"></p>
<h5 id="3-2-3-2-准备工作"><a href="#3-2-3-2-准备工作" class="headerlink" title="3.2.3.2 准备工作"></a>3.2.3.2 准备工作</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="comment">/*!32312 IF NOT EXISTS*/</span>`sg_security` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 */</span>;</span><br><span class="line"></span><br><span class="line">USE `sg_security`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `sys_menu` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_menu`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_menu` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `menu_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;NULL&#x27;</span> COMMENT <span class="string">&#x27;菜单名&#x27;</span>,</span><br><span class="line">  `path` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;路由地址&#x27;</span>,</span><br><span class="line">  `component` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;组件路径&#x27;</span>,</span><br><span class="line">  `visible` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;菜单状态（0显示 1隐藏）&#x27;</span>,</span><br><span class="line">  `status` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;菜单状态（0正常 1停用）&#x27;</span>,</span><br><span class="line">  `perms` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;权限标识&#x27;</span>,</span><br><span class="line">  `icon` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;#&#x27;</span> COMMENT <span class="string">&#x27;菜单图标&#x27;</span>,</span><br><span class="line">  `create_by` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_by` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `del_flag` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;是否删除（0未删除 1已删除）&#x27;</span>,</span><br><span class="line">  `remark` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;菜单表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `sys_role` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_role`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_role` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `role_key` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色权限字符串&#x27;</span>,</span><br><span class="line">  `status` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;角色状态（0正常 1停用）&#x27;</span>,</span><br><span class="line">  `del_flag` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;del_flag&#x27;</span>,</span><br><span class="line">  `create_by` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_by` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `remark` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;角色表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `sys_role_menu` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_role_menu`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_role_menu` (</span><br><span class="line">  `role_id` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line">  `menu_id` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;菜单id&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`role_id`,`menu_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `sys_user` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_user`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_user` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `user_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;NULL&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  `nick_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;NULL&#x27;</span> COMMENT <span class="string">&#x27;昵称&#x27;</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;NULL&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  `status` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;账号状态（0正常 1停用）&#x27;</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">  `phonenumber` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;手机号&#x27;</span>,</span><br><span class="line">  `sex` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户性别（0男，1女，2未知）&#x27;</span>,</span><br><span class="line">  `avatar` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;头像&#x27;</span>,</span><br><span class="line">  `user_type` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;用户类型（0管理员，1普通用户）&#x27;</span>,</span><br><span class="line">  `create_by` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建人的用户id&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_by` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新人&#x27;</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  `del_flag` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;删除标志（0代表未删除，1代表已删除）&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `sys_user_role` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_user_role`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_user_role` (</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `role_id` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;角色id&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`user_id`,`role_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	DISTINCT m.`perms`</span><br><span class="line">FROM</span><br><span class="line">	sys_user_role ur</span><br><span class="line">	LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`</span><br><span class="line">	LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`</span><br><span class="line">	LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`</span><br><span class="line">WHERE</span><br><span class="line">	user_id = 2</span><br><span class="line">	AND r.`status` = 0</span><br><span class="line">	AND m.`status` = 0</span><br></pre></td></tr></table></figure>







<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sangeng.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonInclude;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 菜单表(Menu)实体类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> makejava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-11-24 15:30:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@TableName(value=&quot;sys_menu&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Menu</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">54979041104113736L</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 菜单名</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String menuName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 路由地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 组件路径</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String component;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 菜单状态（0显示 1隐藏）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String visible;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 菜单状态（0正常 1停用）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 权限标识</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String perms;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 菜单图标</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String icon;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Long createBy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Long updateBy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否删除（0未删除 1已删除）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Integer delFlag;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 备注</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String remark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-2-3-3-代码实现"><a href="#3-2-3-3-代码实现" class="headerlink" title="3.2.3.3 代码实现"></a>3.2.3.3 代码实现</h5><p>​    我们只需要根据用户id去查询到其所对应的权限信息即可。</p>
<p>​    所以我们可以先定义个mapper，其中提供一个方法可以根据userid查询权限信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.sangeng.domain.Menu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MenuMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Menu&gt; &#123;</span><br><span class="line">    List&lt;String&gt; <span class="title function_">selectPermsByUserId</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    尤其是自定义方法，所以需要创建对应的mapper文件，定义对应的sql语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.sangeng.mapper.MenuMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPermsByUserId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">            DISTINCT m.`perms`</span><br><span class="line">        FROM</span><br><span class="line">            sys_user_role ur</span><br><span class="line">            LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`</span><br><span class="line">            LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`</span><br><span class="line">            LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`</span><br><span class="line">        WHERE</span><br><span class="line">            user_id = #&#123;userid&#125;</span><br><span class="line">            AND r.`status` = 0</span><br><span class="line">            AND m.`status` = 0</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    在application.yml中配置mapperXML文件的位置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath*:/mapper/**/*.xml</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>​    然后我们可以在UserDetailsServiceImpl中去调用该mapper的方法查询权限信息封装到LoginUser对象中即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MenuMapper menuMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        wrapper.eq(User::getUserName,username);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectOne(wrapper);</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(user))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; permissionKeyList =  menuMapper.selectPermsByUserId(user.getId());</span><br><span class="line"><span class="comment">//        //测试写法</span></span><br><span class="line"><span class="comment">//        List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;test&quot;));</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginUser</span>(user,permissionKeyList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="4-自定义失败处理"><a href="#4-自定义失败处理" class="headerlink" title="4. 自定义失败处理"></a>4. 自定义失败处理</h2><p>​    我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。</p>
<p>​    在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。</p>
<p>​    如果是认证过程中出现的异常会被封装成AuthenticationException然后调用<strong>AuthenticationEntryPoint</strong>对象的方法去进行异常处理。</p>
<p>​    如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用<strong>AccessDeniedHandler</strong>对象的方法去进行异常处理。</p>
<p>​    所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。</p>
<p>①自定义实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessDeniedHandlerImpl</span> <span class="keyword">implements</span> <span class="title class_">AccessDeniedHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">ResponseResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResponseResult</span>(HttpStatus.FORBIDDEN.value(), <span class="string">&quot;权限不足&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSON.toJSONString(result);</span><br><span class="line">        WebUtils.renderString(response,json);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticationEntryPointImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationEntryPoint</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">ResponseResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResponseResult</span>(HttpStatus.UNAUTHORIZED.value(), <span class="string">&quot;认证失败请重新登录&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSON.toJSONString(result);</span><br><span class="line">        WebUtils.renderString(response,json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>②配置给SpringSecurity</p>
<p>​    </p>
<p>​    先注入对应的处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AuthenticationEntryPoint authenticationEntryPoint;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AccessDeniedHandler accessDeniedHandler;</span><br></pre></td></tr></table></figure>

<p>​    然后我们可以使用HttpSecurity对象的方法去配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint).</span><br><span class="line">        accessDeniedHandler(accessDeniedHandler);</span><br></pre></td></tr></table></figure>



<h2 id="5-跨域"><a href="#5-跨域" class="headerlink" title="5. 跨域"></a>5. 跨域</h2><p>​    浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 </p>
<p>​    前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。</p>
<p>​    所以我们就要处理一下，让前端能进行跨域请求。</p>
<p>①先对SpringBoot配置，运行跨域请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">      <span class="comment">// 设置允许跨域的路径</span></span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                <span class="comment">// 设置允许跨域请求的域名</span></span><br><span class="line">                .allowedOriginPatterns(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                <span class="comment">// 是否允许cookie</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                <span class="comment">// 设置允许的请求方式</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;PUT&quot;</span>)</span><br><span class="line">                <span class="comment">// 设置允许的header属性</span></span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                <span class="comment">// 跨域允许时间</span></span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②开启SpringSecurity的跨域访问</p>
<p>由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">            <span class="comment">//关闭csrf</span></span><br><span class="line">            .csrf().disable()</span><br><span class="line">            <span class="comment">//不通过Session获取SecurityContext</span></span><br><span class="line">            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">            .and()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            <span class="comment">// 对于登录接口 允许匿名访问</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()</span><br><span class="line">            <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">            .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加过滤器</span></span><br><span class="line">    http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置异常处理器</span></span><br><span class="line">    http.exceptionHandling()</span><br><span class="line">            <span class="comment">//配置认证失败处理器</span></span><br><span class="line">            .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">            .accessDeniedHandler(accessDeniedHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//允许跨域</span></span><br><span class="line">    http.cors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="6-遗留小问题"><a href="#6-遗留小问题" class="headerlink" title="6. 遗留小问题"></a>6. 遗留小问题</h2><h3 id="其它权限校验方法"><a href="#其它权限校验方法" class="headerlink" title="其它权限校验方法"></a>其它权限校验方法</h3><p>​    我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。</p>
<p>​    </p>
<p>​    这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。</p>
<p>​    hasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。</p>
<p>​    它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。</p>
<p>​    hasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasAnyAuthority(&#x27;admin&#x27;,&#x27;test&#x27;,&#x27;system:dept:list&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​    hasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 <strong>ROLE_</strong> 后再去比较。所以这种情况下要用用户对应的权限也要有 <strong>ROLE_</strong> 这个前缀才可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;system:dept:list&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​    hasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 <strong>ROLE_</strong> 后再去比较。所以这种情况下要用用户对应的权限也要有 <strong>ROLE_</strong> 这个前缀才可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasAnyRole(&#x27;admin&#x27;,&#x27;system:dept:list&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="自定义权限校验方法"><a href="#自定义权限校验方法" class="headerlink" title="自定义权限校验方法"></a>自定义权限校验方法</h3><p>​    我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;ex&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SGExpressionRoot</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasAuthority</span><span class="params">(String authority)</span>&#123;</span><br><span class="line">        <span class="comment">//获取当前用户的权限</span></span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authentication.getPrincipal();</span><br><span class="line">        List&lt;String&gt; permissions = loginUser.getPermissions();</span><br><span class="line">        <span class="comment">//判断用户权限集合中是否存在authority</span></span><br><span class="line">        <span class="keyword">return</span> permissions.contains(authority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​     在SPEL表达式中使用 @ex相当于获取容器中bean的名字未ex的对象。然后再调用这个对象的hasAuthority方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;@ex.hasAuthority(&#x27;system:dept:list&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="基于配置的权限控制"><a href="#基于配置的权限控制" class="headerlink" title="基于配置的权限控制"></a>基于配置的权限控制</h3><p>​    我们也可以在配置类中使用使用配置的方式对资源进行权限控制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">            <span class="comment">//关闭csrf</span></span><br><span class="line">            .csrf().disable()</span><br><span class="line">            <span class="comment">//不通过Session获取SecurityContext</span></span><br><span class="line">            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">            .and()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            <span class="comment">// 对于登录接口 允许匿名访问</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/testCors&quot;</span>).hasAuthority(<span class="string">&quot;system:dept:list222&quot;</span>)</span><br><span class="line">            <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">            .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加过滤器</span></span><br><span class="line">    http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置异常处理器</span></span><br><span class="line">    http.exceptionHandling()</span><br><span class="line">            <span class="comment">//配置认证失败处理器</span></span><br><span class="line">            .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">            .accessDeniedHandler(accessDeniedHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//允许跨域</span></span><br><span class="line">    http.cors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>​    CSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。</p>
<p>​    <a href="https://blog.csdn.net/freeking101/article/details/86537087">https://blog.csdn.net/freeking101/article/details/86537087</a></p>
<p>​    SpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。</p>
<p>​    我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。</p>
<h3 id="认证成功处理器"><a href="#认证成功处理器" class="headerlink" title="认证成功处理器"></a>认证成功处理器</h3><p>​    实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。</p>
<p>​    我们也可以自己去自定义成功处理器进行成功后的相应处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SGSuccessHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationSuccessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;认证成功了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationSuccessHandler successHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.formLogin().successHandler(successHandler);</span><br><span class="line"></span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="认证失败处理器"><a href="#认证失败处理器" class="headerlink" title="认证失败处理器"></a>认证失败处理器</h3><p>​    实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。</p>
<p>​    我们也可以自己去自定义失败处理器进行失败后的相应处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SGFailureHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationFailureHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;认证失败了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationSuccessHandler successHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationFailureHandler failureHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.formLogin()</span><br><span class="line"><span class="comment">//                配置认证成功处理器</span></span><br><span class="line">                .successHandler(successHandler)</span><br><span class="line"><span class="comment">//                配置认证失败处理器</span></span><br><span class="line">                .failureHandler(failureHandler);</span><br><span class="line"></span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="登出成功处理器"><a href="#登出成功处理器" class="headerlink" title="登出成功处理器"></a>登出成功处理器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SGLogoutSuccessHandler</span> <span class="keyword">implements</span> <span class="title class_">LogoutSuccessHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLogoutSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;注销成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationSuccessHandler successHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationFailureHandler failureHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogoutSuccessHandler logoutSuccessHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.formLogin()</span><br><span class="line"><span class="comment">//                配置认证成功处理器</span></span><br><span class="line">                .successHandler(successHandler)</span><br><span class="line"><span class="comment">//                配置认证失败处理器</span></span><br><span class="line">                .failureHandler(failureHandler);</span><br><span class="line"></span><br><span class="line">        http.logout()</span><br><span class="line">                <span class="comment">//配置注销成功处理器</span></span><br><span class="line">                .logoutSuccessHandler(logoutSuccessHandler);</span><br><span class="line"></span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>安全框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis/Mybatis-Plus</title>
    <url>/2022/02/28/MyBatis/</url>
    <content><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a><strong>MyBatis</strong></h1><h2 id="第一章-ssm-x3D-spring-springmvc-mybatis"><a href="#第一章-ssm-x3D-spring-springmvc-mybatis" class="headerlink" title="第一章(ssm &#x3D; spring + springmvc + mybatis)"></a><strong>第一章(ssm &#x3D; spring + springmvc + mybatis)</strong></h2><ol>
<li>三层架构<br>界面层： 和用户打交道的， 接收用户的请求参数， 显示处理结果的。（jsp ，html ，servlet）<br>业务逻辑层： 接收了界面层传递的数据，计算逻辑，调用数据库，获取数据<br>数据访问层： 就是访问数据库， 执行对数据的查询，修改，删除等等的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">三层对应的包</span><br><span class="line">  界面层： controller包 （servlet）</span><br><span class="line">  业务逻辑层： service 包（XXXService类）</span><br><span class="line">  数据访问层： dao包（XXXDao类）</span><br></pre></td></tr></table></figure>


<pre><code> 三层中类的交互
   用户使用界面层--&gt; 业务逻辑层---&gt;数据访问层（持久层）--&gt;数据库（mysql）
</code></pre>
<p>​     三层对应的处理框架<br>​       界面层—servlet—springmvc（框架）<br>​       业务逻辑层—service类–spring（框架）<br>​       数据访问层—dao类–mybatis（框架）</p>
  <span id="more"></span>

<p> 2.框架<br>   框架是一个舞台， 一个模版</p>
<p>   模版：<br>     1. 规定了好一些条款，内容。<br>          2. 加入自己的东西</p>
<p>   框架是一个模块<br>    1.框架中定义好了一些功能。这些功能是可用的。<br>    2.可以加入项目中自己的功能， 这些功能可以利用框架中写好的功能。</p>
<p>   框架是一个软件，半成品的软件，定义好了一些基础功能， 需要加入你的功能就是完整的。<br>   基础功能是可重复使用的，可升级的。</p>
<p>   框架特点：<br>    1. 框架一般不是全能的， 不能做所有事情<br>        2. 框架是针对某一个领域有效。 特长在某一个方面，比如mybatis做数据库操作强，但是他不能做其它的。<br>        3. 框架是一个软件</p>
<p> mybatis框架<br>   一个框架，早期叫做ibatis,  代码在github。<br>   mybatis是 MyBatis SQL Mapper Framework for Java （sql映射框架）<br>   1）sql mapper :sql映射<br>         可以把数据库表中的一行数据  映射为 一个java对象。<br>     一行数据可以看做是一个java对象。操作这个对象，就相当于操作表中的数据</p>
<p>   2） Data Access Objects（DAOs） : 数据访问 ， 对数据库执行增删改查。</p>
<p> mybatis提供了哪些功能：</p>
<ol>
<li>提供了创建Connection ,Statement, ResultSet的能力 ，不用开发人员创建这些对象了</li>
<li>提供了执行sql语句的能力， 不用你执行sql</li>
<li>提供了循环sql， 把sql的结果转为java对象， List集合的能力<br> while (rs.next()) {<br>   Student stu &#x3D; new Student();<br>   stu.setId(rs.getInt(“id”));<br>   stu.setName(rs.getString(“name”));<br>   stu.setAge(rs.getInt(“age”));<br>   &#x2F;&#x2F;从数据库取出数据转为 Student 对象，封装到 List 集合<br>   stuList.add(stu);<br> }</li>
</ol>
<pre><code>4.提供了关闭资源的能力，不用你关闭Connection, Statement, ResultSet
</code></pre>
<p> 开发人员做的是： 提供sql语句<br> 最后是： 开发人员提供sql语句–mybatis处理sql—开发人员得到List集合或java对象（表中的数据）</p>
<p> 总结：<br>  mybatis是一个sql映射框架，提供的数据库的操作能力。增强的JDBC,<br>  使用mybatis让开发人员集中精神写sql就可以了，不必关心Connection,Statement,ResultSet<br>  的创建，销毁，sql的执行。 </p>
<h2 id="第二章："><a href="#第二章：" class="headerlink" title="第二章："></a><strong>第二章：</strong></h2><p>  1 主要类的介绍<br>   1） Resources： mybatis中的一个类， 负责读取主配置文件<br>      InputStream in &#x3D; Resources.getResourceAsStream(“mybatis.xml”);</p>
<pre><code>2)SqlSessionFactoryBuilder : 创建SqlSessionFactory对象， 
     SqlSessionFactoryBuilder builder  = new SqlSessionFactoryBuilder();
    //创建SqlSessionFactory对象
    SqlSessionFactory factory = builder.build(in);
</code></pre>
<p>  3）SqlSessionFactory ： 重量级对象， 程序创建一个对象耗时比较长，使用资源比较多。<br>        在整个项目中，有一个就够用了。</p>
<pre><code> SqlSessionFactory:接口  ， 接口实现类： DefaultSqlSessionFactory
  SqlSessionFactory作用： 获取SqlSession对象。SqlSession sqlSession = factory.openSession();

  openSession()方法说明：
   1. openSession() ：无参数的， 获取是非自动提交事务的SqlSession对象
    2. openSession(boolean): openSession(true)  获取自动提交事务的SqlSession. 
                             openSession(false)  非自动提交事务的SqlSession对象
</code></pre>
<p> 4)SqlSession:<br>   SqlSession接口 ：定义了操作数据的方法 例如 selectOne() ,selectList() ,insert(),update(), delete(), commit(), rollback()<br>   SqlSession接口的实现类DefaultSqlSession。</p>
<pre><code>使用要求： SqlSession对象不是线程安全的，需要在方法内部使用， 在执行sql语句之前，使用openSession()获取SqlSession对象。
在执行完sql语句后，需要关闭它，执行SqlSession.close(). 这样能保证他的使用是线程安全的。
</code></pre>
<h2 id="第三章："><a href="#第三章：" class="headerlink" title="第三章："></a><strong>第三章：</strong></h2><ol>
<li><p>动态代理： 使用SqlSession.getMapper(dao接口.class) 获取这个dao接口的对象</p>
</li>
<li><p>传入参数： 从java代码中把数据传入到mapper文件的sql语句中。<br>1）parameterType ： 写在mapper文件中的 一个属性。 表示dao接口中方法的参数的数据类型。<br>例如StudentDao接口<br> public Student  selectStudentById(Integer id) </p>
<ol start="2">
<li>一个简单类型的参数：<br>简单类型： mybatis把java的基本数据类型和String都叫简单类型。<br>在mapper文件获取简单类型的一个参数的值，使用 #{任意字符}</li>
</ol>
<p> 接口：public Student  selectStudentById(Integer id)<br> mapper:select id,name, email,age from student where id&#x3D;#{studentId}</p>
</li>
</ol>
<pre><code>3) 多个参数，使用@Param命名参数
  接口 public List&lt;Student&gt; selectMulitParam(@Param(&quot;myname&quot;) String name, @Param(&quot;myage&quot;) Integer age)
  使用  @Param(&quot;参数名&quot;)  String name 
 mapper文件：
     &lt;select&gt;
         select * from student where name=#&#123;myname&#125; or age=#&#123;myage&#125;
      &lt;/select&gt;

4) 多个参数，使用java对象
   语法 #&#123;属性名&#125;
</code></pre>
<p>   vo: value object , 放一些存储数据的类。比如说 提交请求参数， name ,age<br>         现在想把name ,age 传给一个service 类。</p>
<p>   vo: view object , 从servlet把数据返回给浏览器使用的类，表示显示结果的类。</p>
<p>   pojo: 普通的有set， get方法的java类。 普通的java对象</p>
<pre><code>      Servlet --- StudentService( addStudent( MyParam  param)  )
</code></pre>
<p>   entity（domain域）: 实体类， 和数据库中的表对应的类， </p>
<pre><code>5) # 和  $

  select id,name, email,age from student where id=#&#123;studentId&#125;
  # 的结果： select id,name, email,age from student where id=? 


   select id,name, email,age from student where id=$&#123;studentId&#125;
  $ 的结果：select id,name, email,age from student where id=1001

  String sql=&quot;select id,name, email,age from student where id=&quot; + &quot;1001&quot;;
  使用的Statement对象执行sql， 效率比PreparedStatement低。


  $:可以替换表名或者列名， 你能确定数据是安全的。可以使用$


  # 和 $区别
  1. #使用 ？在sql语句中做站位的， 使用PreparedStatement执行sql，效率高
  2. #能够避免sql注入，更安全。
  3. $不使用占位符，是字符串连接方式，使用Statement对象执行sql，效率低
  4. $有sql注入的风险，缺乏安全性。
  5. $:可以替换表名或者列名
</code></pre>
<ol start="3">
<li><p>mybatis的输出结果<br>mybatis执行了sql语句，得到java对象。</p>
<p> 1）resultType结果类型， 指sql语句执行完毕后， 数据转为的java对象， java类型是任意的。<br>   resultType结果类型的它值 1. 类型的全限定名称   2. 类型的别名， 例如 java.lang.Integer别名是int</p>
<pre><code>处理方式：
   1. mybatis执行sql语句， 然后mybatis调用类的无参数构造方法，创建对象。
    2. mybatis把ResultSet指定列值付给同名的属性。


    &lt;select id=&quot;selectMultiPosition&quot; resultType=&quot;com.bjpowernode.domain.Student&quot;&gt;
  select id,name, email,age from student
&lt;/select&gt;

  对等的jdbc
  ResultSet rs = executeQuery(&quot; select id,name, email,age from student&quot; )
  while(rs.next())&#123;
       Student  student = new Student();
            student.setId(rs.getInt(&quot;id&quot;));
            student.setName(rs.getString(&quot;name&quot;))
  &#125;
</code></pre>
</li>
</ol>
<ol start="2">
<li>定义自定义类型的别名<br> 1）在mybatis主配置文件中定义，使<typeAlias>定义别名<br>  2）可以在resultType中使用自定义别名</li>
</ol>
<p>   3）resultMap:结果映射， 指定列名和java对象的属性对应关系。<br>        1）你自定义列值赋值给哪个属性<br>         2）当你的列名和属性名不一样时，一定使用resultMap</p>
<pre><code>     resultMap和resultType不要一起用，二选一
</code></pre>
<p>dao接口中的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示使用ResultMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> List&lt;Student&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;Student&gt; <span class="title function_">selectStudents</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>StudentDao.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用ResultMap 必须先定义ResultMap</span></span><br><span class="line"><span class="comment">可以防止实体类中的属性名与数据库表中的列名的不同的囧境--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--定义ResultMap--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.dyw.Domain.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--主键列使用 id标签</span></span><br><span class="line"><span class="comment">        column 表的列名</span></span><br><span class="line"><span class="comment">        property java类型的属性名</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--非主键列使用result标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudents&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentMap&quot;</span>&gt;</span></span><br><span class="line">    select id,name,age from student order by id;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出:</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220111153344824.png" alt="image-20220111153344824"></p>
<p><strong>注意</strong>:如果Dao接口使用Map作为返回结果的话 需要在ResultType中配置Map的全限定名称 而不是实体类的名称(如果返回值为List则依旧使用实体类的全限定名称) 并且返回的结果是以列名作为键 列值作为值  </p>
<h2 id="第四章动态sql"><a href="#第四章动态sql" class="headerlink" title="第四章动态sql"></a><strong>第四章动态sql</strong></h2><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询:"></a>模糊查询:</h4><p>​    **like:**在dao.xml配置文件中 直接使用like即可 当使用#{}拼接时 我们前面说过 他是以占位符?(即preparedStatement)所以格式为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--模糊查询的两种方式</span></span><br><span class="line"><span class="comment">        1.直接传入一个字符串 类似与%丁%</span></span><br><span class="line"><span class="comment">        2.使用字符串拼接</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentsByLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.dyw.Domain.Student&quot;</span>&gt;</span></span><br><span class="line">        select id,name,age from student where name like &quot;%&quot; #&#123;name&#125; &quot;%&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">底层为</span><br><span class="line"><span class="comment">&lt;!--Preparing: select id,name,age from student where name like &quot;%&quot; ? &quot;%&quot;--&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    但是使用${}时不一样它是使用Statement即字符串拼接 所以格式为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentsByLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.dyw.Domain.Student&quot;</span>&gt;</span></span><br><span class="line">        select id,name,age from student where name like &quot;%$&#123;name&#125;%&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">底层</span><br><span class="line"><span class="comment">&lt;!--Preparing: select id,name,age from student where name like &quot;%丁%&quot;--&gt;</span></span><br></pre></td></tr></table></figure>



<p> 动态sql: sql的内容是变化的，可以根据条件获取到不同的sql语句。<br>           主要是where部分发生变化。</p>
<p> 动态sql的实现，使用的是mybatis提供的标签， <if> ,<where>,<foreach></p>
<p> 1)<if>是判断条件的，<br>   语法<if test="判断java对象的属性值"><br>            部分sql语句<br>        </if></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用标签&lt;if&gt;可以判断条件 如果条件满足要求则将条件拼接在where后 可以防止sql运行时报错--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    多个if拼接的时候一般在where后面加一个1=1 保证拼接时不会出错</span></span><br><span class="line"><span class="comment">        注意使用动态sql语句 一定要传java对象作为参数</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentsByLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.dyw.Domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select id,name,age from student</span><br><span class="line">        where 1=1</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name !=null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and name like #&#123;name&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age &gt; 0&quot;</span>&gt;</span></span><br><span class="line">            and age &gt; #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但这样有弊端，就是为了避免拼接错误，需要使用or 1&#x3D;1， 但是这样又会导致另一个错误，那就是可以会将所有的内容都查出来，这是我们不想看到的。</p>
<p> 2)<where> 用来包含 多个<if>的， 当多个if有一个成立的， <where>会自动增加一个where关键字，<br>            并去掉 if中多余的 and ，or等。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用where标签时就不会出现拼接错误现象 底层会自动判别然后进行拼接 可以自动去除and or等连接词比直接用&lt;if&gt;安全性好--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentsByLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.dyw.Domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select id,name,age from student</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null and name !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and name like #&#123;name&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age &gt; 0&quot;</span>&gt;</span></span><br><span class="line">            and age &gt;#&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    使用&lt; where&gt;标签就不会出现上述&lt; if&gt;的情况 &lt; where&gt;标签可以智能帮助我们去除and or 等 防止拼接错误</p>
<p> 3）<foreach> 循环java中的数组，list集合的。 主要用在sql的in语句中。(用于当传入的参数为集合时 为了获取里面的数据)<br>    学生id是 1001,1002,1003的三个学生</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select * from student where id <span class="title function_">in</span> <span class="params">(<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">selectFor</span><span class="params">(List&lt;Integer&gt; idlist)</span></span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ...</span><br><span class="line">list.add(<span class="number">1001</span>);</span><br><span class="line">list.add(<span class="number">1002</span>);</span><br><span class="line">list.add(<span class="number">1003</span>);</span><br><span class="line"></span><br><span class="line">dao.selectFor(list)</span><br></pre></td></tr></table></figure>


<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;&quot;</span> <span class="attr">item</span>=<span class="string">&quot;&quot;</span> <span class="attr">open</span>=<span class="string">&quot;&quot;</span> <span class="attr">close</span>=<span class="string">&quot;&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">         #&#123;xxx&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"></span><br><span class="line">collection:表示接口中的方法参数的类型， 如果是数组使用array , 如果是list集合使用list</span><br><span class="line"> item:自定义的，表示数组和集合成员的变量</span><br><span class="line"> open:循环开始是的字符</span><br><span class="line"> close:循环结束时的字符</span><br><span class="line">separator:集合成员之间的分隔符</span><br></pre></td></tr></table></figure>

<p>  4）sql代码片段， 就是复用一些语法<br>    步骤<br>     1.先定义 <sql id="自定义名称唯一">  sql语句， 表名，字段等 </sql><br>    2.再使用， <include refid="id的值" /></p>
<h2 id="第五章："><a href="#第五章：" class="headerlink" title="第五章："></a><strong>第五章：</strong></h2><ol>
<li>数据库的属性配置文件： 把数据库连接信息放到一个单独的文件中。 和mybatis主配置文件分开。<br>目的是便于修改，保存，处理多个数据库的信息。<br><!--便于维护,管理与使用--><ol>
<li><p>在resources目录中定义一个属性配置文件， xxxx.properties ,例如 jdbc.properties<br>   在属性配置文件中， 定义数据，格式是 key&#x3D;value<br>     key： 一般使用 . 做多级目录的。<br>     例如 jdbc.mysql.driver    , jdbc.driver, mydriver<br>     jdbc.driver&#x3D;com.mysql.jdbc.Driver<br>     jdbc.url&#x3D;jdbc:mysql&#x2F;&#x2F;…..<br>     jdbc.username&#x3D;root<br>     jdbc.password&#x3D;123456</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定properties文件路径 从类路径根开始查找--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>​     </p>
</li>
<li><p>在mybatis的主配置文件，使用<property> 指定文件的位置<br> 在需要使用值的地方， ${key}</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.user&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<p> 2.mapper文件，使用package指定路径<br>    在MyBatis-config文件中可以指定多个mapper文件 第一个中方式直接在<mappers></mappers>中加入多个<mapper/><br>    注意mapper的路径从类路径的根开始(target&#x2F;classes)<br>     <mappers></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!--第二种方式： 使用包名</span></span><br><span class="line"><span class="comment">        name: xml文件（mapper文件）所在的包名, 这个包中所有xml文件一次都能加载给mybatis</span></span><br><span class="line"><span class="comment">        使用package的要求：</span></span><br><span class="line"><span class="comment">         1. mapper文件名称需要和接口名称一样， 区分大小写的一样</span></span><br><span class="line"><span class="comment">         2. mapper文件和dao接口需要在同一目录</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.bjpowernode.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="第六章：PageHelper"><a href="#第六章：PageHelper" class="headerlink" title="第六章：PageHelper"></a><strong>第六章：PageHelper</strong></h2><p> <strong>PageHelper做数据分页的。</strong>(国人写的)</p>
<ol>
<li><p>maven中添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>在MyBatis-config中配置插件<br>注意:<strong>MyBatis-config配置顺序如下properties, settings,plugins</strong>;</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在&lt;plugins&gt;标签中配置--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置pageHelper插件放在setting后面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>配置完成后在使用时调用 pagehelper.startpage(页码(int),每页显示条数(int))方法 注意放在执行sql语句之前 输出会自动显示参数指定的几条</p>
</li>
</ol>
<hr>
<h2 id="MyBatis的缓存机制"><a href="#MyBatis的缓存机制" class="headerlink" title="MyBatis的缓存机制"></a><strong>MyBatis的缓存机制</strong></h2><p>​                                                                            <a href="https://segmentfault.com/a/1190000041193993">https://segmentfault.com/a/1190000041193993</a></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">缓存机制减轻数据库压力，提高数据库性能</span><br><span class="line">mybatis的缓存分为两级：一级缓存、二级缓存</span><br></pre></td></tr></table></figure>

<h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存:"></a><strong>一级缓存</strong>:</h4><p>​    一级缓存为 <code>sqlsession</code> 缓存，缓存的数据只在 SqlSession 内有效。在操作数据库的时候需要先  创建 SqlSession 会话对象，在对象中有一个 HashMap 用于存储缓存数据，此 HashMap 是当前    会话对象私有的，别的 SqlSession 会话对象无法访问。</p>
<p>​    具体流程：</p>
<p>​    第一次执行 select 完毕会将查到的数据写入 <strong>SqlSession</strong> 内的 <strong>HashMap</strong> 中缓存起来</p>
<p>​    第二次执行(可能多次) select 会从<strong>缓存</strong>中查数据，如果 select 同传参数一样，那么就能从缓存中返回数据，不用去数据库了，从而提高了效率</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h4><p>​    1、如果 在<strong>同</strong>一个SqlSession 执行了 DML 操作（insert、update、delete），并 commit 了，那么 mybatis 就会清空当前 SqlSession 缓存中的所有缓存数据，这样可以保证缓存中的存的数据永远和数据库中一致，避免出现差异</p>
<p>​    2、当一个 SqlSession 结束后那么他里面的一级缓存也就不存在了， mybatis 默认是开启一级缓存且默认作用范围时SESSION，也可以手动配置为STATEMENT(让一级缓存仅针对当前执行的<code>SQL</code>语句生效；)，不需要配置二级缓存默认时没有开启的为false 需要手动在Mybatis-config中配置(<setting></setting>中)</p>
<p>​    3、 mybatis 的缓存是基于 [namespace:sql语句:参数] 来进行缓存的，意思就是， SqlSession 的 HashMap 存储缓存数据时，是使用 [namespace:sql:参数] 作为 key ，查询返回的语句作为 value 保存的,**即{key&#x3D;namespace:sql:参数，value&#x3D;查询到的数据}**。</p>
<p>​    4. 不同会话持有不同的一级缓存，本会话内的操作不会影响其它会话内的一级缓存。</p>
<h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a><strong>二级缓存</strong></h4><p>二级缓存是<code> mapper</code> 级别的缓存，也就是同一个 namespace 的 mapper.xml ，当多个 SqlSession 使用同一个 Mapper 操作数据库的时候，得到的数据会缓存在同一个二级缓存区域</p>
<p>二级缓存默认是没有开启的。需要在 setting 全局参数中配置开启二级缓存</p>
<p>开启二级缓存步骤：</p>
<p>1、<code>conf.xml</code> 配置全局变量开启二级缓存</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>默认是false：关闭二级缓存</span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、在<code>userMapper.xml</code>中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">&quot;LRU&quot;</span> <span class="attr">type</span>=<span class="string">&quot;org.apache.ibatis.cache.impl.PerpetualCache&quot;</span> <span class="attr">flushInterval</span>=<span class="string">&quot;60000&quot;</span> <span class="attr">size</span>=<span class="string">&quot;512&quot;</span> <span class="attr">readOnly</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>当前mapper下所有语句开启二级缓存</span><br></pre></td></tr></table></figure>

<p>这里配置了一个 LRU 缓存，并每隔60秒刷新，最大存储512个对象，而返回的对象是只读的</p>
<p>若想禁用当前<code>select</code>语句的二级缓存，添加 <code>useCache=&quot;false&quot;</code>修改如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getCountByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.Map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;INTEGER&quot;</span> <span class="attr">statementType</span>=<span class="string">&quot;CALLABLE&quot;</span> <span class="attr">useCache</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>具体流程：</p>
<p>1.当一个<code>sqlseesion</code>执行了一次<code> select</code> 后，在关闭此<code> session</code> 的时候，会将查询结果缓存到二级缓存</p>
<p>2.当另一个<code>sqlsession</code>执行<code> select</code> 时，（前提二级缓存开启时）首先会在他自己的二级缓存中找，如果没找到，就回去一级缓存中找，找到了就返回，就不用去数据库了，从而减少了数据库压力提高了性能</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><ol>
<li><p>如果 <code>SqlSession</code> 执行了 DML 操作<code>（insert、update、delete）</code>，并 <code>commit</code> 了，那么 <code>mybatis</code> 就会清空当前<code> mapper</code> 缓存中的所有缓存数据，这样可以保证缓存中的存的数据永远和数据库中一致，避免出现差异（如果没有commit）就不会清空mybatis中的二级缓存</p>
</li>
<li><p><code> mybatis</code> 的缓存是基于<code>[namespace:sql语句:参数]</code>来进行缓存的，意思就是，<code>SqlSession</code> 的 <code>HashMap</code> 存储缓存数据时，是使用 <code>[namespace:sql:参数] </code>作为 <code>key</code> ，查询返回的语句作为 <code>value</code> 保存的。</p>
</li>
<li><p><code>Mybatis</code>中需要在映射文件中添加<code>&lt;cache&gt;</code>标签来为映射文件配置二级缓存，也可以在映射文件中添加<code>&lt;cache-ref&gt;</code>标签来引用其它映射文件的二级缓存以达到多个映射文件持有同一份二级缓存的效果。</p>
</li>
<li><p><cache-ref namespace="com.mybatis.learn.dao.BookMapper"/>该语句可以在另一个mybatis-mapper中指定二级缓存（一个mapper拥有一个二级缓存 这里指定了缓存的指向）这样两个mapper可以共享一个二级缓存</p>
<hr>
</li>
</ol>
<p><strong><code>&lt;cache&gt;</code>标签如下所示。</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>默认值</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>eviction</strong></td>
<td>缓存淘汰策略。<strong>LRU</strong>表示最近使用频次最少的优先被淘汰；<strong>FIFO</strong>表示先被缓存的会先被淘汰；<strong>SOFT</strong>表示基于软引用规则来淘汰；<strong>WEAK</strong>表示基于弱引用规则来淘汰</td>
<td><strong>LRU</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>flushInterval</strong></td>
<td>缓存刷新间隔。单位毫秒</td>
<td>空，表示永不过期</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>type</strong></td>
<td>缓存的类型</td>
<td><code>PerpetualCache</code>(永久缓存)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>size</strong></td>
<td>最多缓存的对象个数</td>
<td>1024</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>blocking</strong></td>
<td>缓存未命中时是否阻塞</td>
<td><strong>false</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>readOnly</strong></td>
<td>缓存中的对象是否只读。配置为<strong>true</strong>时，表示缓存对象只读，命中缓存时会直接将缓存的对象返回，性能更快，但是线程不安全；配置为<strong>false</strong>时，表示缓存对象可读写，命中缓存时会将缓存的对象克隆然后返回克隆的对象，性能更慢，但是线程安全</td>
<td><strong>false</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th>含义</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>namespace</strong></td>
<td>其它映射文件的命名空间，设置之后则当前映射文件将和其它映射文件将持有同一份二级缓存</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a><strong>MyBatis-Plus</strong></h1><p><strong>注意</strong>：引入 <code>MyBatis-Plus</code> 之后请不要再次引入 <code>MyBatis</code> 以及 <code>MyBatis-Spring</code>，以避免因版本差异导致的问题。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus (opens new window)</a>（简称 MP）是一个 <a href="https://www.mybatis.org/mybatis-3/">MyBatis (opens new window)</a>的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<blockquote>
<p> 愿景</p>
<p>我们的愿景是成为 MyBatis 最好的搭档，就像 <a href="https://www.mybatis-plus.com/img/contra.jpg">魂斗罗</a> 中的 1P、2P，基友搭配，效率翻倍。</p>
</blockquote>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li>
<li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li>
<li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li>
<li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li>
<li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li>
<li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li>
<li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li>
<li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li>
<li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li>
<li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li>
<li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li>
<li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li>
</ul>
<h3 id="支持数据库"><a href="#支持数据库" class="headerlink" title="#支持数据库"></a><a href="https://www.mybatis-plus.com/guide/#%E6%94%AF%E6%8C%81%E6%95%B0%E6%8D%AE%E5%BA%93">#</a>支持数据库</h3><blockquote>
<p>任何能使用 <code>mybatis</code> 进行 CRUD, 并且支持标准 SQL 的数据库，具体支持情况如下，如果不在下列表查看分页部分教程 PR 您的支持。</p>
</blockquote>
<ul>
<li>mysql，oracle，db2，h2，hsql，sqlite，postgresql，sqlserver，Phoenix，Gauss ，clickhouse，Sybase，OceanBase，Firebird，cubrid，goldilocks，csiidb</li>
<li>达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库</li>
</ul>
<h3 id="框架结构"><a href="#框架结构" class="headerlink" title="#框架结构"></a><a href="https://www.mybatis-plus.com/guide/#%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84">#</a>框架结构</h3><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/mybatis-plus-framework.jpg" alt="framework"></p>
<p><strong>就是在mybatis的基础上再次简化操作 让原来需要程序员写的curd代码都节省了</strong> 同时还优化了性能</p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a><strong>快速开始</strong></h2><h4 id="一：创建一个boot工程（SpringBoot-Initializr）"><a href="#一：创建一个boot工程（SpringBoot-Initializr）" class="headerlink" title="一：创建一个boot工程（SpringBoot Initializr）"></a>一：创建一个boot工程（SpringBoot Initializr）</h4><p>勾选SQL中的MySQL Driver</p>
<h4 id="二：引入mybatis-plus相关依赖"><a href="#二：引入mybatis-plus相关依赖" class="headerlink" title="二：引入mybatis-plus相关依赖"></a>二：引入mybatis-plus相关依赖</h4><p>引入 Spring Boot Starter 父工程：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>spring-latest-version<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>引入 <code>spring-boot-starter</code>、<code>spring-boot-starter-test</code>、<code>mybatis-plus-boot-starter</code> <code>、mysql-connector-java、lombok</code>依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="三：配置"><a href="#三：配置" class="headerlink" title="三：配置"></a>三：配置</h4><ul>
<li>在application.yml中配置数据库连接的相关信息</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/my_db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">devil</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在 Spring Boot 启动类中添加 <code>@MapperScan</code> 注解，扫描 Mapper 文件夹：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.dyw.mybatisplus01pre.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlus01PreApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MybatisPlus01PreApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>借助lombok插件编写实体类 Student.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@TableId</span> 指定之间的方式：</span></span><br><span class="line"><span class="comment">     * value：主键字段的名称，如果时id，可以不用写</span></span><br><span class="line"><span class="comment">     * type:指定主键的类型，主键的值如何生成。idType.AUTO,表示自动增长</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableId(</span></span><br><span class="line"><span class="meta">            type = IdType.AUTO</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编写Mapper接口 <code>StudentMapper.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义Mapper，就是Dao接口</span></span><br><span class="line"><span class="comment"> * 1.要继承BaseMapper</span></span><br><span class="line"><span class="comment"> * 2.指定实体类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BaseMapper是Mp框架中的对象，定义了十七个方法（CRUD）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Student&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试类 测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MybatisPlus01PreApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentMapper studentMapper;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Student&gt; students = studentMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220121180912055.png" alt="image-20220121180912055"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>*　通过以上几个简单的步骤，我们就实现了 Student 表的 CRUD 功能，甚至连 XML 文件都不用编写！<br>*　从以上步骤中，我们可以看到集成<code>MyBatis-Plus</code>非常的简单，只需要引入 starter 工程，并配置 mapper 扫描路径即可。<br>*　<strong>对于mapper的扫描可以选择在启动类中写@MapperScan() 也可以在mapper接口上加@mapper 前者适合mapper接口多的情况 后者则书写更方便。</strong><br>*　在执行插入操作时 执行成功后 会将结果返回到传入的对象中（例如我们可以通过传入的对象获得主键自增长的主键值）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">People</span> <span class="variable">people1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="literal">null</span>, <span class="string">&quot;王裴豫川&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> peopleMapper.insert(people1);</span><br><span class="line"></span><br><span class="line">        System.out.println(row&gt;<span class="number">0</span>?<span class="string">&quot;成功&quot;</span>:<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;主键id：&quot;</span>+people1.getId());</span><br><span class="line">        System.out.println();</span><br><span class="line">        List&lt;People&gt; people = peopleMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">for</span> (People person : people) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    可以看到我们没有对传入的对象的主键赋值（自动增长）但我们通过执行操作后的对象获得了插入到表中的该行数据的主    键 证实了上述结论</p>
<h2 id="Spring整合Mybatis-Plus"><a href="#Spring整合Mybatis-Plus" class="headerlink" title="Spring整合Mybatis-Plus"></a><strong>Spring整合Mybatis-Plus</strong></h2><ul>
<li>上面的快速开始我们介绍了通过SpringBoot整合MyBatis-Plus</li>
</ul>
<h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p><strong>加入Spring依赖和数据库JDBC依赖后还需要加入Mybatis-Plus的依赖</strong></p>
<p><strong>引入 <code>MyBatis-Plus</code> 之后请不要再次引入 <code>MyBatis</code> 以及 <code>MyBatis-Spring</code>，以避免因版本差异导致的问题。</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>MyBatis-Plus 的配置异常的简单，我们仅需要一些简单的配置即可使用 MyBatis-Plus 的强大功能！</p>
<p>配置 MapperScan  spring.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.dyw.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>要想使用mybatis-plus的日志功能 需要在application.yml中添加如下语句</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure>

<h2 id="CRUD接口"><a href="#CRUD接口" class="headerlink" title="CRUD接口"></a><strong>CRUD接口</strong></h2><h2 id="Service-CRUD-接口"><a href="#Service-CRUD-接口" class="headerlink" title="Service CRUD 接口"></a><a href="https://www.mybatis-plus.com/guide/crud-interface.html#service-crud-%E6%8E%A5%E5%8F%A3">Service CRUD 接口</a></h2><blockquote>
<p>说明:</p>
<ul>
<li><p>通用 Service CRUD 封装<a href="https://gitee.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-extension/src/main/java/com/baomidou/mybatisplus/extension/service/IService.java">IService (opens new window)</a>接口，进一步封装 CRUD 采用 <code>get 查询单行</code> <code>remove 删除</code> <code>list 查询集合</code> <code>page 分页</code> 前缀命名方式区分 <code>Mapper</code> 层避免混淆，</p>
</li>
<li><p>泛型 <code>T</code> 为任意实体对象</p>
</li>
<li><p>建议如果存在自定义通用 Service 方法的可能，请创建自己的 <code>IBaseService</code> 继承 <code>Mybatis-Plus</code> 提供的基类</p>
</li>
<li><p>对象 <code>Wrapper</code> 为 <a href="https://www.mybatis-plus.com/guide/wrapper.html">条件构造器</a></p>
</li>
<li><p>&#96;&#96;&#96;java<br>@SuppressWarnings(“all”)<br>public interface BookService extends IService<Book> {<br>&#x2F;&#x2F;boolean save(Book book);<br>&#x2F;&#x2F;boolean update(Book book);<br>&#x2F;&#x2F;boolean delete(Integer id);<br>&#x2F;&#x2F;Book getById(Integer id);<br>List<Book> getAll();<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 可以追加自定义操作 需要自己编写方法实体 模板如下</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  @Service</span><br><span class="line">  @SuppressWarnings(&quot;all&quot;)</span><br><span class="line">  public class BookServiceImpl extends ServiceImpl&lt;BookMapper,Book&gt; implements BookService&#123;</span><br><span class="line">      @Autowired</span><br><span class="line">      private BookMapper mapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public List&lt;Book&gt; getAll() &#123;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<hr>
<h2 id="Mapper-CRUD-接口"><a href="#Mapper-CRUD-接口" class="headerlink" title="Mapper CRUD 接口"></a><a href="https://www.mybatis-plus.com/guide/crud-interface.html#mapper-crud-%E6%8E%A5%E5%8F%A3">Mapper CRUD 接口</a></h2><blockquote>
<p>说明:</p>
<ul>
<li>通用 CRUD 封装<a href="https://gitee.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-core/src/main/java/com/baomidou/mybatisplus/core/mapper/BaseMapper.java">BaseMapper (opens new window)</a>接口，为 <code>Mybatis-Plus</code> 启动时自动解析实体表关系映射转换为 <code>Mybatis</code> 内部对象注入容器</li>
<li>泛型 <code>T</code> 为任意实体对象</li>
<li>参数 <code>Serializable</code> 为任意类型主键 <code>Mybatis-Plus</code> 不推荐使用复合主键约定每一张表都有自己的唯一 <code>id</code> 主键</li>
<li>对象 <code>Wrapper</code> 为 <a href="https://www.mybatis-plus.com/guide/wrapper.html">条件构造器</a></li>
</ul>
</blockquote>
<hr>
<p>以下是Mapper接口中的CRUD方法介绍</p>
<h4 id="一-查询"><a href="#一-查询" class="headerlink" title="一:查询"></a>一:查询</h4><ol>
<li>selectById() 通过单个主键值查询 只需要传入主键值即可  <strong>SELECT id,name FROM people WHERE id&#x3D;?</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * selectById 根据单个主键值查询</span></span><br><span class="line"><span class="comment"> * 参数:主键值</span></span><br><span class="line"><span class="comment"> * 返回值:实体对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">People</span> <span class="variable">people1</span> <span class="operator">=</span> peopleMapper.selectById(<span class="number">1</span>);</span><br><span class="line">System.out.println(people1);</span><br></pre></td></tr></table></figure>

<p><strong>如果id值对应的行不存在 会返回空 所以一般使用会判断是否为空 再做其他操作</strong></p>
<ol start="2">
<li>selectBatchIds() 批处理查询 通过多个主键值的一个集合 来查询满足条件的数据 返回值是一个集合 如果没有满足条件的数据 则返回null  <strong>SELECT id,name FROM people WHERE id IN ( ? , ? , ? )</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * selectBatchIds 批处理查询 根据多个主键值查询</span></span><br><span class="line"><span class="comment"> * 参数:id的集合</span></span><br><span class="line"><span class="comment"> * 返回值:集合List&lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;Integer&gt; collect = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>).collect(Collectors.toList());</span><br><span class="line">List&lt;People&gt; people1 = peopleMapper.selectBatchIds(collect);</span><br><span class="line">System.out.println(people1);</span><br><span class="line"><span class="keyword">for</span> (People people2 : people1) &#123;</span><br><span class="line">    System.out.println(people2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>selectByMap() 通过将多条件字段字段封装到map中 通过读取map中的值来拼接条件 来实现  <strong>SELECT id,name FROM people WHERE name &#x3D; ? AND id &#x3D; ?</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * selectMap 使用map封装多条件字段查询</span></span><br><span class="line"><span class="comment">  * 参数:Map&lt;String,Object&gt;</span></span><br><span class="line"><span class="comment">  * 返回值:集合List&lt;T&gt;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"> map.put(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>);</span><br><span class="line"> map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;易顺坤&quot;</span>);</span><br><span class="line"> List&lt;People&gt; people1 = peopleMapper.selectByMap(map);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (People people2 : people1) &#123;</span><br><span class="line">     System.out.println(people2);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>4.selectList() 通过传入实体类 更具实体类中的字段值解析为条件 查询</p>
<p>……</p>
<p><strong>注意:</strong> 当select操作条件为null时默认查询表中全部数据</p>
<h4 id="二-更新"><a href="#二-更新" class="headerlink" title="二:更新"></a>二:更新</h4><ol>
<li>updateById(实体类对象);</li>
</ol>
<p>通过传入实体类对象根据实体类对象中的声明主键的值, 自动生成where条件 where id&#x3D;?  , 然后以实体类中的其他非null属性的值对表中的数据进行修改(<strong>注意:包装类的默认值是null 而基本数据类型默认值不一定是null 如int类型默认值是0</strong>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新操作（update）</span></span><br><span class="line"><span class="comment">     * 通过对象的形式传入要修改的数据 默认修改传入对象中非null属性的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">        people.setId(<span class="number">2</span>);</span><br><span class="line">        people.setName(<span class="string">&quot;易顺坤&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * updateById()顾名思义就是条件是根据id的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> peopleMapper.updateById(people);</span><br><span class="line">        System.out.println(i&gt;<span class="number">0</span>?<span class="string">&quot;cg&quot;</span>:<span class="string">&quot;sb&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;People&gt; people1 = peopleMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">for</span> (People people2 : people1) &#123;</span><br><span class="line">            System.out.println(people2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="三-删除"><a href="#三-删除" class="headerlink" title="三:删除"></a>三:删除</h4><ol>
<li>deleteById 通过传入的实体类中声明的主键值 来生成where条件 delete from tablename where id &#x3D; ?  也可以直接传入一个id值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> peopleMapper.deleteById(<span class="number">3</span>);</span><br><span class="line"><span class="comment">/**************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">people.setId(<span class="number">2</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* deleteById()顾名思义就是条件是根据id的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> peopleMapper.deleteById(people);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>deleteByMap 将字段条件通过键值对的方式封装到map中 再调用deleteByMap方法 将map中的值读取填入where之后 多个字段以and方式连接 <strong>DELETE FROM people WHERE name &#x3D; ? AND id &#x3D; ?</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deleteByMap()通过map存储条件字段键值对 多个字段 在where条件后用and连接</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DELETE FROM people WHERE name = ? AND id = ?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;丁杨维&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> peopleMapper.deleteByMap(map);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>deleteBatchIds 通过id批量删除 是通过in关键字 填入where条件关键字之后 <strong>DELETE FROM people WHERE id IN ( ? , ? )</strong></li>
</ol>
<blockquote>
<ul>
<li><p>deleteBatchIds() 批处理方式:使用多个主键值,删除数据</p>
</li>
<li><p>参数:Collection&lt;? extends Serializable&gt; </p>
</li>
<li><p>返回值删除的记录数</p>
</li>
</ul>
</blockquote>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * deleteBatchIds() 批处理方式:使用多个主键值,删除数据</span></span><br><span class="line"><span class="comment">         * 参数:Collection&lt;? extends Serializable&gt;</span></span><br><span class="line"><span class="comment">         * 返回值删除的记录数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">6</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> peopleMapper.deleteBatchIds(list);</span><br></pre></td></tr></table></figure>

<p>新知识:可以通过Stream.Of().collect(Collectors.toList())的方式创建List集合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;?&gt; list = Stream.of(Object,Object....).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h4 id="四-插入"><a href="#四-插入" class="headerlink" title="四:插入"></a>四:插入</h4><ul>
<li>insert() 通过创建一个实体对象 再调用mapper的insert方法即可完成插入 <strong>INSERT INTO people ( name ) VALUES ( ? )</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">People</span> <span class="variable">people1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="literal">null</span>, <span class="string">&quot;fan&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> peopleMapper.insert(people1);</span><br></pre></td></tr></table></figure>

<h2 id="AR操作"><a href="#AR操作" class="headerlink" title="AR操作"></a><strong>AR操作</strong></h2><h4 id="ActiveRecord简介"><a href="#ActiveRecord简介" class="headerlink" title="ActiveRecord简介:"></a>ActiveRecord简介:</h4><ul>
<li>每一个数据库表对应创建一个类,类的每一个对象实例对应于数据库中表的一行记录;通常表的每个字段在类中都有相应的Field;</li>
<li>ActiveRecord 负责把自己持久化,在ActiveRecord中封装了对数据库的访问,通过对象自己实现CRUD,实现优雅的数据库操作</li>
<li>ActiveRecord也封住给你了部分业务逻辑.可以作为业务对象使用</li>
</ul>
<h4 id="快速开始-1"><a href="#快速开始-1" class="headerlink" title="快速开始"></a>快速开始</h4><ul>
<li>创建表</li>
<li>创建springboot整合mybatis-plus项目 与前面操作一致</li>
<li>编写实体类 继承Model<T>(这个Model时Mybatis-plus中的 这个Model中封装了很多crud方法实现机制 也是mybatis中的sqlsession)</li>
</ul>
<p>​    entity.People.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-01-21-23:08</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用AR,要求实体类需要继承MP中的Model</span></span><br><span class="line"><span class="comment"> *Model中提供了对数据库的CRUD的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">extends</span> <span class="title class_">Model</span>&lt;People&gt; &#123;</span><br><span class="line">    <span class="comment">//定义属性,属性名和表的列名一样</span></span><br><span class="line">    <span class="meta">@TableId(</span></span><br><span class="line"><span class="meta">            value = &quot;id&quot;,</span></span><br><span class="line"><span class="meta">            type = IdType.AUTO</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编写Mapper接口继承BaseMapper<T></li>
</ul>
<p>​    加上@Mapper注解</p>
<p>​    注意:<strong>我们后续使用不使用该mapper而是使用实体类的对象(继承了Model的原因 实体类对象已经具有了对数据库表的crud操作)</strong> 该mapper是不需要使用的,MP需要使用该mapper获取数据库的表的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Devil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-01-21-23:22</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PeopleMapper是不需要使用的,Mp需要使用PeopleMapper获取数据库的表的信息.</span></span><br><span class="line"><span class="comment"> * 如果不定义DeptMapper,MP会报错</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PeopleMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;People&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AR的CRUD操作"><a href="#AR的CRUD操作" class="headerlink" title="AR的CRUD操作"></a>AR的CRUD操作</h4><h5 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h5><ul>
<li>创建一个实体对象 设置属性 再使用该对象调用继承来的insert方法 就可以完成插入操作</li>
<li>返回值是一个boolean值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">people.setId(<span class="number">4</span>);</span><br><span class="line">people.setName(<span class="string">&quot;xie&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">insert</span> <span class="operator">=</span> people.insert();</span><br></pre></td></tr></table></figure>

<h5 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h5><ul>
<li>deleteById() 创建一个实体对象 只需要设置属性主键值(也可不设置 直接在方法参数上写) 再调用该方法 就会识别主键值 并根据主键值进行删除操作 <strong>DELETE FROM people WHERE id&#x3D;?</strong></li>
<li>返回值是boolean(注意与其他操作不同 这里的删除操作只要语句正确就不会为false)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">people.setId(<span class="number">5</span>);</span><br><span class="line"><span class="comment">/** 根据对象设置的主键id的值删除记录*/</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">delete</span> <span class="operator">=</span> people.deleteById();</span><br></pre></td></tr></table></figure>

<h5 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h5><ul>
<li>selectById() 创建一个实体对象 只需要设置属性主键值(也可不设置 直接在方法参数上写) 再调用该方法 就会识别主键值 并根据主键值进行查询操作 <strong>SELECT id,name FROM people WHERE id&#x3D;?</strong></li>
<li><strong>有记录返回值是一个Object 如果在创建实体类时继承Model设置了泛型那么返回值就是实体类的类型 无记录就是一个null</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">        people.setId(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/** 根据对象设置的主键id的值查询记录*/</span></span><br><span class="line">        <span class="type">People</span> <span class="variable">people1</span> <span class="operator">=</span> people.selectById(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>还有如下方法</p>
<p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220122174725782.png" alt="image-20220122174725782"></p>
<h5 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h5><ol>
<li>updateById() 创建一个实体对象 设置属性主键值 和其他属性 调用对象的updateById()方法 它会自动识别主键值(前面我们创建类时 设置了主键信息)并 修改 <strong>默认修改对象中非空的值</strong><ul>
<li>返回值是boolean</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">        people.setId(<span class="number">1</span>);</span><br><span class="line">        people.setName(<span class="string">&quot;kun&quot;</span>);</span><br><span class="line">        <span class="comment">/** 根据对象设置的主键id的值更新记录*/</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">update</span> <span class="operator">=</span> people.updateById();</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="主键类型"><a href="#主键类型" class="headerlink" title="主键类型"></a><strong>主键类型</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">IdType</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库ID自增</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;该类型请确保数据库设置了 ID自增 否则无效&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AUTO(<span class="number">0</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该类型为未设置主键类型(注解里等于跟随全局,全局里约等于 INPUT)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NONE(<span class="number">1</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户输入ID</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;该类型可以通过自己注册自动填充插件进行填充&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INPUT(<span class="number">2</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以下3种类型、只有当插入对象ID 为空，才自动填充。 */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分配ID (主键类型为number或string）,</span></span><br><span class="line"><span class="comment">     * 默认实现类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator&#125;(雪花算法)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.3.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ASSIGN_ID(<span class="number">3</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分配UUID (主键类型为 string)</span></span><br><span class="line"><span class="comment">     * 默认实现类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator&#125;(UUID.replace(&quot;-&quot;,&quot;&quot;))</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ASSIGN_UUID(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">    IdType(<span class="type">int</span> key) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述枚举类型 我们可以知道共有五种主键类型</p>
<p><strong>IdType</strong> 对于自动填充 只有当插入对象ID 为空，才自动填充。</p>
<ul>
<li><strong>0.NONE</strong> : 没有主键类型</li>
<li><strong>1.AUTO</strong> : 自动增长 前提是确保数据库设置了 ID自增 否则无效</li>
<li><strong>2.INPUT</strong> : 手工输入</li>
<li><strong>3.ASSIGN_ID</strong> :</li>
</ul>
<blockquote>
<p>分配ID (主键类型为number或string）  </p>
<p>默认实现类 {@link com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator}(雪花算法) </p>
</blockquote>
<ul>
<li><strong>4.ASSIGN_UUID</strong> :</li>
</ul>
<blockquote>
<p> 分配UUID (主键类型为 string)</p>
<p>默认实现类 {@link com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator}(UUID.replace(“-“,””))</p>
</blockquote>
<p>​    </p>
<h4 id="IdType-AUTO"><a href="#IdType-AUTO" class="headerlink" title="IdType.AUTO"></a>IdType.AUTO</h4><ol>
<li>表中建表使用数字作为主键, 设置主键id自增</li>
</ol>
<p>​    <img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220122180836796.png" alt="image-20220122180836796"></p>
<ol start="2">
<li>实体类表中主键值也要为数字类型 并添加注解@TableId 设置主键以及主键类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">extends</span> <span class="title class_">Model</span>&lt;People&gt; &#123;</span><br><span class="line">    <span class="comment">//定义属性,属性名和表的列名一样</span></span><br><span class="line">    <span class="meta">@TableId(</span></span><br><span class="line"><span class="meta">            value = &quot;id&quot;,</span></span><br><span class="line"><span class="meta">            type = IdType.AUTO</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="IdType-ASSIGN-ID"><a href="#IdType-ASSIGN-ID" class="headerlink" title="IdType.ASSIGN_ID"></a>IdType.ASSIGN_ID</h4><ol>
<li>使用时需要在数据库表中 需要取消主键自动增长 并且设置主键类型时bigint 因为这个主键的值很大 int类型大小不够 <strong>还可以使用varchar(50)类型</strong></li>
</ol>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220122182035368.png" alt="image-20220122182035368"></p>
<ol start="2">
<li>实体类中将主键类型设置为Long原因与上述一样 并且设置注解@TableId中type的值为<strong>IdType.ASSIGN_ID</strong> <strong>如果数据库中主键使用varchar(50)那么相应的实体类中的主键类型也应当为String类型</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">extends</span> <span class="title class_">Model</span>&lt;People&gt; &#123;</span><br><span class="line">    <span class="comment">//定义属性,属性名和表的列名一样</span></span><br><span class="line">    <span class="meta">@TableId(</span></span><br><span class="line"><span class="meta">            value = &quot;id&quot;,</span></span><br><span class="line"><span class="meta">            type = IdType.ASSIGN_ID</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> Long/String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220122182324329.png" alt="image-20220122182324329"></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220122182719124.png" alt="image-20220122182719124"></p>
<h4 id="IdType-ASSIGN-UUID"><a href="#IdType-ASSIGN-UUID" class="headerlink" title="IdType.ASSIGN_UUID"></a>IdType.ASSIGN_UUID</h4><ol>
<li>使用时需要在数据库表中, 将主键类型设置为varchar(50)类型</li>
</ol>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220122183109184.png" alt="image-20220122183109184"></p>
<ol start="2">
<li>实体类中的主键类型设置为String类型 并且注解@TableId中需要将type设置为<strong>IdType.ASSIGN_UUID</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">extends</span> <span class="title class_">Model</span>&lt;People&gt; &#123;</span><br><span class="line">    <span class="comment">//定义属性,属性名和表的列名一样</span></span><br><span class="line">    <span class="meta">@TableId(</span></span><br><span class="line"><span class="meta">            value = &quot;id&quot;,</span></span><br><span class="line"><span class="meta">            type = IdType.ASSIGN_UUID</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220122183419332.png" alt="image-20220122183419332"></p>
<p>分布式中推荐使用 <strong>IdType.ASSIGN_ID</strong> 它可以生成数字而且长度更短更有规律</p>
<hr>
<h2 id="指定表名"><a href="#指定表名" class="headerlink" title="指定表名"></a><strong>指定表名</strong></h2><ul>
<li>定义实体类,默认的表名和实体类同名; 如果不一致,在实体类上面使用@TableName说明表名称</li>
<li>例如: <strong>@TableName(value&#x3D;”数据库表名”)</strong> </li>
<li>使用: 在实体类的上方</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(value = &quot;people&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">extends</span> <span class="title class_">Model</span>&lt;People&gt; &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指定列名"><a href="#指定列名" class="headerlink" title="指定列名"></a><strong>指定列名</strong></h2><ul>
<li>在实际开发中, 不能完全出现实体类中的属性名与 数据库表中的列名完全一致; 如果不一致,在实体类上面使用@TableField完成两者之间的映射关系</li>
<li>例如:<strong>@TableField(value&#x3D;”数据库表中的列名”)</strong> 查询时需要将结果封装成一个一个的对象时 需要在@TableName中设置<strong>autoResultMap &#x3D; true</strong> 否则在使用了@TableField后可能会出现控制的情况</li>
<li>使用: 在实体类中的属性的上方</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义属性,属性名和表的列名一样</span></span><br><span class="line"><span class="meta">@TableId(</span></span><br><span class="line"><span class="meta">        value = &quot;pid&quot;,</span></span><br><span class="line"><span class="meta">        type = IdType.ASSIGN_UUID</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@TableField(value = &quot;pid&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String id;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="驼峰命名"><a href="#驼峰命名" class="headerlink" title="驼峰命名"></a>驼峰命名</h4><p>上述 在开发中使用@TableField指定属性与表中的列名的映射关系十分麻烦</p>
<p>一般在设计数据库表时采用下划线的方式命名 如<strong>user_name</strong></p>
<p>​    这就引申出Mybatis-plus的另一个特性 驼峰命名 即: <strong>列名使用下划线,属性名时驼峰命名的方式.Mybatis-plus默认支持这种规则.</strong> (即列名为: user_name  属性名为:userName 不需要使用@TableField Mybatis-plus同样能够识别)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">列名: people_name</span><br><span class="line">属性名: <span class="keyword">private</span> String peopleName;</span><br></pre></td></tr></table></figure>

<h2 id="自定义mapper"><a href="#自定义mapper" class="headerlink" title="自定义mapper"></a><strong>自定义mapper</strong></h2><p>自定义mapper</p>
<p>与mybatis一样 需要在创建一个接口写入自定义的方法 然后再编写一个mapper.xml文件 声明namespace 方法标签 resultType 和自定义方法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.dyw.mybatisplus05mapper.mapper.PersonMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAllPerson&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.dyw.mybatisplus05mapper.entity.Person&quot;</span>&gt;</span></span><br><span class="line">        select pid,people_name from people order by pid</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>做完一切之后可以选择再mapper接口上加上@Mapper注解 或者 在启动类上加上@MapperScan(value&#x3D;”mapper接口路径”) 用来指明mapper的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonMapper</span> &#123;</span><br><span class="line">    List&lt;Person&gt; <span class="title function_">selectAllPerson</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在application.yml中声明mapper.xml的路径</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath*:xml/*mapper.xml</span></span><br></pre></td></tr></table></figure>

<p><strong>这样的方法也同样适用于Springboot+mybatis(@Mapper&#x2F;@MapperScan+mapper.xml)</strong></p>
<p><strong>还有一种方法 @Mapper&#x2F;@MapperScan+@crud操作</strong> 也同样适用于mybatis 或者说正是因为mybatis有 所以mybatis-plus也支持</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">@SuppressWarnings(&quot;all&quot;)</span><br><span class="line">public interface PersonMapper &#123;</span><br><span class="line">    @Select(&quot;select pid,people_name from people order by pid&quot;)</span><br><span class="line">    List&lt;Person&gt; selectAllPerson();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Mapper和@MapperScan作用 告诉了程序mapper接口在哪 </p>
<h2 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a><strong>条件构造器</strong></h2><h4 id="条件构造器-Wrapper"><a href="#条件构造器-Wrapper" class="headerlink" title="条件构造器: Wrapper"></a>条件构造器: Wrapper</h4><p>QueryWrapper(LambdaQueryWrapper) 和 UpdateWrapper(LambdaUpdateWrapper)的父类 用于生成sql的where条件,entity属性也用于生成sql的where条件,MP3.0开始支持lambda表达式, LambdaQueryWrapper, LambdaUpdateWrapper 支持lambda表达式的构造查询条件</p>
<p><strong>注意:</strong> entity 生成的 where 条件与 使用各个 api 生成的 where 条件<strong>没有任何关联行为</strong></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220122210417087.png" alt="image-20220122210417087"></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220122210440192.png" alt="image-20220122210440192"></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220122210457290.png" alt="image-20220122210457290"></p>
<p><img src="https://gitee.com/Devildyw/blogimage/raw/master/img/image-20220122210545890.png" alt="image-20220122210545890"></p>
<p><strong>使用时根据不同的crud操作选择不同的条件封装类</strong></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220122211725390.png" alt="image-20220122211725390"></p>
<p>实际使用的例子都在官方文档中可以查看<a href="https://www.mybatis-plus.com/guide/wrapper.html#abstractwrapper">条件构造器</a></p>
<p>具体使用</p>
<h5 id="allEq"><a href="#allEq" class="headerlink" title="allEq"></a>allEq</h5><h6 id="1-allEq-Map-lt-R-V-gt-params"><a href="#1-allEq-Map-lt-R-V-gt-params" class="headerlink" title="1. allEq(Map&lt;R, V&gt; params)"></a>1. allEq(Map&lt;R, V&gt; params)</h6><ul>
<li>根据不同的crud选择不同的条件封装类 创建相应的条件封装类实体 </li>
<li>由于要使用allEq(Map&lt;R, V&gt; params)方法, 它的参数是一个map 所以需要新建一个map, map中的键值对 就是条件 用<strong>and连接</strong></li>
<li>再调用mapper的方法将封装类实体传入</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 alleq</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/*map&lt;key,value&gt; key:列名 value:条件的值 */</span></span><br><span class="line">map.put(<span class="string">&quot;pid&quot;</span>,<span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;people_name&quot;</span>,<span class="string">&quot;kun&quot;</span>);</span><br><span class="line"><span class="comment">/*封装到Wrapper中*/</span></span><br><span class="line">qw.allEq(map);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure>



<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220122212326283.png" alt="image-20220122212326283"></p>
<hr>
<h6 id="2-allEq-Map-lt-R-V-gt-params-boolean-null2IsNull"><a href="#2-allEq-Map-lt-R-V-gt-params-boolean-null2IsNull" class="headerlink" title="2. allEq(Map&lt;R, V&gt; params,boolean null2IsNull)"></a>2. allEq(Map&lt;R, V&gt; params,boolean null2IsNull)</h6><ul>
<li><p>后面的boolean值是用来处理传入的map中的value空值的.</p>
<blockquote>
<p>true: 将map中value控制用is 拼接</p>
<p>false: 忽略空value和key 不对该字段进行拼接</p>
</blockquote>
</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220122213108202.png" alt="image-20220122213108202"></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220122213134669.png" alt="image-20220122213134669"></p>
<hr>
<h5 id="eq-封装单个条件"><a href="#eq-封装单个条件" class="headerlink" title="eq: 封装单个条件"></a>eq: 封装单个条件</h5><h6 id="eq-R-column-Object-val-列名-值"><a href="#eq-R-column-Object-val-列名-值" class="headerlink" title="eq(R column, Object val): 列名,值"></a>eq(R column, Object val): 列名,值</h6><p>使用条件封装类的实体类的eq方法 调用直接填入列名和相应的值即可 是使用的’&#x3D;’连接</p>
<p><code>SELECT pid,people_name FROM people WHERE (pid = ?)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 eq</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/*封装到Wrapper中*/</span></span><br><span class="line">qw.eq(<span class="string">&quot;pid&quot;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="ne-不等于"><a href="#ne-不等于" class="headerlink" title="ne:不等于"></a>ne:不等于</h5><h6 id="ne-R-column-Object-val-表示-lt-gt-和-x3D"><a href="#ne-R-column-Object-val-表示-lt-gt-和-x3D" class="headerlink" title="ne(R column, Object val) 表示&lt;&gt; 和 !&#x3D;"></a>ne(R column, Object val) 表示&lt;&gt; 和 !&#x3D;</h6><ul>
<li>使用列名, 值 通过&lt;&gt; 拼接  </li>
<li><code>Preparing: SELECT pid,people_name FROM people WHERE (pid &lt;&gt; ?)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 eq</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/*封装到Wrapper中*/</span></span><br><span class="line">qw.ne(<span class="string">&quot;pid&quot;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="gt-大于"><a href="#gt-大于" class="headerlink" title="gt:大于"></a>gt:大于</h5><h6 id="gt-R-column-Object-val-表示-gt"><a href="#gt-R-column-Object-val-表示-gt" class="headerlink" title="gt(R column, Object val) 表示 &gt;"></a>gt(R column, Object val) 表示 &gt;</h6><ul>
<li>使用列名, 值 通过&gt; 拼接  </li>
<li><code>SELECT pid,people_name FROM people WHERE (pid &gt; ?)</code></li>
</ul>
<hr>
<h5 id="ge-大于等于"><a href="#ge-大于等于" class="headerlink" title="ge:大于等于"></a>ge:大于等于</h5><h6 id="ge-R-column-Object-val-表示-gt-x3D"><a href="#ge-R-column-Object-val-表示-gt-x3D" class="headerlink" title="ge(R column, Object val) 表示 &gt;&#x3D;"></a>ge(R column, Object val) 表示 &gt;&#x3D;</h6><ul>
<li>使用列名, 值 通过&gt;&#x3D; 拼接  </li>
<li><code>SELECT pid,people_name FROM people WHERE (pid &gt;= ?)</code></li>
</ul>
<hr>
<h5 id="lt-小于"><a href="#lt-小于" class="headerlink" title="lt:小于"></a>lt:小于</h5><h6 id="lt-R-column-Object-val-表示-lt"><a href="#lt-R-column-Object-val-表示-lt" class="headerlink" title="lt(R column, Object val) 表示 &lt;"></a>lt(R column, Object val) 表示 &lt;</h6><ul>
<li>使用列名, 值 通过&lt; 拼接  </li>
<li><code>SELECT pid,people_name FROM people WHERE (pid &lt; ?)</code></li>
</ul>
<hr>
<h5 id="le-小于等于"><a href="#le-小于等于" class="headerlink" title="le:小于等于"></a>le:小于等于</h5><h6 id="lt-R-column-Object-val-表示-lt-x3D"><a href="#lt-R-column-Object-val-表示-lt-x3D" class="headerlink" title="lt(R column, Object val) 表示 &lt;&#x3D;"></a>lt(R column, Object val) 表示 &lt;&#x3D;</h6><ul>
<li>使用列名, 值 通过&lt;&#x3D; 拼接  </li>
<li><code>SELECT pid,people_name FROM people WHERE (pid &lt;= ?)</code></li>
</ul>
<hr>
<h5 id="between-两个值范围之间-gt-x3D-and-lt-x3D"><a href="#between-两个值范围之间-gt-x3D-and-lt-x3D" class="headerlink" title="between: 两个值范围之间(&gt;&#x3D; and &lt;&#x3D;)"></a>between: 两个值范围之间(&gt;&#x3D; and &lt;&#x3D;)</h5><h6 id="1-between-R-column-Object-val1-Object-val2-列名-值1-值2"><a href="#1-between-R-column-Object-val1-Object-val2-列名-值1-值2" class="headerlink" title="1.between(R column, Object val1, Object val2) 列名 值1 值2"></a>1.between(R column, Object val1, Object val2) 列名 值1 值2</h6><ul>
<li><p>通过列名相同的两个值 来创建两个值范围之间的条件 通过<strong>between</strong>拼接</p>
</li>
<li><p><code>SELECT pid,people_name FROM people WHERE (pid BETWEEN ? AND ?)</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 between</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/*封装到Wrapper中*/</span></span><br><span class="line">qw.between(<span class="string">&quot;pid&quot;</span>,<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="2-notBetween-R-column-Object-val1-Object-val2-列名-值1-值2"><a href="#2-notBetween-R-column-Object-val1-Object-val2-列名-值1-值2" class="headerlink" title="2. notBetween(R column, Object val1, Object val2) 列名 值1 值2"></a>2. notBetween(R column, Object val1, Object val2) 列名 值1 值2</h6><ul>
<li><p>通过列名相同的两个值 来创建两个值范围之间的条件 通过<strong>between</strong>拼接</p>
</li>
<li><p><code>SELECT pid,people_name FROM people WHERE (pid NOT BETWEEN ? AND ?)</code></p>
</li>
</ul>
<hr>
<h5 id="like-模糊查询"><a href="#like-模糊查询" class="headerlink" title="like 模糊查询"></a>like 模糊查询</h5><h6 id="1-like-R-column-Object-val-列名-值"><a href="#1-like-R-column-Object-val-列名-值" class="headerlink" title="1. like(R column, Object val) 列名 值"></a>1. like(R column, Object val) 列名 值</h6><ul>
<li>like模糊查询 在值的前后都是用%拼接( %val% ) 查询之中存在val的数据</li>
<li><code>SELECT pid,people_name FROM people WHERE (people_name LIKE ?)  Parameters: %k%(String)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 like</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/*封装到Wrapper中*/</span></span><br><span class="line">qw.like(<span class="string">&quot;people_name&quot;</span>,<span class="string">&quot;k&quot;</span>);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="2-notLike-R-column-Object-val-列名-值"><a href="#2-notLike-R-column-Object-val-列名-值" class="headerlink" title="2. notLike(R column, Object val) 列名 值"></a>2. notLike(R column, Object val) 列名 值</h6><ul>
<li>notLike模糊查询 在值的前后都是用%拼接( %val%)  查询之中不存在val的数据</li>
<li><code>SELECT pid,people_name FROM people WHERE (people_name NOT LIKE ?)  Parameters: %k%(String)</code></li>
</ul>
<hr>
<h6 id="3-likeLeft-R-column-Object-val-列名-值"><a href="#3-likeLeft-R-column-Object-val-列名-值" class="headerlink" title="3. likeLeft(R column, Object val) 列名 值"></a>3. likeLeft(R column, Object val) 列名 值</h6><ul>
<li>likeLeft模糊查询 在值的左边用%拼接( %val)  查询以val结尾的的数据</li>
<li><code>SELECT pid,people_name FROM people WHERE (people_name LIKE ?)  Parameters: %k(String)</code></li>
</ul>
<hr>
<h6 id="4-likeLeft-R-column-Object-val-列名-值"><a href="#4-likeLeft-R-column-Object-val-列名-值" class="headerlink" title="4. likeLeft(R column, Object val) 列名 值"></a>4. likeLeft(R column, Object val) 列名 值</h6><ul>
<li>likeLeft模糊查询 在值的右边用%拼接( val%)  查询以val开头的的数据</li>
<li><code>SELECT pid,people_name FROM people WHERE (people_name LIKE ?)  Parameters: k%(String)</code></li>
</ul>
<hr>
<h5 id="null-判空"><a href="#null-判空" class="headerlink" title="null: 判空"></a>null: 判空</h5><h6 id="1-isNull-R-column-列名"><a href="#1-isNull-R-column-列名" class="headerlink" title="1.isNull(R column) 列名"></a>1.isNull(R column) 列名</h6><ul>
<li>判断所指列名为空的情况 以 is null 连接</li>
<li><code>SELECT pid,people_name FROM people WHERE (people_name IS NULL)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 like</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/*封装到Wrapper中*/</span></span><br><span class="line">qw.isNull(<span class="string">&quot;people_name&quot;</span>);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="1-isNull-R-column-列名-1"><a href="#1-isNull-R-column-列名-1" class="headerlink" title="1.isNull(R column) 列名"></a>1.isNull(R column) 列名</h6><ul>
<li>判断所指列名为不为空的情况 以 is not null 连接</li>
<li><code>SELECT pid,people_name FROM people WHERE (people_name IS NOT NULL)</code></li>
</ul>
<hr>
<h5 id="in-集合查询"><a href="#in-集合查询" class="headerlink" title="in 集合查询"></a>in 集合查询</h5><h6 id="1-in-R-column-Object…-values-列名-值1…-也可以传入一个集合"><a href="#1-in-R-column-Object…-values-列名-值1…-也可以传入一个集合" class="headerlink" title="1. in(R column, Object… values) 列名,值1…..  也可以传入一个集合"></a>1. in(R column, Object… values) 列名,值1…..  也可以传入一个集合</h6><ul>
<li>in查询 将值封装到一个集合中 底层是or连接 查询满足集合范围中条件的数据</li>
<li><code>SELECT pid,people_name FROM people WHERE (pid IN (?,?,?))</code></li>
</ul>
<h6 id="2-notIn-R-column-Object…-values-列名-值1…-也可以传入一个集合"><a href="#2-notIn-R-column-Object…-values-列名-值1…-也可以传入一个集合" class="headerlink" title="2. notIn(R column, Object… values) 列名,值1…..  也可以传入一个集合"></a>2. notIn(R column, Object… values) 列名,值1…..  也可以传入一个集合</h6><ul>
<li>in查询 将值封装到一个集合中 底层是or连接 查询不符合集合范围中条件的数据</li>
<li><code>SELECT pid,people_name FROM people WHERE (pid NOT IN (?,?,?))</code></li>
</ul>
<hr>
<h5 id="inSql-子查询"><a href="#inSql-子查询" class="headerlink" title="inSql 子查询"></a>inSql 子查询</h5><h6 id="1-inSql-R-column-String-inValue-列名-子查询语句"><a href="#1-inSql-R-column-String-inValue-列名-子查询语句" class="headerlink" title="1. inSql(R column, String inValue) 列名, 子查询语句"></a>1. inSql(R column, String inValue) 列名, 子查询语句</h6><ul>
<li>类型于in(),  前面的列名用来筛选子查询结果中符合条件的值 将其放在in()的集合中 后续步骤与in查询一致  </li>
<li><code>SELECT pid,people_name FROM people WHERE (people_name IN (select people_name from people where pid = 1))</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 inSql</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/*封装到Wrapper中*/</span></span><br><span class="line">qw.inSql(<span class="string">&quot;people_name&quot;</span>,<span class="string">&quot;select people_name from people where pid = 1&quot;</span>);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="2-notInSql-R-column-String-inValue-列名-子查询语句"><a href="#2-notInSql-R-column-String-inValue-列名-子查询语句" class="headerlink" title="2. notInSql(R column, String inValue) 列名, 子查询语句"></a>2. notInSql(R column, String inValue) 列名, 子查询语句</h6><ul>
<li>类型于notIn(),  前面的列名用来筛选子查询结果中符合条件的值 将其放在in()的集合中 后续步骤与notIn查询一致  </li>
<li><code>SELECT pid,people_name FROM people WHERE (people_name NOT IN (select people_name from people where pid = 1))</code></li>
</ul>
<hr>
<h5 id="groupBy-分组函数"><a href="#groupBy-分组函数" class="headerlink" title="groupBy 分组函数"></a>groupBy 分组函数</h5><h6 id="1-groupBy-R-column-列名"><a href="#1-groupBy-R-column-列名" class="headerlink" title="1. groupBy(R column): 列名"></a>1. groupBy(R column): 列名</h6><ul>
<li><p>在使用分组函数之前 需要调用Wrapper的select方法 指定要输出的参数 例如<code>select(&quot;people_name, count(*)&quot;);</code></p>
</li>
<li><p>按指定的列名进行分组</p>
</li>
<li><p><code>SELECT people_name, count(*) FROM people GROUP BY people_name</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 groupBy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/*封装到Wrapper中*/</span></span><br><span class="line">qw.select(<span class="string">&quot;people_name, count(*)&quot;</span>);</span><br><span class="line">qw.groupBy(<span class="string">&quot;people_name&quot;</span>);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="orderBy-排序"><a href="#orderBy-排序" class="headerlink" title="orderBy 排序"></a>orderBy 排序</h5><h6 id="1-orderByAsc-R-column-列名"><a href="#1-orderByAsc-R-column-列名" class="headerlink" title="1. orderByAsc(R column) 列名"></a>1. orderByAsc(R column) 列名</h6><ul>
<li><p>按列名字段升序排序 还可以设置多个列名字段 来作为第二排序字段 也可以是集合</p>
</li>
<li><p><code>SELECT pid,people_name FROM people ORDER BY pid ASC</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 orderBy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">qw.orderByAsc(<span class="string">&quot;pid&quot;</span>);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="2-orderByDesc-R-column-列名"><a href="#2-orderByDesc-R-column-列名" class="headerlink" title="2. orderByDesc(R column) 列名"></a>2. orderByDesc(R column) 列名</h6><ul>
<li><p>按列名字段降序排序 还可以设置多个列名字段 来作为第二排序字段 也可以是集合</p>
</li>
<li><p><code>SELECT pid,people_name FROM people ORDER BY pid DESC</code></p>
</li>
</ul>
<hr>
<h6 id="3-orderBy-boolean-condition-boolean-isAsc-R-column-条件-是否升序-列名字段"><a href="#3-orderBy-boolean-condition-boolean-isAsc-R-column-条件-是否升序-列名字段" class="headerlink" title="3. orderBy(boolean condition, boolean isAsc, R column) 条件 是否升序 列名字段"></a>3. orderBy(boolean condition, boolean isAsc, R column) 条件 是否升序 列名字段</h6><ul>
<li><p>按列isAsc来判断是否是升序 还是降序排序 还可以设置多个列名字段 来作为第二排序字段 也可以是集合</p>
</li>
<li><p><code>SELECT pid,people_name FROM people ORDER BY pid ASC/DESC</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 orderBy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">qw.orderBy(<span class="literal">true</span>,<span class="literal">true</span>,<span class="string">&quot;pid&quot;</span>);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure>

<h6 id="4-多字段不同排序规则排序"><a href="#4-多字段不同排序规则排序" class="headerlink" title="4. 多字段不同排序规则排序"></a>4. 多字段不同排序规则排序</h6><ul>
<li><p>可以在上述的方法后再调用orderBy()相关方法 完成多字段不同排序规则排序 可拼接多个</p>
</li>
<li><p><code>qw.orderBy(true,true,&quot;pid&quot;).orderBy(true,false,&quot;people_name&quot;);</code></p>
</li>
<li><p><code>SELECT pid,people_name FROM people ORDER BY pid ASC,people_name DESC</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 orderBy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">qw.orderBy(<span class="literal">true</span>,<span class="literal">true</span>,<span class="string">&quot;pid&quot;</span>).orderBy(<span class="literal">true</span>,<span class="literal">false</span>,<span class="string">&quot;people_name&quot;</span>);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="or-and-连接词"><a href="#or-and-连接词" class="headerlink" title="or and 连接词"></a>or and 连接词</h5><h6 id="1-and"><a href="#1-and" class="headerlink" title="1. and"></a>1. and</h6><ul>
<li>与or() 有关 再显式调用or()方法时 时使用or来连接 不调用or()方法连接 默认使用and连接</li>
<li><code>qw.eq(&quot;pid&quot;,1).eq(&quot;people_name&quot;,&quot;k&quot;);</code></li>
<li><code>SELECT pid,people_name FROM people WHERE (pid = ? AND people_name = ?)</code></li>
</ul>
<hr>
<h6 id="2-or-无参"><a href="#2-or-无参" class="headerlink" title="2.or() 无参"></a>2.or() 无参</h6><ul>
<li>在单个条件方法后面使用 or() 再拼接另一个条件 以此类推 可拼接多个</li>
<li><code>qw.eq(&quot;pid&quot;,1).or().eq(&quot;people_name&quot;,&quot;k&quot;);</code></li>
<li><code>SELECT pid,people_name FROM people WHERE (pid = ? OR people_name = ?)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建条件构造器 or</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">qw.eq(<span class="string">&quot;pid&quot;</span>,<span class="number">1</span>).or().eq(<span class="string">&quot;people_name&quot;</span>,<span class="string">&quot;k&quot;</span>);</span><br><span class="line"><span class="comment">/*调用方法 将条件构造器填入*/</span></span><br><span class="line">List&lt;Person&gt; people = personMapper.selectList(qw);</span><br></pre></td></tr></table></figure>



<p>还有or 和 and 的嵌套用法 再官方文档可以了解<a href="https://www.mybatis-plus.com/guide/wrapper.html#or">or and 的嵌套</a></p>
<hr>
<h5 id="last-末尾拼接"><a href="#last-末尾拼接" class="headerlink" title="last 末尾拼接"></a>last 末尾拼接</h5><h6 id="1-last-String-lastSql-拼接的sql语句"><a href="#1-last-String-lastSql-拼接的sql语句" class="headerlink" title="1. last(String lastSql) 拼接的sql语句"></a>1. last(String lastSql) 拼接的sql语句</h6><ul>
<li>无视优化规则直接拼接到 sql 的最后</li>
<li>会将参数中的sql语句 拼接到末尾 可以调用了方法之后调用</li>
<li><code>qw.gt(&quot;pid&quot;,1).last(&quot;limit 1,10&quot;);</code></li>
<li><code>SELECT pid,people_name FROM people WHERE (pid &gt; ?) limit 1,10</code></li>
</ul>
<p><strong>这种方法存在sql注入风险</strong></p>
<p>**注意: **只能调用一次,多次调用以最后一次为准 有sql注入的风险,请谨慎使用</p>
<hr>
<h5 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h5><h6 id="1-exists-String-existsSql-sql语句"><a href="#1-exists-String-existsSql-sql语句" class="headerlink" title="1. exists(String existsSql) sql语句"></a>1. exists(String existsSql) sql语句</h6><ul>
<li>判断参数中的sql语句 是否成立 符合条件即成立</li>
<li><code> qw.exists(&quot;select pid from people where pid &gt; 7&quot;);</code></li>
<li><code>SELECT pid,people_name FROM people WHERE (EXISTS (select pid from people where pid &gt; 7))</code></li>
</ul>
<hr>
<h6 id="1-notExists-String-existsSql-sql语句"><a href="#1-notExists-String-existsSql-sql语句" class="headerlink" title="1. notExists(String existsSql) sql语句"></a>1. notExists(String existsSql) sql语句</h6><ul>
<li>判断参数中的sql语句 是否成立 不符合条件即成立</li>
<li><code> qw.notExists(&quot;select pid from people where pid &lt;0 &quot;);</code></li>
<li><code>SELECT pid,people_name FROM people WHERE (NOT EXISTS (select pid from people where pid &lt;0 ))</code></li>
</ul>
<hr>
<h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意:"></a>注意:</h5><p>方法参数<strong>boolean condition</strong> (可以防止条件判断例如name!&#x3D;null)决定后面该条件是否添加 true:添加 false:不添加</p>
<hr>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a><strong>分页</strong></h2><h3 id="InnerInterceptor插件"><a href="#InnerInterceptor插件" class="headerlink" title="InnerInterceptor插件"></a>InnerInterceptor插件</h3><p>我们提供的插件都将基于此接口来实现功能</p>
<p>目前已有的功能:</p>
<ul>
<li>自动分页: <strong>PaginationInnerInterceptor</strong></li>
<li>多租户: TenantLineInnerInterceptor</li>
<li>动态表名: DynamicTableNameInnerInterceptor</li>
<li>乐观锁: OptimisticLockerInnerInterceptor</li>
<li>sql性能规范: IllegalSQLInnerInterceptor</li>
<li>防止全表更新与删除: BlockAttackInnerInterceptor</li>
</ul>
<p>前提: 配置分页插件,实现物理分页. 默认是内存分页</p>
<h3 id="spring-boot"><a href="#spring-boot" class="headerlink" title="spring-boot"></a>spring-boot</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;scan.your.mapper.package&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新的分页插件,一缓和二缓遵循mybatis的规则,需要设置 MybatisConfiguration#useDeprecatedExecutor = false 避免缓存出现问题(该属性会在旧插件移除后一同移除)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    @Bean</span></span><br><span class="line"><span class="comment">    public ConfigurationCustomizer configurationCustomizer() &#123;</span></span><br><span class="line"><span class="comment">        return configuration -&gt; configuration.setUseDeprecatedExecutor(false);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringBoot中创建配置上述配置类 @Configuration @Bean</p>
<p>将MybatisPlusInterceptor组件交给SpringBoot容器</p>
<p>再在使用的时候创建IPage接口对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IPage&lt;Person&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;();<span class="comment">//也可使用有参构造</span></span><br></pre></td></tr></table></figure>

<p>设置完参数过后 使用mapper对象的selectPage方法 返回一个Ipage对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IPage&lt;Person&gt; personIPage = peopleMapper.selectPage(page, qw);</span><br></pre></td></tr></table></figure>

<p>通过该对象 可以获得分页相关的信息(包括查询的记录)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">QueryWrapper&lt;Person&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">        qw.ge(<span class="string">&quot;pid&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        IPage&lt;Person&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//设置分页的数据</span></span><br><span class="line"></span><br><span class="line">        page.setCurrent(<span class="number">1</span>);<span class="comment">//设置第几页</span></span><br><span class="line">        page.setSize(<span class="number">4</span>);<span class="comment">//显示多少条记录</span></span><br><span class="line">        IPage&lt;Person&gt; personIPage = peopleMapper.selectPage(page, qw);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取分页后的记录 getRecords()</span></span><br><span class="line">        List&lt;Person&gt; records = personIPage.getRecords();</span><br><span class="line">        System.out.println(records.size());</span><br><span class="line">        <span class="keyword">for</span> (Person record : records) &#123;</span><br><span class="line">            System.out.println(record);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//页数</span></span><br><span class="line">        System.out.println(personIPage.getPages());</span><br><span class="line">        <span class="comment">//总记录数</span></span><br><span class="line">        System.out.println(personIPage.getTotal());</span><br><span class="line">        <span class="comment">//当前页码</span></span><br><span class="line">        System.out.println(personIPage.getCurrent());</span><br><span class="line">        <span class="comment">//每页记录数</span></span><br><span class="line">        System.out.println(personIPage.getSize());</span><br></pre></td></tr></table></figure>



<p><strong>会根据指定的数据库选择分页操作</strong>(mysql是limit)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT pid,people_name FROM people <span class="title function_">WHERE</span> <span class="params">(pid &gt;= ?)</span> LIMIT ?</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis-config.xml"></a>mybatis-config.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;@page&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;page:dbType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a><strong><a href="https://www.mybatis-plus.com/guide/generator-new.html#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8-3-5-1-%E7%89%88%E6%9C%AC">代码生成器</a></strong></h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><p>AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。</p>
<blockquote>
<p>特别说明:</p>
<p>自定义模板有哪些可用参数？<a href="https://github.com/baomidou/generator/blob/develop/mybatis-plus-generator/src/main/java/com/baomidou/mybatisplus/generator/engine/AbstractTemplateEngine.java">Github (opens new window)</a>AbstractTemplateEngine 类中方法 getObjectMap 返回 objectMap 的所有值都可用。</p>
</blockquote>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用:"></a>使用:</h4><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">   // 注意！！当前包未传递依赖 mp 包，需要自己引入</span><br><span class="line">   <span class="comment">&lt;!--模板引擎--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在工程包下建立一个实体类(启动类)如下 修改相应的信息即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/my_db&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;devil&quot;</span>;</span><br><span class="line"></span><br><span class="line">        FastAutoGenerator.create(url,name,password)</span><br><span class="line">                <span class="comment">//全局配置</span></span><br><span class="line">                .globalConfig((scanner,builder) -&gt;</span><br><span class="line">                        builder.author(scanner.apply(<span class="string">&quot;Devil&quot;</span>))</span><br><span class="line">                                <span class="comment">//输出目录</span></span><br><span class="line">                                .outputDir(<span class="string">&quot;E:\\MyBatis\\mybatis-puls-07-generator&quot;</span>+<span class="string">&quot;\\src\\main\\java&quot;</span>)</span><br><span class="line">                                <span class="comment">//覆盖已生成的文件</span></span><br><span class="line">                                .fileOverride()</span><br><span class="line">                                <span class="comment">//禁止打开输出目录: 默认true</span></span><br><span class="line">                                .disableOpenDir()</span><br><span class="line">                )</span><br><span class="line">                <span class="comment">//包配置</span></span><br><span class="line">                .packageConfig((scanner,builder)-&gt;</span><br><span class="line">                        builder.parent(<span class="string">&quot;com.dyw.mybatispuls07generator&quot;</span>)</span><br><span class="line">                                <span class="comment">//自定义实体包名</span></span><br><span class="line">                                .entity(<span class="string">&quot;entity&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">                <span class="comment">//策略配置</span></span><br><span class="line">                .strategyConfig((scanner,builder) -&gt;</span><br><span class="line">                        builder.addInclude(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                                <span class="comment">//控制层配置</span></span><br><span class="line">                                .controllerBuilder().enableRestStyle().enableHyphenStyle()</span><br><span class="line">                                <span class="comment">//服务层配置</span></span><br><span class="line">                                .serviceBuilder()</span><br><span class="line">                                    <span class="comment">//去除服务接口的I前缀 %s表示实体类名:</span></span><br><span class="line">                                    .formatServiceFileName(<span class="string">&quot;%sServcie&quot;</span>)</span><br><span class="line">                                <span class="comment">//实体层配置</span></span><br><span class="line">                                .entityBuilder()</span><br><span class="line">                                .enableLombok()</span><br><span class="line">                                <span class="comment">//主键策略</span></span><br><span class="line">                                .idType(IdType.AUTO)</span><br><span class="line">                                <span class="comment">//时间自动填充</span></span><br><span class="line"><span class="comment">//                                .addTableFills(new Column(&quot;gmt_create&quot;, FieldFill.INSERT))</span></span><br><span class="line"><span class="comment">//                                .addTableFills(new Column(&quot;gmt_modified&quot;, FieldFill.INSERT_UPDATE))</span></span><br><span class="line">                                <span class="comment">//乐观锁</span></span><br><span class="line">                                .versionColumnName(<span class="string">&quot;version&quot;</span>)</span><br><span class="line">                                .versionPropertyName(<span class="string">&quot;version&quot;</span>)</span><br><span class="line">                                <span class="comment">//逻辑删除</span></span><br><span class="line">                                .logicDeleteColumnName(<span class="string">&quot;deleted&quot;</span>)</span><br><span class="line">                                .logicDeletePropertyName(<span class="string">&quot;deleted&quot;</span>)</span><br><span class="line">                ).templateEngine(<span class="keyword">new</span> <span class="title class_">VelocityTemplateEngine</span>()).execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a><a href="https://baomidou.com/pages/6b03c5/#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">逻辑删除</a></h3><p><strong>简介:</strong> 通过在数据库中设定的逻辑删除字段 达到并未真正删除 而是逻辑删除的效果</p>
<p><strong>说明:</strong></p>
<ul>
<li><p>只针对Mybatis-plus自动注入的sql语句起效(即 自定义的sql不能享受)</p>
</li>
<li><p>插入: 不做限制</p>
</li>
<li><p>查找: 会在where条件后面过滤掉已删除数据,且使用wrapper.entity生产的where条件会忽略此字段(<strong>如有特殊要求 需要查询历史所有字段 需要自定义sql语句</strong>)</p>
</li>
<li><p>更新: 会追加where条件防止更新到已删除的数据, 且使用wrapper.entity生产的where条件会忽略此字段</p>
</li>
<li><p>删除: 转变为更新(即将逻辑删除字段设置为逻辑删除属性)</p>
</li>
</ul>
<p><strong>例如:</strong></p>
<ul>
<li>删除(实际sql): <code>update user set deleted=1 where id = 1 and deleted = 0 </code></li>
<li>查找(实际sql): <code>select id,name,deleted from user where deleted = 0</code></li>
</ul>
<p><strong>字段类型支持说明:</strong></p>
<ul>
<li>支持所有数据类型(推荐使用 <code>Integer</code>,<code>Boolean</code>,<code>LocalDateTime</code>)</li>
<li>如果数据库字段使用<code>datetime</code>,逻辑未删除值和已删除值支持配置为字符串<code>null</code>,另一个值支持配置为函数来获取值如<code>now()</code></li>
</ul>
<p><strong>附录:</strong></p>
<ul>
<li>逻辑删除是为了方便数据恢复和保护数据本身价值等等的一种方案，但实际就是删除。</li>
<li>如果你需要频繁查出来看就不应使用逻辑删除，而是以一个状态去表示。</li>
</ul>
<hr>
<p><strong>使用</strong>(pringBoot):</p>
<ul>
<li>配置 application.yml文件</li>
</ul>
<blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment"># logic-delete-field: flag # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>在实体类的逻辑删除字段上添加@TableLogic注解(加上此字段可以不用配置logic-delete-field)</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给逻辑删除字段加上<span class="doctag">@TableLogic</span>注解 使其生效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> Integer deleted;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>配置完成后 正常调用mybatis-plus自动注入的sql语句即可</li>
</ul>
<hr>
<p><strong>注意</strong>: 数据库中的逻辑删除字段不要设置为 <strong><code>delete</code></strong> 敏感字段会报错</p>
<h3 id="通用枚举"><a href="#通用枚举" class="headerlink" title="通用枚举"></a><a href="https://baomidou.com/pages/8390a4/#_1%E3%80%81%E5%A3%B0%E6%98%8E%E9%80%9A%E7%94%A8%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7">通用枚举</a></h3><p><strong>简介:</strong> 使用mybatis-plus 通用枚举功能 可以在存储是存储value 查询自动显示为desc</p>
<hr>
<p><strong>使用:</strong> </p>
<blockquote>
<ul>
<li>方式一:  使用@EnumValue注解枚举属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">GradeEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    PRIMARY(<span class="number">1</span>, <span class="string">&quot;小学&quot;</span>),  SECONDORY(<span class="number">2</span>, <span class="string">&quot;中学&quot;</span>),  HIGH(<span class="number">3</span>, <span class="string">&quot;高中&quot;</span>);</span><br><span class="line"></span><br><span class="line">    GradeEnum(<span class="type">int</span> code, String descp) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.descp = descp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EnumValue</span><span class="comment">//标记数据库存的值是code</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String descp;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.descp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式二: 枚举属性,实现IEnum接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">AgeEnum</span> <span class="keyword">implements</span> <span class="title class_">IEnum</span>&lt;Integer&gt; &#123;</span><br><span class="line">    ONE(<span class="number">1</span>, <span class="string">&quot;一岁&quot;</span>),</span><br><span class="line">    TWO(<span class="number">2</span>, <span class="string">&quot;二岁&quot;</span>),</span><br><span class="line">    THREE(<span class="number">3</span>, <span class="string">&quot;三岁&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一定重写toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>配置扫描通用枚举(SpringBoot): </p>
<blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">    <span class="comment"># 支持统配符 * 或者 ; 分割 通用枚举所在包</span></span><br><span class="line">    <span class="attr">typeEnumsPackage:</span> <span class="string">com.baomidou.springboot.entity.enums</span></span><br><span class="line">  <span class="string">....</span></span><br></pre></td></tr></table></figure>

<p>或是使用配置类配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusPropertiesCustomizer <span class="title function_">mybatisPlusPropertiesCustomizer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> properties -&gt; &#123;</span><br><span class="line">            <span class="type">GlobalConfig</span> <span class="variable">globalConfig</span> <span class="operator">=</span> properties.getGlobalConfig();</span><br><span class="line">            globalConfig.setBanner(<span class="literal">false</span>);</span><br><span class="line">            <span class="type">MybatisConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisConfiguration</span>();</span><br><span class="line">            configuration.setDefaultEnumTypeHandler(MybatisEnumTypeHandler.class);</span><br><span class="line">            properties.setConfiguration(configuration);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</blockquote>
</li>
</ul>
</blockquote>
<h3 id="自动填充功能"><a href="#自动填充功能" class="headerlink" title="自动填充功能"></a><a href="https://baomidou.com/pages/4c6bcf/">自动填充功能</a></h3><p><strong>原理:</strong></p>
<ul>
<li>实现元对象处理器接口：com.baomidou.mybatisplus.core.handlers.MetaObjectHandler</li>
<li>注解填充字段 <code>@TableField(.. fill = FieldFill.INSERT)</code> 生成器策略部分也可以配置！</li>
</ul>
<ul>
<li><p>自定义实现类 MyMetaObjectHandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在这里配置insert时填充的字段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        setFieldValByName(<span class="string">&quot;sex&quot;</span>, UserSexEnum.MAN,metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里配置update时填充的字段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>配置好了之后 只要指定字段再插入&#x2F;更新时 为null 就能自动填充</li>
</ul>
</li>
</ul>
<p><strong>注意:</strong></p>
<blockquote>
<ul>
<li>填充原理是直接给<code>entity</code>的属性设置值!!!</li>
<li>注解则是指定该属性在对应情况下必有值,如果无值则入库会是<code>null</code></li>
<li><code>MetaObjectHandler</code>提供的默认方法的策略均为:如果属性有值则不覆盖,如果填充值为<code>null</code>则不填充</li>
<li>字段必须声明<code>TableField</code>注解,属性<code>fill</code>选择对应策略,该声明告知<code>Mybatis-Plus</code>需要预留注入<code>SQL</code>字段</li>
<li>填充处理器<code>MyMetaObjectHandler</code>在 Spring Boot 中需要声明<code>@Component</code>或<code>@Bean</code>注入</li>
<li>要想根据注解<code>FieldFill.xxx</code>和<code>字段名</code>以及<code>字段类型</code>来区分必须使用父类的<code>strictInsertFill</code>或者<code>strictUpdateFill</code>方法</li>
<li>不需要根据任何来区分可以使用父类的<code>fillStrategy</code>方法</li>
<li>update(T t,Wrapper updateWrapper)时t不能为空,否则自动填充失效</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>持久层框架</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>RESTful API</title>
    <url>/2022/04/06/RESTful%20API/</url>
    <content><![CDATA[<h1 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h1><p>正式学习RESTful API之前,我们需要把什么是API搞懂.</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/v2-1564b88f4461d69b90cd1ab50411f61b_b.jpg" alt="查看源图像"></h2><h2 id="什么是API"><a href="#什么是API" class="headerlink" title="什么是API?"></a>什么是API?</h2><p><strong>API（Application Programming Interface）</strong> 翻译过来是应用程序编程接口的意思。</p>
<p>相信大家对于API这个此已经不陌生了, 比如”我调用了某某的API”等 又比如我们在进行后端开发的时候，主要的工作就是为前端或者其他后端服务提供 API 比如查询用户数据的 API. </p>
<ul>
<li><p>API不仅仅代表了后端系统暴露出的接口, 像框架中提供的方法也属于是API的范畴.</p>
<p>例如: </p>
<ul>
<li>你写的程序需要由支付功能,需要微信支付,就需要去调用微信提供支付的相关API</li>
<li>使用JDK开发Java程序, 需要获取当前系统时间,需要使用JDK提供的Date相关的API</li>
<li>….</li>
</ul>
</li>
<li><p>API可以理解为程序与程序之间通信的桥梁, 其本质就是一个函数或者一个方法(函数和方法还是不同的)而已. 另外, API的使用也不是没有章法了, 它的相关规则或是使用协议由API的提供者制订.</p>
</li>
</ul>
<hr>
<h2 id="什么是RESTful-API"><a href="#什么是RESTful-API" class="headerlink" title="什么是RESTful API?"></a>什么是RESTful API?</h2><p><strong>RESTful API</strong> 经常也被叫做 <strong>REST API</strong>，它是基于 REST 构建的 API.</p>
<p>举个例子，如果我给你下面两个 API 你是不是立马能知道它们是干什么用的！这就是 RESTful API 的强大之处！</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">GET  /XXXX/classes: 查询列出所有班级</span><br><span class="line">POST  /XXXX/classes: 创建一个新的班级</span><br></pre></td></tr></table></figure>

<ul>
<li>由上述例子可以看出 RESTful API可以让人很清楚的知道每个API的目的与作用(前提是它有一定的基础 这个似乎不是什么问题).</li>
<li><strong>RESTful API</strong>可以让人看到URL+Http Method 就知道这个方法是干什么的, 让你看到HTTP状态码(status code)就知道请求结果如何</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">http动作(请求方式) + url [动作+url合起来保证唯一性]</span><br></pre></td></tr></table></figure>

<p>我们在开发过程中设计API时也应当满足RESTful API的最基本要求(RESTful API 不是协议</p>
<p>规定, 但是提倡这样设计) <strong>接口中尽量使用名词</strong>, 例如<code>GET /notes/id</code>：获取某个指定 id 的笔记的信息）毕竟是使用Http Method(动词)操作的应当是名词才对.</p>
<h2 id="解读REST-了解内容"><a href="#解读REST-了解内容" class="headerlink" title="解读REST(了解内容)"></a>解读REST(了解内容)</h2><p><strong>REST</strong> 是 <code>REpresentational State Transfer</code> 的缩写。这个词组的翻译过来就是“<strong>表现层状态转化</strong>”。</p>
<p>实际上 REST 的全称是 <strong>Resource Representational State Transfer</strong> ，直白地翻译过来就是 <strong>“资源”在网络传输中以某种“表现形式”进行“状态转移”</strong> 。</p>
<ul>
<li><strong>资源(Resource):</strong> 任何东西都可以是资源, 图片,甚至是对象, 资源可以是一个集合,也可以是一个个体. 每一种资源都有特定的URL(统一资源标识符)与之对应, 如果我们需要访问这个资源只需要访问这个URI就可以访问.</li>
<li><strong>表现形式(Representational):</strong>“资源”是一个信息实体,它可以有多种外在表现形式.通常我们把资源具体呈现出来的形式有:<code>json</code>、<code>xml</code>、<code>image</code>、<code>txt</code>等等叫做它的**”表现形式”**。</li>
<li>**状态转移(State Transfer):**指的就是你的行为对于资源的操作(通过HTTP动词实现)引起资源的状态发生了变化.(ps:互联网通讯协议HTTP协议，是一个无状态协议，所有的资源状态都保存在服务器端.)</li>
</ul>
<p>综合总结:</p>
<blockquote>
<ul>
<li>每一个URI代表一种资源；</li>
<li>客户端与服务器之间,传递这种资源的某种表现形式比如<code>json</code>、<code>xml</code>、 <code>txt</code>、 <code>image</code>等；</li>
<li>客户端通过特定的HTTP动词，对服务器资源进行操作，实现”表现层状态转化”。</li>
</ul>
</blockquote>
<h2 id="RESTful-API-规范"><a href="#RESTful-API-规范" class="headerlink" title="RESTful API 规范"></a>RESTful API 规范</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6db537c4f5274fc098ed9bf710b41cc4~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.awebp" alt="RESTful API 设计规范"></p>
<p><strong>动作：</strong></p>
<blockquote>
<ul>
<li><strong><code>GET</code>：</strong>请求从服务器获取特定资源。举个例子：<code>GET /classes</code>（获取所有班级）</li>
<li><strong><code>POST</code> ：</strong>在服务器上创建一个新的资源。举个例子：<code>POST /classes</code>（创建班级）</li>
<li><strong><code>PUT</code> ：</strong>更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：<code>PUT /classes/12</code>（更新编号为 12 的班级）</li>
<li><strong><code>DELETE</code> ：</strong>从服务器删除特定的资源。举个例子：<code>DELETE /classes/12</code>（删除编号为 12 的班级）</li>
<li><code>PATCH</code> ：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，这里就不举例子了。</li>
</ul>
</blockquote>
<p><strong>路劲(接口命名)：</strong></p>
<p>路劲又称”终点”(endpoint), 表示API的具体网址。实际开发中的常见规范如下：</p>
<blockquote>
<ul>
<li><strong>网址中不能出现动词，只能都是名词，API中的名词也应该使用复数。</strong> 因为REST中的资源往往和数据库中的表相对应，而数据库中的表都是同种记录的”集合”（collection）。<strong>如果API调用并不涉及资源（如登录、运算等操作）可以使用动词。</strong>比如：**<code>GET /sign-login</code>**</li>
<li><strong>不用大写，建议用中杠<code>-</code>而不用下划线<code>_</code></strong> 。比如：**<code>GET /signLogin</code>**</li>
<li><strong>善用版本化API。</strong>当我们的API发生了重大改变而不兼容前期版本的时候，我们可以通过URL来实现版本化，比如**<code>/github.com/kataras/iris/v12</code>**。版本不必非要数字，只是数字使用最多，日期、季节都可以作为版本的标识符，项目团队达成共识即可。</li>
<li><strong>接口尽量使用名词，避免使用名词。</strong>RESTful API操作(HTTP Method)的是资源（名词）而不是动作（动词）。</li>
</ul>
</blockquote>
<p>现在有这样的一个API提供班级大学班级（class）的信息，还包括学生、老师的信息，则应该设计呈现吗这样。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">GET    /classes：列出所有班级</span><br><span class="line">POST   /classes：新建一个班级</span><br><span class="line">GET	   /classes/&#123;classId&#125;:获取某个指定班级的信息</span><br><span class="line">PUT	   /classes/&#123;classId&#125;:更新某个指定班级的信息(一般倾向于整体更新)</span><br><span class="line">PATCH  /classes/&#123;classId&#125;：更新某个指定班级的信息（一般倾向部分更新）</span><br><span class="line">GET    /classes/&#123;classId&#125;/teachers：列出某个指定班级的所有老师的信息</span><br><span class="line">GET    /classes/&#123;classId&#125;/students：列出某个指定班级的所有学生的信息</span><br><span class="line">DELETE /classes/&#123;classId&#125;/teachers/&#123;ID&#125;：删除某个指定班级下的指定的老师的信息</span><br></pre></td></tr></table></figure>

<p><strong>反例:</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">/getAllclasses</span><br><span class="line">/createNewclass</span><br><span class="line">/deleteAllActiveclasses</span><br></pre></td></tr></table></figure>

<p>清理资源的层次结构,比如业务针对的范围是学校,那么学校会是一级资源:<code>/schools</code>、老师：<code>/shcools/teachers</code>、学生：<code>/shcools/students</code>就是二级资源。</p>
<h3 id="信息过滤"><a href="#信息过滤" class="headerlink" title="信息过滤"></a>信息过滤</h3><p>如果我们在查询的时候需要添加特定的条件的话，建议使用url中添加参数的形式。比如我们要查询state状态位active并且name为guideege的班级：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">GET		/classes?state=active<span class="built_in">&amp;</span>name=guigege</span><br></pre></td></tr></table></figure>

<p>如果要实现分页查询：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">GET		/classes?page=1<span class="built_in">&amp;</span>size=10 //指定第几页，每页十条数据</span><br></pre></td></tr></table></figure>

<h3 id="状态码（Status-Codes）"><a href="#状态码（Status-Codes）" class="headerlink" title="状态码（Status Codes）"></a>状态码（Status Codes）</h3><p><strong>状态码范围：</strong></p>
<table>
<thead>
<tr>
<th>2xx：成功</th>
<th>3xx：重定向</th>
<th>4xx：客户端错误</th>
<th>5xx：服务器错误</th>
<th></th>
<th align="right"></th>
</tr>
</thead>
<tbody><tr>
<td>200 成功</td>
<td>301 永久重定向</td>
<td>400 错误请求</td>
<td>500 服务器错误</td>
<td></td>
<td align="right"></td>
</tr>
<tr>
<td>201 创建</td>
<td>304 资源未修改</td>
<td>401 未授权</td>
<td>502 网关错误</td>
<td></td>
<td align="right"></td>
</tr>
<tr>
<td></td>
<td></td>
<td>403 禁止访问</td>
<td>504 网关超时</td>
<td></td>
<td align="right"></td>
</tr>
<tr>
<td></td>
<td></td>
<td>404 未找到</td>
<td></td>
<td></td>
<td align="right"></td>
</tr>
<tr>
<td></td>
<td></td>
<td>405 请求方法不对</td>
<td></td>
<td></td>
<td align="right"></td>
</tr>
</tbody></table>
<h2 id="RESTful-的极致-HATEOAS"><a href="#RESTful-的极致-HATEOAS" class="headerlink" title="RESTful 的极致 HATEOAS"></a>RESTful 的极致 HATEOAS</h2><blockquote>
<p>RESTful的极致是hateoas，但是这个基本不会在实际项目中用到。</p>
</blockquote>
<p>在 Spring 中有一个叫做 HATEOAS 的 API 库，通过它我们可以更轻松的创建出符合 HATEOAS 设计的 API。相关文章(可以参考)：</p>
<ul>
<li><a href="https://blog.aisensiy.me/2017/06/04/spring-boot-and-hateoas/">在 Spring Boot 中使用 HATEOASopen in new window</a></li>
<li><a href="https://spring.io/guides/tutorials/rest/">Building REST services with Springopen in new window</a> (Spring 官网 )</li>
<li><a href="https://www.baeldung.com/spring-hateoas-tutorial">An Intro to Spring HATEOASopen in new window</a></li>
<li><a href="https://github.com/spring-projects/spring-hateoas-examples/tree/master/hypermedia">spring-hateoas-examplesopen in new window</a></li>
<li><a href="https://spring.io/projects/spring-hateoas#learn">Spring HATEOASopen in new window</a> (Spring 官网)</li>
</ul>
<p>参考：</p>
<blockquote>
<p><a href="https://javaguide.cn/system-design/basis/RESTfulAPI.html#%E4%BD%95%E4%B8%BA-api">RestFul API | JavaGuide</a></p>
</blockquote>
<h1 id="END"><a href="#END" class="headerlink" title="-END-"></a>-END-</h1>]]></content>
      <categories>
        <category>开发规范</category>
      </categories>
      <tags>
        <tag>Developer</tag>
      </tags>
  </entry>
  <entry>
    <title>实际开发中常常遇到的问题 或是 遵守的规则</title>
    <url>/2022/02/28/%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E5%B8%B8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%20%E6%88%96%E6%98%AF%20%E9%81%B5%E5%AE%88%E7%9A%84%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h1 id="实际开发中常常遇到的问题-或是-遵守的规则"><a href="#实际开发中常常遇到的问题-或是-遵守的规则" class="headerlink" title="实际开发中常常遇到的问题 或是 遵守的规则"></a>实际开发中常常遇到的问题 或是 遵守的规则</h1><hr>
<h2 id="Maven子工程继承父工程"><a href="#Maven子工程继承父工程" class="headerlink" title="Maven子工程继承父工程"></a><a href="https://www.cnblogs.com/javasl/p/12391732.html">Maven子工程继承父工程</a></h2><p>利用Maven可以对项目进行分模块开发。那么怎样把各个模块整合到一起呢？这就利用了Maven继承的特性。一般是每个模块都继承一个父工程。</p>
<p><strong>几个注意的地方：</strong></p>
<p>　　（1）父工程的packaging是pom</p>
<p>　　（2）父工程中定义属性，子模块不用定义，会继承下来</p>
<p>　　（3）父工程的依赖放在dependencyManagement中，这样子模块才能继承父工程的依赖</p>
<p>　　（4）父工程的pom.xml文件中定义了modules，整合子模块的artifactId</p>
<p>　　（5）子模块的pom.xml文件中定义了parent标签，里面是父工程的gav</p>
<p>　　（6）子模块只需定义自己的artifactId</p>
<p>　　（7）子模块如果继承父工程的依赖可以不写版本，但是如果父工程中没有该依赖，那么子模块必须写完整的gav(坐标)</p>
<h2 id="登陆拦截器"><a href="#登陆拦截器" class="headerlink" title="登陆拦截器"></a><strong>登陆拦截器</strong></h2><p>在使用登录拦截器时,可以再拦截检查后将用户数据存入ThreadLocal中(因为传入Controller中的处理器方法的参数只能被读取一次, 防止拦截请求参数检查后,接收不到参数而报错, 读取参数的流只能被使用一次)供该线程其他业务使用.</p>
<h2 id="Hutool工具类库"><a href="#Hutool工具类库" class="headerlink" title="Hutool工具类库"></a><strong>Hutool工具类库</strong></h2><p>hutool是一个较为全面的工具类库.详情请看官网.</p>
<p><a href="https://gitee.com/dromara/hutool">hutool: 🍬小而全的Java工具类库，使Java拥有函数式语言般的优雅，让Java语言也可以“甜甜的”。 (gitee.com)</a></p>
<h3 id="手动创建线程池"><a href="#手动创建线程池" class="headerlink" title="手动创建线程池"></a>手动创建线程池</h3><p><a href="https://blog.csdn.net/hello_cmy/article/details/118895056">手动创建线程池，效果会更好哦_hello_cmy的博客-CSDN博客_手动创建线程池,效果会更好哦。</a></p>
]]></content>
      <categories>
        <category>开发规范</category>
      </categories>
      <tags>
        <tag>Developer</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程初识</title>
    <url>/2021/10/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<h1 id="每日一记之多线程初识"><a href="#每日一记之多线程初识" class="headerlink" title="每日一记之多线程初识"></a>每日一记之多线程初识</h1><hr>
<p>在这之前我们要搞清楚进程与线程之间的区别。</p>
<p><strong>进程:</strong> 是程序执行的一次过程，或是正在运行的一个程序，是一个动态的过程，由它自身的产生，存在和消亡的过程。</p>
<p><strong>线程:</strong>  进程可以进一步细化为线程，线程指的是一个进程的执行过程中，同时执行了多项任务  例如：到中午了 我一边吃着饭一边玩着手机一边在聊天， 我在这个进程中同时执行了三个任务（分别是 吃饭、玩手机、聊天）。</p>
<p><strong>注：</strong> 对于单核心cpu来说 多线程并不是真正意义上的多线程 而是处理速度太快让你误以为实在同时处理任务。多核心cpu则能带来真正的多线程处理，随着当今科技的发展电脑的cpu也都是多核心的了</p>
<p>创建多线程的三个方法：</p>
<ul>
<li><p>继承<strong>Thread</strong>类 重写**void run()<strong>方法 创建对象(创建线程) 调用</strong>start()**方法启动线程 <strong>注：</strong> <strong>Thrad</strong>类实现了Runnable接口</p>
</li>
<li><p>实现<strong>Runnable</strong>接口 实现<strong>void run()<strong>方法 创建对象，再创建一个</strong>Thread</strong>对象将刚刚创建的对象放入(创建线程)，在使用刚刚创建的<strong>Thread</strong>对象调用**start()**方法启动线程</p>
</li>
<li><p>实现<strong>Callable</strong>接口(泛型接口 需要返回值类型)，重写<strong>call()<strong>方法，创建目标对象，创建执行服务</strong>ExecutorService ser &#x3D; Executors.newFixedThreadPool(1)</strong> <em>创建线程池 池内线程个数 1</em>，然后提交执行：Futue&lt;?&gt; result &#x3D; set.submit(1), 获取结果 var r1 &#x3D; result.get(), 最后要关闭线程现有的池以关闭服务：ser.shutdownNow();</p>
</li>
</ul>
<hr>
<h2 id="方法一：继承Thread类"><a href="#方法一：继承Thread类" class="headerlink" title="方法一：继承Thread类"></a>方法一：继承Thread类</h2><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DEVIL.多线程;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil(丁杨维)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-13-11:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建线程方式一: 继承Tread类,重写run方法,调用start方法启动线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E_01</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;<span class="comment">//继承Tread类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//重写run方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//run方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在学习&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//main线程 主线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个线程对象</span></span><br><span class="line">        <span class="type">E_01</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E_01</span>();</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在看代码&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*注: 线程开启不一定会立即执行 会根据cpu的安排调度执行</span></span><br><span class="line"><span class="comment">对于单核cpu多线程其实是虚拟多线程 实际上是cpu执行速度很快 让人觉得是一瞬间执行了多个任务实际上还是单个执行</span></span><br><span class="line"><span class="comment">多核则是真正的多线程在同一时间可以真正执行多个任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>控制台:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我在看代码0</span><br><span class="line">我在学习0</span><br><span class="line">我在看代码1</span><br><span class="line">我在学习1</span><br><span class="line">我在看代码2</span><br><span class="line">我在学习2</span><br><span class="line">我在看代码3</span><br><span class="line">我在学习3</span><br><span class="line">我在看代码4</span><br><span class="line">我在学习4</span><br><span class="line">我在看代码5</span><br><span class="line">我在学习5</span><br><span class="line">我在看代码6</span><br><span class="line">我在学习6</span><br><span class="line">我在看代码7</span><br><span class="line">我在学习7</span><br><span class="line">我在看代码8</span><br><span class="line">我在学习8</span><br><span class="line">我在看代码9</span><br><span class="line">我在学习9</span><br><span class="line">我在看代码10</span><br><span class="line">我在学习10</span><br><span class="line">我在看代码11</span><br><span class="line">我在学习11</span><br><span class="line">我在看代码12</span><br><span class="line">我在学习12</span><br><span class="line">我在看代码13</span><br><span class="line">我在学习13</span><br><span class="line">我在看代码14</span><br><span class="line">我在学习14</span><br><span class="line">我在看代码15</span><br><span class="line">我在学习15</span><br><span class="line">我在看代码16</span><br><span class="line">我在学习16</span><br><span class="line">我在看代码17</span><br><span class="line">我在学习17</span><br><span class="line">我在看代码18</span><br><span class="line">我在学习18</span><br><span class="line">我在看代码19</span><br><span class="line">我在学习19</span><br><span class="line">我在看代码20</span><br><span class="line">我在看代码21</span><br><span class="line">我在看代码22</span><br><span class="line">我在看代码23</span><br><span class="line">我在看代码24</span><br><span class="line">我在看代码25</span><br><span class="line">我在看代码26</span><br><span class="line">我在看代码27</span><br><span class="line">我在看代码28</span><br><span class="line">我在看代码29</span><br><span class="line">我在看代码30</span><br><span class="line">我在看代码31</span><br><span class="line">我在看代码32</span><br><span class="line">我在看代码33</span><br><span class="line">我在看代码34</span><br><span class="line">我在看代码35</span><br><span class="line">我在看代码36</span><br><span class="line">我在看代码37</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.//此处省略 因为创建的线程早已结束</span><br><span class="line">.</span><br><span class="line">我在看代码191</span><br><span class="line">我在看代码192</span><br><span class="line">我在看代码193</span><br><span class="line">我在看代码194</span><br><span class="line">我在看代码195</span><br><span class="line">我在看代码196</span><br><span class="line">我在看代码197</span><br><span class="line">我在看代码198</span><br><span class="line">我在看代码199</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以发现我们创建的线程与main线程(主线程)是同时进行的 对这就是多线程</p>
<hr>
<h3 id="练习一：用方法一实现多线程同时下载图片"><a href="#练习一：用方法一实现多线程同时下载图片" class="headerlink" title="练习一：用方法一实现多线程同时下载图片"></a>练习一：用方法一实现多线程同时下载图片</h3><p>图片可以在网上通过源码查找图片地址</p>
<p>下载器则使用了外部引入的包里的类 包为<strong>commonio.jar</strong>。</p>
<p>使用了其中的<strong>FileUtils</strong>类的<strong>copyURLtoFile</strong>类方法（可以将URL转换为文件存储）</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DEVIL.多线程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;<span class="comment">//引入了一个类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil(丁杨维)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-13-12:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;<span class="comment">//创建一个线程类 继承Thread类</span></span><br><span class="line">    <span class="keyword">private</span> String URl;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tread1</span><span class="params">(String URl, String name)</span>&#123;<span class="comment">//初始化 URL用与存储URL name用于存储文件名</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.URl = URl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">//Thread类run方法重载</span></span><br><span class="line">        <span class="type">webDownLoader</span> <span class="variable">webDownLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">webDownLoader</span>();<span class="comment">//创建一个下载器对象</span></span><br><span class="line">        webDownLoader.downLoader(<span class="built_in">this</span>.URl,<span class="built_in">this</span>.name);<span class="comment">//传参</span></span><br><span class="line">        System.out.println(<span class="string">&quot;下载了文件名:&quot;</span>+name);<span class="comment">//输出文件名 用于一会查看线程执行情况</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//main线程 主线程</span></span><br><span class="line">        <span class="comment">//创建三个线程对象</span></span><br><span class="line">        <span class="type">Tread1</span> <span class="variable">tread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tread1</span>(<span class="string">&quot;https://t12.baidu.com/it/u=3350456484,1876742898&amp;fm=55&amp;app=54&amp;fmt=auto?w=1680&amp;h=630&quot;</span>, <span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">        <span class="type">Tread1</span> <span class="variable">tread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tread1</span>(<span class="string">&quot;https://t10.baidu.com/it/u=2536294109,1654178484&amp;fm=55&amp;app=54&amp;fmt=auto?w=1680&amp;h=630&quot;</span>, <span class="string">&quot;2.jpg&quot;</span>);</span><br><span class="line">        <span class="type">Tread1</span> <span class="variable">tread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tread1</span>(<span class="string">&quot;https://t10.baidu.com/it/u=2156539333,402435846&amp;fm=55&amp;app=54&amp;fmt=auto?w=1120&amp;h=420&quot;</span>,<span class="string">&quot;3.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">//对象调用start方法启动线程</span></span><br><span class="line">        tread1.start();</span><br><span class="line">        tread2.start();</span><br><span class="line">        tread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">webDownLoader</span> &#123;<span class="comment">//定义一个下载器可以将URL转换为文件 用到了我们刚引入的类</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">downLoader</span><span class="params">(String URl, String name)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                FileUtils.copyURLToFile(<span class="keyword">new</span> <span class="title class_">URL</span>(URl), <span class="keyword">new</span> <span class="title class_">File</span>(name));<span class="comment">//类方法将URL转换为文件</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.out.println(<span class="string">&quot;IO异常，downLoader方法出现异常&quot;</span>);<span class="comment">//异常提示</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>控制台：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下载了文件名:3.jpg</span><br><span class="line">下载了文件名:2.jpg</span><br><span class="line">下载了文件名:1.jpg</span><br></pre></td></tr></table></figure>

<p>可以看出如果不是多线程的情况下下载次序应该是1 2 3 但实际却是3 2 1</p>
<hr>
<h2 id="方法二：实现Runnable接口"><a href="#方法二：实现Runnable接口" class="headerlink" title="方法二：实现Runnable接口"></a>方法二：实现Runnable接口</h2><p>代码：</p>
<p>使用接口可以打破单一继承的局限、灵活方便、方便同一个对象被多个线程使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DEVIL.多线程;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil(丁杨维)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-13-16:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//方式二：实现接口Runnable具有多线程能力</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E_02</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//重写run方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//run方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在学习&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//main线程 主线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个线程对象</span></span><br><span class="line">        <span class="type">E_02</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E_02</span>();</span><br><span class="line">        <span class="comment">//启动线程：传入目标对象+Thread对象.start()</span></span><br><span class="line"><span class="comment">//      Thread thread1 = new Thread(thread);</span></span><br><span class="line"><span class="comment">//      thread1.start();</span></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在看代码&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注: 推荐使用实现接口Runnable方法创建多线程 避免单线程局限性、灵活方便、方便同一个对象被多个线程使用</span></span><br></pre></td></tr></table></figure>

<p>控制台：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我在看代码0</span><br><span class="line">我在学习0</span><br><span class="line">我在看代码1</span><br><span class="line">我在学习1</span><br><span class="line">我在看代码2</span><br><span class="line">我在学习2</span><br><span class="line">我在看代码3</span><br><span class="line">我在学习3</span><br><span class="line">我在看代码4</span><br><span class="line">我在学习4</span><br><span class="line">我在看代码5</span><br><span class="line">我在学习5</span><br><span class="line">我在看代码6</span><br><span class="line">我在学习6</span><br><span class="line">我在看代码7</span><br><span class="line">我在学习7</span><br><span class="line">我在看代码8</span><br><span class="line">我在学习8</span><br><span class="line">我在看代码9</span><br><span class="line">我在学习9</span><br><span class="line">我在看代码10</span><br><span class="line">我在学习10</span><br><span class="line">我在看代码11</span><br><span class="line">我在学习11</span><br><span class="line">我在看代码12</span><br><span class="line">我在学习12</span><br><span class="line">我在看代码13</span><br><span class="line">我在学习13</span><br><span class="line">我在看代码14</span><br><span class="line">我在学习14</span><br><span class="line">我在看代码15</span><br><span class="line">我在学习15</span><br><span class="line">我在看代码16</span><br><span class="line">我在学习16</span><br><span class="line">我在看代码17</span><br><span class="line">我在学习17</span><br><span class="line">我在看代码18</span><br><span class="line">我在学习18</span><br><span class="line">我在看代码19</span><br><span class="line">我在学习19</span><br><span class="line">我在看代码20</span><br><span class="line">我在看代码21</span><br><span class="line">我在看代码22</span><br><span class="line">我在看代码23</span><br><span class="line">我在看代码24</span><br><span class="line">我在看代码25</span><br><span class="line">我在看代码26</span><br><span class="line">我在看代码27</span><br><span class="line">我在看代码28</span><br><span class="line">我在看代码29</span><br><span class="line">我在看代码30</span><br><span class="line">我在看代码31</span><br><span class="line">我在看代码32</span><br><span class="line">我在看代码33</span><br><span class="line">我在看代码34</span><br><span class="line">我在看代码35</span><br><span class="line">我在看代码36</span><br><span class="line">我在看代码37</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.//此处省略 因为创建的线程早已结束</span><br><span class="line">.</span><br><span class="line">我在看代码191</span><br><span class="line">我在看代码192</span><br><span class="line">我在看代码193</span><br><span class="line">我在看代码194</span><br><span class="line">我在看代码195</span><br><span class="line">我在看代码196</span><br><span class="line">我在看代码197</span><br><span class="line">我在看代码198</span><br><span class="line">我在看代码199</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果与方法一实现的一致。</p>
<hr>
<h3 id="练习二：用方法二完成练习一"><a href="#练习二：用方法二完成练习一" class="headerlink" title="练习二：用方法二完成练习一"></a>练习二：用方法二完成练习一</h3><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DEVIL.多线程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil(丁杨维)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-13-17:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runnable1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String URl;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Runnable1</span><span class="params">(String URl, String name)</span>&#123;<span class="comment">//初始化 URL用与存储URL name用于存储文件名</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.URl = URl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">//Thread类run方法重载</span></span><br><span class="line">        <span class="type">webDownLoader</span> <span class="variable">webDownLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">webDownLoader</span>();<span class="comment">//创建一个下载器对象</span></span><br><span class="line">        webDownLoader.downLoader(<span class="built_in">this</span>.URl,<span class="built_in">this</span>.name);<span class="comment">//传参</span></span><br><span class="line">        System.out.println(<span class="string">&quot;下载了文件名:&quot;</span>+name);<span class="comment">//输出文件名 用于一会查看线程执行情况</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//main线程 主线程</span></span><br><span class="line">        <span class="comment">//创建三个线程对象</span></span><br><span class="line">        <span class="type">Runnable1</span> <span class="variable">tread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable1</span>(<span class="string">&quot;https://t12.baidu.com/it/u=3350456484,1876742898&amp;fm=55&amp;app=54&amp;fmt=auto?w=1680&amp;h=630&quot;</span>, <span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">        <span class="type">Runnable1</span> <span class="variable">tread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable1</span>(<span class="string">&quot;https://t10.baidu.com/it/u=2536294109,1654178484&amp;fm=55&amp;app=54&amp;fmt=auto?w=1680&amp;h=630&quot;</span>, <span class="string">&quot;2.jpg&quot;</span>);</span><br><span class="line">        <span class="type">Runnable1</span> <span class="variable">tread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable1</span>(<span class="string">&quot;https://t10.baidu.com/it/u=2156539333,402435846&amp;fm=55&amp;app=54&amp;fmt=auto?w=1120&amp;h=420&quot;</span>,<span class="string">&quot;3.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">//对象调用start方法启动线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(tread1).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(tread2).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(tread3).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">webDownLoader</span> &#123;<span class="comment">//定义一个下载器可以将URL转换为文件 用到了我们刚引入的类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">downLoader</span><span class="params">(String URl, String name)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyURLToFile(<span class="keyword">new</span> <span class="title class_">URL</span>(URl), <span class="keyword">new</span> <span class="title class_">File</span>(name));<span class="comment">//类方法将URL转换为文件</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;IO异常，downLoader方法出现异常&quot;</span>);<span class="comment">//异常提示</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果与练习一致</p>
<hr>
<h3 id="练习三：龟兔赛跑"><a href="#练习三：龟兔赛跑" class="headerlink" title="练习三：龟兔赛跑"></a>练习三：龟兔赛跑</h3><p>此处使用了<strong>Thread</strong>类的类方法**sleep()**用于模拟延时</p>
<p>总路程100步 先到即为冠军 兔子每十部休息10毫秒求冠军</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DEVIL.多线程;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil(丁杨维)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-13-17:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E_04</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Race</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String winner;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//模拟兔子睡觉</span></span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;兔子&quot;</span>)&amp;&amp; i%<span class="number">10</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> gameOver(i);<span class="comment">//判断比赛是否结束了</span></span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;<span class="comment">//是跳出结束循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;跑了&quot;</span>+i+<span class="string">&quot;步了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">gameOver</span><span class="params">(<span class="type">int</span> steps)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(winner!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(steps&gt;=<span class="number">100</span>)&#123;</span><br><span class="line">                winner = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(<span class="string">&quot;winner is &quot;</span>+winner);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Race</span> <span class="variable">race</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Race</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(race,<span class="string">&quot;兔子&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(race,<span class="string">&quot;乌龟&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">乌龟---&gt;跑了1步了</span><br><span class="line">兔子---&gt;跑了1步了</span><br><span class="line">兔子---&gt;跑了2步了</span><br><span class="line">乌龟---&gt;跑了2步了</span><br><span class="line">乌龟---&gt;跑了3步了</span><br><span class="line">兔子---&gt;跑了3步了</span><br><span class="line">乌龟---&gt;跑了4步了</span><br><span class="line">乌龟---&gt;跑了5步了</span><br><span class="line">兔子---&gt;跑了4步了</span><br><span class="line">乌龟---&gt;跑了6步了</span><br><span class="line">乌龟---&gt;跑了7步了</span><br><span class="line">乌龟---&gt;跑了8步了</span><br><span class="line">乌龟---&gt;跑了9步了</span><br><span class="line">乌龟---&gt;跑了10步了</span><br><span class="line">乌龟---&gt;跑了11步了</span><br><span class="line">兔子---&gt;跑了5步了</span><br><span class="line">乌龟---&gt;跑了12步了</span><br><span class="line">兔子---&gt;跑了6步了</span><br><span class="line">乌龟---&gt;跑了13步了</span><br><span class="line">乌龟---&gt;跑了14步了</span><br><span class="line">乌龟---&gt;跑了15步了</span><br><span class="line">乌龟---&gt;跑了16步了</span><br><span class="line">兔子---&gt;跑了7步了</span><br><span class="line">乌龟---&gt;跑了17步了</span><br><span class="line">乌龟---&gt;跑了18步了</span><br><span class="line">乌龟---&gt;跑了19步了</span><br><span class="line">乌龟---&gt;跑了20步了</span><br><span class="line">乌龟---&gt;跑了21步了</span><br><span class="line">乌龟---&gt;跑了22步了</span><br><span class="line">乌龟---&gt;跑了23步了</span><br><span class="line">乌龟---&gt;跑了24步了</span><br><span class="line">乌龟---&gt;跑了25步了</span><br><span class="line">乌龟---&gt;跑了26步了</span><br><span class="line">兔子---&gt;跑了8步了</span><br><span class="line">乌龟---&gt;跑了27步了</span><br><span class="line">兔子---&gt;跑了9步了</span><br><span class="line">乌龟---&gt;跑了28步了</span><br><span class="line">乌龟---&gt;跑了29步了</span><br><span class="line">乌龟---&gt;跑了30步了</span><br><span class="line">乌龟---&gt;跑了31步了</span><br><span class="line">乌龟---&gt;跑了32步了</span><br><span class="line">乌龟---&gt;跑了33步了</span><br><span class="line">乌龟---&gt;跑了34步了</span><br><span class="line">乌龟---&gt;跑了35步了</span><br><span class="line">乌龟---&gt;跑了36步了</span><br><span class="line">乌龟---&gt;跑了37步了</span><br><span class="line">乌龟---&gt;跑了38步了</span><br><span class="line">乌龟---&gt;跑了39步了</span><br><span class="line">乌龟---&gt;跑了40步了</span><br><span class="line">乌龟---&gt;跑了41步了</span><br><span class="line">乌龟---&gt;跑了42步了</span><br><span class="line">乌龟---&gt;跑了43步了</span><br><span class="line">乌龟---&gt;跑了44步了</span><br><span class="line">乌龟---&gt;跑了45步了</span><br><span class="line">乌龟---&gt;跑了46步了</span><br><span class="line">乌龟---&gt;跑了47步了</span><br><span class="line">乌龟---&gt;跑了48步了</span><br><span class="line">乌龟---&gt;跑了49步了</span><br><span class="line">乌龟---&gt;跑了50步了</span><br><span class="line">乌龟---&gt;跑了51步了</span><br><span class="line">乌龟---&gt;跑了52步了</span><br><span class="line">乌龟---&gt;跑了53步了</span><br><span class="line">乌龟---&gt;跑了54步了</span><br><span class="line">乌龟---&gt;跑了55步了</span><br><span class="line">乌龟---&gt;跑了56步了</span><br><span class="line">乌龟---&gt;跑了57步了</span><br><span class="line">乌龟---&gt;跑了58步了</span><br><span class="line">乌龟---&gt;跑了59步了</span><br><span class="line">乌龟---&gt;跑了60步了</span><br><span class="line">乌龟---&gt;跑了61步了</span><br><span class="line">乌龟---&gt;跑了62步了</span><br><span class="line">乌龟---&gt;跑了63步了</span><br><span class="line">乌龟---&gt;跑了64步了</span><br><span class="line">乌龟---&gt;跑了65步了</span><br><span class="line">乌龟---&gt;跑了66步了</span><br><span class="line">乌龟---&gt;跑了67步了</span><br><span class="line">乌龟---&gt;跑了68步了</span><br><span class="line">乌龟---&gt;跑了69步了</span><br><span class="line">乌龟---&gt;跑了70步了</span><br><span class="line">乌龟---&gt;跑了71步了</span><br><span class="line">乌龟---&gt;跑了72步了</span><br><span class="line">乌龟---&gt;跑了73步了</span><br><span class="line">乌龟---&gt;跑了74步了</span><br><span class="line">乌龟---&gt;跑了75步了</span><br><span class="line">乌龟---&gt;跑了76步了</span><br><span class="line">乌龟---&gt;跑了77步了</span><br><span class="line">乌龟---&gt;跑了78步了</span><br><span class="line">乌龟---&gt;跑了79步了</span><br><span class="line">乌龟---&gt;跑了80步了</span><br><span class="line">乌龟---&gt;跑了81步了</span><br><span class="line">乌龟---&gt;跑了82步了</span><br><span class="line">乌龟---&gt;跑了83步了</span><br><span class="line">乌龟---&gt;跑了84步了</span><br><span class="line">乌龟---&gt;跑了85步了</span><br><span class="line">乌龟---&gt;跑了86步了</span><br><span class="line">乌龟---&gt;跑了87步了</span><br><span class="line">乌龟---&gt;跑了88步了</span><br><span class="line">乌龟---&gt;跑了89步了</span><br><span class="line">乌龟---&gt;跑了90步了</span><br><span class="line">乌龟---&gt;跑了91步了</span><br><span class="line">乌龟---&gt;跑了92步了</span><br><span class="line">乌龟---&gt;跑了93步了</span><br><span class="line">乌龟---&gt;跑了94步了</span><br><span class="line">乌龟---&gt;跑了95步了</span><br><span class="line">乌龟---&gt;跑了96步了</span><br><span class="line">乌龟---&gt;跑了97步了</span><br><span class="line">乌龟---&gt;跑了98步了</span><br><span class="line">乌龟---&gt;跑了99步了</span><br><span class="line">winner is 乌龟</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="方法三：实现Callable接口"><a href="#方法三：实现Callable接口" class="headerlink" title="方法三：实现Callable接口"></a>方法三：实现Callable接口</h2><p>关联到线程池 以后一定用到很多 现在初学阶段使用少</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DEVIL.多线程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Devil(丁杨维)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-14-0:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E_05</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个新的线程类 通过实现Callable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Callable1</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Boolean&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在学习多线程&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//主线程</span></span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        <span class="type">Callable1</span> <span class="variable">callable1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Callable1</span>();</span><br><span class="line">        <span class="comment">//创建线程池（创建执行服务）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">ser</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//提交执行</span></span><br><span class="line">        Future&lt;Boolean&gt; result = ser.submit(callable1);</span><br><span class="line">        <span class="comment">//执行主线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取结果</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">r1</span> <span class="operator">=</span> result.get();</span><br><span class="line">        <span class="comment">//关闭服务</span></span><br><span class="line">        ser.shutdownNow();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>控制台：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我在学习多线程0</span><br><span class="line">我在学习多线程1</span><br><span class="line">主线程0</span><br><span class="line">主线程1</span><br><span class="line">主线程2</span><br><span class="line">主线程3</span><br><span class="line">主线程4</span><br><span class="line">我在学习多线程2</span><br><span class="line">主线程5</span><br><span class="line">主线程6</span><br><span class="line">主线程7</span><br><span class="line">我在学习多线程3</span><br><span class="line">主线程8</span><br><span class="line">主线程9</span><br><span class="line">我在学习多线程4</span><br><span class="line">主线程10</span><br><span class="line">主线程11</span><br><span class="line">主线程12</span><br><span class="line">我在学习多线程5</span><br><span class="line">我在学习多线程6</span><br><span class="line">主线程13</span><br><span class="line">主线程14</span><br><span class="line">我在学习多线程7</span><br><span class="line">主线程15</span><br><span class="line">主线程16</span><br><span class="line">主线程17</span><br><span class="line">主线程18</span><br><span class="line">主线程19</span><br><span class="line">我在学习多线程8</span><br><span class="line">主线程20</span><br><span class="line">主线程21</span><br><span class="line">主线程22</span><br><span class="line">我在学习多线程9</span><br><span class="line">主线程23</span><br><span class="line">主线程24</span><br><span class="line">主线程25</span><br><span class="line">我在学习多线程10</span><br><span class="line">主线程26</span><br><span class="line">主线程27</span><br><span class="line">主线程28</span><br><span class="line">我在学习多线程11</span><br><span class="line">主线程29</span><br><span class="line">主线程30</span><br><span class="line">主线程31</span><br><span class="line">主线程32</span><br><span class="line">主线程33</span><br><span class="line">我在学习多线程12</span><br><span class="line">主线程34</span><br><span class="line">主线程35</span><br><span class="line">我在学习多线程13</span><br><span class="line">主线程36</span><br><span class="line">主线程37</span><br><span class="line">主线程38</span><br><span class="line">我在学习多线程14</span><br><span class="line">主线程39</span><br><span class="line">我在学习多线程15</span><br><span class="line">主线程40</span><br><span class="line">我在学习多线程16</span><br><span class="line">主线程41</span><br><span class="line">我在学习多线程17</span><br><span class="line">主线程42</span><br><span class="line">我在学习多线程18</span><br><span class="line">主线程43</span><br><span class="line">我在学习多线程19</span><br><span class="line">主线程44</span><br><span class="line">主线程45</span><br><span class="line">主线程46</span><br><span class="line">主线程47</span><br><span class="line">主线程48</span><br><span class="line">主线程49</span><br><span class="line">主线程50</span><br><span class="line">主线程51</span><br><span class="line">主线程52</span><br><span class="line">主线程53</span><br><span class="line">主线程54</span><br><span class="line">主线程55</span><br><span class="line">主线程56</span><br><span class="line">主线程57</span><br><span class="line">主线程58</span><br><span class="line">主线程59</span><br><span class="line">主线程60</span><br><span class="line">主线程61</span><br><span class="line">主线程62</span><br><span class="line">主线程63</span><br><span class="line">主线程64</span><br><span class="line">主线程65</span><br><span class="line">主线程66</span><br><span class="line">主线程67</span><br><span class="line">主线程68</span><br><span class="line">主线程69</span><br><span class="line">主线程70</span><br><span class="line">主线程71</span><br><span class="line">主线程72</span><br><span class="line">主线程73</span><br><span class="line">主线程74</span><br><span class="line">主线程75</span><br><span class="line">主线程76</span><br><span class="line">主线程77</span><br><span class="line">主线程78</span><br><span class="line">主线程79</span><br><span class="line">主线程80</span><br><span class="line">主线程81</span><br><span class="line">主线程82</span><br><span class="line">主线程83</span><br><span class="line">主线程84</span><br><span class="line">主线程85</span><br><span class="line">主线程86</span><br><span class="line">主线程87</span><br><span class="line">主线程88</span><br><span class="line">主线程89</span><br><span class="line">主线程90</span><br><span class="line">主线程91</span><br><span class="line">主线程92</span><br><span class="line">主线程93</span><br><span class="line">主线程94</span><br><span class="line">主线程95</span><br><span class="line">主线程96</span><br><span class="line">主线程97</span><br><span class="line">主线程98</span><br><span class="line">主线程99</span><br></pre></td></tr></table></figure>

<p>符合多线程执行</p>
<h1 id="end"><a href="#end" class="headerlink" title="-end-"></a>-end-</h1>]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/2021/12/28/Servlet/</url>
    <content><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="关于系统架构"><a href="#关于系统架构" class="headerlink" title="关于系统架构"></a>关于系统架构</h2><ol>
<li>系统架构包括什么形式？<ul>
<li>C&#x2F;S架构</li>
<li>B&#x2F;S架构</li>
</ul>
</li>
<li>C&#x2F;S架构？<ul>
<li>Client &#x2F; Server（客户端 &#x2F; 服务器）</li>
<li>C&#x2F;S架构的软件或者说系统有哪些呢？<ul>
<li>QQ（先去腾讯官网下载一个QQ软件，几十MB，然后把这个客户端软件安装上去，然后输入QQ号以及密码，登录之后，就可以和你的朋友聊天了，就可以使用这个软件了。）</li>
</ul>
</li>
<li>C&#x2F;S架构的特点：需要安装特定的客户端软件。</li>
<li>C&#x2F;S架构的系统优点和缺点分别是什么？<ul>
<li>优点：<ul>
<li>速度快（软件中的数据大部分都是集成到客户端软件当中的，很少量的数据从服务器端传送过来，所以C&#x2F;S结构的系统速度快）</li>
<li>体验好（速度又快，界面又酷炫，当然体验好了。）</li>
<li>界面酷炫（专门的语言去实现界面的，更加灵活。）</li>
<li>服务器压力小（因为大量的数据都是集成在客户端软件当中，所以服务器只需要传送很少的数据量，当然服务器压力小。）</li>
<li>安全（因为大量的数据是集成在客户端软件当中的，并且客户端有很多个，服务器虽然只有一个，就算服务器那边地震了，火灾了，服务器受损了，问题也不大，因为大量的数据在多个客户端上有缓存，有存储，所以从这个方面来说，C&#x2F;S结构的系统比较安全。）</li>
<li>…..</li>
</ul>
</li>
<li>缺点：<ul>
<li>升级维护比较差劲。（升级维护比较麻烦。成本比较高。每一个客户端软件都需要升级。有一些软件不是那么容易安装的。）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>B&#x2F;S架构？<ul>
<li>B&#x2F;S（Browser &#x2F; Server，浏览器 &#x2F; 服务器）</li>
<li><a href="http://www.baidu.com/">http://www.baidu.com</a></li>
<li><a href="http://www.jd.com/">http://www.jd.com</a></li>
<li><a href="http://www.126.com/">http://www.126.com</a></li>
<li>B&#x2F;S结构的系统是不是一个特殊的C&#x2F;S系统？<ul>
<li>实际上B&#x2F;S结构的系统还是一个C&#x2F;S，只不过这个C比较特殊，这个Client是一个固定不变浏览器软件。</li>
</ul>
</li>
<li>B&#x2F;S结构的系统优点和缺点是：<ul>
<li>优点：<ul>
<li>升级维护方便，成本比较低。（只需要升级服务器端即可。）</li>
<li>不需要安装特定的客户端软件，用户操作极其方便。只需要打开浏览器，输入网址即可。</li>
</ul>
</li>
<li>缺点：<ul>
<li>速度慢（不是因为带宽低的问题，是因为所有的数据都是在服务器上，用户发送的每一个请求都是需要服务器全身心的响应数据，所以B&#x2F;S结构的系统在网络中传送的数据量比较大。）</li>
<li>体验差（界面不是那么酷炫，因为浏览器只支持三个语言HTML CSS JavaScript。在加上速度慢。）</li>
<li>不安全（所有的数据都在服务器上，只要服务器发生火灾，地震等不可抗力，最终数据全部丢失。）</li>
<li>….</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>C&#x2F;S和B&#x2F;S结构的系统，哪个好，哪个不好？<ul>
<li>这个问题问的没有水平。并不是哪个好，哪个不好。不同结构的系统在不同的业务场景下有不同的适用场景。</li>
<li>娱乐性软件建议使用？<ul>
<li>C&#x2F;S 结构</li>
</ul>
</li>
<li>公司内部使用的一些业务软件建议使用？<ul>
<li>公司内部使用的系统，需要维护成本低。</li>
<li>公司内部使用的系统，不需要很酷炫。</li>
<li>公司内部使用的企业级系统主要是能够进行数据的维护即可。</li>
<li>B&#x2F;S 结构。</li>
</ul>
</li>
</ul>
</li>
<li>注意了：开发B&#x2F;S结构的系统，其实就是开发网站，其实就是开发一个WEB系统。<ul>
<li>开发一个WEB系统你需要会哪些技术？<ul>
<li>WEB前端（运行在浏览器上的程序。）<ul>
<li>HTML</li>
<li>CSS</li>
<li>JavaScript</li>
</ul>
</li>
<li>WEB后端（WEB服务器端的程序。）<ul>
<li>Java可以（Java做WEB开发我们称为JavaWEB开发。JavaWEB开发最核心的规范：Servlet【Server Applet服务器端的Java小程序。】）</li>
<li>C语言也可以</li>
<li>C++也可以</li>
<li>Python也行</li>
<li>PHP也可以</li>
<li>….</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>JavaEE是什么？<ul>
<li>Java包括三大块：<ul>
<li>JavaSE<ul>
<li>Java标准版（一套类库：别人写好的一套类库，只不过这个类库是标准类库，走EE，或者走ME，这个SE一定是基础，先学。）</li>
</ul>
</li>
<li>JavaEE（WEB方向，WEB系统。）<ul>
<li>Java企业版（也是一套类库：也是别人写好的一套类库，只不过这套类库可以帮助我们完成企业级项目的开发，专门为企业内部提供解决方案的一套（多套）类库。）</li>
<li>别人写好的，你用就行了，用它可以开发企业级项目。</li>
<li>可以开发web系统。</li>
<li>Java比较火爆的就是这个JavaEE方向。</li>
</ul>
</li>
<li>JavaME<ul>
<li>Java微型版（还是一套类库，只不过这套类库帮助我们进行电子微型设备内核程序的开发）</li>
<li>机顶盒内核程序，吸尘器内核程序，电冰箱内核程序，电饭煲内核程序。。。。。</li>
</ul>
</li>
</ul>
</li>
<li>JavaEE实际上包括很多种规范，13种规范，其中Servlet就是JavaEE规范之一。学Servlet还是Java语言。</li>
</ul>
</li>
</ol>
<h2 id="B-x2F-S结构的系统通信原理（没有涉及到Java小程序）"><a href="#B-x2F-S结构的系统通信原理（没有涉及到Java小程序）" class="headerlink" title="B&#x2F;S结构的系统通信原理（没有涉及到Java小程序）"></a>B&#x2F;S结构的系统通信原理（没有涉及到Java小程序）</h2><ul>
<li>WEB系统的访问过程<ul>
<li>第一步：打开浏览器</li>
<li>第二步：找到地址栏</li>
<li>第三步：输入一个合法的网址</li>
<li>第四步：回车</li>
<li>第五步：在浏览器上会展示响应的结果。</li>
</ul>
</li>
<li>关于域名：<ul>
<li><a href="https://www.baidu.com/">https://www.baidu.com/</a> （网址）</li>
<li><a href="http://www.baidu.com/">www.baidu.com</a> 是一个域名</li>
<li>在浏览器地址栏上输入域名，回车之后，域名解析器会将域名解析出来一个具体的IP地址和端口号等。</li>
<li>解析结果也许是：<a href="http://110.242.68.3/index.html">http://110.242.68.3:80/index.html</a></li>
</ul>
</li>
<li>IP地址是啥？<ul>
<li>计算机在网络当中的一个身份证号。在同一个网络当中，IP地址是唯一的。</li>
<li>A计算机要想和B计算机通信，首先你需要知道B计算机的IP地址，有了IP地址才能建立连接。</li>
</ul>
</li>
<li>端口号是啥？<ul>
<li>一个端口代表一个软件（一个端口代表一个应用，一个端口仅代表一个服务）。</li>
<li>一个计算机当中有很多软件，每一个软件启动之后都有一个端口号。</li>
<li>在同一个计算机上，端口号具有唯一性。</li>
</ul>
</li>
<li>一个WEB系统的通信原理？通信步骤：<ul>
<li>第一步：用户输入网址（URL）</li>
<li>第二步：域名解析器进行域名解析：<a href="http://110.242.68.3/index.html">http://110.242.68.3:80/index.html</a></li>
<li>第三步：浏览器软件在网络中搜索110.242.68.3这一台主机，直到找到这台主机。</li>
<li>第四步：定位110.242.68.3这台主机上的服务器软件，因为是80端口，可以很轻松的定位到80端口对应的服务器软件。</li>
<li>第五步：80端口对应的服务器软件得知浏览器想要的资源名是：index.html</li>
<li>第六步：服务器软件找到index.html文件，并且将index.html文件中的内容直接输出响应到浏览器上。</li>
<li>第七步：浏览器接收到来自服务器的代码（HTML CSS JS）</li>
<li>第八步：浏览器渲染，执行HTML CSS JS代码，展示效果。</li>
</ul>
</li>
<li>什么是URL？<ul>
<li>统一资源定位符（<a href="http://www.baidu.com)/">http://www.baidu.com）</a></li>
</ul>
</li>
<li>什么是请求，什么是响应？<ul>
<li>请求和响应实际上说的是数据的流向不同。</li>
<li>从Browser端发送数据到Server端，我们称为请求。英语单词：request</li>
<li>从Server端向浏览器Browser端发送数据，我们称为响应。英语单词：response</li>
<li>B –&gt; S （请求request）</li>
<li>S –&gt; B （响应response）</li>
</ul>
</li>
</ul>
<h2 id="关于WEB服务器软件"><a href="#关于WEB服务器软件" class="headerlink" title="关于WEB服务器软件"></a>关于WEB服务器软件</h2><ul>
<li><p>WEB服务器软件都有哪些呢？（这些软件都是提前开发好的。）</p>
<ul>
<li>Tomcat（WEB服务器）</li>
<li>jetty（WEB服务器）</li>
<li>JBOSS（应用服务器）</li>
<li>WebLogic（应用服务器）</li>
<li>WebSphere（应用服务器）</li>
</ul>
</li>
<li><p>应用服务器和WEB服务器的关系？</p>
<ul>
<li>应用服务器实现了JavaEE的所有规范。(JavaEE有13个不同的规范。)</li>
<li>WEB服务器只实现了JavaEE中的Servlet + JSP两个核心的规范。</li>
<li>通过这个讲解说明了：应用服务器是包含WEB服务器的。</li>
<li>用过JBOSS服务器的同学应该很清楚，JBOSS中内嵌了一个Tomcat服务器。</li>
</ul>
</li>
<li><p>Tomcat下载</p>
<ul>
<li>apache官网地址：<a href="https://www.apache.org/">https://www.apache.org/</a></li>
<li>tomcat官网地址：<a href="https://tomcat.apache.org/">https://tomcat.apache.org</a></li>
<li>tomcat开源免费的轻量级WEB服务器。</li>
<li>tomcat还有另外一个名字：catalina（catalina是美国的一个岛屿，风景秀丽，据说作者是在这个风景秀丽的小岛上开发了一个轻量级的WEB服务器，体积小，运行速度快，因此tomcat又被称为catalina）</li>
<li>tomcat的logo是一只公猫（寓意表示Tomcat服务器是轻巧的，小巧的，果然，体积小，运行速度快，只实现了Servlet+JSP规范）</li>
<li>tomcat是java语言写的。</li>
<li>tomcat服务器要想运行，必须先又jre（Java的运行时环境）</li>
</ul>
</li>
<li><p>Tomcat服务器要想运行，需要先有jre，所以要先安装JDK，配置java运行环境。</p>
<ul>
<li>JAVA_HOME&#x3D;C:\Program Files\Java\jdk-17.0.1</li>
<li>PATH&#x3D;%JAVA_HOME%\bin</li>
<li>目前JAVA_HOME没有配置，思考一个问题，这样行不行呢？目前只运行java程序是没问题的。真的没问题吗？</li>
</ul>
</li>
<li><p>Tomcat服务器的安装：</p>
<ul>
<li>绿色版本的安装很简单，直接zip包解压即可。解压就是安装。</li>
<li>我有一个好习惯，在C盘的根目录下新建一个dev目录，java开发所有相关的工具都安装到dev目录下，这样比较方便管理。（你随意）</li>
<li>启动Tomcat<ul>
<li>bin目录下有一个文件：startup.bat,通过它可以启动Tomcat服务器。<ul>
<li>xxx.bat文件是个什么文件？bat文件是windows操作系统专用的，bat文件是批处理文件，这种文件中可以编写大量的windows的dos命令，然后执行bat文件就相当于批量的执行dos命令。</li>
<li>startup.sh，这个文件在windows当中无法执行，在Linux环境当中可以使用。在Linux环境下能够执行的是shell命令，大量的shell命令编写在shell文件当中，然后执行这个shell文件可以批量的执行shell命令。</li>
<li>tomcat服务器提供了bat和sh文件，说明了这个tomcat服务器的通用性。</li>
<li>分析startup.bat文件得出，执行这个命令，实际上最后是执行：catalina.bat文件。</li>
<li>catalina.bat文件中有这样一行配置：MAINCLASS&#x3D;org.apache.catalina.startup.Bootstrap （这个类就是main方法所在的类。）</li>
<li>tomcat服务器就是Java语言写的，既然是java语言写的，那么启动Tomcat服务器就是执行main方法。</li>
</ul>
</li>
<li>我们尝试打开dos命令窗口，在dos命令窗口中输入startup.bat来启动tomcat服务器。</li>
<li>启动Tomcat服务器只配置path对应的bin目录是不行的。有两个环境变量需要配置：<ul>
<li>JAVA_HOME&#x3D;JDK的根</li>
<li>CATALINA_HOME&#x3D;Tomcat服务器的根</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>关于Tomcat服务器的目录</p>
<ul>
<li>bin ： 这个目录是Tomcat服务器的命令文件存放的目录，比如：启动Tomcat，关闭Tomcat等。</li>
<li>conf： 这个目录是Tomcat服务器的配置文件存放目录。（server.xml文件中可以配置端口号，默认Tomcat端口是8080）</li>
<li>lib ：这个目录是Tomcat服务器的核心程序目录，因为Tomcat服务器是Java语言编写的，这里的jar包里面都是class文件。</li>
<li>logs: Tomcat服务器的日志目录，Tomcat服务器启动等信息都会在这个目录下生成日志文件。</li>
<li>temp：Tomcat服务器的临时目录。存储临时文件。</li>
<li>webapps：这个目录当中就是用来存放大量的webapp（web application：web应用）</li>
<li>work：这个目录是用来存放JSP文件翻译之后的java文件以及编译之后的class文件。</li>
</ul>
</li>
<li><p>配置Tomcat服务器需要哪些环境变量？</p>
<ul>
<li>JAVA_HOME&#x3D;JDK的根</li>
<li>CATALINA_HOME&#x3D;Tomcat服务器的根</li>
<li>PATH&#x3D;%JAVA_HOME%\bin;%CATALINA_HOME%\bin</li>
</ul>
</li>
<li><p>启动Tomcat： startup</p>
</li>
<li><p>关闭Tomcat：stop （shutdown.bat文件重命名为stop.bat，为什么？原因是shutdown命令和windows中的关机命令冲突。所以修改一下。）</p>
</li>
<li><p>怎么测试Tomcat服务器有没有启动成功呢？</p>
<ul>
<li>打开浏览器，在浏览器的地址栏上输入URL即可：<ul>
<li><a href="http://ip地址:端口号">http://ip地址:端口号</a></li>
<li>ip地址是什么？端口号我知道，是8080</li>
<li>本机的IP地址是：127.0.0.1，或者是localhost，都行。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="实现一个最基本的web应用（这个web应用中没有java小程序）"><a href="#实现一个最基本的web应用（这个web应用中没有java小程序）" class="headerlink" title="实现一个最基本的web应用（这个web应用中没有java小程序）"></a>实现一个最基本的web应用（这个web应用中没有java小程序）</h2><ul>
<li><p>第一步：找到CATALINA_HOME\webapps目录</p>
<ul>
<li>因为所有的webapp要放到webapps目录下。（没有为什么，这是Tomcat服务器的要求。如果不放到这里，Tomcat服务器找不到你的应用。）</li>
</ul>
</li>
<li><p>第二步：在CATALINA_HOME\webapps目录下新建一个子目录，起名：oa</p>
<ul>
<li>这个目录名oa就是你这个webapp的名字。</li>
</ul>
</li>
<li><p>第三步：在oa目录下新建资源文件，例如：index.html</p>
<ul>
<li>编写index.html文件的内容。</li>
</ul>
</li>
<li><p>第四步：启动Tomcat服务器</p>
</li>
<li><p>第五步：打开浏览器，在浏览器地址栏上输入这样的URL：</p>
<ul>
<li><a href="http://127.0.0.1:8080/oa/index.html">http://127.0.0.1:8080/oa/index.html</a></li>
</ul>
</li>
<li><p>思考一个问题：</p>
<ul>
<li><p>我们在浏览器上直接输入一个URL，然后回车。这个动作和超链接一样吗？既然是一样的，我们完全可以使用超链接。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注意以下的路径，以/开始，带项目名，是一个绝对路径。不需要添加：http://127.0.0.1:8080--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/oa/login.html&quot;</span>&gt;</span>user login2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--多个层级也没有关系，正常访问即可。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注意：我们目前前端上的路径都以“/”开始的，都是加项目名的。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/oa/test/debug/d.html&quot;</span>&gt;</span>d page<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><a href="http://127.0.0.1:8080/oa/userList.html">http://127.0.0.1:8080/oa/userList.html</a> </p>
<ul>
<li>访问这个地址，可以展示一个用户列表页面。但是这个用户列表页面是写死在HTML文件当中的。这种资源我们称为静态资源。怎么能变成动态资源。显然需要连接数据库。</li>
<li>连接数据库需要JDBC程序，也就是说需要编写Java程序连接数据库，数据库中有多少条记录，页面上就显示多少条记录，这种技术被称为动态网页技术。（动态网页技术并不是说页面中有flash动画。动态网页技术是说页面中的数据是动态的，根据数据库中数据的变化而变化。）</li>
</ul>
</li>
</ul>
<h2 id="对于一个动态的web应用来说，一个请求和响应的过程有多少个角色参与，角色和角色之间有多少个协议"><a href="#对于一个动态的web应用来说，一个请求和响应的过程有多少个角色参与，角色和角色之间有多少个协议" class="headerlink" title="对于一个动态的web应用来说，一个请求和响应的过程有多少个角色参与，角色和角色之间有多少个协议"></a>对于一个动态的web应用来说，一个请求和响应的过程有多少个角色参与，角色和角色之间有多少个协议</h2><ul>
<li><p>有哪些角色（在整个BS结构的系统当中，有哪些人参与进去了）</p>
<ul>
<li>浏览器软件的开发团队（浏览器软件太多了：谷歌浏览器、火狐浏览器、IE浏览器….）</li>
<li>WEB Server的开发团队（WEB Server这个软件也是太多了：Tomcat、Jetty、WebLogic、JBOSS、WebSphere….）</li>
<li>DB Server的开发团队（DB Server这个软件也是太多了：Oracle、MySQL…..）</li>
<li>webapp的开发团队（WEB应用是我们做为JavaWEB程序员开发的）</li>
</ul>
</li>
<li><p>角色和角色之间需要遵守哪些规范，哪些协议</p>
<ul>
<li>webapp的开发团队   和    WEB Server的开发团队  之间有一套规范: JavaEE规范之一Servlet规范。<ul>
<li>Servlet规范的作用是什么？<ul>
<li>WEB Server   和   webapp解耦合。</li>
</ul>
</li>
</ul>
</li>
<li>Browser  和   WebServer之间有一套传输协议：HTTP协议。（超文本传输协议。）</li>
<li>webapp开发团队  和  DB Server的开发团队之间有一套规范：JDBC规范。</li>
</ul>
</li>
<li><p>Servlet规范是一个什么规范？</p>
<ul>
<li>遵循Servlet规范的webapp，这个webapp就可以放在不同的WEB服务器中运行。（因为这个webapp是遵循Servlet规范的。）</li>
<li>Servlet规范包括什么呢？<ul>
<li>规范了哪些接口</li>
<li>规范了哪些类</li>
<li>规范了一个web应用中应该有哪些配置文件</li>
<li>规范了一个web应用中配置文件的名字</li>
<li>规范了一个web应用中配置文件存放的路径</li>
<li>规范了一个web应用中配置文件的内容</li>
<li>规范了一个合法有效的web应用它的目录结构应该是怎样的。</li>
<li>…..</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="开发一个带有Servlet（Java小程序）的webapp（重点）"><a href="#开发一个带有Servlet（Java小程序）的webapp（重点）" class="headerlink" title="开发一个带有Servlet（Java小程序）的webapp（重点）"></a>开发一个带有Servlet（Java小程序）的webapp（重点）</h2><ul>
<li><p>开发步骤是怎样的？</p>
<ul>
<li><p>第一步：在webapps目录下新建一个目录，起名crm（这个crm就是webapp的名字）。当然，也可以是其它项目，比如银行项目，可以创建一个目录bank，办公系统可以创建一个oa。</p>
<ul>
<li>注意：crm就是这个webapp的根</li>
</ul>
</li>
<li><p>第二步：在webapp的根下新建一个目录：WEB-INF</p>
<ul>
<li>注意：这个目录的名字是Servlet规范中规定的，必须全部大写，必须一模一样。必须的必须。</li>
</ul>
</li>
<li><p>第三步：在WEB-INF目录下新建一个目录：classes</p>
<ul>
<li>注意：这个目录的名字必须是全部小写的classes。这也是Servlet规范中规定的。另外这个目录下一定存放的是Java程序编译之后的class文件（这里存放的是字节码文件）。</li>
</ul>
</li>
<li><p>第四步：在WEB-INF目录下新建一个目录：lib</p>
<ul>
<li>注意：这个目录不是必须的。但如果一个webapp需要第三方的jar包的话，这个jar包要放到这个lib目录下，这个目录的名字也不能随意编写，必须是全部小写的lib。例如java语言连接数据库需要数据库的驱动jar包。那么这个jar包就一定要放到lib目录下。这Servlet规范中规定的。</li>
</ul>
</li>
<li><p>第五步：在WEB-INF目录下新建一个文件：web.xml</p>
<ul>
<li>注意：这个文件是必须的，这个文件名必须叫做web.xml。这个文件必须放在这里。一个合法的webapp，web.xml文件是必须的，这个web.xml文件就是一个配置文件，在这个配置文件中描述了请求路径和Servlet类之间的对照关系。</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/5291509-01ac23b210d5e6df.webp" alt="5291509-01ac23b210d5e6df"></p>
<ul>
<li><p><strong>以上图说明</strong>：</p>
<ul>
<li>bbs目录代表一个web应用</li>
<li>bbs目录下的html,jsp文件可以直接被浏览器访问</li>
<li><strong>WEB-INF目录下的资源是不能直接被浏览器访问的(默认安全的一个目录)</strong></li>
<li>web.xml文件是web程序的主要配置文件</li>
<li>所有的classes文件都放在classes目录下</li>
<li>jar文件放在lib目录下</li>
</ul>
</li>
<li><p>这个文件最好从其他的webapp中拷贝，最好别手写。没必要。复制粘贴</p>
</li>
<li><p>&#96;&#96;&#96;xml</p>
<?xml version="1.0" encoding="UTF-8"?>

<p><web-app xmlns="https://jakarta.ee/xml/ns/jakartaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee
                  https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd"
  version="5.0"
  metadata-complete="true"></p>
</web-app>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 第六步：编写一个Java程序，这个小Java程序也不能随意开发，这个小java程序必须实现Servlet接口。</span><br><span class="line"></span><br><span class="line">  - 这个Servlet接口不在JDK当中。（因为Servlet不是JavaSE了。Servlet属于JavaEE，是另外的一套类库。）</span><br><span class="line">  - Servlet接口（Servlet.class文件）是Oracle提供的。（最原始的是sun公司提供的。）</span><br><span class="line">  - Servlet接口是JavaEE的规范中的一员。</span><br><span class="line">  - Tomcat服务器实现了Servlet规范，所以Tomcat服务器也需要使用Servlet接口。Tomcat服务器中应该有这个接口，Tomcat服务器的CATALINA_HOME\lib目录下有一个servlet-api.jar，解压这个servlet-api.jar之后，你会看到里面有一个Servlet.class文件。</span><br><span class="line">  - 重点：从JakartaEE9开始，Servlet接口的全名变了：jakarta.servlet.Servlet</span><br><span class="line">  - 注意：编写这个Java小程序的时候，java源代码你愿意在哪里就在哪里，位置无所谓，你只需要将java源代码编译之后的class文件放到classes目录下即可。</span><br><span class="line"></span><br><span class="line">- 第七步：编译我们编写的HelloServlet</span><br><span class="line"></span><br><span class="line">  - 重点：你怎么能让你的HelloServlet编译通过呢？配置环境变量CLASSPATH</span><br><span class="line"></span><br><span class="line">    CLASSPATH=.;C:\dev\apache-tomcat-10.0.12\lib\servlet-api.jar</span><br><span class="line"></span><br><span class="line">  - 思考问题：以上配置的CLASSPATH和Tomcat服务器运行有没有关系？</span><br><span class="line"></span><br><span class="line">    - 没有任何关系，以上配置这个环境变量只是为了让你的HelloServlet能够正常编译生成class文件。</span><br><span class="line"></span><br><span class="line">- 第八步：将以上编译之后的HelloServlet.class文件拷贝到WEB-INF\classes目录下。</span><br><span class="line"></span><br><span class="line">- 第九步：在web.xml文件中编写配置信息，让“请求路径”和“Servlet类名”关联在一起。</span><br><span class="line"></span><br><span class="line">  - 这一步用专业术语描述：在web.xml文件中注册Servlet类。</span><br><span class="line"></span><br><span class="line">  - ```xml</span><br><span class="line">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span><br><span class="line">      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">      xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee</span><br><span class="line">                          https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span><br><span class="line">      version=&quot;5.0&quot;</span><br><span class="line">      metadata-complete=&quot;true&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    	&lt;!--servlet描述信息--&gt;</span><br><span class="line">    	&lt;!--任何一个servlet都对应一个servlet-mapping --&gt;</span><br><span class="line">    	&lt;servlet&gt;</span><br><span class="line">    		&lt;servlet-name&gt;fdsafdsagfdsafdsa&lt;/servlet-name&gt;</span><br><span class="line">    		&lt;!--这个位置必须是带有包名的全限定类名--&gt;</span><br><span class="line">    		&lt;servlet-class&gt;com.bjpowernode.servlet.HelloServlet&lt;/servlet-class&gt;</span><br><span class="line">    	&lt;/servlet&gt;</span><br><span class="line">    </span><br><span class="line">    	&lt;!--servlet映射信息--&gt;</span><br><span class="line">    	&lt;servlet-mapping&gt;</span><br><span class="line">    		&lt;!--这个也是随便的，不过这里写的内容要和上面的一样。--&gt;</span><br><span class="line">    		&lt;servlet-name&gt;fdsafdsagfdsafdsa&lt;/servlet-name&gt;</span><br><span class="line">    		&lt;!--这里需要一个路径--&gt;</span><br><span class="line">    		&lt;!--这个路径唯一的要求是必须以 / 开始--&gt;</span><br><span class="line">    		&lt;!--当前这个路径可以随便写--&gt;</span><br><span class="line">    		&lt;url-pattern&gt;/fdsa/fd/saf/d/sa/fd/sa/fd&lt;/url-pattern&gt;</span><br><span class="line">    	&lt;/servlet-mapping&gt;</span><br><span class="line">    	</span><br><span class="line">    &lt;/web-app&gt;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>第十步：启动Tomcat服务器</p>
</li>
<li><p>第十一步：打开浏览器，在浏览器地址栏上输入一个url，这个URL必须是：</p>
<ul>
<li><a href="http://127.0.0.1:8080/crm/fdsa/fd/saf/d/sa/fd/sa/fd">http://127.0.0.1:8080/crm/fdsa/fd/saf/d/sa/fd/sa/fd</a>   </li>
<li>非常重要的一件事：浏览器上的请求路径不能随便写，这个请求路径必须和web.xml文件中的url-pattern一致。</li>
<li>注意：浏览器上的请求路径和web.xml文件中的url-pattern的唯一区别就是：浏览器上的请求路径带项目名：&#x2F;crm</li>
</ul>
</li>
<li><p>浏览器上编写的路径太复杂，可以使用超链接。（<strong>非常重要：html页面只能放到WEB-INF目录外面。</strong>）</p>
</li>
<li><p>以后不需要我们编写main方法了。tomcat服务器负责调用main方法，Tomcat服务器启动的时候执行的就是main方法。我们javaweb程序员只需要编写Servlet接口的实现类，然后将其注册到web.xml文件中，即可。</p>
</li>
<li><p><strong>总结一下</strong>：一个合法的webapp目录结构应该是怎样的？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webapproot</span><br><span class="line">     |------WEB-INF</span><br><span class="line">     		  |------classes(存放字节码)</span><br><span class="line">     		  |------lib(第三方jar包)</span><br><span class="line">     		  |------web.xml(注册Servlet)</span><br><span class="line">     |------html</span><br><span class="line">     |------css</span><br><span class="line">     |------javascript</span><br><span class="line">     |------image</span><br><span class="line">     ....</span><br></pre></td></tr></table></figure>
</li>
<li><p>浏览器发送请求，到最终服务器调用Servlet中的方法，是怎样的一个过程？（以下这个过程描述的很粗糙。其中还有很多步骤我省略了。）</p>
<ul>
<li>用户输入URL，或者直接点击超链接：<a href="http://127.0.0.1:8080/crm/fdsa/fd/saf/d/sa/fd/sa/fd">http://127.0.0.1:8080/crm/fdsa/fd/saf/d/sa/fd/sa/fd</a>  </li>
<li>然后Tomcat服务器接收到请求，截取路径：&#x2F;crm&#x2F;fdsa&#x2F;fd&#x2F;saf&#x2F;d&#x2F;sa&#x2F;fd&#x2F;sa&#x2F;fd  </li>
<li>Tomcat服务器找到crm项目</li>
<li>Tomcat服务器在web.xml文件中查找&#x2F;fdsa&#x2F;fd&#x2F;saf&#x2F;d&#x2F;sa&#x2F;fd&#x2F;sa&#x2F;fd  对应的Servlet是：com.bjpowernode.servlet.HelloServlet</li>
<li>Tomcat服务器通过反射机制，创建com.bjpowernode.servlet.HelloServlet的对象。</li>
<li>Tomcat服务器调用com.bjpowernode.servlet.HelloServlet对象的service方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="关于JavaEE的版本"><a href="#关于JavaEE的版本" class="headerlink" title="关于JavaEE的版本"></a>关于JavaEE的版本</h2><ul>
<li>JavaEE目前最高版本是 JavaEE8</li>
<li>JavaEE被Oracle捐献了，Oracle将JavaEE规范捐献给Apache了。</li>
<li>Apache把JavaEE换名了，以后不叫JavaEE了，以后叫做 jakarta EE。</li>
<li>以后没有JavaEE了。以后都叫做Jakarta EE。</li>
<li>JavaEE8版本升级之后的”JavaEE 9”，不再是”JavaEE9”这个名字了，叫做JakartaEE9</li>
<li>JavaEE8的时候对应的Servlet类名是：javax.servlet.Servlet</li>
<li>JakartaEE9的时候对应的Servlet类名是：jakarta.servlet.Servlet （包名都换了）</li>
<li>如果你之前的项目还是在使用javax.servlet.Servlet，那么你的项目无法直接部署到Tomcat10+版本上。你只能部署到Tomcat9-版本上。在Tomcat9以及Tomcat9之前的版本中还是能够识别javax.servlet这个包。</li>
</ul>
<h2 id="解决Tomcat服务器在DOS命令窗口中的乱码问题（控制台乱码）"><a href="#解决Tomcat服务器在DOS命令窗口中的乱码问题（控制台乱码）" class="headerlink" title="解决Tomcat服务器在DOS命令窗口中的乱码问题（控制台乱码）"></a>解决Tomcat服务器在DOS命令窗口中的乱码问题（控制台乱码）</h2><p>将CATALINA_HOME&#x2F;conf&#x2F;logging.properties文件中的内容修改如下：</p>
<p>java.util.logging.ConsoleHandler.encoding &#x3D; GBK</p>
<h2 id="向浏览器响应一段HTML代码"><a href="#向浏览器响应一段HTML代码" class="headerlink" title="向浏览器响应一段HTML代码"></a>向浏览器响应一段HTML代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest request, ServletResponse response)</span>&#123;</span><br><span class="line">    response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">    <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">    out.print(<span class="string">&quot;&lt;h1&gt;hello servlet!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在Servlet中连接数据库，怎么做？"><a href="#在Servlet中连接数据库，怎么做？" class="headerlink" title="在Servlet中连接数据库，怎么做？"></a>在Servlet中连接数据库，怎么做？</h2><ul>
<li>Servlet是Java程序，所以在Servlet中完全可以编写JDBC代码连接数据库。</li>
<li>在一个webapp中去连接数据库，需要将驱动jar包放到WEB-INF&#x2F;lib目录下。（com.mysql.cj.jdbc.Driver 这个类就在驱动jar包当中。）</li>
</ul>
<h2 id="在集成开发环境当中开发Servlet程序"><a href="#在集成开发环境当中开发Servlet程序" class="headerlink" title="在集成开发环境当中开发Servlet程序"></a>在集成开发环境当中开发Servlet程序</h2><ul>
<li><p>集成开发工具很多，其中目前使用比较多的是：</p>
<ul>
<li>IntelliJ IDEA（这个居多，IDEA在提示功能方面要强于Eclipse，也就是说IDEA使用起来比Eclipse更加智能，更好用。JetBrain公司开发的。收费的。）</li>
<li>Eclipse（这个少一些），Eclipse目前还是有团队使用，只不过处于减少的趋势，自己从事工作之后，可能会遇到。Eclipse是IBM团队开发的。Eclipse寓意是“日食”。“日食”表示将太阳吃掉。太阳是SUN。IBM团队开发Eclipse的寓意是吞并SUN公司，但是2009年的时候SUN公司被Oracle公司并购了。IBM并没有成功并购SUN公司。</li>
</ul>
</li>
<li><p>使用IDEA集成开发工具开发Servlet</p>
<ul>
<li>第一步：New Project（我比较习惯先创建一个Empty Project【空工程】，然后在空工程下新建Module【模块】，这不是必须的，只是一种习惯，你可以直接新建非空的Project），这个Empty Project起名为：javaweb（不是必须的，只是一个名字而已。一般情况下新建的Project的名字最好和目录的名字一致。）</li>
<li>第二步：新建模块（File –&gt; new –&gt; Module…）<ul>
<li>这里新建的是一个普通的JavaSE模块（这里先不要新建Java Enterprise模块）</li>
<li>这个Module自动会被放在javaweb的project下面。</li>
<li>这个Module起名：servlet01</li>
</ul>
</li>
<li>第三步：让Module变成JavaEE的模块。（让Module变成webapp的模块。符合webapp规范。符合Servlet规范的Module）<ul>
<li>在Module上点击右键：Add Framework Support…（添加框架支持）</li>
<li>在弹出的窗口中，选择Web Application（选择的是webapp的支持）</li>
<li>选择了这个webapp的支持之后，IDEA会自动给你生成一个符合Servlet规范的webpp目录结构。</li>
<li><strong>重点，需要注意的：在IDEA工具中根据Web Application模板生成的目录中有一个web目录，这个目录就代表webapp的根</strong></li>
</ul>
</li>
<li>第四步（非必须）：根据Web Application生成的资源中有index.jsp文件，这里我选择删除这个index.jsp文件。</li>
<li>第五步：编写Servlet（StudentServlet）<ul>
<li>class StudentServlet implements Servlet</li>
<li>这个时候发现Servlet.class文件没有。怎么办？将CATALINA_HOME&#x2F;lib&#x2F;servlet-api.jar和jsp-api.jar添加到classpath当中（这里的classpath说的是IDEA的classpath）<ul>
<li>File –&gt; Project Structrue –&gt; Modules –&gt; + 加号 –&gt; Add JARS….</li>
</ul>
</li>
<li>实现jakarta.servlet.Servlet接口中的5个方法。</li>
</ul>
</li>
<li>第六步：在Servlet当中的service方法中编写业务代码（我们这里连接数据库了。）</li>
<li>第七步：在WEB-INF目录下新建了一个子目录：lib（这个目录名可不能随意，必须是全部小写的lib），并且将连接数据库的驱动jar包放到lib目录下。</li>
<li>第八步：在web.xml文件中完成StudentServlet类的注册。（请求路径和Servlet之间对应起来）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;web-app xmlns=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="line">         version=<span class="string">&quot;4.0&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;studentServlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;com.bjpowernode.javaweb.servlet.StudentServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;studentServlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/servlet/student&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>第九步：给一个html页面，在HTML页面中编写一个超链接，用户点击这个超链接，发送请求，Tomcat执行后台的StudentServlet。</p>
<ul>
<li><p>student.html</p>
</li>
<li><p>这个文件不能放到WEB-INF目录里面，只能放到WEB-INF目录外面。</p>
</li>
<li><p>student.html文件的内容</p>
</li>
<li><p>&#96;&#96;&#96;html</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>student page</title>
</head>
<body>
    <!--这里的项目名是 /xmm ，无法动态获取，先写死-->
    <a href="/xmm/servlet/student">student list</a>
</body>
</html>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">  - 第十步：让IDEA工具去关联Tomcat服务器。关联的过程当中将webapp部署到Tomcat服务器当中。</span><br><span class="line"></span><br><span class="line">    - IDEA工具右上角，绿色小锤子右边有一个：Add Configuration</span><br><span class="line">    - 左上角加号，点击Tomcat Server --&gt; local</span><br><span class="line">    - 在弹出的界面中设置服务器Server的参数（基本上不用动）</span><br><span class="line">    - 在当前窗口中有一个Deployment（点击这个用来部署webapp），继续点击加号，部署即可。</span><br><span class="line">    - 修改 Application context为：/xmm</span><br><span class="line"></span><br><span class="line">  - 第十一步：启动Tomcat服务器</span><br><span class="line"></span><br><span class="line">    - 在右上角有绿色的箭头，或者绿色的小虫子，点击这个绿色的小虫子，可以采用debug的模式启动Tomcat服务器。</span><br><span class="line">    - 我们开发中建议适用debug模式启动Tomcat</span><br><span class="line"></span><br><span class="line">  - 第十二步：打开浏览器，在浏览器地址栏上输入：http://localhost:8080/xmm/student.html</span><br><span class="line"></span><br><span class="line">## Servlet对象的生命周期</span><br><span class="line"></span><br><span class="line">- 什么是Servlet对象生命周期？</span><br><span class="line"></span><br><span class="line">  - Servlet对象什么时候被创建。</span><br><span class="line">  - Servlet对象什么时候被销毁。</span><br><span class="line">  - Servlet对象创建了几个？</span><br><span class="line">  - Servlet对象的生命周期表示：一个Servlet对象从出生在最后的死亡，整个过程是怎样的。</span><br><span class="line"></span><br><span class="line">- Servlet对象是由谁来维护的？</span><br><span class="line"></span><br><span class="line">  - Servlet对象的创建，对象上方法的调用，对象最终的销毁，Javaweb程序员是无权干预的。</span><br><span class="line">  - Servlet对象的生命周期是由Tomcat服务器（WEB Server）全权负责的。</span><br><span class="line">  - Tomcat服务器通常我们又称为：WEB容器。（这个叫法你要知道【WEB Container】）</span><br><span class="line">  - WEB容器来管理Servlet对象的死活。</span><br><span class="line"></span><br><span class="line">- 思考：我们自己new的Servlet对象受WEB容器的管理吗？</span><br><span class="line"></span><br><span class="line">  - 我们自己new的Servlet对象是不受WEB容器管理的。</span><br><span class="line"></span><br><span class="line">  - WEB容器创建的Servlet对象，这些Servlet对象都会被放到一个集合当中（HashMap），只有放到这个HashMap集合中的Servlet才能够被WEB容器管理，自己new的Servlet对象不会被WEB容器管理。（自己new的Servlet对象不在容器当中）</span><br><span class="line"></span><br><span class="line">  - web容器底层应该有一个HashMap这样的集合，在这个集合当中存储了Servlet对象和请求路径之间的关系</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- 研究：服务器在启动的Servlet对象有没有被创建出来（默认情况下）？</span><br><span class="line"></span><br><span class="line">  - 在Servlet中提供一个无参数的构造方法，启动服务器的时候看看构造方法是否执行。</span><br><span class="line">  - 经过测试得出结论：默认情况下，服务器在启动的时候Servlet对象并不会被实例化。</span><br><span class="line">  - 这个设计是合理的。用户没有发送请求之前，如果提前创建出来所有的Servlet对象，必然是耗费内存的，并且创建出来的Servlet如果一直没有用户访问，显然这个Servlet对象是一个废物，没必要先创建。</span><br><span class="line"></span><br><span class="line">- 怎么让服务器启动的时候创建Servlet对象呢？</span><br><span class="line"></span><br><span class="line">  - 在servlet标签中添加&lt;load-on-startup&gt;子标签，在该子标签中填写整数，越小的整数优先级越高。</span><br><span class="line"></span><br><span class="line">  - ```xml</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;aservlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;com.bjpowernode.javaweb.servlet.AServlet&lt;/servlet-class&gt;</span><br><span class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;aservlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/a&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>Servlet对象生命周期</p>
<ul>
<li><p>默认情况下服务器启动的时候AServlet对象并没有被实例化</p>
</li>
<li><p>用户发送第一次请求的时候，控制台输出了以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AServlet无参数构造方法执行了</span><br><span class="line">AServlet&#x27;s init method execute!</span><br><span class="line">AServlet&#x27;s service method execute!</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据以上输出内容得出结论：</p>
<ul>
<li>用户在发送第一次请求的时候Servlet对象被实例化（AServlet的构造方法被执行了。并且执行的是无参数构造方法。）</li>
<li>AServlet对象被创建出来之后，Tomcat服务器马上调用了AServlet对象的init方法。（init方法在执行的时候，AServlet对象已经存在了。已经被创建出来了。）</li>
<li>用户发送第一次请求的时候，init方法执行之后，Tomcat服务器马上调用AServlet对象的service方法。</li>
</ul>
</li>
<li><p>用户继续发送第二次请求，控制台输出了以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AServlet&#x27;s service method execute!</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据以上输出结果得知，用户在发送第二次，或者第三次，或者第四次请求的时候，Servlet对象并没有新建，还是使用之前创建好的Servlet对象，直接调用该Servlet对象的service方法，这说明：</p>
<ul>
<li>第一：Servlet对象是单例的（单实例的。但是要注意：Servlet对象是单实例的，但是Servlet类并不符合单例模式。我们称之为假单例。之所以单例是因为Servlet对象的创建我们javaweb程序员管不着，这个对象的创建只能是Tomcat来说了算，Tomcat只创建了一个，所以导致了单例，但是属于假单例。真单例模式，构造方法是私有化的。）</li>
<li>第二：无参数构造方法、init方法只在第一次用户发送请求的时候执行。也就是说无参数构造方法只执行一次。init方法也只被Tomcat服务器调用一次。</li>
<li>第三：只要用户发送一次请求：service方法必然会被Tomcat服务器调用一次。发送100次请求，service方法会被调用100次。</li>
</ul>
</li>
<li><p>关闭服务器的时候，控制台输出了以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AServlet&#x27;s destroy method execute!</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过以上输出内容，可以得出以下结论：</p>
<ul>
<li>Servlet的destroy方法只被Tomcat服务器调用一次。</li>
<li>destroy方法是在什么时候被调用的？<ul>
<li>在服务器关闭的时候。</li>
<li>因为服务器关闭的时候要销毁AServlet对象的内存。</li>
<li>服务器在销毁AServlet对象内存之前，Tomcat服务器会自动调用AServlet对象的destroy方法。</li>
</ul>
</li>
</ul>
</li>
<li><p>请问：destroy方法调用的时候，对象销毁了还是没有销毁呢？</p>
<ul>
<li>destroy方法执行的时候AServlet对象还在，没有被销毁。destroy方法执行结束之后，AServlet对象的内存才会被Tomcat释放。</li>
</ul>
</li>
<li><p>Servlet对象更像一个人的一生：</p>
<ul>
<li>Servlet的无参数构造方法执行：标志着你出生了。</li>
<li>Servlet对象的init方法的执行：标志着你正在接受教育。</li>
<li>Servlet对象的service方法的执行：标志着你已经开始工作了，已经开始为人类提供服务了。</li>
<li>Servlet对象的destroy方法的执行：标志着临终。有什么遗言，抓紧的。要不然，来不及了。</li>
</ul>
</li>
<li><p>关于Servlet类中方法的调用次数？</p>
<ul>
<li>构造方法只执行一次。</li>
<li>init方法只执行一次。</li>
<li>service方法：用户发送一次请求则执行一次，发送N次请求则执行N次。</li>
<li>destroy方法只执行一次。</li>
</ul>
</li>
<li><p>当我们Servlet类中编写一个有参数的构造方法，如果没有手动编写无参数构造方法会出现什么问题？</p>
<ul>
<li>报错了：500错误。</li>
<li>注意：500是一个HTTP协议的错误状态码。</li>
<li>500一般情况下是因为服务器端的Java程序出现了异常。（服务器端的错误都是500错误：服务器内部错误。）</li>
<li>如果没有无参数的构造方法，会导致出现500错误，无法实例化Servlet对象。</li>
<li>所以，一定要注意：在Servlet开发当中，不建议程序员来定义构造方法，因为定义不当，一不小心就会导致无法实例化Servlet对象。</li>
</ul>
</li>
<li><p>思考：Servlet的无参数构造方法是在对象第一次创建的时候执行，并且只执行一次。init方法也是在对象第一次创建的时候执行，并且只执行一次。那么这个无参数构造方法可以代替掉init方法吗？</p>
<ul>
<li>不能。</li>
<li>Servlet规范中有要求，作为javaweb程序员，编写Servlet类的时候，不建议手动编写构造方法，因为编写构造方法，很容易让无参数构造方法消失，这个操作可能会导致Servlet对象无法实例化。所以init方法是有存在的必要的。</li>
</ul>
</li>
<li><p>init、service、destroy方法中使用最多的是哪个方法？</p>
<ul>
<li>使用最多就是service方法，service方法是一定要实现的，因为service方法是处理用户请求的核心方法。</li>
<li>什么时候使用init方法呢？<ul>
<li>init方法很少用。</li>
<li>通常在init方法当中做初始化操作，并且这个初始化操作只需要执行一次。例如：初始化数据库连接池，初始化线程池….</li>
</ul>
</li>
<li>什么时候使用destroy方法呢？<ul>
<li>destroy方法也很少用。</li>
<li>通常在destroy方法当中，进行资源的关闭。马上对象要被销毁了，还有什么没有关闭的，抓紧时间关闭资源。还有什么资源没保存的，抓紧时间保存一下。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="总结-Servlet生命周期可分为5个步骤"><a href="#总结-Servlet生命周期可分为5个步骤" class="headerlink" title="总结:Servlet生命周期可分为5个步骤"></a>总结:Servlet生命周期可分为5个步骤</h4><ol>
<li><strong>加载Servlet</strong>。当Tomcat第一次访问Servlet的时候，<strong>Tomcat会负责创建Servlet的实例</strong></li>
<li><strong>初始化</strong>。当Servlet被实例化后，Tomcat会<strong>调用init()方法初始化这个对象</strong></li>
<li><strong>处理服务</strong>。当浏览器<strong>访问Servlet</strong>的时候，Servlet <strong>会调用service()方法处理请求</strong></li>
<li><strong>销毁</strong>。当Tomcat关闭时或者检测到Servlet要从Tomcat删除的时候会自动调用destroy()方法，<strong>让该实例释放掉所占的资源</strong>。一个Servlet如果长时间不被使用的话，也会被Tomcat自动销毁</li>
<li><strong>卸载</strong>。当Servlet调用完destroy()方法后，等待垃圾回收。如果<strong>有需要再次使用这个Servlet，会重新调用init()方法进行初始化操作</strong>。</li>
</ol>
<ul>
<li>简单总结：<strong>只要访问Servlet，service()就会被调用。init()只有第一次访问Servlet的时候才会被调用。<br> destroy()只有在Tomcat关闭的时候才会被调用。</strong></li>
</ul>
</li>
</ul>
<h2 id="GenericServlet"><a href="#GenericServlet" class="headerlink" title="GenericServlet"></a>GenericServlet</h2><ul>
<li><p>我们编写一个Servlet类直接实现Servlet接口有什么缺点？</p>
<ul>
<li>我们只需要service方法，其他方法大部分情况下是不需要使用的。代码很丑陋。</li>
</ul>
</li>
<li><p>适配器设计模式Adapter</p>
<ul>
<li>手机直接插到220V的电压上，手机直接就报废了。怎么办？可以找一个充电器。这个充电器就是一个适配器。手机连接适配器。适配器连接220V的电压。这样问题就解决了。</li>
</ul>
</li>
<li><p>编写一个GenericServlet类，这个类是一个抽象类，其中有一个抽象方法service。</p>
<ul>
<li>GenericServlet实现Servlet接口。</li>
<li>GenericServlet是一个适配器。</li>
<li>以后编写的所有Servlet类继承GenericServlet，重写service方法即可。</li>
</ul>
</li>
<li><p>思考：GenericServlet类是否需要改造一下？怎么改造？更利于子类程序的编写？</p>
<ul>
<li><p>思考第一个问题：我提供了一个GenericServlet之后，init方法还会执行吗？</p>
<ul>
<li>还会执行。会执行GenericServlet类中的init方法。</li>
</ul>
</li>
<li><p>思考第二个问题：init方法是谁调用的？</p>
<ul>
<li>Tomcat服务器调用的。</li>
</ul>
</li>
<li><p>思考第三个问题：init方法中的ServletConfig对象是谁创建的？是谁传过来的？</p>
<ul>
<li>都是Tomcat干的。</li>
<li>Tomcat服务器先创建了ServletConfig对象，然后调用init方法，将ServletConfig对象传给了init方法。</li>
</ul>
</li>
<li><p>思考一下Tomcat服务器伪代码：</p>
<ul>
<li>&#96;&#96;&#96;java<br>public class Tomcat {<br>public static void main(String[] args){<br>    &#x2F;&#x2F; …..<br>    &#x2F;&#x2F; Tomcat服务器伪代码<br>    &#x2F;&#x2F; 创建LoginServlet对象（通过反射机制，调用无参数构造方法来实例化LoginServlet对象）<br>    Class clazz &#x3D; Class.forName(“com.bjpowernode.javaweb.servlet.LoginServlet”);<br>    Object obj &#x3D; clazz.newInstance();<br><br>    &#x2F;&#x2F; 向下转型<br>    Servlet servlet &#x3D; (Servlet)obj;<br><br>    &#x2F;&#x2F; 创建ServletConfig对象<br>    &#x2F;&#x2F; Tomcat服务器负责将ServletConfig对象实例化出来。<br>    &#x2F;&#x2F; 多态（Tomcat服务器完全实现了Servlet规范）<br>    ServletConfig servletConfig &#x3D; new org.apache.catalina.core.StandardWrapperFacade();<br><br>    &#x2F;&#x2F; 调用Servlet的init方法<br>    servlet.init(servletConfig);<br><br>    &#x2F;&#x2F; 调用Servlet的service方法<br>    &#x2F;&#x2F; ….<br><br>}<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## ServletConfig</span><br><span class="line"></span><br><span class="line">- 什么是ServletConfig？</span><br><span class="line"></span><br><span class="line">  - Servlet对象的配置信息对象。</span><br><span class="line">  - ServletConfig对象中封装了&lt;servlet&gt;&lt;/servlet&gt;标签中的配置信息。（web.xml文件中servlet的配置信息）</span><br><span class="line"></span><br><span class="line">- 一个Servlet对应一个ServletConfig对象。</span><br><span class="line"></span><br><span class="line">- Servlet对象是Tomcat服务器创建，并且ServletConfig对象也是Tomcat服务器创建。并且默认情况下，他们都是在用户发送第一次请求的时候创建。</span><br><span class="line"></span><br><span class="line">- Tomcat服务器调用Servlet对象的init方法的时候需要传一个ServletConfig对象的参数给init方法。</span><br><span class="line"></span><br><span class="line">- ServletConfig接口的实现类是Tomcat服务器给实现的。（Tomcat服务器说的就是WEB服务器。）</span><br><span class="line"></span><br><span class="line">- ServletConfig接口有哪些常用的方法？</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public String getInitParameter(String name); // 通过初始化参数的name获取value</span><br><span class="line">    public Enumeration&lt;String&gt; getInitParameterNames(); // 获取所有的初始化参数的name</span><br><span class="line">    public ServletContext getServletContext(); // 获取ServletContext对象</span><br><span class="line">    public String getServletName(); // 获取Servlet的name</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>以上方法在Servlet类当中，都可以使用this去调用。因为GenericServlet实现了ServletConfig接口。</p>
</li>
</ul>
</li>
</ul>
<h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><ul>
<li><p>一个Servlet对象对应一个ServletConfig。100个Servlet对象则对应100个ServletConfig对象。</p>
</li>
<li><p>只要在同一个webapp当中，只要在同一个应用当中，所有的Servlet对象都是共享同一个ServletContext对象的。</p>
</li>
<li><p>ServletContext对象在服务器启动阶段创建，在服务器关闭的时候销毁。这就是ServletContext对象的生命周期。ServletContext对象是应用级对象。</p>
</li>
<li><p>Tomcat服务器中有一个webapps，这个webapps下可以存放webapp，可以存放多个webapp，假设有100个webapp，那么就有100个ServletContext对象。但是，总之，一个应用，一个webapp肯定是只有一个ServletContext对象。</p>
</li>
<li><p>ServletContext被称为Servlet上下文对象。（Servlet对象的四周环境对象。）</p>
</li>
<li><p>一个ServletContext对象通常对应的是一个web.xml文件。</p>
</li>
<li><p>ServletContext对应显示生活中的什么例子呢？</p>
<ul>
<li>一个教室里有多个学生，那么每一个学生就是一个Servlet，这些学生都在同一个教室当中，那么我们可以把这个教室叫做ServletContext对象。那么也就是说放在这个ServletContext对象（环境）当中的数据，在同一个教室当中，物品都是共享的。比如：教室中有一个空调，所有的学生都可以操作。可见，空调是共享的。因为空调放在教室当中。教室就是ServletContext对象。</li>
</ul>
</li>
<li><p>ServletContext是一个接口，Tomcat服务器对ServletContext接口进行了实现。</p>
<ul>
<li>ServletContext对象的创建也是Tomcat服务器来完成的。启动webapp的时候创建的。</li>
</ul>
</li>
<li><p>ServletContext接口中有哪些常用的方法？</p>
<ul>
<li><pre><code class="java">public String getInitParameter(String name); // 通过初始化参数的name获取value
public Enumeration&lt;String&gt; getInitParameterNames(); // 获取所有的初始化参数的name
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```xml</span><br><span class="line">  &lt;!--以上两个方法是ServletContext对象的方法，这个方法获取的是什么信息？是以下的配置信息--&gt;</span><br><span class="line">  &lt;context-param&gt;</span><br><span class="line">      &lt;param-name&gt;pageSize&lt;/param-name&gt;</span><br><span class="line">      &lt;param-value&gt;10&lt;/param-value&gt;</span><br><span class="line">  &lt;/context-param&gt;</span><br><span class="line">  &lt;context-param&gt;</span><br><span class="line">      &lt;param-name&gt;startIndex&lt;/param-name&gt;</span><br><span class="line">      &lt;param-value&gt;0&lt;/param-value&gt;</span><br><span class="line">  &lt;/context-param&gt;</span><br><span class="line">  &lt;!--注意：以上的配置信息属于应用级的配置信息，一般一个项目中共享的配置信息会放到以上的标签当中。--&gt;</span><br><span class="line">  &lt;!--如果你的配置信息只是想给某一个servlet作为参考，那么你配置到servlet标签当中即可，使用ServletConfig对象来获取。--&gt;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="java">// 获取应用的根路径（非常重要），因为在java源代码当中有一些地方可能会需要应用的根路径，这个方法可以动态获取应用的根路径
// 在java源码当中，不要将应用的根路径写死，因为你永远都不知道这个应用在最终部署的时候，起一个什么名字。
public String getContextPath();
//String contextPath = application.getContextPath();
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  // 获取文件的绝对路径（真实路径）</span><br><span class="line">  public String getRealPath(String path);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F; 通过ServletContext对象也是可以记录日志的<br>public void log(String message);<br>public void log(String message, Throwable t);<br>&#x2F;&#x2F; 这些日志信息记录到哪里了？<br>&#x2F;&#x2F; localhost.2021-11-05.log</p>
<p>&#x2F;&#x2F; Tomcat服务器的logs目录下都有哪些日志文件？<br>&#x2F;&#x2F;catalina.2021-11-05.log 服务器端的java程序运行的控制台信息。<br>&#x2F;&#x2F;localhost.2021-11-05.log ServletContext对象的log方法记录的日志信息存储到这个文件中。<br>&#x2F;&#x2F;localhost_access_log.2021-11-05.txt 访问日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  // ServletContext对象还有另一个名字：应用域（后面还有其他域，例如：请求域、会话域）</span><br><span class="line">  </span><br><span class="line">  // 如果所有的用户共享一份数据，并且这个数据很少的被修改，并且这个数据量很少，可以将这些数据放到ServletContext这个应用域中</span><br><span class="line">  </span><br><span class="line">  // 为什么是所有用户共享的数据？ 不是共享的没有意义。因为ServletContext这个对象只有一个。只有共享的数据放进去才有意义。</span><br><span class="line">  </span><br><span class="line">  // 为什么数据量要小？ 因为数据量比较大的话，太占用堆内存，并且这个对象的生命周期比较长，服务器关闭的时候，这个对象才会被销毁。大数据量会影响服务器的性能。占用内存较小的数据量可以考虑放进去。</span><br><span class="line">  </span><br><span class="line">  // 为什么这些共享数据很少的修改，或者说几乎不修改？</span><br><span class="line">  // 所有用户共享的数据，如果涉及到修改操作，必然会存在线程并发所带来的安全问题。所以放在ServletContext对象中的数据一般都是只读的。</span><br><span class="line">  </span><br><span class="line">  // 数据量小、所有用户共享、又不修改，这样的数据放到ServletContext这个应用域当中，会大大提升效率。因为应用域相当于一个缓存，放到缓存中的数据，下次在用的时候，不需要从数据库中再次获取，大大提升执行效率。</span><br><span class="line">  </span><br><span class="line">  // 存（怎么向ServletContext应用域中存数据）</span><br><span class="line">  public void setAttribute(String name, Object value); // map.put(k, v)</span><br><span class="line">  // 取（怎么从ServletContext应用域中取数据）</span><br><span class="line">  public Object getAttribute(String name); // Object v = map.get(k)</span><br><span class="line">  // 删（怎么删除ServletContext应用域中的数据）</span><br><span class="line">  public void removeAttribute(String name); // map.remove(k)</span><br><span class="line">  </span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>注意：以后我们编写Servlet类的时候，实际上是不会去直接继承GenericServlet类的，因为我们是B&#x2F;S结构的系统，这种系统是基于HTTP超文本传输协议的，在Servlet规范当中，提供了一个类叫做HttpServlet，它是专门为HTTP协议准备的一个Servlet类。我们编写的Servlet类要继承HttpServlet。（HttpServlet是HTTP协议专用的。）使用HttpServlet处理HTTP协议更便捷。但是你需要直到它的继承结构：</p>
<ul>
<li><pre><code>jakarta.servlet.Servlet（接口）【爷爷】
jakarta.servlet.GenericServlet implements Servlet（抽象类）【儿子】
jakarta.servlet.http.HttpServlet extends GenericServlet（抽象类）【孙子】

我们以后编写的Servlet要继承HttpServlet类。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 大家到目前为止都接触过哪些缓存机制了？</span><br><span class="line"></span><br><span class="line">  - 堆内存当中的字符串常量池。</span><br><span class="line">    - &quot;abc&quot; 先在字符串常量池中查找，如果有，直接拿来用。如果没有则新建，然后再放入字符串常量池。</span><br><span class="line">  - 堆内存当中的整数型常量池。</span><br><span class="line">    - [-128 ~ 127] 一共256个Integer类型的引用，放在整数型常量池中。没有超出这个范围的话，直接从常量池中取。</span><br><span class="line">  - 连接池(Connection Cache)</span><br><span class="line">    - 这里所说的连接池中的连接是java语言连接数据库的连接对象：java.sql.Connection对象。</span><br><span class="line">    - JVM是一个进程。MySQL数据库是一个进程。进程和进程之间建立连接，打开通道是很费劲的。是很耗费资源的。怎么办？可以提前先创建好N个Connection连接对象，将连接对象放到一个集合当中，我们把这个放有Connection对象的集合称为连接池。每一次用户连接的时候不需要再新建连接对象，省去了新建的环节，直接从连接池中获取连接对象，大大提升访问效率。</span><br><span class="line">    - 连接池</span><br><span class="line">      - 最小连接数</span><br><span class="line">      - 最大连接数</span><br><span class="line">      - 连接池可以提高用户的访问效率。当然也可以保证数据库的安全性。</span><br><span class="line">  - 线程池</span><br><span class="line">    - Tomcat服务器本身就是支持多线程的。</span><br><span class="line">    - Tomcat服务器是在用户发送一次请求，就新建一个Thread线程对象吗？</span><br><span class="line">      - 当然不是，实际上是在Tomcat服务器启动的时候，会先创建好N多个线程Thread对象，然后将线程对象放到集合当中，称为线程池。用户发送请求过来之后，需要有一个对应的线程来处理这个请求，这个时候线程对象就会直接从线程池中拿，效率比较高。</span><br><span class="line">      - 所有的WEB服务器，或者应用服务器，都是支持多线程的，都有线程池机制。</span><br><span class="line">  - redis</span><br><span class="line">    - NoSQL数据库。非关系型数据库。缓存数据库。</span><br><span class="line">  - 向ServletContext应用域中存储数据，也等于是将数据存放到缓存cache当中了。</span><br><span class="line"></span><br><span class="line">## HTTP协议</span><br><span class="line"></span><br><span class="line">- 什么是协议？</span><br><span class="line"></span><br><span class="line">  - 协议实际上是某些人，或者某些组织提前制定好的一套规范，大家都按照这个规范来，这样可以做到沟通无障碍。</span><br><span class="line">  - 协议就是一套规范，就是一套标准。由其他人或其他组织来负责制定的。</span><br><span class="line">  - 我说的话你能听懂，你说的话，我也能听懂，这说明我们之间是有一套规范的，一套协议的，这套协议就是：中国普通话协议。我们都遵守这套协议，我们之间就可以沟通无障碍。</span><br><span class="line"></span><br><span class="line">- 什么是HTTP协议？</span><br><span class="line"></span><br><span class="line">  - HTTP协议：是W3C制定的一种超文本传输协议。（通信协议：发送消息的模板提前被制定好。）</span><br><span class="line">  - W3C：</span><br><span class="line">    - 万维网联盟组织</span><br><span class="line">    - 负责制定标准的：HTTP HTML4.0 HTML5 XML DOM等规范都是W3C制定的。</span><br><span class="line">    - 万维网之父：蒂姆·伯纳斯·李</span><br><span class="line">  - 什么是超文本？</span><br><span class="line">    - 超文本说的就是：不是普通文本，比如流媒体：声音、视频、图片等。</span><br><span class="line">    - HTTP协议支持：不但可以传送普通字符串，同样支持传递声音、视频、图片等流媒体信息。</span><br><span class="line">  - 这种协议游走在B和S之间。B向S发数据要遵循HTTP协议。S向B发数据同样需要遵循HTTP协议。这样B和S才能解耦合。</span><br><span class="line">  - 什么是解耦合？</span><br><span class="line">    - B不依赖S。</span><br><span class="line">    - S也不依赖B。</span><br><span class="line">  - B/S表示：B/S结构的系统（浏览器访问WEB服务器的系统）</span><br><span class="line">  - 浏览器   向   WEB服务器发送数据，叫做：请求（request)</span><br><span class="line">  - WEB服务器   向   浏览器发送数据，叫做：响应（response）</span><br><span class="line">  - HTTP协议包括：</span><br><span class="line">    - 请求协议</span><br><span class="line">      - 浏览器  向   WEB服务器发送数据的时候，这个发送的数据需要遵循一套标准，这套标准中规定了发送的数据具体格式。</span><br><span class="line">    - 响应协议</span><br><span class="line">      - WEB服务器  向  浏览器发送数据的时候，这个发送的数据需要遵循一套标准，这套标准中规定了发送的数据具体格式。</span><br><span class="line">  - HTTP协议就是提前制定好的一种消息模板。</span><br><span class="line">    - 不管你是哪个品牌的浏览器，都是这么发。</span><br><span class="line">    - 不管你是哪个品牌的WEB服务器，都是这么发。</span><br><span class="line">    - FF浏览器  可以向 Tomcat发送请求，也可以向Jetty服务器发送请求。浏览器不依赖具体的服务器品牌。</span><br><span class="line">    - WEB服务器也不依赖具体的浏览器品牌。可以是FF浏览器，也可以是Chrome浏览器，可以是IE，都行。</span><br><span class="line"></span><br><span class="line">- HTTP的请求协议（B --&gt; S）</span><br><span class="line"></span><br><span class="line">  - HTTP的请求协议包括：4部分</span><br><span class="line"></span><br><span class="line">    - 请求行</span><br><span class="line">    - 请求头</span><br><span class="line">    - 空白行</span><br><span class="line">    - 请求体</span><br><span class="line"></span><br><span class="line">  - HTTP请求协议的具体报文：GET请求</span><br><span class="line"></span><br><span class="line">    - ```</span><br><span class="line">      GET /servlet05/getServlet?username=lucy&amp;userpwd=1111 HTTP/1.1                           请求行</span><br><span class="line">      Host: localhost:8080                                                                    请求头</span><br><span class="line">      Connection: keep-alive</span><br><span class="line">      sec-ch-ua: &quot;Google Chrome&quot;;v=&quot;95&quot;, &quot;Chromium&quot;;v=&quot;95&quot;, &quot;;Not A Brand&quot;;v=&quot;99&quot;</span><br><span class="line">      sec-ch-ua-mobile: ?0</span><br><span class="line">      sec-ch-ua-platform: &quot;Windows&quot;</span><br><span class="line">      Upgrade-Insecure-Requests: 1</span><br><span class="line">      User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Safari/537.36</span><br><span class="line">      Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">      Sec-Fetch-Site: same-origin</span><br><span class="line">      Sec-Fetch-Mode: navigate</span><br><span class="line">      Sec-Fetch-User: ?1</span><br><span class="line">      Sec-Fetch-Dest: document</span><br><span class="line">      Referer: http://localhost:8080/servlet05/index.html</span><br><span class="line">      Accept-Encoding: gzip, deflate, br</span><br><span class="line">      Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">                                                                                              空白行</span><br><span class="line">                                                                                              请求体</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li><p>HTTP请求协议的具体报文：POST请求</p>
<ul>
<li>&#96;&#96;&#96;<br>POST &#x2F;servlet05&#x2F;postServlet HTTP&#x2F;1.1                                                  请求行<br>Host: localhost:8080                                                                  请求头<br>Connection: keep-alive<br>Content-Length: 25<br>Cache-Control: max-age&#x3D;0<br>sec-ch-ua: “Google Chrome”;v&#x3D;”95”, “Chromium”;v&#x3D;”95”, “;Not A Brand”;v&#x3D;”99”<br>sec-ch-ua-mobile: ?0<br>sec-ch-ua-platform: “Windows”<br>Upgrade-Insecure-Requests: 1<br>Origin: <a href="http://localhost:8080/">http://localhost:8080</a><br>Content-Type: application&#x2F;x-www-form-urlencoded<br>User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;95.0.4638.54 Safari&#x2F;537.36<br>Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,<em>&#x2F;</em>;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9<br>Sec-Fetch-Site: same-origin<br>Sec-Fetch-Mode: navigate<br>Sec-Fetch-User: ?1<br>Sec-Fetch-Dest: document<br>Referer: <a href="http://localhost:8080/servlet05/index.html">http://localhost:8080/servlet05/index.html</a><br>Accept-Encoding: gzip, deflate, br<br>Accept-Language: zh-CN,zh;q&#x3D;0.9<br>                                                                                  空白行<br>username&#x3D;lisi&amp;userpwd&#x3D;123                                                             请求体<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 请求行</span><br><span class="line"></span><br><span class="line">    - 包括三部分：</span><br><span class="line">      - 第一部分：请求方式（7种）</span><br><span class="line">        - get（常用的）</span><br><span class="line">        - post（常用的）</span><br><span class="line">        - delete</span><br><span class="line">        - put</span><br><span class="line">        - head</span><br><span class="line">        - options</span><br><span class="line">        - trace</span><br><span class="line">      - 第二部分：URI</span><br><span class="line">        - 什么是URI？ 统一资源标识符。代表网络中某个资源的名字。但是通过URI是无法定位资源的。</span><br><span class="line">        - 什么是URL？统一资源定位符。代表网络中某个资源，同时，通过URL是可以定位到该资源的。</span><br><span class="line">        - URI和URL什么关系，有什么区别？</span><br><span class="line">          - URL包括URI</span><br><span class="line">          - http://localhost:8080/servlet05/index.html 这是URL。</span><br><span class="line">          - /servlet05/index.html 这是URI。</span><br><span class="line">      - 第三部分：HTTP协议版本号</span><br><span class="line"></span><br><span class="line">  - 请求头</span><br><span class="line"></span><br><span class="line">    - 请求的主机</span><br><span class="line">    - 主机的端口</span><br><span class="line">    - 浏览器信息</span><br><span class="line">    - 平台信息</span><br><span class="line">    - cookie等信息</span><br><span class="line">    - ....</span><br><span class="line"></span><br><span class="line">  - 空白行</span><br><span class="line"></span><br><span class="line">    - 空白行是用来区分“请求头”和“请求体”</span><br><span class="line"></span><br><span class="line">  - 请求体</span><br><span class="line"></span><br><span class="line">    - 向服务器发送的具体数据。</span><br><span class="line"></span><br><span class="line">- HTTP的响应协议（S --&gt; B）</span><br><span class="line"></span><br><span class="line">  - HTTP的响应协议包括：4部分</span><br><span class="line"></span><br><span class="line">    - 状态行</span><br><span class="line">    - 响应头</span><br><span class="line">    - 空白行</span><br><span class="line">    - 响应体</span><br><span class="line"></span><br><span class="line">  - HTTP响应协议的具体报文：</span><br><span class="line"></span><br><span class="line">    - ```</span><br><span class="line">      HTTP/1.1 200 ok                                     状态行</span><br><span class="line">      Content-Type: text/html;charset=UTF-8               响应头</span><br><span class="line">      Content-Length: 160</span><br><span class="line">      Date: Mon, 08 Nov 2021 13:19:32 GMT</span><br><span class="line">      Keep-Alive: timeout=20</span><br><span class="line">      Connection: keep-alive</span><br><span class="line">                                                          空白行</span><br><span class="line">      &lt;!doctype html&gt;                                     响应体</span><br><span class="line">      &lt;html&gt;</span><br><span class="line">          &lt;head&gt;</span><br><span class="line">              &lt;title&gt;from get servlet&lt;/title&gt;</span><br><span class="line">          &lt;/head&gt;</span><br><span class="line">          &lt;body&gt;</span><br><span class="line">              &lt;h1&gt;from get servlet&lt;/h1&gt;</span><br><span class="line">          &lt;/body&gt;</span><br><span class="line">      &lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>状态行</p>
<ul>
<li>三部分组成<ul>
<li>第一部分：协议版本号（HTTP&#x2F;1.1）</li>
<li>第二部分：状态码（HTTP协议中规定的响应状态号。不同的响应结果对应不同的号码。）<ul>
<li>200 表示请求响应成功，正常结束。</li>
<li>404表示访问的资源不存在，通常是因为要么是你路径写错了，要么是路径写对了，但是服务器中对应的资源并没有启动成功。总之404错误是前端错误。</li>
<li>405表示前端发送的请求方式与后端请求的处理方式不一致时发生：<ul>
<li>比如：前端是POST请求，后端的处理方式按照get方式进行处理时，发生405</li>
<li>比如：前端是GET请求，后端的处理方式按照post方式进行处理时，发生405</li>
</ul>
</li>
<li>500表示服务器端的程序出现了异常。一般会认为是服务器端的错误导致的。</li>
<li>以4开始的，一般是浏览器端的错误导致的。</li>
<li>以5开始的，一般是服务器端的错误导致的。</li>
</ul>
</li>
<li>第三部分：状态的描述信息<ul>
<li>ok 表示正常成功结束。</li>
<li>not found 表示资源找不到。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>响应头：</p>
<ul>
<li>响应的内容类型</li>
<li>响应的内容长度</li>
<li>响应的时间</li>
<li>….</li>
</ul>
</li>
<li><p>空白行：</p>
<ul>
<li>用来分隔“响应头”和“响应体”的。</li>
</ul>
</li>
<li><p>响应体：</p>
<ul>
<li>响应体就是响应的正文，这些内容是一个长的字符串，这个字符串被浏览器渲染，解释并执行，最终展示出效果。</li>
</ul>
</li>
</ul>
</li>
<li><p>怎么查看的协议内容？</p>
<ul>
<li>使用chrome浏览器：F12。然后找到network，通过这个面板可以查看协议的具体内容。</li>
</ul>
</li>
<li><p>怎么向服务器发送GET请求，怎么向服务器发送POST请求？</p>
<ul>
<li>到目前为止，只有一种情况可以发送POST请求：使用form表单，并且form标签中的method属性值为：method&#x3D;”post”。</li>
<li>其他所有情况一律都是get请求：<ul>
<li>在浏览器地址栏上直接输入URL，敲回车，属于get请求。</li>
<li>在浏览器上直接点击超链接，属于get请求。</li>
<li>使用form表单提交数据时，form标签中没有写method属性，默认就是get</li>
<li>或者使用form的时候，form标签中method属性值为：method&#x3D;”get”</li>
<li>….</li>
</ul>
</li>
</ul>
</li>
<li><p>GET请求和POST请求有什么区别？</p>
<ul>
<li>get请求发送数据的时候，数据会挂在URI的后面，并且在URI后面添加一个“?”，”?”后面是数据。这样会导致发送的数据回显在浏览器的地址栏上。（get请求在“请求行”上发送数据）<ul>
<li><a href="http://localhost:8080/servlet05/getServlet?username=zhangsan&amp;userpwd=1111">http://localhost:8080/servlet05/getServlet?username=zhangsan&amp;userpwd=1111</a></li>
</ul>
</li>
<li>post请求发送数据的时候，在请求体当中发送。不会回显到浏览器的地址栏上。也就是说post发送的数据，在浏览器地址栏上看不到。（post在“请求体”当中发送数据）</li>
<li>get请求只能发送普通的字符串。并且发送的字符串长度有限制，不同的浏览器限制不同。这个没有明确的规范。</li>
<li>get请求无法发送大数据量。</li>
<li>post请求可以发送任何类型的数据，包括普通字符串，流媒体等信息：视频、声音、图片。</li>
<li>post请求可以发送大数据量，理论上没有长度限制。</li>
<li>get请求在W3C中是这样说的：get请求比较适合从服务器端获取数据。</li>
<li>post请求在W3C中是这样说的：post请求比较适合向服务器端传送数据。</li>
<li>get请求是安全的。get请求是绝对安全的。为什么？因为get请求只是为了从服务器上获取数据。不会对服务器造成威胁。（get本身是安全的，你不要用错了。用错了之后又冤枉人家get不安全，你这样不好（太坏了），那是你自己的问题，不是get请求的问题。）</li>
<li>post请求是危险的。为什么？因为post请求是向服务器提交数据，如果这些数据通过后门的方式进入到服务器当中，服务器是很危险的。另外post是为了提交数据，所以一般情况下拦截请求的时候，大部分会选择拦截（监听）post请求。</li>
<li>get请求支持缓存。<ul>
<li><a href="https://n.sinaimg.cn/finance/590/w240h350/20211101/b40c-b425eb67cabc342ff5b9dc018b4b00cc.jpg">https://n.sinaimg.cn/finance/590/w240h350/20211101/b40c-b425eb67cabc342ff5b9dc018b4b00cc.jpg</a></li>
<li>任何一个get请求最终的“响应结果”都会被浏览器缓存起来。在浏览器缓存当中：<ul>
<li>一个get请求的路径a  对应  一个资源。</li>
<li>一个get请求的路径b  对应  一个资源。</li>
<li>一个get请求的路径c  对应  一个资源。</li>
<li>……</li>
</ul>
</li>
<li>实际上，你只要发送get请求，浏览器做的第一件事都是先从本地浏览器缓存中找，找不到的时候才会去服务器上获取。这种缓存机制目的是为了提高用户的体验。</li>
<li>有没有这样一个需求：我们不希望get请求走缓存，怎么办？怎么避免走缓存？我希望每一次这个get请求都去服务器上找资源，我不想从本地浏览器的缓存中取。<ul>
<li>只要每一次get请求的请求路径不同即可。</li>
<li><a href="https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=789789787897898">https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=789789787897898</a></li>
<li><a href="https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=789789787897899">https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=789789787897899</a></li>
<li><a href="https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=%E7%B3%BB%E7%BB%9F%E6%AF%AB%E7%A7%92%E6%95%B0">https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=系统毫秒数</a></li>
<li>怎么解决？可以在路径的后面添加一个每时每刻都在变化的“时间戳”，这样，每一次的请求路径都不一样，浏览器就不走缓存了。</li>
</ul>
</li>
</ul>
</li>
<li>post请求不支持缓存。（POST是用来修改服务器端的资源的。）<ul>
<li>post请求之后，服务器“响应的结果”不会被浏览器缓存起来。因为这个缓存没有意义。</li>
</ul>
</li>
</ul>
</li>
<li><p>GET请求和POST请求如何选择，什么时候使用GET请求，什么时候使用POST请求？</p>
<ul>
<li>怎么选择GET请求和POST请求呢？衡量标准是什么呢？你这个请求是想获取服务器端的数据，还是想向服务器发送数据。如果你是想从服务器上获取资源，建议使用GET请求，如果你这个请求是为了向服务器提交数据，建议使用POST请求。</li>
<li>大部分的form表单提交，都是post方式，因为form表单中要填写大量的数据，这些数据是收集用户的信息，一般是需要传给服务器，服务器将这些数据保存&#x2F;修改等。</li>
<li>如果表单中有敏感信息，还是建议适用post请求，因为get请求会回显敏感信息到浏览器地址栏上。（例如：密码信息）</li>
<li>做文件上传，一定是post请求。要传的数据不是普通文本。</li>
<li>其他情况都可以使用get请求。</li>
</ul>
</li>
<li><p>不管你是get请求还是post请求，发送的请求数据格式是完全相同的，只不过位置不同，格式都是统一的：</p>
<ul>
<li>name&#x3D;value&amp;name&#x3D;value&amp;name&#x3D;value&amp;name&#x3D;value</li>
<li>name是什么？<ul>
<li>以form表单为例：form表单中input标签的name。</li>
</ul>
</li>
<li>value是什么？<ul>
<li>以form表单为例：form表单中input标签的value。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h2><ul>
<li>什么是设计模式？<ul>
<li>某个问题的固定的解决方案。(可以被重复使用。)</li>
</ul>
</li>
<li>你知道哪些设计模式？<ul>
<li>GoF设计模式：<ul>
<li>通常我们所说的23种设计模式。（Gang of Four：4人组提出的设计模式）</li>
<li>单例模式</li>
<li>工厂模式</li>
<li>代理模式</li>
<li>门面模式</li>
<li>责任链设计模式</li>
<li>观察者模式</li>
<li>模板方法设计模式</li>
<li>…..</li>
</ul>
</li>
<li>JavaEE设计模式：<ul>
<li>DAO</li>
<li>DTO</li>
<li>VO</li>
<li>PO</li>
<li>pojo</li>
<li>….</li>
</ul>
</li>
<li>….</li>
</ul>
</li>
<li>什么是模板方法设计模式？<ul>
<li>在模板类的模板方法当中定义核心算法骨架，具体的实现步骤可以延迟到子类当中完成。</li>
</ul>
</li>
<li>模板类通常是一个抽象类，模板类当中的模板方法定义核心算法，这个方法通常是final的（但也可以不是final的）</li>
<li>模板类当中的抽象方法就是不确定实现的方法，这个不确定怎么实现的事儿交给子类去做。</li>
</ul>
<h2 id="HttpServlet源码分析"><a href="#HttpServlet源码分析" class="headerlink" title="HttpServlet源码分析"></a>HttpServlet源码分析</h2><ul>
<li>HttpServlet类是专门为HTTP协议准备的。比GenericServlet更加适合HTTP协议下的开发。</li>
<li>HttpServlet在哪个包下？<ul>
<li>jakarta.servlet.http.HttpServlet</li>
</ul>
</li>
<li>到目前为止我们接触了servlet规范中哪些接口？<ul>
<li>jakarta.servlet.Servlet  核心接口（接口）</li>
<li>jakarta.servlet.ServletConfig Servlet配置信息接口（接口）</li>
<li>jakarta.servlet.ServletContext Servlet上下文接口（接口）</li>
<li>jakarta.servlet.ServletRequest Servlet请求接口（接口）</li>
<li>jakarta.servlet.ServletResponse Servlet响应接口（接口）</li>
<li>jakarta.servlet.ServletException Servlet异常（类）</li>
<li>jakarta.servlet.GenericServlet 标准通用的Servlet类（抽象类）</li>
</ul>
</li>
<li>http包下都有哪些类和接口呢？jakarta.servlet.http.*;<ul>
<li>jakarta.servlet.http.HttpServlet （HTTP协议专用的Servlet类，抽象类）</li>
<li>jakarta.servlet.http.HttpServletRequest （HTTP协议专用的请求对象）</li>
<li>jakarta.servlet.http.HttpServletResponse （HTTP协议专用的响应对象）</li>
</ul>
</li>
<li>HttpServletRequest对象中封装了什么信息？<ul>
<li>HttpServletRequest，简称request对象。</li>
<li>HttpServletRequest中封装了请求协议的全部内容。</li>
<li>Tomcat服务器（WEB服务器）将“请求协议”中的数据全部解析出来，然后将这些数据全部封装到request对象当中了。</li>
<li>也就是说，我们只要面向HttpServletRequest，就可以获取请求协议中的数据。</li>
</ul>
</li>
<li>HttpServletResponse对象是专门用来响应HTTP协议到浏览器的。</li>
<li>回忆Servlet生命周期？<ul>
<li>用户第一次请求<ul>
<li>Tomcat服务器通过反射机制，调用无参数构造方法。创建Servlet对象。(web.xml文件中配置的Servlet类对应的对象。)</li>
<li>Tomcat服务器调用Servlet对象的init方法完成初始化。</li>
<li>Tomcat服务器调用Servlet对象的service方法处理请求。</li>
</ul>
</li>
<li>用户第二次请求<ul>
<li>Tomcat服务器调用Servlet对象的service方法处理请求。</li>
</ul>
</li>
<li>用户第三次请求<ul>
<li>Tomcat服务器调用Servlet对象的service方法处理请求。</li>
</ul>
</li>
<li>….<ul>
<li>Tomcat服务器调用Servlet对象的service方法处理请求。</li>
</ul>
</li>
<li>服务器关闭<ul>
<li>Tomcat服务器调用Servlet对象的destroy方法，做销毁之前的准备工作。</li>
<li>Tomcat服务器销毁Servlet对象。</li>
</ul>
</li>
</ul>
</li>
<li>HttpServlet源码分析：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">	<span class="comment">// 用户第一次请求，创建HelloServlet对象的时候，会执行这个无参数构造方法。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">HelloServlet</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//override 重写 doGet方法</span></span><br><span class="line">    <span class="comment">//override 重写 doPost方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GenericServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>, ServletConfig,</span><br><span class="line">        java.io.Serializable &#123;</span><br><span class="line">           </span><br><span class="line">	<span class="comment">// 用户第一次请求的时候，HelloServlet对象第一次被创建之后，这个init方法会执行。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="built_in">this</span>.config = config;</span><br><span class="line">        <span class="built_in">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 用户第一次请求的时候，带有参数的init(ServletConfig config)执行之后，会执行这个没有参数的init()</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// NOOP by default</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HttpServlet模板类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HttpServlet</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 用户发送第一次请求的时候这个service会执行</span></span><br><span class="line">    <span class="comment">// 用户发送第N次请求的时候，这个service方法还是会执行。</span></span><br><span class="line">    <span class="comment">// 用户只要发送一次请求，这个service方法就会执行一次。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        HttpServletRequest  request;</span><br><span class="line">        HttpServletResponse response;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将ServletRequest和ServletResponse向下转型为带有Http的HttpServletRequest和HttpServletResponse</span></span><br><span class="line">            request = (HttpServletRequest) req;</span><br><span class="line">            response = (HttpServletResponse) res;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(lStrings.getString(<span class="string">&quot;http.non_http&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用重载的service方法。</span></span><br><span class="line">        service(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个service方法的两个参数都是带有Http的。</span></span><br><span class="line">    <span class="comment">// 这个service是一个模板方法。</span></span><br><span class="line">    <span class="comment">// 在该方法中定义核心算法骨架，具体的实现步骤延迟到子类中去完成。</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取请求方式</span></span><br><span class="line">        <span class="comment">// 这个请求方式最终可能是：&quot;&quot;</span></span><br><span class="line">        <span class="comment">// 注意：request.getMethod()方法获取的是请求方式，可能是七种之一：</span></span><br><span class="line">        <span class="comment">// GET POST PUT DELETE HEAD OPTIONS TRACE</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果请求方式是GET请求，则执行doGet方法。</span></span><br><span class="line">        <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// servlet doesn&#x27;t support if-modified-since, no reason</span></span><br><span class="line">                <span class="comment">// to go through further expensive logic</span></span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">long</span> ifModifiedSince;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException iae) &#123;</span><br><span class="line">                    <span class="comment">// Invalid date header - proceed as if none was set</span></span><br><span class="line">                    ifModifiedSince = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ifModifiedSince &lt; (lastModified / <span class="number">1000</span> * <span class="number">1000</span>)) &#123;</span><br><span class="line">                    <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                    <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                    <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">                    maybeSetLastModified(resp, lastModified);</span><br><span class="line">                    doGet(req, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">            maybeSetLastModified(resp, lastModified);</span><br><span class="line">            doHead(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">            <span class="comment">// 如果请求方式是POST请求，则执行doPost方法。</span></span><br><span class="line">            doPost(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">            doPut(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">            doDelete(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">            doOptions(req,resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">            doTrace(req,resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Note that this means NO servlet supports whatever</span></span><br><span class="line">            <span class="comment">// method was requested, anywhere on this server.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">            errArgs[<span class="number">0</span>] = method;</span><br><span class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line"></span><br><span class="line">            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException&#123;</span><br><span class="line">        <span class="comment">// 报405错误</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_get_not_supported&quot;</span>);</span><br><span class="line">        sendMethodNotAllowed(req, resp, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 报405错误</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_post_not_supported&quot;</span>);</span><br><span class="line">        sendMethodNotAllowed(req, resp, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过以上源代码分析：</span></span><br><span class="line"><span class="comment">	假设前端发送的请求是get请求，后端程序员重写的方法是doPost</span></span><br><span class="line"><span class="comment">	假设前端发送的请求是post请求，后端程序员重写的方法是doGet</span></span><br><span class="line"><span class="comment">	会发生什么呢？</span></span><br><span class="line"><span class="comment">		发生405这样的一个错误。</span></span><br><span class="line"><span class="comment">		405表示前端的错误，发送的请求方式不对。和服务器不一致。不是服务器需要的请求方式。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	通过以上源代码可以知道：只要HttpServlet类中的doGet方法或doPost方法执行了，必然405.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">怎么避免405的错误呢？</span></span><br><span class="line"><span class="comment">	后端重写了doGet方法，前端一定要发get请求。</span></span><br><span class="line"><span class="comment">	后端重写了doPost方法，前端一定要发post请求。</span></span><br><span class="line"><span class="comment">	这样可以避免405错误。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	这种前端到底需要发什么样的请求，其实应该后端说了算。后端让发什么方式，前端就得发什么方式。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">有的人，你会看到为了避免405错误，在Servlet类当中，将doGet和doPost方法都进行了重写。</span></span><br><span class="line"><span class="comment">这样，确实可以避免405的发生，但是不建议，405错误还是有用的。该报错的时候就应该让他报错。</span></span><br><span class="line"><span class="comment">如果你要是同时重写了doGet和doPost，那还不如你直接重写service方法好了。这样代码还能</span></span><br><span class="line"><span class="comment">少写一点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们编写的HelloServlet直接继承HttpServlet，直接重写HttpServlet类中的service()方法行吗？</p>
<ul>
<li>可以，只不过你享受不到405错误。享受不到HTTP协议专属的东西。</li>
</ul>
</li>
<li><p>到今天我们终于得到了最终的一个Servlet类的开发步骤：</p>
<ul>
<li>第一步：编写一个Servlet类，直接继承HttpServlet</li>
<li>第二步：重写doGet方法或者重写doPost方法，到底重写谁，javaweb程序员说了算。</li>
<li>第三步：将Servlet类配置到web.xml文件当中。</li>
<li>第四步：准备前端的页面（form表单），form表单中指定请求路径即可。</li>
</ul>
</li>
</ul>
<h2 id="关于一个web站点的欢迎页面"><a href="#关于一个web站点的欢迎页面" class="headerlink" title="关于一个web站点的欢迎页面"></a>关于一个web站点的欢迎页面</h2><ul>
<li><p>什么是一个web站点的欢迎页面？</p>
<ul>
<li>对于一个webapp来说，我们是可以设置它的欢迎页面的。</li>
<li>设置了欢迎页面之后，当你访问这个webapp的时候，或者访问这个web站点的时候，没有指定任何“资源路径”，这个时候会默认访问你的欢迎页面。</li>
<li>我们一般的访问方式是：<ul>
<li><a href="http://localhost:8080/servlet06/login.html">http://localhost:8080/servlet06/login.html</a> 这种方式是指定了要访问的就是login.html资源。</li>
</ul>
</li>
<li>如果我们访问的方式是：<ul>
<li><a href="http://localhost:8080/servlet06">http://localhost:8080/servlet06</a> 如果我们访问的就是这个站点，没有指定具体的资源路径。它默认会访问谁呢？</li>
<li>默认会访问你设置的欢迎页面。</li>
</ul>
</li>
</ul>
</li>
<li><p>怎么设置欢迎页面呢？</p>
<ul>
<li><p>第一步：我在IDEA工具的web目录下新建了一个文件login.html</p>
</li>
<li><p>第二步：在web.xml文件中进行了以下的配置</p>
<ul>
<li><pre><code class="xml">&lt;welcome-file-list&gt;
        &lt;welcome-file&gt;login.html&lt;/welcome-file&gt;
    &lt;/welcome-file-list&gt;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 注意：设置欢迎页面的时候，这个路径不需要以“/”开始。并且这个路径默认是从webapp的根下开始查找。</span><br><span class="line"></span><br><span class="line">  - 第三步：启动服务器，浏览器地址栏输入地址</span><br><span class="line"></span><br><span class="line">    - http://localhost:8080/servlet07</span><br><span class="line"></span><br><span class="line">- 如果在webapp的根下新建一个目录，目录中再给一个文件，那么这个欢迎页该如何设置呢？</span><br><span class="line"></span><br><span class="line">  - 在webapp根下新建page1</span><br><span class="line"></span><br><span class="line">  - 在page1下新建page2目录</span><br><span class="line"></span><br><span class="line">  - 在page2目录下新建page.html页面</span><br><span class="line"></span><br><span class="line">  - 在web.xml文件中应该这样配置</span><br><span class="line"></span><br><span class="line">    - ```</span><br><span class="line">      &lt;welcome-file-list&gt;</span><br><span class="line">          &lt;welcome-file&gt;page1/page2/page.html&lt;/welcome-file&gt;</span><br><span class="line">      &lt;/welcome-file-list&gt;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>注意：路径不需要以“&#x2F;”开始，并且路径默认从webapp的根下开始找。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>一个webapp是可以设置多个欢迎页面的</p>
<ul>
<li>&#96;&#96;&#96;xml<welcome-file-list>
    <welcome-file>page1/page2/page.html</welcome-file>
    <welcome-file>login.html</welcome-file>
</welcome-file-list>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 注意：越靠上的优先级越高。找不到的继续向下找。</span><br><span class="line"></span><br><span class="line">- 你有没有注意一件事：当我的文件名设置为index.html的时候，不需要在web.xml文件中进行配置欢迎页面。这是为什么？</span><br><span class="line"></span><br><span class="line">  - 这是因为小猫咪Tomcat服务器已经提前配置好了。</span><br><span class="line"></span><br><span class="line">  - 实际上配置欢迎页面有两个地方可以配置：</span><br><span class="line"></span><br><span class="line">    - 一个是在webapp内部的web.xml文件中。（在这个地方配置的属于局部配置）</span><br><span class="line"></span><br><span class="line">    - 一个是在CATALINA_HOME/conf/web.xml文件中进行配置。（在这个地方配置的属于全局配置）</span><br><span class="line"></span><br><span class="line">      - ```xml</span><br><span class="line">        &lt;welcome-file-list&gt;</span><br><span class="line">            &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;</span><br><span class="line">            &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;</span><br><span class="line">            &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;</span><br><span class="line">        &lt;/welcome-file-list&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Tomcat服务器的全局欢迎页面是：index.html index.htm index.jsp。如果你一个web站点没有设置局部的欢迎页面，Tomcat服务器就会以index.html index.htm index.jsp作为一个web站点的欢迎页面。</p>
</li>
<li><p>注意原则：局部优先原则。（就近原则）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>欢迎页可以是一个Servlet吗？</p>
<ul>
<li><p>当然可以。</p>
</li>
<li><p>你不要多想，欢迎页就是一个资源，既然是一个资源，那么可以是静态资源，也可以是动态资源。</p>
</li>
<li><p>静态资源：index.html welcome.html …..</p>
</li>
<li><p>动态资源：Servlet类。</p>
</li>
<li><p>步骤：</p>
<ul>
<li><p>第一步：写一个Servlet</p>
<ul>
<li>&#96;&#96;&#96;java<br>public class WelcomeServlet extends HttpServlet {<br>@Override<br>protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {<br>    response.setContentType(“text&#x2F;html”);<br>    PrintWriter out &#x3D; response.getWriter();<br>    out.print(“<h1>welcome to bjpowernode!</h1>“);<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- 第二步：在web.xml文件中配置servlet</span><br><span class="line"></span><br><span class="line">  - ```xml</span><br><span class="line">        &lt;servlet&gt;</span><br><span class="line">            &lt;servlet-name&gt;welcomeServlet&lt;/servlet-name&gt;</span><br><span class="line">            &lt;servlet-class&gt;com.bjpowernode.javaweb.servlet.WelcomeServlet&lt;/servlet-class&gt;</span><br><span class="line">        &lt;/servlet&gt;</span><br><span class="line">        &lt;servlet-mapping&gt;</span><br><span class="line">            &lt;servlet-name&gt;welcomeServlet&lt;/servlet-name&gt;</span><br><span class="line">            &lt;url-pattern&gt;/fdsa/fds/a/fds/af/ds/af/dsafdsafdsa&lt;/url-pattern&gt;</span><br><span class="line">        &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>第三步：在web.xml文件中配置欢迎页</p>
<ul>
<li>&#96;&#96;&#96;xml<br><welcome-file-list><br>    <welcome-file>fdsa&#x2F;fds&#x2F;a&#x2F;fds&#x2F;af&#x2F;ds&#x2F;af&#x2F;dsafdsafdsa</welcome-file><br></welcome-file-list><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">## 关于WEB-INF目录</span><br><span class="line"></span><br><span class="line">- 在WEB-INF目录下新建了一个文件：welcome.html</span><br><span class="line">- 打开浏览器访问：http://localhost:8080/servlet07/WEB-INF/welcome.html 出现了404错误。</span><br><span class="line">- 注意：放在WEB-INF目录下的资源是受保护的。在浏览器上不能够通过路径直接访问。所以像HTML、CSS、JS、image等静态资源一定要放到WEB-INF目录之外。</span><br><span class="line"></span><br><span class="line">## HttpServletRequest接口详解</span><br><span class="line"></span><br><span class="line">- HttpServletRequest是一个接口，全限定名称：jakarta.servlet.http.HttpServletRequest</span><br><span class="line"></span><br><span class="line">- HttpServletRequest接口是Servlet规范中的一员。</span><br><span class="line"></span><br><span class="line">- HttpServletRequest接口的父接口：ServletRequest</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public interface HttpServletRequest extends ServletRequest &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>HttpServletRequest接口的实现类谁写的? HttpServletRequest对象是谁给创建的？</p>
<ul>
<li><p>通过测试：org.apache.catalina.connector.RequestFacade 实现了 HttpServletRequest接口</p>
<ul>
<li><pre><code class="java">public class RequestFacade implements HttpServletRequest &#123;&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 测试结果说明：Tomcat服务器（WEB服务器、WEB容器）实现了HttpServletRequest接口，还是说明了Tomcat服务器实现了Servlet规范。而对于我们javaweb程序员来说，实际上不需要关心这个，我们只需要面向接口编程即可。我们关心的是HttpServletRequest接口中有哪些方法，这些方法可以完成什么功能！！！！</span><br><span class="line"></span><br><span class="line">- HttpServletRequest对象中都有什么信息？都包装了什么信息？</span><br><span class="line"></span><br><span class="line">  - HttpServletRequest对象是Tomcat服务器负责创建的。这个对象中封装了什么信息？封装了HTTP的请求协议。</span><br><span class="line">  - 实际上是用户发送请求的时候，遵循了HTTP协议，发送的是HTTP的请求协议，Tomcat服务器将HTTP协议中的信息以及数据全部解析出来，然后Tomcat服务器把这些信息封装到HttpServletRequest对象当中，传给了我们javaweb程序员。</span><br><span class="line">  - javaweb程序员面向HttpServletRequest接口编程，调用方法就可以获取到请求的信息了。</span><br><span class="line"></span><br><span class="line">- request和response对象的生命周期？</span><br><span class="line"></span><br><span class="line">  - request对象和response对象，一个是请求对象，一个是响应对象。这两个对象只在当前请求中有效。</span><br><span class="line">  - 一次请求对应一个request。</span><br><span class="line">  - 两次请求则对应两个request。</span><br><span class="line">  - .....</span><br><span class="line"></span><br><span class="line">- HttpServletRequest接口中有哪些常用的方法？</span><br><span class="line"></span><br><span class="line">  - 怎么获取前端浏览器用户提交的数据？</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      Map&lt;String,String[]&gt; getParameterMap() 这个是获取Map</span><br><span class="line">      Enumeration&lt;String&gt; getParameterNames() 这个是获取Map集合中所有的key</span><br><span class="line">      String[] getParameterValues(String name) 根据key获取Map集合的value</span><br><span class="line">      String getParameter(String name)  获取value这个一维数组当中的第一个元素。这个方法最常用。</span><br><span class="line">      // 以上的4个方法，和获取用户提交的数据有关系。</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>思考：如果是你，前端的form表单提交了数据之后，你准备怎么存储这些数据，你准备采用什么样的数据结构去存储这些数据呢？</p>
<ul>
<li><p>前端提交的数据格式：username&#x3D;abc&amp;userpwd&#x3D;111&amp;aihao&#x3D;s&amp;aihao&#x3D;d&amp;aihao&#x3D;tt</p>
</li>
<li><p>我会采用Map集合来存储：</p>
<ul>
<li>&#96;&#96;&#96;java<br>Map&lt;String,String&gt;<br>key存储String<br>value存储String<br>这种想法对吗？不对。<br>如果采用以上的数据结构存储会发现key重复的时候value覆盖。<br>key         value<br>———————<br>username    abc<br>userpwd     111<br>aihao       s<br>aihao       d<br>aihao       tt<br>这样是不行的，因为map的key不能重复。<br>Map&lt;String, String[]&gt;<br>key存储String<br>value存储String[]<br>key                value<br>——————————-<br>username        {“abc”}<br>userpwd            {“111”}<br>aihao            {“s”,”d”,”tt”}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 注意：前端表单提交数据的时候，假设提交了120这样的“数字”，其实是以字符串&quot;120&quot;的方式提交的，所以服务器端获取到的一定是一个字符串的&quot;120&quot;，而不是一个数字。（前端永远提交的是字符串，后端获取的也永远是字符串。）</span><br><span class="line">  </span><br><span class="line">- 手工开发一个webapp。测试HttpServletRequest接口中的相关方法。</span><br><span class="line"></span><br><span class="line">  - 先测试了4个常用的方法，获取请求参数的四个方法。</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      	Map&lt;String,String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">      	Enumeration&lt;String&gt; names = request.getParameterNames();</span><br><span class="line">      	String[] values = request.getParameterValues(&quot;name&quot;);</span><br><span class="line">      	String value = request.getParameter(&quot;name&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>request对象实际上又称为“请求域”对象。</p>
<ul>
<li><p>应用域对象是什么？</p>
<ul>
<li><p>ServletContext （Servlet上下文对象。）</p>
</li>
<li><p>什么情况下会考虑向ServletContext这个应用域当中绑定数据呢？</p>
<ul>
<li>第一：所有用户共享的数据。</li>
<li>第二：这个共享的数据量很小。</li>
<li>第三：这个共享的数据很少的修改操作。</li>
<li>在以上三个条件都满足的情况下，使用这个应用域对象，可以大大提高我们程序执行效率。</li>
<li>实际上向应用域当中绑定数据，就相当于把数据放到了缓存（Cache）当中，然后用户访问的时候直接从缓存中取，减少IO的操作，大大提升系统的性能，所以缓存技术是提高系统性能的重要手段。</li>
</ul>
</li>
<li><p>你见过哪些缓存技术呢？</p>
<ul>
<li>字符串常量池</li>
<li>整数型常量池 [-128~127]，但凡是在这个范围当中的Integer对象不再创建新对象，直接从这个整数型常量池中获取。大大提升系统性能。</li>
<li>数据库连接池（提前创建好N个连接对象，将连接对象放到集合当中，使用连接对象的时候，直接从缓存中拿。省去了连接对象的创建过程。效率提升。）</li>
<li>线程池（Tomcat服务器就是支持多线程的。所谓的线程池就是提前先创建好N个线程对象，将线程对象存储到集合中，然后用户请求过来之后，直接从线程池中获取线程对象，直接拿来用。提升系统性能）</li>
<li>后期你还会学习更多的缓存技术，例如：redis、mongoDB…..</li>
</ul>
</li>
<li><p>ServletContext当中有三个操作域的方法：</p>
<ul>
<li><p>&#96;&#96;&#96;java<br>void setAttribute(String name, Object obj); &#x2F;&#x2F; 向域当中绑定数据。<br>Object getAttribute(String name); &#x2F;&#x2F; 从域当中根据name获取数据。<br>void removeAttribute(String name); &#x2F;&#x2F; 将域当中绑定的数据移除</p>
<p>&#x2F;&#x2F; 以上的操作类似于Map集合的操作。<br>Map&lt;String, Object&gt; map;<br>map.put(“name”, obj); &#x2F;&#x2F; 向map集合中放key和value<br>Object obj &#x3D; map.get(“name”); &#x2F;&#x2F; 通过map集合的key获取value<br>map.remove(“name”); &#x2F;&#x2F; 通过Map集合的key删除key和value这个键值对。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- “请求域”对象</span><br><span class="line"></span><br><span class="line">  - “请求域”对象要比“应用域”对象范围小很多。生命周期短很多。请求域只在一次请求内有效。</span><br><span class="line"></span><br><span class="line">  - 一个请求对象request对应一个请求域对象。一次请求结束之后，这个请求域就销毁了。</span><br><span class="line"></span><br><span class="line">  - 请求域对象也有这三个方法：</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      void setAttribute(String name, Object obj); // 向域当中绑定数据。</span><br><span class="line">      Object getAttribute(String name); // 从域当中根据name获取数据。</span><br><span class="line">      void removeAttribute(String name); // 将域当中绑定的数据移除</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>请求域和应用域的选用原则？</p>
<ul>
<li>尽量使用小的域对象，因为小的域对象占用的资源较少。</li>
</ul>
</li>
</ul>
</li>
<li><p>跳转</p>
<ul>
<li><p>转发（一次请求）</p>
<ul>
<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F; 第一步：获取请求转发器对象<br>RequestDispatcher dispatcher &#x3D; request.getRequestDispatcher(“&#x2F;b”);<br>&#x2F;&#x2F; 第二步：调用转发器的forward方法完成跳转&#x2F;转发<br>dispatcher.forward(request,response);</p>
<p>&#x2F;&#x2F; 第一步和第二步代码可以联合在一起。<br>request.getRequestDispatcher(“&#x2F;b”).forward(request,response);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 两个Servlet怎么共享数据？</span><br><span class="line"></span><br><span class="line">  - 将数据放到ServletContext应用域当中，当然是可以的，但是应用域范围太大，占用资源太多。不建议使用。</span><br><span class="line">  - 可以将数据放到request域当中，然后AServlet转发到BServlet，保证AServlet和BServlet在同一次请求当中，这样就可以做到两个Servlet，或者多个Servlet共享同一份数据。</span><br><span class="line"></span><br><span class="line">- 转发的下一个资源必须是一个Servlet吗？</span><br><span class="line"></span><br><span class="line">  - 不一定，只要是Tomcat服务器当中的合法资源，都是可以转发的。例如：html....</span><br><span class="line">  - 注意：转发的时候，路径的写法要注意，转发的路径以“/”开始，不加项目名。</span><br><span class="line"></span><br><span class="line">- 关于request对象中两个非常容易混淆的方法：</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    </span><br><span class="line">    // uri?username=zhangsan&amp;userpwd=123&amp;sex=1</span><br><span class="line">    String username = request.getParameter(&quot;username&quot;);</span><br><span class="line">    </span><br><span class="line">    // 之前一定是执行过：request.setAttribute(&quot;name&quot;, new Object())</span><br><span class="line">    Object obj = request.getAttribute(&quot;name&quot;);</span><br><span class="line">    </span><br><span class="line">    // 以上两个方法的区别是什么？</span><br><span class="line">    // 第一个方法：获取的是用户在浏览器上提交的数据。</span><br><span class="line">    // 第二个方法：获取的是请求域当中绑定的数据。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>HttpServletRequest接口的其他常用方法：</p>
<ul>
<li><pre><code class="java">// 获取客户端的IP地址
String remoteAddr = request.getRemoteAddr();

// get请求在请求行上提交数据。
// post请求在请求体中提交数据。
// 设置请求体的字符集。（显然这个方法是处理POST请求的乱码问题。这种方式并不能解决get请求的乱码问题。）
// Tomcat10之后，request请求体当中的字符集默认就是UTF-8，不需要设置字符集，不会出现乱码问题。
// Tomcat9前（包括9在内），如果前端请求体提交的是中文，后端获取之后出现乱码，怎么解决这个乱码？执行以下代码。
request.setCharacterEncoding(&quot;UTF-8&quot;);

// 在Tomcat9之前（包括9），响应中文也是有乱码的，怎么解决这个响应的乱码？
response.setContentType(&quot;text/html;charset=UTF-8&quot;);
// 在Tomcat10之后，包括10在内，响应中文的时候就不在出现乱码问题了。以上代码就不需要设置UTF-8了。

// 注意一个细节
// 在Tomcat10包括10在内之后的版本，中文将不再出现乱码。（这也体现了中文地位的提升。）

// get请求乱码问题怎么解决？
// get请求发送的时候，数据是在请求行上提交的，不是在请求体当中提交的。
// get请求乱码怎么解决
// 方案：修改CATALINA_HOME/conf/server.xml配置文件
&lt;Connector URIEncoding=&quot;UTF-8&quot; /&gt;
// 注意：从Tomcat8之后，URIEncoding的默认值就是UTF-8，所以GET请求也没有乱码问题了。
    
// 获取应用的根路径
String contextPath = request.getContextPath();

// 获取请求方式
String method = request.getMethod();

// 获取请求的URI
String uri = request.getRequestURI();  // /aaa/testRequest

// 获取servlet path
String servletPath = request.getServletPath(); //   /testRequest
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a><strong>Cookie</strong></h2><p>…</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a><strong>Session</strong></h2><p>…</p>
<h1 id="END"><a href="#END" class="headerlink" title="-END-"></a>-END-</h1>]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Annotation</title>
    <url>/2022/04/07/Annotation/</url>
    <content><![CDATA[<h1 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    <code>Annotation</code>（注解）是JDK5开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类，方法或者变量，在框架中大量使用（如 Spring、Mybatis等）</p>
<blockquote>
<p>注解是一种能被添加到java代码中的元数据，类、方法、变量、参数和包都可以用注解来修饰。注解对于它所修饰的代码并没有直接的影响。</p>
</blockquote>
<p>​    下面是我简单写的一个自定义注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">msg</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;Hi&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    通过对上述文件的字节码（.class）的反编译（javap - p xxx.class）可以得到<code>@interface</code>其实就是一个继承了<code>Annotation</code>的一个接口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javap -p Test.class</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">com</span>.dyw.annotation.Test <span class="keyword">extends</span> <span class="title class_">java</span>.lang.annotation.Annotation &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> java.lang.String <span class="title function_">msg</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    注解只有被解析之后才会生效，常见的解析方法有两种：</p>
<ul>
<li><strong>编译期间直接扫描：</strong>编译器在编译Java代码的时候扫描对于的注解并处理，比如某个方法使用了<code>@Override</code>，编译器在编译的时候就会检测当前的方法是否重写了父类对于的方法。</li>
<li><strong>运行期间通过反射处理：</strong>这个经常在Spring框架中看到，例如Spring的<code>@Value</code>注解，就是通过反射来进行处理的。</li>
</ul>
<h2 id="注解详细介绍"><a href="#注解详细介绍" class="headerlink" title="注解详细介绍"></a>注解详细介绍</h2><p>我们通过上述的例子可以看到我们的注解上面还有着其他的注解例如<code>@Retention</code>、<code>@Target</code>（这些都统称为元注解）.</p>
<p>所以一个注解是由以下成分组成</p>
<blockquote>
<ul>
<li>元注解</li>
<li><code>public @interface 注解名称</code></li>
</ul>
</blockquote>
<hr>
<h3 id="元注解介绍"><a href="#元注解介绍" class="headerlink" title="元注解介绍"></a>元注解介绍</h3><p>​    JDK1.8版本为我们提供了6个标准的用来<strong>对注解类型进行注解的注解类</strong>（1.8之前只有四个），我们称之为<code>meta-annotation</code>（元注解）.</p>
<p>​    <strong>元注解只能用在注解之上（自定义注解时可用）</strong></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407175816207.png" alt="image-20220407175816207"></p>
<blockquote>
<p><code>@Target</code></p>
<p><code>@Retention</code></p>
<p><code>@Documented</code></p>
<p><code>@Inherited</code></p>
<p><code>@Native</code>（1.8新增）</p>
<p><code>@Repeatable</code>（1.8新增）</p>
</blockquote>
<hr>
<h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a><code>@Target</code></h4><p>官方解释：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">指示注解类型适用的上下文。注解类型可能适用的声明上下文和类型上下文在 JLS 9.6.4.1 中指定，并在源代码中由java.lang.annotation.ElementType的枚举常量表示。</span><br><span class="line">如果注解类型T上不存在@Target元注解，则类型T的注解可以写为除类型参数声明之外的任何声明的修饰符。</span><br><span class="line">如果存在@Target元注解，编译器将强制执行ElementType枚举常量指示的使用限制，符合 JLS 9.7.4。</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>它指明了它所修饰的注解使用的范围 如果自定义的注解为含有@Target元注解修饰，那么默认可以是在（除类型参数之外的）任何项之上使用，若有@Target元注解修饰那么根据Value（ElementType枚举常量）的指定的目标进行规定。</strong></li>
</ul>
<h5 id="ElementType"><a href="#ElementType" class="headerlink" title="ElementType"></a><code>ElementType</code></h5><p><code>ElementType.class</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span> &#123;</span><br><span class="line">    <span class="comment">/** 类、接口（包括注解类型）或枚举声明 */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 字段声明（包括枚举常量） */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 方法声明 */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 参数声明 */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 构造函数声明 */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 局部变量声明 */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 注解类型声明 */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 包装声明 */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型参数声明 类型参数即Map&lt;String,Integer&gt;中的String和Integer这里是作为类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用类型 对应于 JLS 4.11 中的 15 个类型上下文，以及两个声明上下文：类型声明（包括注解类型声明）和类型参数声明。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>ElementType的枚举常量指明了注解可以使用的目标。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span><span class="comment">//可修饰在方法之上</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a><code>@Retention</code></h4><p>官方解释：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">指示要保留带注解类型的注解多长时间。如果注释类型声明中不存在保留注释，则保留策略默认为RetentionPolicy.CLASS 。</span><br><span class="line">仅当元注释类型直接用于注释时，保留元注释才有效。如果将元注释类型用作另一个注释类型中的成员类型，则它没有效果。</span><br></pre></td></tr></table></figure>

<ul>
<li>即<code>@Retention</code>用来约束注解的生命周期，分别有三个值，源码级别（source）、类文件级别（class）或者运行时级别（runtime）可以通过指定<code>@Retention</code>中的值来实现（值为<code>RetentionPolicy</code>枚举常量）。</li>
</ul>
<h5 id="RetentionPolicy-class"><a href="#RetentionPolicy-class" class="headerlink" title="RetentionPolicy.class"></a><code>RetentionPolicy.class</code></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RetentionPolicy</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解将被编译器丢弃。(该类型的注解信息指挥保留在源码中，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class文件中)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解将由编译器记录在类文件中，但不需要在运行时由 VM 保留。这是默认行为.(该类型的注解信息会保留在源码里和class文件里，在执行的时候，不会加载到虚拟机中) 该类型也是未指定<span class="doctag">@Retention</span>值的缺省值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解将由编译器记录在类文件中，并在运行时由 VM 保留，因此可以反射性地读取它们。(源码，class文件和执行时(VM)都保留注解的信息)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>注意：</strong>生命周期大小排序为<code>SOURCE &lt; CLASS &lt; RUNTIME</code>，范围依次增大，前者能使用的地方后者一定能使用。如果需要在运行时去动态获取注解信息，那只能使用<code>RUNTIME</code>；如果要在编译时进行一些预处理操作，比如生成一些辅助代码，就是用<code>CLASS</code>；如果只是做一些检查性的操作，比如<code>@Override和@SupperssWarning</code>，可选择<code>SOURCE</code></p>
<hr>
<h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a><code>@Documented</code></h4><p>官方解释：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">表示默认情况下，带有类型的注释将由 javadoc 和类似工具记录。这种类型应该用于注解类型的声明，这些类型的注释会影响其客户对注释元素的使用。如果使用 Documented 对类型声明进行注释，则其注释将成为注释元素的公共 API 的一部分。</span><br></pre></td></tr></table></figure>

<ul>
<li>带上该注解后的注解表明，在默认情况下这个注解是由JavaDoc和类似工具记录的，即带上了该文档化的注解被使用再生成文档时，会称为API的一部分。（默认情况下JavaDoc是不包含注解的，除非声明注解的时候使用了<code>@Documented</code>）</li>
</ul>
<p><code>Person.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Person &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="meta">@Person(name = &quot;ding&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//@Person(name = &quot;ding&quot;)</span></span><br><span class="line">    <span class="meta">@Person(name = &quot;yang&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>生成的文档</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407193958620.png" alt="image-20220407193958620"></p>
<ul>
<li>不带<code>@Documented</code>注解生成的文档</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407194037553.png" alt="image-20220407194037553"></p>
<hr>
<h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a><code>@Inherited</code></h4><p>官方解释：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">指示注解类型是自动继承的。如果注解类型声明中存在 Inherited 元注解，并且用户在类声明中查询注解类型，并且类声明没有该类型的注解，则将自动查询该类的超类以获取注解类型。将重复此过程，直到找到此类型的注释，或到达类层次结构（对象）的顶部。如果没有超类具有此类型的注释，则查询将指示所讨论的类没有此类注释。</span><br><span class="line">请注意，如果注释类型用于注释类以外的任何内容，则此元注释类型无效。另请注意，此元注释仅导致注释从超类继承；已实现接口上的注解无效。</span><br></pre></td></tr></table></figure>

<ul>
<li>被该元注解修饰的自定义注解再使用后会自动继承，如果使用了该自定义注解去修饰一个class那么这个注解也会作用于该class的子类。就是说如果某个类使用了被<code>@Inherited</code>修饰的注解，则其子类将会自动具有该注释</li>
</ul>
<p>​    <strong>注意：</strong> <code>@Inherited annotation</code>类型是被标注过的<code>class</code>的子类所继承。类并不从它所实现的接口继承<code>annotation</code>，方法并不从它所重载的方法继承<code>annotation</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span> <span class="comment">//使用@Inherited修饰的自定义注解</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Person &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>main.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Father.class.getAnnotation(Person.class));</span><br><span class="line">        System.out.println(Son.class.getAnnotation(Person.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">com</span>.dyw.annotation.obj.Father &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407204033473.png" alt="image-20220407204033473"></p>
<hr>
<h4 id="Native"><a href="#Native" class="headerlink" title="@Native"></a><code>@Native</code></h4><p>官方解释：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">表示可以从本机代码引用定义常量值的字段。注释可以被生成本机头文件的工具用作提示，以确定是否需要头文件，如果需要，它应该包含哪些声明。</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可。</li>
</ul>
<hr>
<h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a><code>@Repeatable</code></h4><p>官方解释：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">注释类型java.lang.annotation.Repeatable用于指示它（元）注释其声明的注释类型是可重复的。 @Repeatable的值表示可重复注解类型的包含注解类型。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>@Repeatable</code>允许在相同的程序元素中重复注解（不报错）。在需要对同一种注解多次使用时，往往需要借助 @Repeatable 注解。Java 8 版本以前，同一个程序元素前最多只能有一个相同类型的注解，如果需要在同一个元素前使用多个相同类型的注解，则必须使用注解“容器”。</p>
</blockquote>
<p>​    <strong>不使用<code>@Repeatable</code>修饰的自定义注解完成重复注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Persons &#123;</span><br><span class="line">    Person[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Person &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Persons(value = &#123;@Person(name = &quot;ding&quot;),@Person(name = &quot;yang&quot;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>使用<code>@Repeatable</code>修饰的自定义注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Persons &#123;</span><br><span class="line">    Person[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable(Persons.class)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Person &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Person(name = &quot;ding&quot;)</span></span><br><span class="line"><span class="meta">@Person(name = &quot;yang&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>两种方法不同的地方是，创建重复注解Person时加上了<code>@Repeatable</code>注解，指向存储注解Persons，这样使用时就可以直接重复使用Person注解。从上述例子可以看出使用<code>@Repeatable</code>注解更符合常规思维，可读性强。</p>
</li>
<li><p>但两种方法的效果相同，只是使用了<code>@Repeatable</code>注解简化了写法，这种简化的底层依旧是多个重复注解使用了一个被称作“容器”注解的value的成员的数组元素处理。</p>
</li>
</ul>
<hr>
<h3 id="JDK基本注解介绍"><a href="#JDK基本注解介绍" class="headerlink" title="JDK基本注解介绍"></a>JDK基本注解介绍</h3><p>​    基本注解包括</p>
<blockquote>
<ul>
<li><p><code>@Override</code></p>
</li>
<li><p><code>@Deprecated</code></p>
</li>
<li><p><code>@SuppressWarnings</code></p>
</li>
<li><p><code>@SafeVarargs </code></p>
</li>
<li><p><code>@FunctionalInterface</code></p>
</li>
</ul>
</blockquote>
<h4 id="Override"><a href="#Override" class="headerlink" title="@Override"></a><code>@Override</code></h4><p>​    官方解释：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">指示方法声明旨在覆盖超类型中的方法声明。如果使用此注解类型对方法进行注解，则编译器需要生成错误消息，除非至少满足以下条件之一：</span><br><span class="line">该方法确实覆盖或实现了在超类型中声明的方法。</span><br><span class="line">该方法的签名与Object中声明的任何公共方法的签名等效。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">msg</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">msg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果将子类中方法名<code>msg</code>改为<code>mg</code>会发生如下编译错误</li>
</ul>
<blockquote>
<p>java: 方法不会覆盖或实现超类型的方法</p>
</blockquote>
<ul>
<li>所以<code>@Override</code>的作用告诉编译器检查这个方法，保证父类要包含一个被该方法重写的方法，否者就会出错，这样可以帮助程序员避免一些低级错误。</li>
</ul>
<hr>
<h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a><code>@Deprecated</code></h4><p>​    官方解释：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">@Deprecated 注释的程序元素是不鼓励程序员使用的程序元素，通常是因为它很危险，或者因为存在更好的替代方案。当在非弃用代码中使用或覆盖弃用的程序元素时，编译器会发出警告。</span><br></pre></td></tr></table></figure>

<ul>
<li>通俗的说被该注解修饰的目标项是已经过时的了，不推荐使用的。**</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">msg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>@Deprecated</code>修饰了Son中的<code>msg</code>方法后，调用该方法会出现<strong>删除线</strong>和编译警告。</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407210522333.png" alt="image-20220407210522333"></p>
<hr>
<h4 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a><code>@SuppressWarnings</code></h4><p>​    官方解释：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">指示应在带注释的元素（以及带注释的元素中包含的所有程序元素）中抑制命名的编译器警告。请注意，给定元素中抑制的警告集是所有包含元素中抑制的警告的超集。例如，如果您注释一个类以抑制一个警告并注释一个方法以抑制另一个警告，则两个警告都将在方法中被抑制。</span><br><span class="line">作为风格问题，程序员应该始终在最有效的嵌套元素上使用此注释。如果您想在特定方法中抑制警告，您应该注释该方法而不是它的类。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *编译器要在带注​​释的元素中抑制的一组警告。允许重复名称。名称的第二次和连续出现将被忽略。存在无法识别的警告名称不是错误：编译器必须忽略它们无法识别的任何警告名称。但是，如果注释包含无法识别的警告名称，它们可以自由发出警告。</span></span><br><span class="line"><span class="comment">字符串&quot;unchecked&quot;用于抑制未经检查的警告。编译器供应商应结合此注释类型记录他们支持的其他警告名称。鼓励他们合作以确保相同的名称在多个编译器中工作。</span></span><br><span class="line"><span class="comment">回报：</span></span><br><span class="line"><span class="comment">要抑制的警告集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Java中的<code>@SuppressWarnings</code> 注解指示被该注解修饰的程序元素（以及该程序元素中的所有子元素）取消显示指定的编译器警告，且会一直作用于该程序元素的所有子元素。</p>
</li>
<li><p>如果你对于代码的规范不做要求又对编译器的警告感到烦躁那么你可以使用<code>@SuppressWarnings</code>（仅仅只是取消显示，并没有消除），它可以让你免去这些烦恼，当然编译器报错他是无法帮你取消显示的。</p>
</li>
<li><p>添加前：</p>
</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407211856114.png" alt="image-20220407211856114"></p>
<ul>
<li>添加后：</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407212004111.png" alt="image-20220407212004111"></p>
<ul>
<li><p>注解的使用有以下三种：</p>
<ul>
<li>抑制单类型的警告：<code>@SuppressWarnings(&quot;unchecked&quot;)</code></li>
<li>抑制多类型的警告：<code>@SuppressWarnings(&quot;unchecked&quot;,&quot;rawtypes&quot;)</code></li>
<li>抑制所有类型的警告：<code>@SuppressWarnings(&quot;unchecked&quot;)</code></li>
</ul>
</li>
<li><p>抑制警告的关键字如下表所示：</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>all</td>
<td>抑制所有警告</td>
</tr>
<tr>
<td>boxing</td>
<td>抑制装箱、拆箱操作时候的警告</td>
</tr>
<tr>
<td>cast</td>
<td>抑制映射相关的警告</td>
</tr>
<tr>
<td>dep-ann</td>
<td>抑制启用注释的警告</td>
</tr>
<tr>
<td>deprecation</td>
<td>抑制过期方法警告</td>
</tr>
<tr>
<td>fallthrough</td>
<td>抑制在 switch 中缺失 breaks 的警告</td>
</tr>
<tr>
<td>finally</td>
<td>抑制 finally 模块没有返回的警告</td>
</tr>
<tr>
<td>hiding</td>
<td>抑制相对于隐藏变量的局部变量的警告</td>
</tr>
<tr>
<td>incomplete-switch</td>
<td>忽略不完整的 switch 语句</td>
</tr>
<tr>
<td>nls</td>
<td>忽略非 nls 格式的字符</td>
</tr>
<tr>
<td>null</td>
<td>忽略对 null 的操作</td>
</tr>
<tr>
<td>rawtypes</td>
<td>使用 generics 时忽略没有指定相应的类型</td>
</tr>
<tr>
<td>restriction</td>
<td>抑制禁止使用劝阻或禁止引用的警告</td>
</tr>
<tr>
<td>serial</td>
<td>忽略在 serializable 类中没有声明 serialVersionUID 变量</td>
</tr>
<tr>
<td>static-access</td>
<td>抑制不正确的静态访问方式警告</td>
</tr>
<tr>
<td>synthetic-access</td>
<td>抑制子类没有按最优方法访问内部类的警告</td>
</tr>
<tr>
<td>unchecked</td>
<td>抑制没有进行类型检查操作的警告</td>
</tr>
<tr>
<td>unqualified-field-access</td>
<td>抑制没有权限访问的域的警告</td>
</tr>
<tr>
<td>unused</td>
<td>抑制没被使用过的代码的警告</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h4 id="SafeVarargs"><a href="#SafeVarargs" class="headerlink" title="@SafeVarargs "></a><code>@SafeVarargs </code></h4><p>​    官方解释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">程序员断言带注释的方法或构造函数的主体不会对其 varargs 参数执行潜在的不安全操作。将此注释应用于方法或构造函数会抑制有关不可具体化的变量 arity (vararg) 类型的未经检查的警告，并抑制有关在调用站点创建参数化数组的未经检查的警告。</span><br><span class="line">除了<span class="meta">@Target</span>元注解施加的使用限制外，编译器还需要对该注解类型实施额外的使用限制；如果使用<span class="meta">@SafeVarargs</span>注释对方法或构造函数声明进行注释，则这是编译时错误，并且：</span><br><span class="line">声明是一个固定的arity方法或构造函数</span><br><span class="line">声明是一个既不是<span class="keyword">static</span>也不是<span class="keyword">final</span>的变量 arity 方法。</span><br><span class="line">鼓励编译器在将此注释类型应用于方法或构造函数声明时发出警告，其中：</span><br><span class="line">变量 arity 参数具有可具体化的元素类型，包括原始类型、 Object和String 。 （对于可具体化的元素类型，此注释类型抑制的未经检查的警告已经不会出现。）</span><br><span class="line">方法或构造函数声明的主体执行潜在的不安全操作，例如对变量 arity 参数数组的元素的赋值会生成未经检查的警告。一些不安全的操作不会触发未经检查的警告。例如，别名在</span><br><span class="line">   <span class="meta">@SafeVarargs</span> <span class="comment">// 实际上并不安全！</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(List&lt;String&gt;... stringLists)</span> &#123;</span><br><span class="line">     Object[] array = stringLists;</span><br><span class="line">     List&lt;Integer&gt; tmpList = Arrays.asList(<span class="number">42</span>);</span><br><span class="line">     array[<span class="number">0</span>] = tmpList; <span class="comment">// 语义上无效，但可以编译</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringLists[<span class="number">0</span>].get(<span class="number">0</span>); <span class="comment">// 哦不，运行时的 ClassCastException！</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">在运行时导致ClassCastException 。</span><br><span class="line">该平台的未来版本可能会要求此类不安全操作出现编译器错误。</span><br></pre></td></tr></table></figure>

<p>在学习<code>@SafeVarargs</code>之前先来看看下面有一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        display(<span class="string">&quot;10&quot;</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(T ...array)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (T arg : array)&#123;</span><br><span class="line">            System.out.println(arg.getClass().getName()+<span class="string">&quot;:&quot;</span>+arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这段代码中我设计了一个接收可变参数的方法<code>public static &lt;T&gt; void display(T ...array)&#123;&#125;</code>可变参数方法中的参数类型相同，为此声明参数是需要指定泛型。</p>
<p>​    但是调用可变参数方法时，应该提供相同类型的参数，但是代码中传入了不同类型的参数集合，此时可以看到display签名处有如下警告</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407213806123.png" alt="image-20220407213806123"></p>
<p>​    翻译过来就是<code>参数化可变参数类型可能造成的堆污染</code>并且提示添加<code>@SafeVarargs</code>注解（仅仅起一个取消显示的作用，某种方面上来说是和 <code>@SuppressWarnings</code> 作用相同的）。</p>
<p>​    这个警告是 unchecked（未检查不安全代码），就是因为将非泛型变量赋值给泛型变量所发生的。</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407214116091.png" alt="image-20220407214116091"></p>
<p>​    可以发现加上了<code>@SafeVarargs</code>注解后编译器警告没有显示了，你肯定会说我使用<code>@SuppressWarnings</code>效果也是一样的，效果虽然一样，但是两者相较来说这里使用<code>@SafeVarargs</code>注解更合适</p>
<p>​    <strong>注意：</strong><code>@SafeVarargs</code>注解<strong>不适用于非 <code>static</code> 或非 <code>final</code> 声明的方法</strong>，对于未声明为 <code>static</code> 或 <code>final</code> 的方法，如果要抑制 <code>unchecked</code> 警告，<strong>可以使用 <code>@SuppressWarnings</code> 注解。</strong></p>
<hr>
<h4 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a><code>@FunctionalInterface</code></h4><p>​    官方解释：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">一种信息性注解类型，用于指示接口类型声明旨在成为 Java 语言规范定义的功能接口。从概念上讲，函数式接口只有一个抽象方法。由于默认方法有一个实现，它们不是抽象的。如果接口声明了一个覆盖java.lang.Object的公共方法之一的抽象方法，这也不会计入接口的抽象方法计数，因为接口的任何实现都将具有来自java.lang.Object或其他地方的实现(接口的实现是类,所有类的父类都是Object)。</span><br><span class="line">请注意，函数式接口的实例可以使用 lambda 表达式、方法引用或构造函数引用来创建。</span><br><span class="line">如果使用此注解类型对类型进行注解，则编译器需要生成错误消息，除非：</span><br><span class="line">该类型是接口类型，而不是注解类型、枚举或类。</span><br><span class="line">带注解的类型满足功能接口的要求。</span><br><span class="line">但是，无论接口声明中是否存在FunctionalInterface注释，编译器都会将满足功能接口定义的任何接口视为功能接口。</span><br></pre></td></tr></table></figure>

<p>​    在学习Lambda表达式时，我们了解过函数式接口（接口中只有个一个抽象方法可以存在多个默认方法或多个static方法）。</p>
<ul>
<li><p><code>@FunctionalInterface</code>作用就是用来指定某一个接口必须是函数式接口的，所以<code>@FunctionalInterface</code>只能修饰接口。</p>
</li>
<li><p>这里我写了两个抽象方法出现了编译器报错</p>
</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407214859347.png" alt="image-20220407214859347"></p>
<ul>
<li>这里我只写了一个抽象方法 一个static方法和一个默认方法 符合要求没有报错</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220407215038533.png" alt="image-20220407215038533"></p>
<p>​    <strong>注意：</strong>如果接口声明了一个覆盖<code>java.lang.Object</code>的公共方法之一的抽象方法，这也不会计入接口的抽象方法计数</p>
<p>得出结论：<code>@FunctionalInterface</code>只是告诉编译器去检查这个接口是不是函数式接口，保证该接口只能包含一个抽象方法，否者就会出现编译错误。</p>
<hr>
<h2 id="写一个自己的注解"><a href="#写一个自己的注解" class="headerlink" title="写一个自己的注解"></a>写一个自己的注解</h2><p>注解的格式就是</p>
<blockquote>
<ul>
<li>元注解</li>
<li><code>public @interface 注解名</code></li>
<li>注解内容体</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span> <span class="comment">//这里我希望我的注解能够生成在JavaDoc生成的文档中</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span> <span class="comment">//这里我希望我的注解能够在字节码文件中保留</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span> <span class="comment">//这里我希望我的注解可以修饰于类、接口、抽象类和方法上</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123; <span class="comment">//我声明了一个名为MyAnnotation的注解</span></span><br><span class="line">    <span class="comment">//定义带两个成员变量的注解</span></span><br><span class="line">    <span class="comment">//注解中的成员以方法的形式命名（注解的本质是接口） 并且可以带有默认值</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    想要获取注解中的成员变量需要使用反射的知识、首先需要获取类的Class对象，我们就可以通过的这个Class对象反射得到注解的成员变量了。</p>
<p>​    反射相关的可以参考这篇博客<a href="https://blog.csdn.net/D1842501760/article/details/120714043?spm=1001.2014.3001.5502">反射</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test</span>().testMyAnnotation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="meta">@MyAnnotation(name = &quot;dyw&quot;,age = 20)</span><span class="comment">//这里我们使用了我们刚才自定义的注解</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMyAnnotation</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">        <span class="comment">//这里获取Test类的Class对象 当类被编译后会当jvm加载时会生成该class文件的Class对象 通过这个Class对象可以完成反射相关的操作</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">testMyAnnotation</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getMethod(<span class="string">&quot;testMyAnnotation&quot;</span>);</span><br><span class="line">        <span class="comment">//通过Class对象的getAnnotation()方法反射得到我们的MyAnnotation对象</span></span><br><span class="line">        <span class="type">MyAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> testMyAnnotation.getAnnotation(MyAnnotation.class);</span><br><span class="line">        <span class="comment">//通过该对象可以获取注解类的成员</span></span><br><span class="line">        System.out.println(<span class="string">&quot;name :&quot;</span>+annotation.name());</span><br><span class="line">        System.out.println(<span class="string">&quot;age :&quot;</span>+annotation.age());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220408151357416.png" alt="image-20220408151357416"></p>
<p>​    这里只介绍了自定义注解类的简单用法，但是却完美展现了注解搭配反射可以碰撞出的巨大火花。熟悉掌握注解与反射后就有一定能力去学习那些大佬开发的框架的底层代码了。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://c.biancheng.net/java/java/135/">Java注解 (biancheng.net)</a></p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/package-summary.html">java.lang.annotation (Java Platform SE 8 ) (oracle.com)</a></p>
<p><a href="https://juejin.cn/post/6844903776088752141">理解注解中的@Inherited - 掘金 (juejin.cn)</a></p>
<p><a href="https://blog.csdn.net/qq_34576220/article/details/105731364">java元注解@Native &amp;&amp; @Repeatable （java8 新增）_似火似水的博客-CSDN博客_native注解</a></p>
<p><a href="%5D(https://blog.csdn.net/qq_34576220/article/details/105731364">反射</a></p>
<h1 id="END"><a href="#END" class="headerlink" title="-END-"></a>-END-</h1>]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>事务的嵌套</title>
    <url>/2022/04/09/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B5%8C%E5%A5%97/</url>
    <content><![CDATA[<h1 id="事务的嵌套"><a href="#事务的嵌套" class="headerlink" title="事务的嵌套"></a>事务的嵌套</h1><p><strong>什么是嵌套事务？</strong><br>       嵌套是子事务在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。</p>
<p><strong>可以通过下述的问答进一步去熟悉嵌套事务？</strong></p>
<ol>
<li>如果子事务回滚，会发生什么？<br>      父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。</li>
<li>如果父事务回滚，会发生什么？<br>      父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。</li>
<li>事务的提交，是什么情况？<br>      父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。</li>
</ol>
<p>原文链接：<a href="https://blog.csdn.net/javashareauthor/article/details/82842177">https://blog.csdn.net/javashareauthor/article/details/82842177</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>HttpClient</title>
    <url>/2022/04/11/HttpClient/</url>
    <content><![CDATA[<h1 id="Apache-HttpClient"><a href="#Apache-HttpClient" class="headerlink" title="Apache HttpClient"></a>Apache HttpClient</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>HttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。HttpClient 已经应用在很多的项目中，比如 Apache Jakarta 上很著名的另外两个开源项目 Cactus 和 <strong>HTMLUnit</strong> 都使用了 HttpClient。</p>
</blockquote>
<p>​    使用HttpClient、可以灵活地发送HTTP请求，并且Apache HttpClient提供了很多自定义的请求内容的API（包括连接超时时间设置等）。方便了开发人员测试接口（基于HTTP协议的），既提高了开发效率，也方便了提高代码的健壮性。（后续的RestTemplate的底层也是HttpClient）因此熟悉掌握HttpClient是很重要的必修内容，掌握了HttpClient后，对于HTTP的协议的了解也会更加深刻。</p>
<hr>
<h2 id="Apache-HttpClient特性"><a href="#Apache-HttpClient特性" class="headerlink" title="Apache HttpClient特性"></a>Apache HttpClient特性</h2><ul>
<li>基于标准，纯净的Java语言。实现了HTTP1.0和HTTP1.1</li>
<li>以可扩展的面向对象的结构实现了 HTTP 全部的方法（<code>GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE</code>）。</li>
<li>支持 HTTPS 协议。</li>
<li>通过 HTTP 代理建立透明的连接。</li>
<li>利用 CONNECT 方法通过 HTTP 代理建立隧道的 HTTPS 连接。</li>
<li><code>Basic,Digest,NTLMv1,NTLMv2,NTLM2Session,SNPNEGO/Kerberos </code>认证方案。</li>
<li>插件式的自定义认证方案。</li>
<li>便携可靠的套接字工厂使它更容易的使用第三方解决方案。</li>
<li>连接管理器支持多线程应用。支持设置最大连接数，同时支持设置每个主机的最大连接数，发现并关闭过期的连接。</li>
<li>自动处理 Set-Cookie 中的 Cookie。</li>
<li>插件式的自定义 Cookie 策略。</li>
<li>Request 的输出流可以避免流中内容直接缓冲到 Socket 服务器。</li>
<li>Response 的输入流可以有效的从 Socket 服务器直接读取相应内容。</li>
<li>在 HTTP 1.0 和 HTTP 1.1 中利用 KeepAlive 保持持久连接。</li>
<li>直接获取服务器发送的 response code 和 headers。</li>
<li>设置连接超时的能力。</li>
<li>实验性的支持 HTTP 1.1 response caching。</li>
</ul>
<h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><ul>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpmime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>HttpClient</code>对象（http客户端对象）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();<span class="comment">//方式一</span></span><br><span class="line"><span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClients.createDefault();<span class="comment">//方式二</span></span><br></pre></td></tr></table></figure>

<p>两种方式相同，因为方式二的底层就是方式一。</p>
</li>
<li><p>创建请求方法的实例，并指定<code>URL</code>。因为<code>HttpClient</code>是实现了所有<code>Http</code>请求方法，我们只需要创建请求方法实例（Httpxxx），在方法实例中指定URL即可，例如我们要发送Get请求，就创建<code>HttpGet</code>对象。</p>
</li>
<li><p>如果需要发送带有参数的请求，可调用<code>HttpGet、HttpPost</code>共同的<code>setParam（HttpParams params）</code>来添加参数（该方法已经过时&#x2F;弃用了）；<code>HttpGet</code>推荐使用单独创建uri，构建自己的带参数的get请求的uri。<code>HttpPost</code>请求则是调用<code>setEntity(HttpEntity entity)</code>方法来设置请求参数（可以设置对象）。</p>
</li>
<li><p>发送请求则是<code>HttpClient</code>的工作，调用<code>HttpClient</code>的<code>execute(HttpUriRequeset request)</code>发送请求，该方法会返回一个<code>HttpResponse</code>（响应模板）</p>
</li>
<li><p>调用<code>HttpResponse</code>的<code>getAllHeader()</code>、<code>getHeaders(Sring name)</code>等方法可以获取服务器的响应头，除此之外还可以获取状态码等。通过<code>HttpResponse</code>的<code>getEntity()</code>方法可以获取响应的响应实体，该对象包装了服务器的响应内容，程序可以通过该对象获取服务器的响应内容。</p>
</li>
<li><p>最后需要释放资源，关闭<code>HttpClient</code>和<code>reseponse</code>的资源连接</p>
</li>
</ul>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p><code>GET请求</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * GET---无参测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGetTestOne</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获得http客户端</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line">        <span class="comment">//创建get请求</span></span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;https://www.cuit.edu.cn/&quot;</span>);</span><br><span class="line">        <span class="comment">//响应模型</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//有客户端指定get请求</span></span><br><span class="line">            response = client.execute(httpGet);</span><br><span class="line">            <span class="comment">//从响应模型中获取响应体</span></span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">responseEntity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;响应状态为:&quot;</span>+response.getStatusLine());</span><br><span class="line">            <span class="keyword">if</span> (responseEntity!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容长度为:&quot;</span>+responseEntity.getContentLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容为:&quot;</span>+ EntityUtils.toString(responseEntity));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//释放资源</span></span><br><span class="line">                <span class="keyword">if</span>(client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * GET--有参测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGetTestWayOne</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获得http客户端</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//参数</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            params.append(<span class="string">&quot;name=&quot;</span>).append(URLEncoder.encode(<span class="string">&quot;&amp;&quot;</span>,<span class="string">&quot;utf-8&quot;</span>)).append(<span class="string">&quot;&amp;&quot;</span>).append(<span class="string">&quot;age=24&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Get请求</span></span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;https://www.cuit.edu.cn/?&quot;</span> + params);</span><br><span class="line">        <span class="comment">//响应模型</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//配置信息</span></span><br><span class="line">            <span class="type">RequestConfig</span> <span class="variable">config</span> <span class="operator">=</span> RequestConfig.custom()</span><br><span class="line">                    <span class="comment">//设置连接超时时间</span></span><br><span class="line">                    .setConnectTimeout(<span class="number">5000</span>)</span><br><span class="line">                    <span class="comment">//设置请求超时时间</span></span><br><span class="line">                    .setConnectionRequestTimeout(<span class="number">5000</span>)</span><br><span class="line">                    <span class="comment">//socket读写超时时间</span></span><br><span class="line">                    .setSocketTimeout(<span class="number">5000</span>)</span><br><span class="line">                    <span class="comment">//设置是否允许重定向(默认为true)</span></span><br><span class="line">                    .setRedirectsEnabled(<span class="literal">true</span>)</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="comment">//将上面的配置信息配入Get请求中</span></span><br><span class="line">            httpGet.setConfig(config);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//由客户端执行Get请求</span></span><br><span class="line">            response = client.execute(httpGet);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从响应模型中获取响应实体</span></span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">responseEntity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;响应状态为:&quot;</span>+response.getStatusLine());</span><br><span class="line">            <span class="keyword">if</span> (responseEntity!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容长度为:&quot;</span>+responseEntity.getContentLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容为:&quot;</span>+ EntityUtils.toString(responseEntity,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientProtocolException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGetTestWayTwo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line">        <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ArrayList&lt;NameValuePair&gt; params = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            params.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;10&quot;</span>));</span><br><span class="line">            params.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>));</span><br><span class="line">            <span class="comment">//这里设置uri信息,并将参数集合放入uri;</span></span><br><span class="line">            <span class="comment">//注: 这里也支持一个键值对一个键值对地往里面方setParameter(String key, String value)</span></span><br><span class="line">            uri = <span class="keyword">new</span> <span class="title class_">URIBuilder</span>().setScheme(<span class="string">&quot;http&quot;</span>).setHost(<span class="string">&quot;www.cuit.edu.cn&quot;</span>)</span><br><span class="line"><span class="comment">//                    .setPort(12345).setPath(&quot;/xw&quot;)</span></span><br><span class="line">                    .setParameters(params).build();</span><br><span class="line">            System.out.println(uri);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建httpGet请求</span></span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(uri);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建响应模型</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">RequestConfig</span> <span class="variable">config</span> <span class="operator">=</span> RequestConfig.custom()</span><br><span class="line">                    .setConnectTimeout(<span class="number">5000</span>)</span><br><span class="line">                    .setConnectionRequestTimeout(<span class="number">5000</span>)</span><br><span class="line">                    .setSocketTimeout(<span class="number">5000</span>)</span><br><span class="line">                    .setRedirectsEnabled(<span class="literal">true</span>).build();</span><br><span class="line"></span><br><span class="line">            httpGet.setConfig(config);</span><br><span class="line">            response = client.execute(httpGet);</span><br><span class="line"></span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;响应状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容长度:&quot;</span>+entity.getContentLength());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容:&quot;</span>+EntityUtils.toString(entity,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientProtocolException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//new GetClient().doGetTestOne();</span></span><br><span class="line">        <span class="comment">//new GetClient().doGetTestWayOne();</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GetClient</span>().doGetTestWayTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>POST请求</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * POST 无参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPostTestOne</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获得http客户端</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line">        <span class="comment">//创建Post请求</span></span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://www.cuit.edu.cn/index.htm&quot;</span>);</span><br><span class="line">        <span class="comment">//创建响应模型</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            response = client.execute(httpPost);</span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;响应状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容长度:&quot;</span>+entity.getContentLength());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容:&quot;</span>+ EntityUtils.toString(entity,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * POST 有参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPostTestFour</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获的http客户端</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//参数</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//字符数据最好encoding; 这样一来, 某些特殊字符才嗯那个传过去(如:某人的名字就是&quot;&amp;&quot;,不encoding,传不过去)</span></span><br><span class="line">            params.append(<span class="string">&quot;phone=&quot;</span>).append(URLEncoder.encode(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            params.append(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">            params.append(<span class="string">&quot;password=admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建post请求</span></span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://www.cuit.edu.cn/?&quot;</span> + params);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置ContentType(注:如果只是传入普通参数的话,ContentType不一定非要用application/json)</span></span><br><span class="line">        httpPost.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//响应模型</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            response = client.execute(httpPost);</span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容长度: &quot;</span>+entity.getContentLength());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容: &quot;</span>+entity);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * POST---有参测试(对象参数)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPostTestTwo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获取Http客户端</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Post请求</span></span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://www.cuit.edu.cn/index.htm&quot;</span>);</span><br><span class="line">        <span class="comment">//User user = new User();</span></span><br><span class="line">        <span class="comment">//user.setName(&quot;潘晓婷&quot;);</span></span><br><span class="line">        <span class="comment">//user.setAge(18);</span></span><br><span class="line">        <span class="comment">//user.setGender(&quot;女&quot;);</span></span><br><span class="line">        <span class="comment">//user.setMotto(&quot;姿势要优雅~&quot;);</span></span><br><span class="line">        <span class="comment">// 我这里利用阿里的fastjson，将Object转换为json字符串;</span></span><br><span class="line">        <span class="comment">// (需要导入com.alibaba.fastjson.JSON包)</span></span><br><span class="line">        <span class="comment">//String jsonString = JSON.toJSONString(user);</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">StringEntity</span> <span class="variable">stringEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringEntity</span>(jsonString, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        httpPost.setEntity(stringEntity);</span><br><span class="line">        httpPost.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=utf8&quot;</span>);</span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            response = client.execute(httpPost);</span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容长度:&quot;</span>+entity.getContentLength());</span><br><span class="line">            System.out.println(<span class="string">&quot;响应内容:&quot;</span>+EntityUtils.toString(entity,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//new PostClient().doPostTestOne();</span></span><br><span class="line">        <span class="comment">//new PostClient().doPostTestFour();</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">PostClient</span>().doPostTestTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>上传文件</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送文件</span></span><br><span class="line"><span class="comment">     注:如果想要灵活方便的传输文件的话，</span></span><br><span class="line"><span class="comment">     *    除了引入org.apache.httpcomponents基本的httpclient依赖外</span></span><br><span class="line"><span class="comment">     *    再额外引入org.apache.httpcomponents的httpmime依赖。</span></span><br><span class="line"><span class="comment">     *    追注:即便不引入httpmime依赖，也是能传输文件的，不过功能不够强大。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://www.cuit.edu.cn/file&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">MultipartEntityBuilder</span> <span class="variable">multipartEntityBuilder</span> <span class="operator">=</span> MultipartEntityBuilder.create();</span><br><span class="line">            <span class="comment">//第一个文件</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileKey</span> <span class="operator">=</span> <span class="string">&quot;files&quot;</span>;</span><br><span class="line">            <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\图片\\《Valorant》3440x1440带鱼屏游戏壁纸_彼岸图网.jpg&quot;</span>);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            防止服务端收到的文件名乱码. 我们这里可以先将文件名URLEncode, 然后服务端拿到文件后URLDecode</span></span><br><span class="line"><span class="comment">            文件名其实是放在请求头的Content-Disposition中 如其值form-data; name=&quot;files&quot;; filename=&quot;头像.jpg&quot;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            multipartEntityBuilder.addBinaryBody(fileKey,file1, ContentType.DEFAULT_BINARY, URLEncoder.encode(file1.getName(),<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//其他参数(注:自定义contentType,设置UTF-8是为了防止服务端拿到的参数出现乱码)</span></span><br><span class="line">            <span class="type">ContentType</span> <span class="variable">contentType</span> <span class="operator">=</span> ContentType.create(<span class="string">&quot;text/plain&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">            multipartEntityBuilder.addTextBody(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;等沙利文&quot;</span>,contentType);</span><br><span class="line">            multipartEntityBuilder.addTextBody(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;25&quot;</span>,contentType);</span><br><span class="line"></span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">httpEntity</span> <span class="operator">=</span> multipartEntityBuilder.build();</span><br><span class="line">            httpPost.setEntity(httpEntity);</span><br><span class="line">            response = client.execute(httpPost);</span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            <span class="keyword">if</span> (entity!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容长度:&quot;</span>+entity.getContentLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容:&quot;</span>+ EntityUtils.toString(entity,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            File file1 = new File(&quot;D:\\图片\\XXX.jpg&quot;);</span></span><br><span class="line"><span class="comment">            multipartEntityBuilder.addBinaryBody(fileKey,file1);</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileClient</span>().test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Stream请求</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://www.cuit.edu.cn/index.htm&quot;</span>);</span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(<span class="string">&quot;流啊流~&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            <span class="type">InputStreamEntity</span> <span class="variable">ise</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamEntity</span>(is);</span><br><span class="line">            httpPost.setEntity(ise);</span><br><span class="line"></span><br><span class="line">            response = client.execute(httpPost);</span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">            System.out.println(<span class="string">&quot;响应状态码:&quot;</span>+response.getStatusLine());</span><br><span class="line">            <span class="keyword">if</span> (entity!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容长度:&quot;</span>+entity.getContentLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;响应内容:&quot;</span>+ EntityUtils.toString(entity,StandardCharsets.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (client!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StreamClient</span>().test5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="END"><a href="#END" class="headerlink" title="-END-"></a>-END-</h1>]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>restTemplate</title>
    <url>/2022/04/16/restTemplate/</url>
    <content><![CDATA[<h1 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h1><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/wallhaven-8oky1j.jpg" alt="General 1920x1080 Gordon Zuchhold (Artstation) digital art science fiction pixel art city cyberpunk animation futuristic city ArtStation artwork futuristic"></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><code>RestTemplate</code>是由<code>Spring</code>框架提供的一个可用于应用中调用<code>rest</code>服务的类它简化了与<code>http</code>服务的通信方式，统一了<code>RESTFul</code>的标准，封装了<code>http</code>连接，我们只需要传入<code>url</code>及其返回值类型即可。相较于之前常用的<code>HttpClient</code>，<code>RestTemplate</code>是一种更为优雅的调用<code>RESTFul</code>服务的方式。</li>
<li>在<code>Spring</code>应用程序中访问第三方<code>REST服务</code>与使用<code>Spring RestTemplate</code>类有关。<code>RestTemplate</code>类的设计原则与许多其他<code>Spring</code>的模板类(例如<code>JdbcTemplate</code>)相同，为执行复杂任务提供了一种具有默认行为的简化方法。</li>
<li><code>RestTemplate</code>默认依赖JDK提供了<code>http</code>连接的能力（<code>HttpURLConnection</code>），如果有需要的话也可以通过<code>setRequestFactory</code>方法替换为例如<code>Apache HttpCompoent、Netty或OKHttp</code>等其他<code>Http libaray</code>。</li>
<li>考虑到了<code>RestTemplate</code>类是为了调用REST服务而设计的，因此它的主要方法与<code>REST</code>的基础紧密相连就不足为奇了，后者时<code>HTTP</code>协议的方法：<code>HEAD、GET、POST、PUT、DELETE、OPTIONS</code>例如，<code>RestTemplate</code>类具有<code>headForHeaders()、getForObject()、putForObject()，put()和delete()</code>等方法。</li>
</ul>
<h2 id="创建RestTemplate"><a href="#创建RestTemplate" class="headerlink" title="创建RestTemplate"></a>创建<code>RestTemplate</code></h2><p>​    因为<code>RestTemplate</code>是<code>Spirng</code>框架提供的所以只要是一个<code>Springboot</code>项目就不用考虑导包的问题，这些都是提供好的。</p>
<p>​    但是<code>Spring</code>并没有将其加入<code>SpringBean</code>容器中，需要我们手动加入，因为我们首先创建一个<code>Springboot</code>配置类，再在配置类中将我们的<code>RestTemlate</code>注册到<code>Bean</code>容器中</p>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​    使用<code>Springboot</code>提供的<code>RestTemplateBuilder</code>构造类来构造一个<code>RestTemplate</code>，可以自定义一些连接参数，如：连接超时时间，读取超时时间，还有认证信息等</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415202710768.png" alt="image-20220415202710768"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">(RestTemplateBuilder builder)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">                <span class="comment">//设置连接超时时间</span></span><br><span class="line">                .setConnectTimeout(Duration.ofSeconds(<span class="number">5000</span>))</span><br><span class="line">                <span class="comment">//设置读取超时时间</span></span><br><span class="line">                .setReadTimeout(Duration.ofSeconds(<span class="number">5000</span>))</span><br><span class="line">                <span class="comment">//设置认证信息</span></span><br><span class="line">                .basicAuthentication(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                <span class="comment">//设置根路径</span></span><br><span class="line">                .rootUri(<span class="string">&quot;https://api.test.com/&quot;</span>)</span><br><span class="line">                <span class="comment">//构建</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="添加自定义的拦截器"><a href="#添加自定义的拦截器" class="headerlink" title="添加自定义的拦截器"></a>添加自定义的拦截器</h4><p>​    自定义拦截器示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomClientHttpRequestInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ClientHttpRequestInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ClientHttpResponse <span class="title function_">intercept</span><span class="params">(HttpRequest request, <span class="type">byte</span>[] body, ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印请求明细</span></span><br><span class="line">        logRequestDetails(request,body);</span><br><span class="line">        <span class="type">ClientHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> execution.execute(request, body);</span><br><span class="line">        <span class="comment">//打印响应明细</span></span><br><span class="line">        logResponseDetails(response);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logRequestDetails</span><span class="params">(HttpRequest request, <span class="type">byte</span>[] body)</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Headers:&#123;&#125;&quot;</span>,request.getHeaders());</span><br><span class="line">        log.debug(<span class="string">&quot;body:&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>(body, StandardCharsets.UTF_8));</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>,request.getMethod(),request.getMethodValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logResponseDetails</span><span class="params">(ClientHttpResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Status code : &#123;&#125;&quot;</span>,response.getStatusCode());</span><br><span class="line">        log.debug(<span class="string">&quot;Status text : &#123;&#125;&quot;</span>,response.getStatusText());</span><br><span class="line">        log.debug(<span class="string">&quot;Headers : &#123;&#125;&quot;</span>,response.getHeaders());</span><br><span class="line">        log.debug(<span class="string">&quot;Response body: &#123;&#125;&quot;</span>, StreamUtils.copyToString(response.getBody(),StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    使用<code>RestTemplateBuilder</code>构造类，添加自定义拦截器，构造带有自定义拦截器的<code>RestTemplate</code>实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">(RestTemplateBuilder builder)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">                .additionalInterceptors(<span class="keyword">new</span> <span class="title class_">CustomClientHttpRequestInterceptor</span>())</span><br><span class="line">                <span class="comment">//构建</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    测试请求确实经过了拦截器，注册成功（注意请求和响应的流只会被读取一次，这里我们读取了response后返回的response就读取不到刚刚读过的内容了）</p>
<p>​    <img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415204816204.png" alt="image-20220415204816204"></p>
<hr>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​    使用<code>RestTemplate</code>构造方法构造一个<code>RestTemlate</code>，虽然不能像<code>RestTemplate</code>构造类那样更详细、更多样的配置参数，但是<code>RestTemplate</code>构造方法在一般情况是够用的。</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415195208601.png" alt="image-20220415195208601"></p>
<ul>
<li>无参构造 全部参数默认</li>
<li>指定<code>ClientHttpRequestFactory</code> 的构造方法可以指定自己实现的<code>ClientHttpRequestFactory</code>（客户端<code>http</code>请求工厂）其他的与无参构造相同。<ul>
<li><code>ClientHttpRequestFactory</code></li>
</ul>
</li>
<li>指定<code>List&lt;HttpMessageConverter&lt;?&gt;&gt;</code>的构造方法可以指定自己是实现的<code>HttpMessageConverter</code>（<code>Http</code>消息转换器）传入其他与无参构造相同。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>​    两者方法都可使用，前者提供了多样的自定义参数的选择，可以将<code>RestTemplate</code>配置的更为完善，后者则简化了配置虽然配置多样性不如前者，但是日常使用调用些<code>API</code>还是足以使用</p>
<h2 id="RestTemplate-API使用"><a href="#RestTemplate-API使用" class="headerlink" title="RestTemplate API使用"></a><code>RestTemplate API</code>使用</h2><p>​    在使用<code>RestTemplate</code>前先让我们看看<code>RestTemplate</code>有哪些<code>API</code></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415205801633.png" alt="image-20220415205801633"><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415205831801.png" alt="image-20220415205831801"></p>
<p>​    相信大家看到这么多方法，一定很头大，但是我们仔细看上述的方法，我们可以提取出主要的几种方法是(这里只讨论Http请求的)：</p>
<ul>
<li><strong><code>GET</code></strong></li>
<li><strong><code>POST</code></strong></li>
<li><strong><code>PUT</code></strong></li>
<li><strong><code>DELETE</code></strong></li>
<li><strong><code>HEAD</code></strong></li>
<li><strong><code>OPTIONS</code></strong></li>
<li><strong><code>EXCHANGE</code></strong></li>
<li><strong><code>EXECUTE</code></strong></li>
</ul>
<p>​    <strong>这里我给大家安利一个一个网站，它提供免费的RESTFul api的样例测试。</strong><a href="http://httpbin.org/">httpbin A simple HTTP Request &amp; Response Service.</a></p>
<hr>
<h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>​    通过上图我们可以发现<code>RestTemlate</code>发送<code>GET</code>请求的方法有两种</p>
<blockquote>
<ul>
<li><code>public &lt;T&gt; T getForObject(...)</code></li>
<li><code>public &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(...)</code></li>
</ul>
</blockquote>
<h4 id="getForEntity"><a href="#getForEntity" class="headerlink" title="getForEntity()"></a><strong><code>getForEntity()</code></strong></h4><p>​    后缀带有<code>Entity</code>的方法都代表返回一个<code>ResponseEntity&lt;T&gt;</code>，<code>ResponseEntity&lt;T&gt;</code>是Spring对<code>HTTP</code>请求响应的封装，包括了几个重要的元素，如响应码，<code>contentType、contentLength</code>、响应消息体等</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415211830207.png" alt="image-20220415211830207"></p>
<p>​    通过它继承父类(<code>HttpEntity&lt;T&gt;</code>)的<code>getHeader()</code>方法我们可以获取<code>contentType、contentLength</code>、响应消息体等。比如下面这个例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryWeather</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        ResponseEntity&lt;Object&gt; forEntity = restTemplate.getForEntity(<span class="string">&quot;https://restapi.amap.com/v3/weather/weatherInfo?city=510100&amp;key=e7a5fa943f706602033b6b329c49fbc6&quot;</span>, Object.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;状态码:&quot;</span>+forEntity.getStatusCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;状态码内容:&quot;</span>+forEntity.getStatusCodeValue());</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> forEntity.getHeaders();</span><br><span class="line">        System.out.println(<span class="string">&quot;响应头:&quot;</span>+headers);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">body</span> <span class="operator">=</span> forEntity.getBody();</span><br><span class="line">        System.out.println(<span class="string">&quot;响应内容:&quot;</span>+body);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    该例子中<code>getForEntity()</code>方法的第一个参数为我要调用服务的<code>URL</code>，第二个参数则为响应内容的类的类型（Java嘛 万物皆对象）还可以添加第三个参数，第三个参数为一个可变参数 代表着调用服务时的传参。</p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220415212800839.png" alt="image-20220415212800839">    <strong>第三个参数可以使用key-value的map来传入参数</strong></p>
<p>​    <strong>get请求也可通过向在url上添加查询参数来发送带有请求的参数</strong></p>
<hr>
<h4 id="getForObject"><a href="#getForObject" class="headerlink" title="getForObject()"></a><strong><code>getForObject()</code></strong></h4><p>​    相比于前者<code>getForEntity()</code>该方法则是，更偏向于直接获取响应内容的，因为他直接返回响应实体的<code>body</code>（响应内容），。比如下面这个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryWeather</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Object</span> <span class="variable">body</span> <span class="operator">=</span> restTemplate.getForObject(<span class="string">&quot;https://restapi.amap.com/v3/weather/weatherInfo?city=510100&amp;key=e7a5fa943f706602033b6b329c49fbc6&quot;</span>, Object.class);</span><br><span class="line">        System.out.println(body);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<pre><code> 方法参数签名与`getForEntity()`基本一致。
</code></pre>
<hr>
<p>​    当你只需要返回的响应内容时，使用<code>getForObject()</code>是一个很好的选择，但当你需要获得更详细的响应信息，如响应头中的信息，你就只能选择<code>getForEntity()</code>了。</p>
<hr>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>​    <code>POST</code>请求有如下三种方法</p>
<blockquote>
<ul>
<li><code>public URI postForLocation(...)</code></li>
<li><code>public &lt;T&gt; T postForObject(...)</code></li>
<li><code>public &lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(...)</code></li>
</ul>
</blockquote>
<p>​    后两种用法与<code>GET</code>基本一致不做详细介绍，这里着重介绍<code>postForLocation()</code></p>
<hr>
<h4 id="postForEntity"><a href="#postForEntity" class="headerlink" title="postForEntity()"></a><code>postForEntity()</code></h4><p>​    该方法有三个参数，第一个为调用服务的地址（URL）</p>
<p>​    第二个参数表示上传的参数(json格式提交)</p>
<p>​    第三个表示返回响应内容的具体类型</p>
<p>​    第四个参数也用于指定参数（在URL中添加）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryWeather</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;鲁大师&quot;</span>);</span><br><span class="line">        ResponseEntity&lt;Object&gt; objectResponseEntity = restTemplate.postForEntity(<span class="string">&quot;https://restapi.amap.com/v3/weather/weatherInfo?city=510100&amp;key=e7a5fa943f706602033b6b329c49fbc6&quot;</span>, user, Object.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息响应内容:&quot;</span>+objectResponseEntity.getBody());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="postForObject"><a href="#postForObject" class="headerlink" title="postForObject()"></a><code>postForObject()</code></h4><p>​    使用方法与<code>getForObject</code>类似只是多了一个传入对象参数（传入方式与<code>postForEntity()</code>相同）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryWeather</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;鲁大师&quot;</span>);</span><br><span class="line">        ResponseEntity&lt;Object&gt; objectResponseEntity = restTemplate.postForEntity(<span class="string">&quot;https://httpbin.org/post&quot;</span>, user, Object.class);</span><br><span class="line">        <span class="type">MediaType</span> <span class="variable">contentType</span> <span class="operator">=</span> objectResponseEntity.getHeaders().getContentType();</span><br><span class="line">        System.out.println(contentType);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息响应内容:&quot;</span>+objectResponseEntity.getBody());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="postForLocation"><a href="#postForLocation" class="headerlink" title="postForLocation()"></a><code>postForLocation()</code></h4><p>​    <code>postForLocation</code>传参用法与前两者一致，只不过返回从实体变成了一个<code>URL</code>，因此它不需要指定返回响应内容的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryWeather</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;鲁大师&quot;</span>);</span><br><span class="line">        <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> restTemplate.postForLocation(<span class="string">&quot;https://httpbin.org/post&quot;</span>, user);</span><br><span class="line">        System.out.println(uri);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个只需要服务提供者返回一个 URI 即可，该<code>URI</code>返回值体现的是：用于提交完成数据之后的页面跳转，或数据提交完成之后的下一步数据操作<code>URI</code>。</p>
<h4 id="使用POST以表单方式提交"><a href="#使用POST以表单方式提交" class="headerlink" title="使用POST以表单方式提交"></a>使用POST以表单方式提交</h4><p>​    这里我们着重说一下，如何自己封装一个请求体。</p>
<p>​    我们需要用到如下几个类</p>
<blockquote>
<ul>
<li><code>HttpHeaders</code></li>
<li><code>MultiValueMap&lt;K,V&gt;</code></li>
<li><code>HttpEntity&lt;T&gt;</code></li>
</ul>
</blockquote>
<h5 id="HttpHeaders"><a href="#HttpHeaders" class="headerlink" title="HttpHeaders"></a><code>HttpHeaders</code></h5><p>​    故名思意，就是用来封装Http请求的请求头的，这里我们要设置他的<code>ContentType</code>为**<code>MediaType.APPLICATION_FORM_URLENCODED</code>**以使得我们提交的参数是以Form(表单)的形式提交。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置请求头, x-www-form-urlencoded格式的数据</span></span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        <span class="comment">//这里指定参数以UTF-8编码格式传输</span></span><br><span class="line">        <span class="type">MediaType</span> <span class="variable">mediaType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaType</span>(MediaType.APPLICATION_FORM_URLENCODED, UTF_8);</span><br><span class="line">        httpHeaders.setContentType(mediaType);</span><br><span class="line">        <span class="comment">//提交参数设置</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">        map.add(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;鲁大师&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="MultiValueMap-lt-K-V-gt"><a href="#MultiValueMap-lt-K-V-gt" class="headerlink" title="MultiValueMap&lt;K,V&gt;"></a><code>MultiValueMap&lt;K,V&gt;</code></h5><p>​    该类是用来封装请求参数的，是以<code>key-value</code>的形式封装但是以单个key对应多个value的格式传输(也就是是以单个<code>key:[value...]</code>的格式传输的)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提交参数设置</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">        map.add(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;鲁大师&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​    <strong>如果像传输单个<code>key</code>对应单个<code>value</code>使用普通的<code>Map</code>传参即可</strong></p>
<hr>
<h5 id="HttpEntity-lt-T-gt"><a href="#HttpEntity-lt-T-gt" class="headerlink" title="HttpEntity&lt;T&gt;"></a><code>HttpEntity&lt;T&gt;</code></h5><p>​    该类是用来封装请求的，主要作用就是将请求头和请求体封装在一起成为一个请求实体 T用来指定用来封装参数的容器的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组装请求体</span></span><br><span class="line">        HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; request = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(map, httpHeaders);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>通过上述介绍后，我们就可以自己封装一个以form形式提交参数的<code>POST</code>请求了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//请求地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://httpbin.org/post&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置请求头, x-www-form-urlencoded格式的数据</span></span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        httpHeaders.setContentType(MediaType.APPLICATION_FORM_URLENCODED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交参数设置</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">        map.add(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;鲁大师&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//组装请求体</span></span><br><span class="line">        HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; request = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(map, httpHeaders);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送post请求并打印结果 以String类型接收响应结果JSON字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> restTemplate.postForObject(url, request, String.class);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416124128856.png" alt="image-20220416124128856"></p>
<p>​    通过拦截器拦截了请求并对请求头进行拆包，可以发现<code>ContentType</code>已经被修改成了<code>x-www-form-urlencoded</code>格式了。</p>
<h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>​    <code>PUT</code>请求的方法只有一类</p>
<blockquote>
<ul>
<li><code>void put()</code></li>
</ul>
</blockquote>
<h4 id="PUT-1"><a href="#PUT-1" class="headerlink" title="PUT()"></a><code>PUT()</code></h4><p>​    使用方法与<code>postForEntity()</code>参数基本一致，只是<code>put</code>方法没有返回值（也就不必去设置响应内容的类型了）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//请求地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/put&quot;</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;鲁大师&quot;</span>);</span><br><span class="line">        restTemplate.put(url,user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>​    与<code>PUT</code>一样，<code>DELETE</code>方法只有一类</p>
<blockquote>
<ul>
<li><code>void delete()</code></li>
</ul>
</blockquote>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete()"></a><code>delete()</code></h4><p>​    <code>delete()</code>可以指定<code>url</code>中的中的参数，但是<code>RestTemplate</code>的<code>delete()</code>方法是不支持上传<code>requestBody</code>的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/delete&quot;</span>;</span><br><span class="line">    restTemplate.delete(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="HEADER"><a href="#HEADER" class="headerlink" title="HEADER"></a>HEADER</h3><p>​    <code>HEADER</code>也只有一类方法</p>
<blockquote>
<ul>
<li><code>public HttpHeaders headForHeaders()</code></li>
</ul>
</blockquote>
<p>​    主要用来发送请求获取响应头部信息，但是像<code>DELETE</code>、<code>PUT</code>这类没有响应的方法，是不能使用该方法的（因为没有响应也就没有响应头了）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//请求地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/get&quot;</span>;</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> restTemplate.headForHeaders(url);</span><br><span class="line">        System.out.println(httpHeaders);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416151836372.png" alt="image-20220416151836372"></p>
<hr>
<h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><blockquote>
<ul>
<li><code>public Set&lt;HttpMethod&gt; optionsForAllow()</code></li>
</ul>
</blockquote>
<p>​    该方法的主要用来判断该服务地址，能够使用那种方法去执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//请求地址</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/get&quot;</span>;</span><br><span class="line">       Set&lt;HttpMethod&gt; httpMethods = restTemplate.optionsForAllow(url);</span><br><span class="line">       System.out.println(httpMethods);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416152755753.png" alt="image-20220416152755753"></p>
<hr>
<h3 id="EXCHANGE"><a href="#EXCHANGE" class="headerlink" title="EXCHANGE"></a>EXCHANGE</h3><blockquote>
<ul>
<li><code>&lt;T&gt; ResponseEntity&lt;T&gt; exchange()</code></li>
</ul>
</blockquote>
<p>​    该接口与其他接口不同</p>
<blockquote>
<ul>
<li>该方法允许用户指定请求的方法（<code>get,post,put</code>等）</li>
<li>可以在请求中增加body以及头信息，其内容通过参数<code>HttpEntity&lt;?&gt; requestEntity</code>描述</li>
<li><code>exchange</code>支持’含参数的类型(即泛型)’作为返回类型，该特性通过<code>ParameterizedTypeReferenceresponseType</code> 描述</li>
</ul>
</blockquote>
<p>​    该方法支持五个参数</p>
<blockquote>
<ul>
<li>第一个是服务地址</li>
<li>第二个是请求方法</li>
<li>第三个是写入的请求实体</li>
<li>第四个是响应内容的类型</li>
<li>第五个是扩展模板的变量或包含<code>URI</code>模板变量的映射</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/post&quot;</span>;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;彭于晏&quot;</span>);</span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    httpHeaders.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">    HttpEntity&lt;User&gt; userHttpEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(user, httpHeaders);</span><br><span class="line">    ResponseEntity&lt;Object&gt; exchange = restTemplate.exchange(url, HttpMethod.POST, userHttpEntity, Object.class);</span><br><span class="line">    System.out.println(exchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上述代码模拟了一个简单的<code>POST</code>请求 <strong>可以理解为可以动态的指定请求方法和请求实体的一个方法。</strong></p>
<p> <strong>响应实体</strong></p>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416154441113.png" alt="image-20220416154441113"></p>
<hr>
<h3 id="EXECUTE"><a href="#EXECUTE" class="headerlink" title="EXECUTE"></a>EXECUTE</h3><blockquote>
<ul>
<li><code>&lt;T&gt; T execute()</code></li>
</ul>
</blockquote>
<p>​    该方法就是执行请求的方法，我们可以发现上述的所有方法的最后执行都是调用的该方法执行，所以他在<code>RestTemplate</code>中十分重要</p>
<p>​    该方法有五个参数</p>
<blockquote>
<ul>
<li>服务地址</li>
<li>请求的方法</li>
<li>准备请求的对象（<code>requestCallback</code>）</li>
<li>从响应中提取返回值的对象</li>
<li>扩展模板的变量或包含<code>URI</code>模板变量的映射</li>
</ul>
</blockquote>
<p><code>execute()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; T <span class="title function_">execute</span><span class="params">(String url, HttpMethod method, <span class="meta">@Nullable</span> RequestCallback requestCallback,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> ResponseExtractor&lt;T&gt; responseExtractor, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">URI</span> <span class="variable">expanded</span> <span class="operator">=</span> getUriTemplateHandler().expand(url, uriVariables);</span><br><span class="line">		<span class="keyword">return</span> doExecute(expanded, method, requestCallback, responseExtractor);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    通过上述源码我们可以发现<code>execute()</code>方法只是将我们传入的<code>String</code>类型的<code>URL</code>转换为了<code>URL</code>类型，最后执行请求是由<code>doExecute()</code>方法</p>
<hr>
<h4 id="doExecute"><a href="#doExecute" class="headerlink" title="doExecute()"></a><code>doExecute()</code></h4><p>​    这里需要了解两个类：<code>RequestCallback</code>和<code>ResPonseExtractor</code></p>
<p>​    <code>RequestCallback</code>: <strong>用于操作请求头和body，在请求发出前执行。不需要关心关闭请求或处理错误：这都将由RestTemplate处理。</strong></p>
<p>​    该接口有两个实现类：</p>
<p>​    <img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/v2-6761e212c99b46b5b24de7784c5f6c44_720w.jpg" alt="img"></p>
<p>​    <code>ResPonseExtractor</code>: <strong>解析HTTP响应的数据，而且不需要担心异常和资源的关闭。</strong></p>
<p>​    该接口在<code>RestTemplate</code>中同样有两个实现类：</p>
<table>
<thead>
<tr>
<th><code>HeadersExtractor</code></th>
<th>提取响应<code>HttpHeaders</code>的响应提取器。直接提取响应体中的响应头</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>ResponseEntityResponseExtractor&lt;T&gt;</code></td>
<td><code>HttpEntity</code><strong>的响应提取器。可以获取响应实体里面包括响应头，响应体等。具体请查看</strong><code>HttpEntity</code></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/post&quot;</span>;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;彭于晏&quot;</span>);</span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    httpHeaders.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">    HttpEntity&lt;User&gt; userHttpEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(user, httpHeaders);</span><br><span class="line">    ResponseEntity&lt;Object&gt; execute = restTemplate.execute(url, HttpMethod.POST, restTemplate.httpEntityCallback(userHttpEntity), restTemplate.responseEntityExtractor(Object.class));</span><br><span class="line">    System.out.println(execute);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416161653708.png" alt="image-20220416161653708"></p>
<hr>
<h2 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h2><ul>
<li>前面我们介绍方法的时候发现有个一个可变参数，那个参数被描述成了<strong>扩展模板的变量或是包含<code>URI</code>模板变量的映射</strong></li>
</ul>
<p>我们来简单看一下这个参数，我们知道请求传参可以通过<code>url</code>拼接参数的方式传参，拼接参数也分为两种：</p>
<blockquote>
<ul>
<li>路径中嵌入占位的格式（<code>http://httpbin.org/&#123;1&#125;/post</code>）也叫模板映射</li>
<li>末尾添加<code>Key-value</code>格式（<code>http://httpbin.org/post?name=&quot;彭于晏&quot;</code>）即扩展模板的变量</li>
</ul>
</blockquote>
<ul>
<li>当我们最后一参数传入map时会以<code>key-value</code>的格式拼接在<code>URL</code>后（通俗的说就是这样设置的变量会跟着<code>URL</code>路径后面）</li>
</ul>
<p>​    <code>http://httpbin.org/post?name=&quot;彭于晏&quot;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/get&quot;</span>;</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;彭于晏&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">forObject</span> <span class="operator">=</span> restTemplate.getForObject(url, Object.class, map);</span><br><span class="line">    System.out.println(forObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当我们传入简单的对象如String，Integer时且路径中有嵌入的占位符时就会代替调用URL中占位符</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/&#123;2&#125;/get&quot;</span>;</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">forObject</span> <span class="operator">=</span> restTemplate.getForObject(url, Object.class, <span class="number">99</span>);</span><br><span class="line">    System.out.println(forObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/image-20220416163605771.png" alt="image-20220416163605771"></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u012843361/article/details/79893638">spring cloud 做微服务时关于RestTemplate中的各种请求方法的使用总结_DWT_CCFK的博客-CSDN博客</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/31681913">RestTemplate 详解 - 知乎 (zhihu.com)</a></p>
<p><a href="https://www.jianshu.com/p/35aca2e31f06">RestTemplate使用教程 - 简书 (jianshu.com)</a></p>
<hr>
<h1 id="End"><a href="#End" class="headerlink" title="-End-"></a>-End-</h1>]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式----创建型模式</title>
    <url>/2022/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式—-创建型模式"><a href="#设计模式—-创建型模式" class="headerlink" title="设计模式—-创建型模式"></a>设计模式—-创建型模式</h1><h2 id="1-1-模式动机"><a href="#1-1-模式动机" class="headerlink" title="1.1. 模式动机"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id15">1.1. 模式动机</a></h2><p>考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。</p>
<hr>
<h2 id="1-2-模式定义"><a href="#1-2-模式定义" class="headerlink" title="1.2. 模式定义"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id16">1.2. 模式定义</a></h2><p>简单工厂模式(<code>Simple Factory Pattern</code>)：又称为<strong>静态工厂方法</strong>(<code>Static Factory Method</code>)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
<hr>
<h2 id="1-3-模式结构"><a href="#1-3-模式结构" class="headerlink" title="1.3. 模式结构"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id17">1.3. 模式结构</a></h2><p>简单工厂模式包含如下角色：</p>
<ul>
<li><p><code>Factory</code>：工厂角色</p>
<p>工厂角色负责实现创建所有实例的内部逻辑</p>
</li>
<li><p><code>Product</code>：抽象产品角色</p>
<p>抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</p>
</li>
<li><p><code>ConcreteProduct</code>：具体产品角色</p>
<p>具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</p>
</li>
</ul>
<p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/SimpleFactory.jpg" alt="../_images/SimpleFactory.jpg"></p>
<hr>
<h2 id="1-4-时序图"><a href="#1-4-时序图" class="headerlink" title="1.4. 时序图"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id18">1.4. 时序图</a></h2><p><img src="https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/seq_SimpleFactory.jpg" alt="../_images/seq_SimpleFactory.jpg"></p>
<hr>
<h2 id="1-5-代码分析"><a href="#1-5-代码分析" class="headerlink" title="1.5. 代码分析"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id19">1.5. 代码分析</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VehiclesGenerator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CAR</span> <span class="operator">=</span> <span class="string">&quot;Car&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BIKE</span> <span class="operator">=</span> <span class="string">&quot;Bike&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TRAIN</span> <span class="operator">=</span> <span class="string">&quot;Train&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">AIRPLANE</span> <span class="operator">=</span> <span class="string">&quot;Airplane&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方式一 交通工具生成器</span></span><br><span class="line"><span class="comment">     * 使用if 判断字段来生成实例</span></span><br><span class="line"><span class="comment">     * 返回值为抽象类类型 根据继承的知识我们知道 父类只能拥有子类重写的方法</span></span><br><span class="line"><span class="comment">     * 所以如果子类有额外的方法时需要向下转型.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vehiclesType 交通工具的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的交通工具</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Vehicles <span class="title function_">getInstance</span><span class="params">(String vehiclesType)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vehiclesType.equals(CAR))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vehiclesType.equals(TRAIN))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Train</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vehiclesType.equals(BIKE))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bike</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vehiclesType.equals(AIRPLANE))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Airplane</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">VehiclesGenerator</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="1-6-模式分析"><a href="#1-6-模式分析" class="headerlink" title="1.6. 模式分析"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id20">1.6. 模式分析</a></h2><ul>
<li>将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。</li>
<li>在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。</li>
<li>简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。</li>
<li>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</li>
</ul>
<hr>
<h2 id="1-7-实例"><a href="#1-7-实例" class="headerlink" title="1.7. 实例"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id21">1.7. 实例</a></h2><p><a href="https://github.com/Devildyw/design-patterns/tree/master/DesignPatterns-Java/SimpleFactoryPattern">简单工厂设计模式实例</a></p>
<hr>
<h2 id="1-8-简单工厂模式的优点"><a href="#1-8-简单工厂模式的优点" class="headerlink" title="1.8. 简单工厂模式的优点"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id22">1.8. 简单工厂模式的优点</a></h2><ul>
<li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。</li>
<li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li>
<li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li>
</ul>
<hr>
<h2 id="1-9-简单工厂模式的缺点"><a href="#1-9-简单工厂模式的缺点" class="headerlink" title="1.9. 简单工厂模式的缺点"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id23">1.9. 简单工厂模式的缺点</a></h2><ul>
<li>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</li>
<li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</li>
<li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li>
<li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li>
</ul>
<hr>
<h2 id="1-10-适用环境"><a href="#1-10-适用环境" class="headerlink" title="1.10. 适用环境"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id24">1.10. 适用环境</a></h2><p><strong>在以下情况下可以使用简单工厂模式：</strong></p>
<ul>
<li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li>
</ul>
<hr>
<h2 id="1-11-模式应用"><a href="#1-11-模式应用" class="headerlink" title="1.11. 模式应用"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id25">1.11. 模式应用</a></h2><ol>
<li><code>JDK</code>类库中广泛使用了简单工厂模式，如工具类<code>java.text.DateFormat</code>，它用于格式化一个本地日期或者时间。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title function_">getDateInstance</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title function_">getDateInstance</span><span class="params">(<span class="type">int</span> style)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title function_">getDateInstance</span><span class="params">(<span class="type">int</span> style,Locale</span></span><br><span class="line"><span class="params">locale)</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>Java</code>加密技术</li>
</ol>
<p>获取不同加密算法的密钥生成器:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">KeyGenerator keyGen=KeyGenerator.getInstance(<span class="string">&quot;DESede&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>创建密码器:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cipher cp=Cipher.getInstance(<span class="string">&quot;DESede&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="1-12-总结"><a href="#1-12-总结" class="headerlink" title="1.12. 总结"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html#id26">1.12. 总结</a></h2><ul>
<li>创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。</li>
<li>简单工厂模式又称为静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</li>
<li>简单工厂模式包含三个角色：工厂角色负责实现创建所有实例的内部逻辑；抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</li>
<li>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</li>
<li>简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。</li>
<li>简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。</li>
</ul>
<hr>
<p><strong>摘自:</strong><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html"> 简单工厂模式( Simple Factory Pattern ) — Graphic Design Patterns (design-patterns.readthedocs.io)</a></p>
<h1 id="End"><a href="#End" class="headerlink" title="-End-"></a>-End-</h1>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Developer</tag>
      </tags>
  </entry>
</search>
